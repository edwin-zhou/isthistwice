(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[179],{255:t=>{function e(t){return Promise.resolve().then(()=>{var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e})}e.keys=()=>[],e.resolve=e,e.id=255,t.exports=e},929:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(I){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function s(t){return!0===(t&&t.__isLong__)}Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=s;var r={},i={};function o(t,e){var n,s,o;return e?(o=0<=(t>>>=0)&&t<256)&&(s=i[t])?s:(n=l(t,(0|t)<0?-1:0,!0),o&&(i[t]=n),n):(o=-128<=(t|=0)&&t<128)&&(s=r[t])?s:(n=l(t,t<0?-1:0,!1),o&&(r[t]=n),n)}function a(t,e){if(isNaN(t))return e?y:g;if(e){if(t<0)return y;if(t>=p)return _}else{if(t<=-f)return k;if(t+1>=f)return x}return t<0?a(-t,e).neg():l(t%d|0,t/d|0,e)}function l(t,e,s){return new n(t,e,s)}n.fromInt=o,n.fromNumber=a,n.fromBits=l;var u=Math.pow;function c(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return g;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var s;if((s=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===s)return c(t.substring(1),e,n).neg();for(var r=a(u(n,8)),i=g,o=0;o<t.length;o+=8){var l=Math.min(8,t.length-o),h=parseInt(t.substring(o,o+l),n);if(l<8){var d=a(u(n,l));i=i.mul(d).add(a(h))}else i=(i=i.mul(r)).add(a(h))}return i.unsigned=e,i}function h(t,e){return"number"==typeof t?a(t,e):"string"==typeof t?c(t,e):l(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=o(1<<24),g=o(0);n.ZERO=g;var y=o(0,!0);n.UZERO=y;var b=o(1);n.ONE=b;var v=o(1,!0);n.UONE=v;var w=o(-1);n.NEG_ONE=w;var x=l(-1,2147483647,!1);n.MAX_VALUE=x;var _=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=_;var k=l(0,-2147483648,!1);n.MIN_VALUE=k;var C=n.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},C.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var e=a(t),n=this.div(e),s=n.mul(e).sub(this);return n.toString(t)+s.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var r=a(u(t,6),this.unsigned),i=this,o="";;){var l=i.div(r),c=(i.sub(l.mul(r)).toInt()>>>0).toString(t);if((i=l).isZero())return c+o;for(;c.length<6;)c="0"+c;o=""+c+o}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1==(1&this.low)},C.isEven=function(){return 0==(1&this.low)},C.equals=function(t){return s(t)||(t=h(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},C.eq=C.equals,C.notEquals=function(t){return!this.eq(t)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(t){return this.comp(t)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(t){return this.comp(t)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(t){return this.comp(t)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(t){return this.comp(t)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(t){if(s(t)||(t=h(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(b)},C.neg=C.negate,C.add=function(t){s(t)||(t=h(t));var e=0,n=0,r=0,i=0;return r+=(i+=(65535&this.low)+(65535&t.low))>>>16,n+=(r+=(this.low>>>16)+(t.low>>>16))>>>16,e+=(n+=(65535&this.high)+(65535&t.high))>>>16,e+=(this.high>>>16)+(t.high>>>16),l((r&=65535)<<16|(i&=65535),(e&=65535)<<16|(n&=65535),this.unsigned)},C.subtract=function(t){return s(t)||(t=h(t)),this.add(t.neg())},C.sub=C.subtract,C.multiply=function(t){if(this.isZero())return g;if(s(t)||(t=h(t)),e)return l(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return g;if(this.eq(k))return t.isOdd()?k:g;if(t.eq(k))return this.isOdd()?k:g;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(m)&&t.lt(m))return a(this.toNumber()*t.toNumber(),this.unsigned);var n=65535&this.high,r=this.low>>>16,i=65535&this.low,o=65535&t.high,u=t.low>>>16,c=65535&t.low,d=0,p=0,f=0,y=0;return f+=(y+=i*c)>>>16,p+=(f+=r*c)>>>16,f&=65535,p+=(f+=i*u)>>>16,d+=(p+=n*c)>>>16,p&=65535,d+=(p+=r*u)>>>16,p&=65535,d+=(p+=i*o)>>>16,d+=(this.high>>>16)*c+n*u+r*o+i*(t.high>>>16),l((f&=65535)<<16|(y&=65535),(d&=65535)<<16|(p&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(t){if(s(t)||(t=h(t)),t.isZero())throw Error("division by zero");var n,r,i;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?l((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return y;if(t.gt(this.shru(1)))return v;i=y}else{if(this.eq(k))return t.eq(b)||t.eq(w)?k:t.eq(k)?b:(n=this.shr(1).div(t).shl(1)).eq(g)?t.isNegative()?b:w:(r=this.sub(t.mul(n)),i=n.add(r.div(t)));if(t.eq(k))return this.unsigned?y:g;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();i=g}for(r=this;r.gte(t);){n=Math.max(1,Math.floor(r.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),c=o<=48?1:u(2,o-48),d=a(n),p=d.mul(t);p.isNegative()||p.gt(r);)p=(d=a(n-=c,this.unsigned)).mul(t);d.isZero()&&(d=b),i=i.add(d),r=r.sub(p)}return i},C.div=C.divide,C.modulo=function(t){return s(t)||(t=h(t)),e?l((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return l(~this.low,~this.high,this.unsigned)},C.and=function(t){return s(t)||(t=h(t)),l(this.low&t.low,this.high&t.high,this.unsigned)},C.or=function(t){return s(t)||(t=h(t)),l(this.low|t.low,this.high|t.high,this.unsigned)},C.xor=function(t){return s(t)||(t=h(t)),l(this.low^t.low,this.high^t.high,this.unsigned)},C.shiftLeft=function(t){return s(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):l(0,this.low<<t-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(t){return s(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):l(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(t){if(s(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?l(this.low>>>t|e<<32-t,e>>>t,this.unsigned):l(32===t?e:e>>>t-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},C.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},C.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,s){return s?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},566:(t,e,n)=>{var s=n(683),r=n(669),i=n(64),o=n(763),a=n(553),l=n(464),u=n(147);u.alea=s,u.xor128=r,u.xorwow=i,u.xorshift7=o,u.xor4096=a,u.tychei=l,t.exports=u},683:function(t,e,n){var s;!function(t,r,i){function o(t){var e,n=this,s=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var s=.02519603282416938*(e+=t.charCodeAt(n));s-=e=s>>>0,e=(s*=e)>>>0,e+=4294967296*(s-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=s(" "),n.s1=s(" "),n.s2=s(" "),n.s0-=s(t),n.s0<0&&(n.s0+=1),n.s1-=s(t),n.s1<0&&(n.s1+=1),n.s2-=s(t),n.s2<0&&(n.s2+=1),s=null}function a(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),s=e&&e.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,s&&("object"==typeof s&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.alea=l}(0,t=n.nmd(t))},464:function(t,e,n){var s;!function(t,r,i){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,s=e.d,r=e.a;return t=t<<25^t>>>7^n,n=n-s|0,s=s<<24^s>>>8^r,r=r-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-s|0,e.d=s<<16^n>>>16^r,e.a=r-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var s=0;s<n.length+20;s++)e.b^=0|n.charCodeAt(s),e.next()}function a(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.tychei=l}(0,t=n.nmd(t))},669:function(t,e,n){var s;!function(t,r,i){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var s=0;s<n.length+64;s++)e.x^=0|n.charCodeAt(s),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xor128=l}(0,t=n.nmd(t))},553:function(t,e,n){var s;!function(t,r,i){function o(t){var e=this;e.next=function(){var t,n,s=e.w,r=e.X,i=e.i;return e.w=s=s+1640531527|0,n=r[i+34&127],t=r[i=i+1&127],n^=n<<13,t^=t<<17,n=r[i]=(n^=n>>>15)^(t^=t>>>12),e.i=i,n+(s^s>>>16)|0},function(t,e){var n,s,r,i,o,a=[],l=128;for(e===(0|e)?(s=e,e=null):(e+="\0",s=0,l=Math.max(l,e.length)),r=0,i=-32;i<l;++i)e&&(s^=e.charCodeAt((i+32)%e.length)),0===i&&(o=s),s^=s<<10,s^=s>>>15,s^=s<<4,s^=s>>>13,i>=0&&(r=0==(n=a[127&i]^=s+(o=o+1640531527|0))?r+1:0);for(r>=128&&(a[127&(e&&e.length||0)]=-1),r=127,i=512;i>0;--i)s=a[r+34&127],n=a[r=r+1&127],s^=s<<13,n^=n<<17,a[r]=(s^=s>>>15)^(n^=n>>>12);t.w=o,t.X=a,t.i=r}(e,t)}function a(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&(s.X&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xor4096=l}(0,t=n.nmd(t))},763:function(t,e,n){var s;!function(t,r,i){function o(t){var e=this;e.next=function(){var t,n,s=e.x,r=e.i;return t=s[r],n=(t^=t>>>7)^t<<24,n^=(t=s[r+1&7])^t>>>10,n^=(t=s[r+3&7])^t>>>3,n^=(t=s[r+4&7])^t<<7,t=s[r+7&7],s[r]=n^=(t^=t<<13)^t<<9,e.i=r+1&7,n},function(t,e){var n,s=[];if(e===(0|e))s[0]=e;else for(e=""+e,n=0;n<e.length;++n)s[7&n]=s[7&n]<<15^e.charCodeAt(n)+s[n+1&7]<<13;for(;s.length<8;)s.push(0);for(n=0;n<8&&0===s[n];++n);for(8==n&&(s[7]=-1),t.x=s,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function a(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&(s.x&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xorshift7=l}(0,t=n.nmd(t))},64:function(t,e,n){var s;!function(t,r,i){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var s=0;s<n.length+64;s++)e.x^=0|n.charCodeAt(s),s==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xorwow=l}(0,t=n.nmd(t))},147:(t,e,n)=>{var s;!function(r,i){var o,a=this,l=256,u=i.pow(l,6),c=i.pow(2,52),h=2*c,d=255;function p(t,e,n){var s=[],d=y(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,b(r)]:null==t?function(){try{var t;return o&&(t=o.randomBytes)?t=t(l):(t=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(t)),b(t)}catch(s){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,b(r)]}}():t,3),s),p=new f(s),v=function(){for(var t=p.g(6),e=u,n=0;t<c;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),r),(e.pass||n||function(t,e,n,s){return s&&(s.S&&m(s,p),t.state=function(){return m(p,{})}),n?(i.random=t,e):t})(v,d,"global"in e?e.global:this==i,e.state)}function f(t){var e,n=t.length,s=this,r=0,i=s.i=s.j=0,o=s.S=[];for(n||(t=[n++]);r<l;)o[r]=r++;for(r=0;r<l;r++)o[r]=o[i=d&i+t[r%n]+(e=o[r])],o[i]=e;(s.g=function(t){for(var e,n=0,r=s.i,i=s.j,o=s.S;t--;)e=o[r=d&r+1],n=n*l+o[d&(o[r]=o[i=d&i+e])+(o[i]=e)];return s.i=r,s.j=i,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,s=[],r=typeof t;if(e&&"object"==r)for(n in t)try{s.push(g(t[n],e-1))}catch(i){}return s.length?s:"string"==r?t:t+"\0"}function y(t,e){for(var n,s=t+"",r=0;r<s.length;)e[d&r]=d&(n^=19*e[d&r])+s.charCodeAt(r++);return b(e)}function b(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=p,y(i.random(),r),t.exports){t.exports=p;try{o=n(42)}catch(v){}}else void 0===(s=(function(){return p}).call(e,n,e,t))||(t.exports=s)}([],Math)},843:(t,e,n)=>{"use strict";var s={};n.r(s),n.d(s,{assertParamsValid:()=>y_,computeFlatOffset:()=>$_,computeOutShape:()=>v_,getNormalizedAxes:()=>k_,isSliceContinous:()=>N_,maskToAxes:()=>b_,parseSliceParams:()=>A_,sliceInfo:()=>R_,startForAxis:()=>E_,startIndicesWithElidedDims:()=>C_,stopForAxis:()=>T_,stopIndicesWithElidedDims:()=>I_,stridesForAxis:()=>S_,stridesWithElidedDims:()=>w_});var r={};n.r(r),n.d(r,{collectGatherOpShapeInfo:()=>ZS,computeOutShape:()=>XS,segOpComputeOptimalWindowSize:()=>KS});var i={};n.r(i),n.d(i,{ERF_A1:()=>IS,ERF_A2:()=>SS,ERF_A3:()=>ES,ERF_A4:()=>TS,ERF_A5:()=>NS,ERF_P:()=>CS,PARALLELIZE_THRESHOLD:()=>cS,SELU_SCALE:()=>kS,SELU_SCALEALPHA:()=>_S,applyActivation:()=>cI,assertAndGetBroadcastShape:()=>Ok,assertAxesAreInnerMostDims:()=>uC,assertParamsConsistent:()=>lS,assignToTypedArray:()=>MS,axesAreInnerMostDims:()=>iC,calculateShapes:()=>xS,checkEinsumDimSizes:()=>US,combineLocations:()=>oC,complexWithEvenIndex:()=>DS,complexWithOddIndex:()=>OS,computeConv2DInfo:()=>J_,computeConv3DInfo:()=>tk,computeDefaultPad:()=>ek,computeDilation2DInfo:()=>Z_,computeOptimalWindowSize:()=>hS,computeOutAndReduceShapes:()=>aC,computeOutShape:()=>uS,computePool2DInfo:()=>Y_,computePool3DInfo:()=>Q_,convertConv2DDataFormat:()=>lk,decodeEinsumEquation:()=>VS,eitherStridesOrDilationsAreOne:()=>ak,expandShapeToKeepDim:()=>lC,exponent:()=>zS,exponents:()=>PS,fromStringArrayToUint8:()=>QS,fromUint8ToStringArray:()=>YS,getAxesPermutation:()=>cC,getBroadcastDims:()=>Fk,getComplexWithIndex:()=>LS,getEinsumComputePath:()=>jS,getEinsumPermutation:()=>WS,getFusedBiasGradient:()=>uI,getFusedDyActivation:()=>lI,getImageCenter:()=>dS,getInnerMostAxes:()=>dC,getPermuted:()=>fS,getReductionAxes:()=>Dk,getReshaped:()=>pS,getReshapedPermuted:()=>mS,getSliceBeginCoords:()=>gS,getSliceSize:()=>yS,getUndoAxesPermutation:()=>hC,isIdentityPermutation:()=>HS,log:()=>AS,mergeRealAndImagArrays:()=>RS,prepareAndValidate:()=>bS,prepareSplitSize:()=>qS,segment_util:()=>r,shouldFuse:()=>hI,slice_util:()=>s,splitRealAndImagArrays:()=>FS,tupleValuesAreOne:()=>ok,upcastType:()=>Yw,validateInput:()=>wS,validateUpdateShape:()=>vS,warn:()=>$S});var o={};function a(t){return"function"==typeof t}n.r(o),n.d(o,{addImpl:()=>vL,bincountImpl:()=>hM,bincountReduceImpl:()=>dM,ceilImpl:()=>mM,concatImpl:()=>xM,equalImpl:()=>sP,expImpl:()=>fP,expm1Impl:()=>vP,floorImpl:()=>LP,gatherNdImpl:()=>jP,gatherV2Impl:()=>GP,greaterEqualImpl:()=>YP,greaterImpl:()=>KP,lessEqualImpl:()=>cz,lessImpl:()=>az,linSpaceImpl:()=>pz,logImpl:()=>mz,maxImpl:()=>$z,maximumImpl:()=>Fz,minimumImpl:()=>Uz,multiplyImpl:()=>XM,negImpl:()=>Jz,notEqualImpl:()=>aB,prodImpl:()=>wB,rangeImpl:()=>_B,rsqrtImpl:()=>DB,simpleAbsImpl:()=>TL,sliceImpl:()=>aM,sparseFillEmptyRowsImpl:()=>tV,sparseReshapeImpl:()=>nV,sparseSegmentReductionImpl:()=>rV,squaredDifferenceImpl:()=>dV,stridedSliceImpl:()=>yV,stringNGramsImpl:()=>wV,stringSplitImpl:()=>kV,stringToHashBucketFastImpl:()=>IV,subImpl:()=>IP,tileImpl:()=>$V,topKImpl:()=>AV,transposeImpl:()=>OL,uniqueImpl:()=>LV});let l=!1;const u={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const t=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+t.stack)}else l&&console.log("RxJS: Back to a better error behavior. Thank you. <3");l=t},get useDeprecatedSynchronousErrorHandling(){return l}};function c(t){setTimeout(()=>{throw t},0)}const h={closed:!0,next(t){},error(t){if(u.useDeprecatedSynchronousErrorHandling)throw t;c(t)},complete(){}},d=(()=>Array.isArray||(t=>t&&"number"==typeof t.length))();function p(t){return null!==t&&"object"==typeof t}const f=(()=>{function t(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t,this}return t.prototype=Object.create(Error.prototype),t})();let m=(()=>{class t{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&&(this._ctorUnsubscribe=!0,this._unsubscribe=t)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:s,_unsubscribe:r,_subscriptions:i}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof t)n.remove(this);else if(null!==n)for(let t=0;t<n.length;++t)n[t].remove(this);if(a(r)){s&&(this._unsubscribe=void 0);try{r.call(this)}catch(o){e=o instanceof f?g(o.errors):[o]}}if(d(i)){let t=-1,n=i.length;for(;++t<n;){const n=i[t];if(p(n))try{n.unsubscribe()}catch(o){e=e||[],o instanceof f?e=e.concat(g(o.errors)):e.push(o)}}}if(e)throw new f(e)}add(e){let n=e;if(!e)return t.EMPTY;switch(typeof e){case"function":n=new t(e);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof t)){const e=n;n=new t,n._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:s}=n;if(null===s)n._parentOrParents=this;else if(s instanceof t){if(s===this)return n;n._parentOrParents=[s,this]}else{if(-1!==s.indexOf(this))return n;s.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[n]:r.push(n),n}remove(t){const e=this._subscriptions;if(e){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}}return t.EMPTY=function(t){return t.closed=!0,t}(new t),t})();function g(t){return t.reduce((t,e)=>t.concat(e instanceof f?e.errors:e),[])}const y=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class b extends m{constructor(t,e,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=h;break;case 1:if(!t){this.destination=h;break}if("object"==typeof t){t instanceof b?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new v(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new v(this,t,e,n)}}[y](){return this}static create(t,e,n){const s=new b(t,e,n);return s.syncErrorThrowable=!1,s}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class v extends b{constructor(t,e,n,s){let r;super(),this._parentSubscriber=t;let i=this;a(e)?r=e:e&&(r=e.next,n=e.error,s=e.complete,e!==h&&(i=Object.create(e),a(i.unsubscribe)&&this.add(i.unsubscribe.bind(i)),i.unsubscribe=this.unsubscribe.bind(this))),this._context=i,this._next=r,this._error=n,this._complete=s}next(t){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;u.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:n}=u;if(this._error)n&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)n?(e.syncErrorValue=t,e.syncErrorThrown=!0):c(t),this.unsubscribe();else{if(this.unsubscribe(),n)throw t;c(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=>this._complete.call(this._context);u.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(n){if(this.unsubscribe(),u.useDeprecatedSynchronousErrorHandling)throw n;c(n)}}__tryOrSetError(t,e,n){if(!u.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,n)}catch(s){return u.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=s,t.syncErrorThrown=!0,!0):(c(s),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const w=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function x(t){return t}let _=(()=>{class t{constructor(t){this._isScalar=!1,t&&(this._subscribe=t)}lift(e){const n=new t;return n.source=this,n.operator=e,n}subscribe(t,e,n){const{operator:s}=this,r=function(t,e,n){if(t){if(t instanceof b)return t;if(t[y])return t[y]()}return t||e||n?new b(t,e,n):new b(h)}(t,e,n);if(r.add(s?s.call(r,this.source):this.source||u.useDeprecatedSynchronousErrorHandling&&!r.syncErrorThrowable?this._subscribe(r):this._trySubscribe(r)),u.useDeprecatedSynchronousErrorHandling&&r.syncErrorThrowable&&(r.syncErrorThrowable=!1,r.syncErrorThrown))throw r.syncErrorValue;return r}_trySubscribe(t){try{return this._subscribe(t)}catch(e){u.useDeprecatedSynchronousErrorHandling&&(t.syncErrorThrown=!0,t.syncErrorValue=e),function(t){for(;t;){const{closed:e,destination:n,isStopped:s}=t;if(e||s)return!1;t=n&&n instanceof b?n:null}return!0}(t)?t.error(e):console.warn(e)}}forEach(t,e){return new(e=k(e))((e,n)=>{let s;s=this.subscribe(e=>{try{t(e)}catch(r){n(r),s&&s.unsubscribe()}},n,e)})}_subscribe(t){const{source:e}=this;return e&&e.subscribe(t)}[w](){return this}pipe(...t){return 0===t.length?this:(0===(e=t).length?x:1===e.length?e[0]:function(t){return e.reduce((t,e)=>e(t),t)})(this);var e}toPromise(t){return new(t=k(t))((t,e)=>{let n;this.subscribe(t=>n=t,t=>e(t),()=>t(n))})}}return t.create=e=>new t(e),t})();function k(t){if(t||(t=u.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const C=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class I extends m{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const n=e.indexOf(this.subscriber);-1!==n&&e.splice(n,1)}}class S extends b{constructor(t){super(t),this.destination=t}}let E=(()=>{class t extends _{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[y](){return new S(this)}lift(t){const e=new T(this,this);return e.operator=t,e}next(t){if(this.closed)throw new C;if(!this.isStopped){const{observers:e}=this,n=e.length,s=e.slice();for(let r=0;r<n;r++)s[r].next(t)}}error(t){if(this.closed)throw new C;this.hasError=!0,this.thrownError=t,this.isStopped=!0;const{observers:e}=this,n=e.length,s=e.slice();for(let r=0;r<n;r++)s[r].error(t);this.observers.length=0}complete(){if(this.closed)throw new C;this.isStopped=!0;const{observers:t}=this,e=t.length,n=t.slice();for(let s=0;s<e;s++)n[s].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(t){if(this.closed)throw new C;return super._trySubscribe(t)}_subscribe(t){if(this.closed)throw new C;return this.hasError?(t.error(this.thrownError),m.EMPTY):this.isStopped?(t.complete(),m.EMPTY):(this.observers.push(t),new I(this,t))}asObservable(){const t=new _;return t.source=this,t}}return t.create=(t,e)=>new T(t,e),t})();class T extends E{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&&e.next&&e.next(t)}error(t){const{destination:e}=this;e&&e.error&&this.destination.error(t)}complete(){const{destination:t}=this;t&&t.complete&&this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):m.EMPTY}}function N(t){return t&&"function"==typeof t.schedule}function $(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new A(t,e))}}class A{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new R(t,this.project,this.thisArg))}}class R extends b{constructor(t,e,n){super(t),this.project=e,this.count=0,this.thisArg=n||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const F=t=>e=>{for(let n=0,s=t.length;n<s&&!e.closed;n++)e.next(t[n]);e.complete()};function D(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const O=D(),L=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function M(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const P=t=>{if(t&&"function"==typeof t[w])return n=t,t=>{const e=n[w]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(L(t))return F(t);if(M(t))return(t=>e=>(t.then(t=>{e.closed||(e.next(t),e.complete())},t=>e.error(t)).then(null,c),e))(t);if(t&&"function"==typeof t[O])return e=t,t=>{const n=e[O]();for(;;){let e;try{e=n.next()}catch(s){return t.error(s),t}if(e.done){t.complete();break}if(t.next(e.value),t.closed)break}return"function"==typeof n.return&&t.add(()=>{n.return&&n.return()}),t};{const e=p(t)?"an invalid object":`'${t}'`;throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var e,n};function z(t,e){return new _(n=>{const s=new m;let r=0;return s.add(e.schedule(function(){r!==t.length?(n.next(t[r++]),n.closed||s.add(this.schedule())):n.complete()})),s})}function B(t,e){return e?function(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[w]}(t))return function(t,e){return new _(n=>{const s=new m;return s.add(e.schedule(()=>{const r=t[w]();s.add(r.subscribe({next(t){s.add(e.schedule(()=>n.next(t)))},error(t){s.add(e.schedule(()=>n.error(t)))},complete(){s.add(e.schedule(()=>n.complete()))}}))})),s})}(t,e);if(M(t))return function(t,e){return new _(n=>{const s=new m;return s.add(e.schedule(()=>t.then(t=>{s.add(e.schedule(()=>{n.next(t),s.add(e.schedule(()=>n.complete()))}))},t=>{s.add(e.schedule(()=>n.error(t)))}))),s})}(t,e);if(L(t))return z(t,e);if(function(t){return t&&"function"==typeof t[O]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new _(n=>{const s=new m;let r;return s.add(()=>{r&&"function"==typeof r.return&&r.return()}),s.add(e.schedule(()=>{r=t[O](),s.add(e.schedule(function(){if(n.closed)return;let t,e;try{const n=r.next();t=n.value,e=n.done}catch(s){return void n.error(s)}e?n.complete():(n.next(t),this.schedule())}))})),s})}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,e):t instanceof _?t:new _(P(t))}class V extends b{constructor(t){super(),this.parent=t}_next(t){this.parent.notifyNext(t)}_error(t){this.parent.notifyError(t),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class W extends b{notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.destination.complete()}}function U(t,e){if(e.closed)return;if(t instanceof _)return t.subscribe(e);let n;try{n=P(t)(e)}catch(s){e.error(s)}return n}function j(t,e,n=Number.POSITIVE_INFINITY){return"function"==typeof e?s=>s.pipe(j((n,s)=>B(t(n,s)).pipe($((t,r)=>e(n,t,s,r))),n)):("number"==typeof e&&(n=e),e=>e.lift(new H(t,n)))}class H{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new G(t,this.project,this.concurrent))}}class G extends W{constructor(t,e,n=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(s){return void this.destination.error(s)}this.active++,this._innerSub(e)}_innerSub(t){const e=new V(this),n=this.destination;n.add(e);const s=U(t,e);s!==e&&n.add(s)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyComplete(){const t=this.buffer;this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function q(t=Number.POSITIVE_INFINITY){return j(x,t)}function K(t,e){return e?z(t,e):new _(F(t))}function X(...t){let e=Number.POSITIVE_INFINITY,n=null,s=t[t.length-1];return N(s)?(n=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(e=t.pop())):"number"==typeof s&&(e=t.pop()),null===n&&1===t.length&&t[0]instanceof _?t[0]:q(e)(K(t,n))}function Z(){return function(t){return t.lift(new Y(t))}}class Y{constructor(t){this.connectable=t}call(t,e){const{connectable:n}=this;n._refCount++;const s=new Q(t,n),r=e.subscribe(s);return s.closed||(s.connection=n.connect()),r}}class Q extends b{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e<=0)return void(this.connection=null);if(t._refCount=e-1,e>1)return void(this.connection=null);const{connection:n}=this,s=t._connection;this.connection=null,!s||n&&s!==n||s.unsubscribe()}}class J extends _{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new m,t.add(this.source.subscribe(new et(this.getSubject(),this))),t.closed&&(this._connection=null,t=m.EMPTY)),t}refCount(){return Z()(this)}}const tt=(()=>{const t=J.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class et extends S{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}}}function nt(){return new E}function st(){return t=>{return Z()((e=nt,function(t){let n;n="function"==typeof e?e:function(){return e};const s=Object.create(t,tt);return s.source=t,s.subjectFactory=n,s})(t));var e}}function rt(t){for(let e in t)if(t[e]===rt)return e;throw Error("Could not find renamed property on target object.")}function it(t,e){for(const n in e)e.hasOwnProperty(n)&&!t.hasOwnProperty(n)&&(t[n]=e[n])}function ot(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(ot).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const e=t.toString();if(null==e)return""+e;const n=e.indexOf("\n");return-1===n?e:e.substring(0,n)}function at(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const lt=rt({__forward_ref__:rt});function ut(t){return t.__forward_ref__=ut,t.toString=function(){return ot(this())},t}function ct(t){return ht(t)?t():t}function ht(t){return"function"==typeof t&&t.hasOwnProperty(lt)&&t.__forward_ref__===ut}class dt extends Error{constructor(t,e){super(function(t,e){return`${t?`NG0${t}: `:""}${e}`}(t,e)),this.code=t}}function pt(t){return"string"==typeof t?t:null==t?"":String(t)}function ft(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():pt(t)}function mt(t,e){const n=e?` in ${e}`:"";throw new dt("201",`No provider for ${ft(t)} found${n}`)}function gt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function yt(t){return{providers:t.providers||[],imports:t.imports||[]}}function bt(t){return vt(t,xt)||vt(t,kt)}function vt(t,e){return t.hasOwnProperty(e)?t[e]:null}function wt(t){return t&&(t.hasOwnProperty(_t)||t.hasOwnProperty(Ct))?t[_t]:null}const xt=rt({"\u0275prov":rt}),_t=rt({"\u0275inj":rt}),kt=rt({ngInjectableDef:rt}),Ct=rt({ngInjectorDef:rt});var It=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}({});let St;function Et(t){const e=St;return St=t,e}function Tt(t,e,n){const s=bt(t);return s&&"root"==s.providedIn?void 0===s.value?s.value=s.factory():s.value:n&It.Optional?null:void 0!==e?e:void mt(ot(t),"Injector")}function Nt(t){return{toString:t}.toString()}var $t=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}({}),At=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}({});const Rt="undefined"!=typeof globalThis&&globalThis,Ft="undefined"!=typeof window&&window,Dt="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Ot="undefined"!=typeof global&&global,Lt=Rt||Ot||Ft||Dt,Mt={},Pt=[],zt=rt({"\u0275cmp":rt}),Bt=rt({"\u0275dir":rt}),Vt=rt({"\u0275pipe":rt}),Wt=rt({"\u0275mod":rt}),Ut=rt({"\u0275loc":rt}),jt=rt({"\u0275fac":rt}),Ht=rt({__NG_ELEMENT_ID__:rt});let Gt=0;function qt(t){return Nt(()=>{const e={},n={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===$t.OnPush,directiveDefs:null,pipeDefs:null,selectors:t.selectors||Pt,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||At.Emulated,id:"c",styles:t.styles||Pt,_:null,setInput:null,schemas:t.schemas||null,tView:null},s=t.directives,r=t.features,i=t.pipes;return n.id+=Gt++,n.inputs=Qt(t.inputs,e),n.outputs=Qt(t.outputs),r&&r.forEach(t=>t(n)),n.directiveDefs=s?()=>("function"==typeof s?s():s).map(Kt):null,n.pipeDefs=i?()=>("function"==typeof i?i():i).map(Xt):null,n})}function Kt(t){return ee(t)||function(t){return t[Bt]||null}(t)}function Xt(t){return function(t){return t[Vt]||null}(t)}const Zt={};function Yt(t){const e={type:t.type,bootstrap:t.bootstrap||Pt,declarations:t.declarations||Pt,imports:t.imports||Pt,exports:t.exports||Pt,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null};return null!=t.id&&Nt(()=>{Zt[t.id]=t.type}),e}function Qt(t,e){if(null==t)return Mt;const n={};for(const s in t)if(t.hasOwnProperty(s)){let r=t[s],i=r;Array.isArray(r)&&(i=r[1],r=r[0]),n[r]=s,e&&(e[r]=i)}return n}const Jt=qt;function te(t){return{type:t.type,name:t.name,factory:null,pure:!1!==t.pure,onDestroy:t.type.prototype.ngOnDestroy||null}}function ee(t){return t[zt]||null}function ne(t,e){const n=t[Wt]||null;if(!n&&!0===e)throw new Error(`Type ${ot(t)} does not have '\u0275mod' property.`);return n}const se=20,re=10;function ie(t){return Array.isArray(t)&&"object"==typeof t[1]}function oe(t){return Array.isArray(t)&&!0===t[1]}function ae(t){return 0!=(8&t.flags)}function le(t){return 2==(2&t.flags)}function ue(t){return 1==(1&t.flags)}function ce(t){return null!==t.template}function he(t,e){return t.hasOwnProperty(jt)?t[jt]:null}class de{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}}function pe(){return fe}function fe(t){return t.type.prototype.ngOnChanges&&(t.setInput=ge),me}function me(){const t=ye(this),e=null==t?void 0:t.current;if(e){const n=t.previous;if(n===Mt)t.previous=e;else for(let t in e)n[t]=e[t];t.current=null,this.ngOnChanges(e)}}function ge(t,e,n,s){const r=ye(t)||function(t,e){return t.__ngSimpleChanges__=e}(t,{previous:Mt,current:null}),i=r.current||(r.current={}),o=r.previous,a=this.declaredInputs[n],l=o[a];i[a]=new de(l&&l.currentValue,e,o===Mt),t[s]=e}function ye(t){return t.__ngSimpleChanges__||null}pe.ngInherit=!0;const be="http://www.w3.org/2000/svg";let ve;function we(){return void 0!==ve?ve:"undefined"!=typeof document?document:void 0}function xe(t){return!!t.listen}const _e={createRenderer:(t,e)=>we()};function ke(t){for(;Array.isArray(t);)t=t[0];return t}function Ce(t,e){return ke(e[t])}function Ie(t,e){return ke(e[t.index])}function Se(t,e){return t.data[e]}function Ee(t,e){const n=e[t];return ie(n)?n:n[0]}function Te(t){return 4==(4&t[2])}function Ne(t){return 128==(128&t[2])}function $e(t,e){return null==e?null:t[e]}function Ae(t){t[18]=0}function Re(t,e){t[5]+=e;let n=t,s=t[3];for(;null!==s&&(1===e&&1===n[5]||-1===e&&0===n[5]);)s[5]+=e,n=s,s=s[3]}const Fe={lFrame:en(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function De(){return Fe.bindingsEnabled}function Oe(){return Fe.lFrame.lView}function Le(){return Fe.lFrame.tView}function Me(t){return Fe.lFrame.contextLView=t,t[8]}function Pe(){let t=ze();for(;null!==t&&64===t.type;)t=t.parent;return t}function ze(){return Fe.lFrame.currentTNode}function Be(t,e){const n=Fe.lFrame;n.currentTNode=t,n.isParent=e}function Ve(){return Fe.lFrame.isParent}function We(){Fe.lFrame.isParent=!1}function Ue(){return Fe.isInCheckNoChangesMode}function je(t){Fe.isInCheckNoChangesMode=t}function He(){return Fe.lFrame.bindingIndex++}function Ge(t,e){const n=Fe.lFrame;n.bindingIndex=n.bindingRootIndex=t,qe(e)}function qe(t){Fe.lFrame.currentDirectiveIndex=t}function Ke(t){const e=Fe.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}function Xe(){return Fe.lFrame.currentQueryIndex}function Ze(t){Fe.lFrame.currentQueryIndex=t}function Ye(t){const e=t[1];return 2===e.type?e.declTNode:1===e.type?t[6]:null}function Qe(t,e,n){if(n&It.SkipSelf){let s=e,r=t;for(;s=s.parent,!(null!==s||n&It.Host||(s=Ye(r),null===s)||(r=r[15],10&s.type)););if(null===s)return!1;e=s,t=r}const s=Fe.lFrame=tn();return s.currentTNode=e,s.lView=t,!0}function Je(t){const e=tn(),n=t[1];Fe.lFrame=e,e.currentTNode=n.firstChild,e.lView=t,e.tView=n,e.contextLView=t,e.bindingIndex=n.bindingStartIndex,e.inI18n=!1}function tn(){const t=Fe.lFrame,e=null===t?null:t.child;return null===e?en(t):e}function en(t){const e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=e),e}function nn(){const t=Fe.lFrame;return Fe.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const sn=nn;function rn(){const t=nn();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function on(){return Fe.lFrame.selectedIndex}function an(t){Fe.lFrame.selectedIndex=t}function ln(){const t=Fe.lFrame;return Se(t.tView,t.selectedIndex)}function un(){Fe.lFrame.currentNamespace=be}function cn(t,e){for(let n=e.directiveStart,s=e.directiveEnd;n<s;n++){const e=t.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:r,ngAfterViewInit:i,ngAfterViewChecked:o,ngOnDestroy:a}=e;s&&(t.contentHooks||(t.contentHooks=[])).push(-n,s),r&&((t.contentHooks||(t.contentHooks=[])).push(n,r),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(n,r)),i&&(t.viewHooks||(t.viewHooks=[])).push(-n,i),o&&((t.viewHooks||(t.viewHooks=[])).push(n,o),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(n,o)),null!=a&&(t.destroyHooks||(t.destroyHooks=[])).push(n,a)}}function hn(t,e,n){fn(t,e,3,n)}function dn(t,e,n,s){(3&t[2])===n&&fn(t,e,n,s)}function pn(t,e){let n=t[2];(3&n)===e&&(n&=2047,n+=1,t[2]=n)}function fn(t,e,n,s){const r=null!=s?s:-1,i=e.length-1;let o=0;for(let a=void 0!==s?65535&t[18]:0;a<i;a++)if("number"==typeof e[a+1]){if(o=e[a],null!=s&&o>=s)break}else e[a]<0&&(t[18]+=65536),(o<r||-1==r)&&(mn(t,n,e,a),t[18]=(4294901760&t[18])+a+2),a++}function mn(t,e,n,s){const r=n[s]<0,i=n[s+1],o=t[r?-n[s]:n[s]];if(r){if(t[2]>>11<t[18]>>16&&(3&t[2])===e){t[2]+=2048;try{i.call(o)}finally{}}}else try{i.call(o)}finally{}}const gn=-1;class yn{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}}function bn(t,e,n){const s=xe(t);let r=0;for(;r<n.length;){const i=n[r];if("number"==typeof i){if(0!==i)break;r++;const o=n[r++],a=n[r++],l=n[r++];s?t.setAttribute(e,a,l,o):e.setAttributeNS(o,a,l)}else{const o=i,a=n[++r];wn(o)?s&&t.setProperty(e,o,a):s?t.setAttribute(e,o,a):e.setAttribute(o,a),r++}}return r}function vn(t){return 3===t||4===t||6===t}function wn(t){return 64===t.charCodeAt(0)}function xn(t,e){if(null===e||0===e.length);else if(null===t||0===t.length)t=e.slice();else{let n=-1;for(let s=0;s<e.length;s++){const r=e[s];"number"==typeof r?n=r:0===n||_n(t,n,r,null,-1===n||2===n?e[++s]:null)}}return t}function _n(t,e,n,s,r){let i=0,o=t.length;if(-1===e)o=-1;else for(;i<t.length;){const n=t[i++];if("number"==typeof n){if(n===e){o=-1;break}if(n>e){o=i-1;break}}}for(;i<t.length;){const e=t[i];if("number"==typeof e)break;if(e===n){if(null===s)return void(null!==r&&(t[i+1]=r));if(s===t[i+1])return void(t[i+2]=r)}i++,null!==s&&i++,null!==r&&i++}-1!==o&&(t.splice(o,0,e),i=o+1),t.splice(i++,0,n),null!==s&&t.splice(i++,0,s),null!==r&&t.splice(i++,0,r)}function kn(t){return t!==gn}function Cn(t){return 32767&t}function In(t,e){let n=t>>16,s=e;for(;n>0;)s=s[15],n--;return s}let Sn=!0;function En(t){const e=Sn;return Sn=t,e}let Tn=0;function Nn(t,e){const n=An(t,e);if(-1!==n)return n;const s=e[1];s.firstCreatePass&&(t.injectorIndex=e.length,$n(s.data,t),$n(e,null),$n(s.blueprint,null));const r=Rn(t,e),i=t.injectorIndex;if(kn(r)){const t=Cn(r),n=In(r,e),s=n[1].data;for(let r=0;r<8;r++)e[i+r]=n[t+r]|s[t+r]}return e[i+8]=r,i}function $n(t,e){t.push(0,0,0,0,0,0,0,0,e)}function An(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===e[t.injectorIndex+8]?-1:t.injectorIndex}function Rn(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let n=0,s=null,r=e;for(;null!==r;){const t=r[1],e=t.type;if(s=2===e?t.declTNode:1===e?r[6]:null,null===s)return gn;if(n++,r=r[15],-1!==s.injectorIndex)return s.injectorIndex|n<<16}return gn}function Fn(t,e,n){!function(t,e,n){let s;"string"==typeof n?s=n.charCodeAt(0)||0:n.hasOwnProperty(Ht)&&(s=n[Ht]),null==s&&(s=n[Ht]=Tn++);const r=255&s;e.data[t+(r>>5)]|=1<<r}(t,e,n)}function Dn(t,e,n){if(n&It.Optional)return t;mt(e,"NodeInjector")}function On(t,e,n,s){if(n&It.Optional&&void 0===s&&(s=null),0==(n&(It.Self|It.Host))){const r=t[9],i=Et(void 0);try{return r?r.get(e,s,n&It.Optional):Tt(e,s,n&It.Optional)}finally{Et(i)}}return Dn(s,e,n)}function Ln(t,e,n,s=It.Default,r){if(null!==t){const i=function(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(Ht)?t[Ht]:void 0;return"number"==typeof e?e>=0?255&e:Pn:e}(n);if("function"==typeof i){if(!Qe(e,t,s))return s&It.Host?Dn(r,n,s):On(e,n,s,r);try{const t=i(s);if(null!=t||s&It.Optional)return t;mt(n)}finally{sn()}}else if("number"==typeof i){let r=null,o=An(t,e),a=gn,l=s&It.Host?e[16][6]:null;for((-1===o||s&It.SkipSelf)&&(a=-1===o?Rn(t,e):e[o+8],a!==gn&&Un(s,!1)?(r=e[1],o=Cn(a),e=In(a,e)):o=-1);-1!==o;){const t=e[1];if(Wn(i,o,t.data)){const t=zn(o,e,n,r,s,l);if(t!==Mn)return t}a=e[o+8],a!==gn&&Un(s,e[1].data[o+8]===l)&&Wn(i,o,e)?(r=t,o=Cn(a),e=In(a,e)):o=-1}}}return On(e,n,s,r)}const Mn={};function Pn(){return new jn(Pe(),Oe())}function zn(t,e,n,s,r,i){const o=e[1],a=o.data[t+8],l=Bn(a,o,n,null==s?le(a)&&Sn:s!=o&&0!=(3&a.type),r&It.Host&&i===a);return null!==l?Vn(e,o,l,a):Mn}function Bn(t,e,n,s,r){const i=t.providerIndexes,o=e.data,a=1048575&i,l=t.directiveStart,u=i>>20,c=r?a+u:t.directiveEnd;for(let h=s?a:a+u;h<c;h++){const t=o[h];if(h<l&&n===t||h>=l&&t.type===n)return h}if(r){const t=o[l];if(t&&ce(t)&&t.type===n)return l}return null}function Vn(t,e,n,s){let r=t[n];const i=e.data;if(r instanceof yn){const o=r;o.resolving&&function(t,e){throw new dt("200",`Circular dependency in DI detected for ${t}`)}(ft(i[n]));const a=En(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?Et(o.injectImpl):null;Qe(t,s,It.Default);try{r=t[n]=o.factory(void 0,i,t,s),e.firstCreatePass&&n>=s.directiveStart&&function(t,e,n){const{ngOnChanges:s,ngOnInit:r,ngDoCheck:i}=e.type.prototype;if(s){const s=fe(e);(n.preOrderHooks||(n.preOrderHooks=[])).push(t,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,s)}r&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-t,r),i&&((n.preOrderHooks||(n.preOrderHooks=[])).push(t,i),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,i))}(n,i[n],e)}finally{null!==l&&Et(l),En(a),o.resolving=!1,sn()}}return r}function Wn(t,e,n){return!!(n[e+(t>>5)]&1<<t)}function Un(t,e){return!(t&It.Self||t&It.Host&&e)}class jn{constructor(t,e){this._tNode=t,this._lView=e}get(t,e){return Ln(this._tNode,this._lView,t,void 0,e)}}function Hn(t){return Nt(()=>{const e=t.prototype.constructor,n=e[jt]||Gn(e),s=Object.prototype;let r=Object.getPrototypeOf(t.prototype).constructor;for(;r&&r!==s;){const t=r[jt]||Gn(r);if(t&&t!==n)return t;r=Object.getPrototypeOf(r)}return t=>new t})}function Gn(t){return ht(t)?()=>{const e=Gn(ct(t));return e&&e()}:he(t)}function qn(t){return function(t,e){if("class"===e)return t.classes;if("style"===e)return t.styles;const n=t.attrs;if(n){const t=n.length;let s=0;for(;s<t;){const r=n[s];if(vn(r))break;if(0===r)s+=2;else if("number"==typeof r)for(s++;s<t&&"string"==typeof n[s];)s++;else{if(r===e)return n[s+1];s+=2}}}return null}(Pe(),t)}const Kn="__parameters__";function Xn(t,e,n){return Nt(()=>{const s=function(t){return function(...e){if(t){const n=t(...e);for(const t in n)this[t]=n[t]}}}(e);function r(...t){if(this instanceof r)return s.apply(this,t),this;const e=new r(...t);return n.annotation=e,n;function n(t,n,s){const r=t.hasOwnProperty(Kn)?t[Kn]:Object.defineProperty(t,Kn,{value:[]})[Kn];for(;r.length<=s;)r.push(null);return(r[s]=r[s]||[]).push(e),t}}return n&&(r.prototype=Object.create(n.prototype)),r.prototype.ngMetadataName=t,r.annotationCls=r,r})}class Zn{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=gt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}const Yn=new Zn("AnalyzeForEntryComponents"),Qn=Function;function Jn(t,e){void 0===e&&(e=t);for(let n=0;n<t.length;n++){let s=t[n];Array.isArray(s)?(e===t&&(e=t.slice(0,n)),Jn(s,e)):e!==t&&e.push(s)}return e}function ts(t,e){t.forEach(t=>Array.isArray(t)?ts(t,e):e(t))}function es(t,e,n){e>=t.length?t.push(n):t.splice(e,0,n)}function ns(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function ss(t,e){const n=[];for(let s=0;s<t;s++)n.push(e);return n}function rs(t,e,n){let s=os(t,e);return s>=0?t[1|s]=n:(s=~s,function(t,e,n,s){let r=t.length;if(r==e)t.push(n,s);else if(1===r)t.push(s,t[0]),t[0]=n;else{for(r--,t.push(t[r-1],t[r]);r>e;)t[r]=t[r-2],r--;t[e]=n,t[e+1]=s}}(t,s,e,n)),s}function is(t,e){const n=os(t,e);if(n>=0)return t[1|n]}function os(t,e){return function(t,e,n){let s=0,r=t.length>>1;for(;r!==s;){const n=s+(r-s>>1),i=t[n<<1];if(e===i)return n<<1;i>e?r=n:s=n+1}return~(r<<1)}(t,e)}const as={},ls=/\n/gm,us="__source",cs=rt({provide:String,useValue:rt});let hs;function ds(t){const e=hs;return hs=t,e}function ps(t,e=It.Default){if(void 0===hs)throw new Error("inject() must be called from an injection context");return null===hs?Tt(t,void 0,e):hs.get(t,e&It.Optional?null:void 0,e)}function fs(t,e=It.Default){return(St||ps)(ct(t),e)}const ms=fs;function gs(t){const e=[];for(let n=0;n<t.length;n++){const s=ct(t[n]);if(Array.isArray(s)){if(0===s.length)throw new Error("Arguments array must have arguments.");let t,n=It.Default;for(let e=0;e<s.length;e++){const r=s[e],i=r.__NG_DI_FLAG__;"number"==typeof i?-1===i?t=r.token:n|=i:t=r}e.push(fs(t,n))}else e.push(fs(s))}return e}function ys(t,e){return t.__NG_DI_FLAG__=e,t.prototype.__NG_DI_FLAG__=e,t}const bs=ys(Xn("Inject",t=>({token:t})),-1),vs=ys(Xn("Optional"),8),ws=ys(Xn("SkipSelf"),4);let xs,_s;function ks(t){var e;return(null===(e=function(){if(void 0===xs&&(xs=null,Lt.trustedTypes))try{xs=Lt.trustedTypes.createPolicy("angular",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return xs}())||void 0===e?void 0:e.createHTML(t))||t}function Cs(t){var e;return(null===(e=function(){if(void 0===_s&&(_s=null,Lt.trustedTypes))try{_s=Lt.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return _s}())||void 0===e?void 0:e.createHTML(t))||t}class Is{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}class Ss extends Is{getTypeName(){return"HTML"}}class Es extends Is{getTypeName(){return"Style"}}class Ts extends Is{getTypeName(){return"Script"}}class Ns extends Is{getTypeName(){return"URL"}}class $s extends Is{getTypeName(){return"ResourceURL"}}function As(t){return t instanceof Is?t.changingThisBreaksApplicationSecurity:t}function Rs(t,e){const n=Fs(t);if(null!=n&&n!==e){if("ResourceURL"===n&&"URL"===e)return!0;throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`)}return n===e}function Fs(t){return t instanceof Is&&t.getTypeName()||null}class Ds{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(ks(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch(e){return null}}}class Os{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const t=this.inertDocument.createElement("html");this.inertDocument.appendChild(t);const e=this.inertDocument.createElement("body");t.appendChild(e)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=ks(t),e;const n=this.inertDocument.createElement("body");return n.innerHTML=ks(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(n),n}stripCustomNsAttrs(t){const e=t.attributes;for(let s=e.length-1;0<s;s--){const n=e.item(s).name;"xmlns:ns1"!==n&&0!==n.indexOf("ns1:")||t.removeAttribute(n)}let n=t.firstChild;for(;n;)n.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(n),n=n.nextSibling}}const Ls=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,Ms=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;function Ps(t){return(t=String(t)).match(Ls)||t.match(Ms)?t:"unsafe:"+t}function zs(t){const e={};for(const n of t.split(","))e[n]=!0;return e}function Bs(...t){const e={};for(const n of t)for(const t in n)n.hasOwnProperty(t)&&(e[t]=!0);return e}const Vs=zs("area,br,col,hr,img,wbr"),Ws=zs("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),Us=zs("rp,rt"),js=Bs(Us,Ws),Hs=Bs(Vs,Bs(Ws,zs("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),Bs(Us,zs("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),js),Gs=zs("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),qs=zs("srcset"),Ks=Bs(Gs,qs,zs("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),zs("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),Xs=zs("script,style,template");class Zs{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,n=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?n=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,n&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let t=this.checkClobberedElement(e,e.nextSibling);if(t){e=t;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!Hs.hasOwnProperty(e))return this.sanitizedSomething=!0,!Xs.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const n=t.attributes;for(let r=0;r<n.length;r++){const t=n.item(r),e=t.name,i=e.toLowerCase();if(!Ks.hasOwnProperty(i)){this.sanitizedSomething=!0;continue}let o=t.value;Gs[i]&&(o=Ps(o)),qs[i]&&(s=o,o=(s=String(s)).split(",").map(t=>Ps(t.trim())).join(", ")),this.buf.push(" ",e,'="',Js(o),'"')}var s;return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();Hs.hasOwnProperty(e)&&!Vs.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(Js(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const Ys=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,Qs=/([^\#-~ |!])/g;function Js(t){return t.replace(/&/g,"&amp;").replace(Ys,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(Qs,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let tr;function er(t,e){let n=null;try{tr=tr||function(t){const e=new Os(t);return function(){try{return!!(new window.DOMParser).parseFromString(ks(""),"text/html")}catch(t){return!1}}()?new Ds(e):e}(t);let s=e?String(e):"";n=tr.getInertBodyElement(s);let r=5,i=s;do{if(0===r)throw new Error("Failed to sanitize html because the input is unstable");r--,s=i,i=n.innerHTML,n=tr.getInertBodyElement(s)}while(s!==i);return ks((new Zs).sanitizeChildren(nr(n)||n))}finally{if(n){const t=nr(n)||n;for(;t.firstChild;)t.removeChild(t.firstChild)}}}function nr(t){return"content"in t&&function(t){return t.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===t.nodeName}(t)?t.content:null}var sr=function(t){return t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL",t}({});function rr(t){const e=or();return e?Cs(e.sanitize(sr.HTML,t)||""):Rs(t,"HTML")?Cs(As(t)):er(we(),pt(t))}function ir(t){const e=or();return e?e.sanitize(sr.URL,t)||"":Rs(t,"URL")?As(t):Ps(pt(t))}function or(){const t=Oe();return t&&t[12]}function ar(t,e){t.__ngContext__=e}function lr(t){const e=function(t){return t.__ngContext__||null}(t);return e?Array.isArray(e)?e:e.lView:null}function ur(t){return t.ngDebugContext}function cr(t){return t.ngOriginalError}function hr(t,...e){t.error(...e)}class dr{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),n=this._findContext(t),s=function(t){return t.ngErrorLogger||hr}(t);s(this._console,"ERROR",t),e&&s(this._console,"ORIGINAL ERROR",e),n&&s(this._console,"ERROR CONTEXT",n)}_findContext(t){return t?ur(t)?ur(t):this._findContext(cr(t)):null}_findOriginalError(t){let e=cr(t);for(;e&&cr(e);)e=cr(e);return e}}const pr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(Lt))();function fr(t){return t instanceof Function?t():t}var mr=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}({});function gr(t,e){return(void 0)(t,e)}function yr(t){const e=t[3];return oe(e)?e[3]:e}function br(t){return wr(t[13])}function vr(t){return wr(t[4])}function wr(t){for(;null!==t&&!oe(t);)t=t[4];return t}function xr(t,e,n,s,r){if(null!=s){let i,o=!1;oe(s)?i=s:ie(s)&&(o=!0,s=s[0]);const a=ke(s);0===t&&null!==n?null==r?Nr(e,n,a):Tr(e,n,a,r||null,!0):1===t&&null!==n?Tr(e,n,a,r||null,!0):2===t?function(t,e,n){const s=Ar(t,e);s&&function(t,e,n,s){xe(t)?t.removeChild(e,n,s):e.removeChild(n)}(t,s,e,n)}(e,a,o):3===t&&e.destroyNode(a),null!=i&&function(t,e,n,s,r){const i=n[7];i!==ke(n)&&xr(e,t,s,i,r);for(let o=re;o<n.length;o++){const r=n[o];zr(r[1],r,t,e,s,i)}}(e,t,i,n,r)}}function _r(t,e,n){return xe(t)?t.createElement(e,n):null===n?t.createElement(e):t.createElementNS(n,e)}function kr(t,e){const n=t[9],s=n.indexOf(e),r=e[3];1024&e[2]&&(e[2]&=-1025,Re(r,-1)),n.splice(s,1)}function Cr(t,e){if(t.length<=re)return;const n=re+e,s=t[n];if(s){const i=s[17];null!==i&&i!==t&&kr(i,s),e>0&&(t[n-1][4]=s[4]);const o=ns(t,re+e);zr(s[1],r=s,r[11],2,null,null),r[0]=null,r[6]=null;const a=o[19];null!==a&&a.detachView(o[1]),s[3]=null,s[4]=null,s[2]&=-129}var r;return s}function Ir(t,e){if(!(256&e[2])){const n=e[11];xe(n)&&n.destroyNode&&zr(t,e,n,3,null,null),function(t){let e=t[13];if(!e)return Sr(t[1],t);for(;e;){let n=null;if(ie(e))n=e[13];else{const t=e[10];t&&(n=t)}if(!n){for(;e&&!e[4]&&e!==t;)ie(e)&&Sr(e[1],e),e=e[3];null===e&&(e=t),ie(e)&&Sr(e[1],e),n=e&&e[4]}e=n}}(e)}}function Sr(t,e){if(!(256&e[2])){e[2]&=-129,e[2]|=256,function(t,e){let n;if(null!=t&&null!=(n=t.destroyHooks))for(let s=0;s<n.length;s+=2){const t=e[n[s]];if(!(t instanceof yn)){const e=n[s+1];if(Array.isArray(e))for(let n=0;n<e.length;n+=2){const s=t[e[n]],r=e[n+1];try{r.call(s)}finally{}}else try{e.call(t)}finally{}}}}(t,e),function(t,e){const n=t.cleanup,s=e[7];let r=-1;if(null!==n)for(let i=0;i<n.length-1;i+=2)if("string"==typeof n[i]){const t=n[i+1],o="function"==typeof t?t(e):ke(e[t]),a=s[r=n[i+2]],l=n[i+3];"boolean"==typeof l?o.removeEventListener(n[i],a,l):l>=0?s[r=l]():s[r=-l].unsubscribe(),i+=2}else{const t=s[r=n[i+1]];n[i].call(t)}if(null!==s){for(let t=r+1;t<s.length;t++)(0,s[t])();e[7]=null}}(t,e),1===e[1].type&&xe(e[11])&&e[11].destroy();const n=e[17];if(null!==n&&oe(e[3])){n!==e[3]&&kr(n,e);const s=e[19];null!==s&&s.detachView(t)}}}function Er(t,e,n){return function(t,e,n){let s=e;for(;null!==s&&40&s.type;)s=(e=s).parent;if(null===s)return n[0];if(2&s.flags){const e=t.data[s.directiveStart].encapsulation;if(e===At.None||e===At.Emulated)return null}return Ie(s,n)}(t,e.parent,n)}function Tr(t,e,n,s,r){xe(t)?t.insertBefore(e,n,s,r):e.insertBefore(n,s,r)}function Nr(t,e,n){xe(t)?t.appendChild(e,n):e.appendChild(n)}function $r(t,e,n,s,r){null!==s?Tr(t,e,n,s,r):Nr(t,e,n)}function Ar(t,e){return xe(t)?t.parentNode(e):e.parentNode}function Rr(t,e,n){return Fr(t,e,n)}let Fr=function(t,e,n){return 40&t.type?Ie(t,n):null};function Dr(t,e,n,s){const r=Er(t,s,e),i=e[11],o=Rr(s.parent||e[6],s,e);if(null!=r)if(Array.isArray(n))for(let a=0;a<n.length;a++)$r(i,r,n[a],o,!1);else $r(i,r,n,o,!1)}function Or(t,e){if(null!==e){const n=e.type;if(3&n)return Ie(e,t);if(4&n)return Mr(-1,t[e.index]);if(8&n){const n=e.child;if(null!==n)return Or(t,n);{const n=t[e.index];return oe(n)?Mr(-1,n):ke(n)}}if(32&n)return gr(e,t)()||ke(t[e.index]);{const n=Lr(t,e);return null!==n?Array.isArray(n)?n[0]:Or(yr(t[16]),n):Or(t,e.next)}}return null}function Lr(t,e){return null!==e?t[16][6].projection[e.projection]:null}function Mr(t,e){const n=re+t+1;if(n<e.length){const t=e[n],s=t[1].firstChild;if(null!==s)return Or(t,s)}return e[7]}function Pr(t,e,n,s,r,i,o){for(;null!=n;){const a=s[n.index],l=n.type;if(o&&0===e&&(a&&ar(ke(a),s),n.flags|=4),64!=(64&n.flags))if(8&l)Pr(t,e,n.child,s,r,i,!1),xr(e,t,r,a,i);else if(32&l){const o=gr(n,s);let l;for(;l=o();)xr(e,t,r,l,i);xr(e,t,r,a,i)}else 16&l?Br(t,e,s,n,r,i):xr(e,t,r,a,i);n=o?n.projectionNext:n.next}}function zr(t,e,n,s,r,i){Pr(n,s,t.firstChild,e,r,i,!1)}function Br(t,e,n,s,r,i){const o=n[16],a=o[6].projection[s.projection];if(Array.isArray(a))for(let l=0;l<a.length;l++)xr(e,t,r,a[l],i);else Pr(t,e,a,o[3],r,i,!0)}function Vr(t,e,n){xe(t)?t.setAttribute(e,"style",n):e.style.cssText=n}function Wr(t,e,n){xe(t)?""===n?t.removeAttribute(e,"class"):t.setAttribute(e,"class",n):e.className=n}function Ur(t,e,n){let s=t.length;for(;;){const r=t.indexOf(e,n);if(-1===r)return r;if(0===r||t.charCodeAt(r-1)<=32){const n=e.length;if(r+n===s||t.charCodeAt(r+n)<=32)return r}n=r+1}}const jr="ng-template";function Hr(t,e,n){let s=0;for(;s<t.length;){let r=t[s++];if(n&&"class"===r){if(r=t[s],-1!==Ur(r.toLowerCase(),e,0))return!0}else if(1===r){for(;s<t.length&&"string"==typeof(r=t[s++]);)if(r.toLowerCase()===e)return!0;return!1}}return!1}function Gr(t){return 4===t.type&&t.value!==jr}function qr(t,e,n){return e===(4!==t.type||n?t.value:jr)}function Kr(t,e,n){let s=4;const r=t.attrs||[],i=function(t){for(let e=0;e<t.length;e++)if(vn(t[e]))return e;return t.length}(r);let o=!1;for(let a=0;a<e.length;a++){const l=e[a];if("number"!=typeof l){if(!o)if(4&s){if(s=2|1&s,""!==l&&!qr(t,l,n)||""===l&&1===e.length){if(Xr(s))return!1;o=!0}}else{const u=8&s?l:e[++a];if(8&s&&null!==t.attrs){if(!Hr(t.attrs,u,n)){if(Xr(s))return!1;o=!0}continue}const c=Zr(8&s?"class":l,r,Gr(t),n);if(-1===c){if(Xr(s))return!1;o=!0;continue}if(""!==u){let t;t=c>i?"":r[c+1].toLowerCase();const e=8&s?t:null;if(e&&-1!==Ur(e,u,0)||2&s&&u!==t){if(Xr(s))return!1;o=!0}}}}else{if(!o&&!Xr(s)&&!Xr(l))return!1;if(o&&Xr(l))continue;o=!1,s=l|1&s}}return Xr(s)||o}function Xr(t){return 0==(1&t)}function Zr(t,e,n,s){if(null===e)return-1;let r=0;if(s||!n){let n=!1;for(;r<e.length;){const s=e[r];if(s===t)return r;if(3===s||6===s)n=!0;else{if(1===s||2===s){let t=e[++r];for(;"string"==typeof t;)t=e[++r];continue}if(4===s)break;if(0===s){r+=4;continue}}r+=n?1:2}return-1}return function(t,e){let n=t.indexOf(4);if(n>-1)for(n++;n<t.length;){const s=t[n];if("number"==typeof s)return-1;if(s===e)return n;n++}return-1}(e,t)}function Yr(t,e,n=!1){for(let s=0;s<e.length;s++)if(Kr(t,e[s],n))return!0;return!1}function Qr(t,e){t:for(let n=0;n<e.length;n++){const s=e[n];if(t.length===s.length){for(let e=0;e<t.length;e++)if(t[e]!==s[e])continue t;return!0}}return!1}function Jr(t,e){return t?":not("+e.trim()+")":e}function ti(t){let e=t[0],n=1,s=2,r="",i=!1;for(;n<t.length;){let o=t[n];if("string"==typeof o)if(2&s){const e=t[++n];r+="["+o+(e.length>0?'="'+e+'"':"")+"]"}else 8&s?r+="."+o:4&s&&(r+=" "+o);else""===r||Xr(o)||(e+=Jr(i,r),r=""),s=o,i=i||!Xr(s);n++}return""!==r&&(e+=Jr(i,r)),e}const ei={};function ni(t){si(Le(),Oe(),on()+t,Ue())}function si(t,e,n,s){if(!s)if(3==(3&e[2])){const s=t.preOrderCheckHooks;null!==s&&hn(e,s,n)}else{const s=t.preOrderHooks;null!==s&&dn(e,s,0,n)}an(n)}function ri(t,e){return t<<17|e<<2}function ii(t){return t>>17&32767}function oi(t){return 2|t}function ai(t){return(131068&t)>>2}function li(t,e){return-131069&t|e<<2}function ui(t){return 1|t}function ci(t,e){const n=t.contentQueries;if(null!==n)for(let s=0;s<n.length;s+=2){const r=n[s],i=n[s+1];if(-1!==i){const n=t.data[i];Ze(r),n.contentQueries(2,e[i],i)}}}function hi(t,e,n,s,r,i,o,a,l,u){const c=e.blueprint.slice();return c[0]=r,c[2]=140|s,Ae(c),c[3]=c[15]=t,c[8]=n,c[10]=o||t&&t[10],c[11]=a||t&&t[11],c[12]=l||t&&t[12]||null,c[9]=u||t&&t[9]||null,c[6]=i,c[16]=2==e.type?t[16]:c,c}function di(t,e,n,s,r){let i=t.data[e];if(null===i)i=function(t,e,n,s,r){const i=ze(),o=Ve(),a=t.data[e]=function(t,e,n,s,r,i){return{type:n,index:s,insertBeforeIndex:null,injectorIndex:e?e.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?i:i&&i.parent,n,e,s,r);return null===t.firstChild&&(t.firstChild=a),null!==i&&(o?null==i.child&&null!==a.parent&&(i.child=a):null===i.next&&(i.next=a)),a}(t,e,n,s,r),Fe.lFrame.inI18n&&(i.flags|=64);else if(64&i.type){i.type=n,i.value=s,i.attrs=r;const t=function(){const t=Fe.lFrame,e=t.currentTNode;return t.isParent?e:e.parent}();i.injectorIndex=null===t?-1:t.injectorIndex}return Be(i,!0),i}function pi(t,e,n,s){if(0===n)return-1;const r=e.length;for(let i=0;i<n;i++)e.push(s),t.blueprint.push(s),t.data.push(null);return r}function fi(t,e,n){Je(e);try{const s=t.viewQuery;null!==s&&Ui(1,s,n);const r=t.template;null!==r&&yi(t,e,r,1,n),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&ci(t,e),t.staticViewQueries&&Ui(2,t.viewQuery,n);const i=t.components;null!==i&&function(t,e){for(let n=0;n<e.length;n++)Pi(t,e[n])}(e,i)}catch(s){throw t.firstCreatePass&&(t.incompleteFirstPass=!0),s}finally{e[2]&=-5,rn()}}function mi(t,e,n,s){const r=e[2];if(256==(256&r))return;Je(e);const i=Ue();try{Ae(e),Fe.lFrame.bindingIndex=t.bindingStartIndex,null!==n&&yi(t,e,n,2,s);const o=3==(3&r);if(!i)if(o){const n=t.preOrderCheckHooks;null!==n&&hn(e,n,null)}else{const n=t.preOrderHooks;null!==n&&dn(e,n,0,null),pn(e,0)}if(function(t){for(let e=br(t);null!==e;e=vr(e)){if(!e[2])continue;const t=e[9];for(let e=0;e<t.length;e++){const n=t[e],s=n[3];0==(1024&n[2])&&Re(s,1),n[2]|=1024}}}(e),function(t){for(let e=br(t);null!==e;e=vr(e))for(let t=re;t<e.length;t++){const n=e[t],s=n[1];Ne(n)&&mi(s,n,s.template,n[8])}}(e),null!==t.contentQueries&&ci(t,e),!i)if(o){const n=t.contentCheckHooks;null!==n&&hn(e,n)}else{const n=t.contentHooks;null!==n&&dn(e,n,1),pn(e,1)}!function(t,e){const n=t.hostBindingOpCodes;if(null!==n)try{for(let t=0;t<n.length;t++){const s=n[t];if(s<0)an(~s);else{const r=s,i=n[++t],o=n[++t];Ge(i,r),o(2,e[r])}}}finally{an(-1)}}(t,e);const a=t.components;null!==a&&function(t,e){for(let n=0;n<e.length;n++)Li(t,e[n])}(e,a);const l=t.viewQuery;if(null!==l&&Ui(2,l,s),!i)if(o){const n=t.viewCheckHooks;null!==n&&hn(e,n)}else{const n=t.viewHooks;null!==n&&dn(e,n,2),pn(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),i||(e[2]&=-73),1024&e[2]&&(e[2]&=-1025,Re(e[3],-1))}finally{rn()}}function gi(t,e,n,s){const r=e[10],i=!Ue(),o=Te(e);try{i&&!o&&r.begin&&r.begin(),o&&fi(t,e,s),mi(t,e,n,s)}finally{i&&!o&&r.end&&r.end()}}function yi(t,e,n,s,r){const i=on(),o=2&s;try{an(-1),o&&e.length>se&&si(t,e,se,Ue()),n(s,r)}finally{an(i)}}function bi(t,e,n){De()&&(function(t,e,n,s){const r=n.directiveStart,i=n.directiveEnd;t.firstCreatePass||Nn(n,e),ar(s,e);const o=n.initialInputs;for(let a=r;a<i;a++){const s=t.data[a],i=ce(s);i&&Ri(e,n,s);const l=Vn(e,t,a,n);ar(l,e),null!==o&&Fi(0,a-r,l,s,0,o),i&&(Ee(n.index,e)[8]=l)}}(t,e,n,Ie(n,e)),128==(128&n.flags)&&function(t,e,n){const s=n.directiveStart,r=n.directiveEnd,i=n.index,o=Fe.lFrame.currentDirectiveIndex;try{an(i);for(let n=s;n<r;n++){const s=t.data[n],r=e[n];qe(n),null===s.hostBindings&&0===s.hostVars&&null===s.hostAttrs||Ei(s,r)}}finally{an(-1),qe(o)}}(t,e,n))}function vi(t,e,n=Ie){const s=e.localNames;if(null!==s){let r=e.index+1;for(let i=0;i<s.length;i+=2){const o=s[i+1],a=-1===o?n(e,t):t[o];t[r++]=a}}}function wi(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=xi(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):e}function xi(t,e,n,s,r,i,o,a,l,u){const c=se+s,h=c+r,d=function(t,e){const n=[];for(let s=0;s<e;s++)n.push(s<t?null:ei);return n}(c,h),p="function"==typeof u?u():u;return d[1]={type:t,blueprint:d,template:n,queries:null,viewQuery:a,declTNode:e,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function _i(t,e,n,s){const r=Hi(e);null===n?r.push(s):(r.push(n),t.firstCreatePass&&Gi(t).push(s,r.length-1))}function ki(t,e,n){for(let s in t)if(t.hasOwnProperty(s)){const r=t[s];(n=null===n?{}:n).hasOwnProperty(s)?n[s].push(e,r):n[s]=[e,r]}return n}function Ci(t,e,n,s,r,i,o,a){const l=Ie(e,n);let u,c=e.inputs;var h;!a&&null!=c&&(u=c[s])?(Xi(t,n,u,s,r),le(e)&&function(t,e){const n=Ee(e,t);16&n[2]||(n[2]|=64)}(n,e.index)):3&e.type&&(s="class"===(h=s)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,r=null!=o?o(r,e.value||"",s):r,xe(i)?i.setProperty(l,s,r):wn(s)||(l.setProperty?l.setProperty(s,r):l[s]=r))}function Ii(t,e,n,s){let r=!1;if(De()){const i=function(t,e,n){const s=t.directiveRegistry;let r=null;if(s)for(let i=0;i<s.length;i++){const o=s[i];Yr(n,o.selectors,!1)&&(r||(r=[]),Fn(Nn(n,e),t,o.type),ce(o)?(Ti(t,n),r.unshift(o)):r.push(o))}return r}(t,e,n),o=null===s?null:{"":-1};if(null!==i){r=!0,$i(n,t.data.length,i.length);for(let t=0;t<i.length;t++){const e=i[t];e.providersResolver&&e.providersResolver(e)}let s=!1,a=!1,l=pi(t,e,i.length,null);for(let r=0;r<i.length;r++){const u=i[r];n.mergedAttrs=xn(n.mergedAttrs,u.hostAttrs),Ai(t,n,e,l,u),Ni(l,u,o),null!==u.contentQueries&&(n.flags|=8),null===u.hostBindings&&null===u.hostAttrs&&0===u.hostVars||(n.flags|=128);const c=u.type.prototype;!s&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(n.index),s=!0),a||!c.ngOnChanges&&!c.ngDoCheck||((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(n.index),a=!0),l++}!function(t,e){const n=e.directiveEnd,s=t.data,r=e.attrs,i=[];let o=null,a=null;for(let l=e.directiveStart;l<n;l++){const t=s[l],n=t.inputs,u=null===r||Gr(e)?null:Di(n,r);i.push(u),o=ki(n,l,o),a=ki(t.outputs,l,a)}null!==o&&(o.hasOwnProperty("class")&&(e.flags|=16),o.hasOwnProperty("style")&&(e.flags|=32)),e.initialInputs=i,e.inputs=o,e.outputs=a}(t,n)}o&&function(t,e,n){if(e){const s=t.localNames=[];for(let t=0;t<e.length;t+=2){const r=n[e[t+1]];if(null==r)throw new dt("301",`Export of name '${e[t+1]}' not found!`);s.push(e[t],r)}}}(n,s,o)}return n.mergedAttrs=xn(n.mergedAttrs,n.attrs),r}function Si(t,e,n,s,r,i){const o=i.hostBindings;if(o){let n=t.hostBindingOpCodes;null===n&&(n=t.hostBindingOpCodes=[]);const i=~e.index;(function(t){let e=t.length;for(;e>0;){const n=t[--e];if("number"==typeof n&&n<0)return n}return 0})(n)!=i&&n.push(i),n.push(s,r,o)}}function Ei(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function Ti(t,e){e.flags|=2,(t.components||(t.components=[])).push(e.index)}function Ni(t,e,n){if(n){if(e.exportAs)for(let s=0;s<e.exportAs.length;s++)n[e.exportAs[s]]=t;ce(e)&&(n[""]=t)}}function $i(t,e,n){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+n,t.providerIndexes=e}function Ai(t,e,n,s,r){t.data[s]=r;const i=r.factory||(r.factory=he(r.type)),o=new yn(i,ce(r),null);t.blueprint[s]=o,n[s]=o,Si(t,e,0,s,pi(t,n,r.hostVars,ei),r)}function Ri(t,e,n){const s=Ie(e,t),r=wi(n),i=t[10],o=zi(t,hi(t,r,null,n.onPush?64:16,s,e,i,i.createRenderer(s,n),null,null));t[e.index]=o}function Fi(t,e,n,s,r,i){const o=i[e];if(null!==o){const t=s.setInput;for(let e=0;e<o.length;){const r=o[e++],i=o[e++],a=o[e++];null!==t?s.setInput(n,a,r,i):n[i]=a}}}function Di(t,e){let n=null,s=0;for(;s<e.length;){const r=e[s];if(0!==r)if(5!==r){if("number"==typeof r)break;t.hasOwnProperty(r)&&(null===n&&(n=[]),n.push(r,t[r],e[s+1])),s+=2}else s+=2;else s+=4}return n}function Oi(t,e,n,s){return new Array(t,!0,!1,e,null,0,s,n,null,null)}function Li(t,e){const n=Ee(e,t);if(Ne(n)){const t=n[1];80&n[2]?mi(t,n,t.template,n[8]):n[5]>0&&Mi(n)}}function Mi(t){for(let n=br(t);null!==n;n=vr(n))for(let t=re;t<n.length;t++){const e=n[t];if(1024&e[2]){const t=e[1];mi(t,e,t.template,e[8])}else e[5]>0&&Mi(e)}const e=t[1].components;if(null!==e)for(let n=0;n<e.length;n++){const s=Ee(e[n],t);Ne(s)&&s[5]>0&&Mi(s)}}function Pi(t,e){const n=Ee(e,t),s=n[1];!function(t,e){for(let n=e.length;n<t.blueprint.length;n++)e.push(t.blueprint[n])}(s,n),fi(s,n,n[8])}function zi(t,e){return t[13]?t[14][4]=e:t[13]=e,t[14]=e,e}function Bi(t){for(;t;){t[2]|=64;const e=yr(t);if(0!=(512&t[2])&&!e)return t;t=e}return null}function Vi(t,e,n){const s=e[10];s.begin&&s.begin();try{mi(t,e,t.template,n)}catch(r){throw Ki(e,r),r}finally{s.end&&s.end()}}function Wi(t){!function(t){for(let e=0;e<t.components.length;e++){const n=t.components[e],s=lr(n),r=s[1];gi(r,s,r.template,n)}}(t[8])}function Ui(t,e,n){Ze(0),e(t,n)}const ji=(()=>Promise.resolve(null))();function Hi(t){return t[7]||(t[7]=[])}function Gi(t){return t.cleanup||(t.cleanup=[])}function qi(t,e,n){return(null===t||ce(t))&&(n=function(t){for(;Array.isArray(t);){if("object"==typeof t[1])return t;t=t[0]}return null}(n[e.index])),n[11]}function Ki(t,e){const n=t[9],s=n?n.get(dr,null):null;s&&s.handleError(e)}function Xi(t,e,n,s,r){for(let i=0;i<n.length;){const o=n[i++],a=n[i++],l=e[o],u=t.data[o];null!==u.setInput?u.setInput(l,r,s,a):l[a]=r}}function Zi(t,e,n){let s=n?t.styles:null,r=n?t.classes:null,i=0;if(null!==e)for(let o=0;o<e.length;o++){const t=e[o];"number"==typeof t?i=t:1==i?r=at(r,t):2==i&&(s=at(s,t+": "+e[++o]+";"))}n?t.styles=s:t.stylesWithoutHost=s,n?t.classes=r:t.classesWithoutHost=r}const Yi=new Zn("INJECTOR",-1);class Qi{get(t,e=as){if(e===as){const e=new Error(`NullInjectorError: No provider for ${ot(t)}!`);throw e.name="NullInjectorError",e}return e}}const Ji=new Zn("Set Injector scope."),to={},eo={};let no;function so(){return void 0===no&&(no=new Qi),no}function ro(t,e=null,n=null,s){return new io(t,n,e||so(),s)}class io{constructor(t,e,n,s=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const r=[];e&&ts(e,n=>this.processProvider(n,t,e)),ts([t],t=>this.processInjectorType(t,[],r)),this.records.set(Yi,lo(void 0,this));const i=this.records.get(Ji);this.scope=null!=i?i.value:null,this.source=s||("object"==typeof t?null:ot(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=as,n=It.Default){this.assertNotDestroyed();const s=ds(this);try{if(!(n&It.SkipSelf)){let e=this.records.get(t);if(void 0===e){const n=("function"==typeof(r=t)||"object"==typeof r&&r instanceof Zn)&&bt(t);e=n&&this.injectableDefInScope(n)?lo(oo(t),to):null,this.records.set(t,e)}if(null!=e)return this.hydrate(t,e)}return(n&It.Self?so():this.parent).get(t,e=n&It.Optional&&e===as?null:e)}catch(i){if("NullInjectorError"===i.name){if((i.ngTempTokenPath=i.ngTempTokenPath||[]).unshift(ot(t)),s)throw i;return function(t,e,n,s){const r=t.ngTempTokenPath;throw e[us]&&r.unshift(e[us]),t.message=function(t,e,n,s=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.substr(2):t;let r=ot(e);if(Array.isArray(e))r=e.map(ot).join(" -> ");else if("object"==typeof e){let t=[];for(let n in e)if(e.hasOwnProperty(n)){let s=e[n];t.push(n+":"+("string"==typeof s?JSON.stringify(s):ot(s)))}r=`{${t.join(", ")}}`}return`${n}${s?"("+s+")":""}[${r}]: ${t.replace(ls,"\n  ")}`}("\n"+t.message,r,n,s),t.ngTokenPath=r,t.ngTempTokenPath=null,t}(i,t,"R3InjectorError",this.source)}throw i}finally{ds(s)}var r}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((e,n)=>t.push(ot(n))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(t,e,n){if(!(t=ct(t)))return!1;let s=wt(t);const r=null==s&&t.ngModule||void 0,i=void 0===r?t:r,o=-1!==n.indexOf(i);if(void 0!==r&&(s=wt(r)),null==s)return!1;if(null!=s.imports&&!o){let t;n.push(i);try{ts(s.imports,s=>{this.processInjectorType(s,e,n)&&(void 0===t&&(t=[]),t.push(s))})}finally{}if(void 0!==t)for(let e=0;e<t.length;e++){const{ngModule:n,providers:s}=t[e];ts(s,t=>this.processProvider(t,n,s||Pt))}}this.injectorDefTypes.add(i);const a=he(i)||(()=>new i);this.records.set(i,lo(a,to));const l=s.providers;if(null!=l&&!o){const e=t;ts(l,t=>this.processProvider(t,e,l))}return void 0!==r&&void 0!==t.providers}processProvider(t,e,n){let s=co(t=ct(t))?t:ct(t&&t.provide);const r=function(t,e,n){return uo(t)?lo(void 0,t.useValue):lo(ao(t),to)}(t);if(co(t)||!0!==t.multi)this.records.get(s);else{let e=this.records.get(s);e||(e=lo(void 0,to,!0),e.factory=()=>gs(e.multi),this.records.set(s,e)),s=t,e.multi.push(t)}this.records.set(s,r)}hydrate(t,e){var n;return e.value===to&&(e.value=eo,e.value=e.factory()),"object"==typeof e.value&&e.value&&null!==(n=e.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=ct(t.providedIn);return"string"==typeof e?"any"===e||e===this.scope:this.injectorDefTypes.has(e)}}function oo(t){const e=bt(t),n=null!==e?e.factory:he(t);if(null!==n)return n;if(t instanceof Zn)throw new Error(`Token ${ot(t)} is missing a \u0275prov definition.`);if(t instanceof Function)return function(t){const e=t.length;if(e>0){const n=ss(e,"?");throw new Error(`Can't resolve all parameters for ${ot(t)}: (${n.join(", ")}).`)}const n=function(t){const e=t&&(t[xt]||t[kt]);if(e){const n=function(t){if(t.hasOwnProperty("name"))return t.name;const e=(""+t).match(/^function\s*([^\s(]+)/);return null===e?"":e[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),e}return null}(t);return null!==n?()=>n.factory(t):()=>new t}(t);throw new Error("unreachable")}function ao(t,e,n){let s;if(co(t)){const e=ct(t);return he(e)||oo(e)}if(uo(t))s=()=>ct(t.useValue);else if((r=t)&&r.useFactory)s=()=>t.useFactory(...gs(t.deps||[]));else if(function(t){return!(!t||!t.useExisting)}(t))s=()=>fs(ct(t.useExisting));else{const e=ct(t&&(t.useClass||t.provide));if(!function(t){return!!t.deps}(t))return he(e)||oo(e);s=()=>new e(...gs(t.deps))}var r;return s}function lo(t,e,n=!1){return{factory:t,value:e,multi:n?[]:void 0}}function uo(t){return null!==t&&"object"==typeof t&&cs in t}function co(t){return"function"==typeof t}const ho=function(t,e,n){return function(t,e=null,n=null,s){const r=ro(t,e,n,s);return r._resolveInjectorDefTypes(),r}({name:n},e,t,n)};let po=(()=>{class t{static create(t,e){return Array.isArray(t)?ho(t,e,""):ho(t.providers,t.parent,t.name||"")}}return t.THROW_IF_NOT_FOUND=as,t.NULL=new Qi,t.\u0275prov=gt({token:t,providedIn:"any",factory:()=>fs(Yi)}),t.__NG_ELEMENT_ID__=-1,t})();function fo(t,e){cn(lr(t)[1],Pe())}function mo(t){let e=Object.getPrototypeOf(t.type.prototype).constructor,n=!0;const s=[t];for(;e;){let r;if(ce(t))r=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new Error("Directives cannot inherit Components");r=e.\u0275dir}if(r){if(n){s.push(r);const e=t;e.inputs=go(t.inputs),e.declaredInputs=go(t.declaredInputs),e.outputs=go(t.outputs);const n=r.hostBindings;n&&vo(t,n);const i=r.viewQuery,o=r.contentQueries;if(i&&yo(t,i),o&&bo(t,o),it(t.inputs,r.inputs),it(t.declaredInputs,r.declaredInputs),it(t.outputs,r.outputs),ce(r)&&r.data.animation){const e=t.data;e.animation=(e.animation||[]).concat(r.data.animation)}}const e=r.features;if(e)for(let s=0;s<e.length;s++){const r=e[s];r&&r.ngInherit&&r(t),r===mo&&(n=!1)}}e=Object.getPrototypeOf(e)}!function(t){let e=0,n=null;for(let s=t.length-1;s>=0;s--){const r=t[s];r.hostVars=e+=r.hostVars,r.hostAttrs=xn(r.hostAttrs,n=xn(n,r.hostAttrs))}}(s)}function go(t){return t===Mt?{}:t===Pt?[]:t}function yo(t,e){const n=t.viewQuery;t.viewQuery=n?(t,s)=>{e(t,s),n(t,s)}:e}function bo(t,e){const n=t.contentQueries;t.contentQueries=n?(t,s,r)=>{e(t,s,r),n(t,s,r)}:e}function vo(t,e){const n=t.hostBindings;t.hostBindings=n?(t,s)=>{e(t,s),n(t,s)}:e}let wo=null;function xo(){if(!wo){const t=Lt.Symbol;if(t&&t.iterator)wo=t.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const n=t[e];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(wo=n)}}}return wo}class _o{constructor(t){this.wrapped=t}static wrap(t){return new _o(t)}static unwrap(t){return _o.isWrapped(t)?t.wrapped:t}static isWrapped(t){return t instanceof _o}}function ko(t){return!!Co(t)&&(Array.isArray(t)||!(t instanceof Map)&&xo()in t)}function Co(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function Io(t,e,n){return!Object.is(t[e],n)&&(t[e]=n,!0)}function So(t,e,n,s){const r=Oe();return Io(r,He(),e)&&(Le(),function(t,e,n,s,r,i){const o=Ie(t,e);!function(t,e,n,s,r,i,o){if(null==i)xe(t)?t.removeAttribute(e,r,n):e.removeAttribute(r);else{const a=null==o?pt(i):o(i,s||"",r);xe(t)?t.setAttribute(e,r,a,n):n?e.setAttributeNS(n,r,a):e.setAttribute(r,a)}}(e[11],o,i,t.value,n,s,r)}(ln(),r,t,e,n,s)),So}function Eo(t,e,n,s,r,i,o,a){const l=Oe(),u=Le(),c=t+se,h=u.firstCreatePass?function(t,e,n,s,r,i,o,a,l){const u=e.consts,c=di(e,t,4,o||null,$e(u,a));Ii(e,n,c,$e(u,l)),cn(e,c);const h=c.tViews=xi(2,c,s,r,i,e.directiveRegistry,e.pipeRegistry,null,e.schemas,u);return null!==e.queries&&(e.queries.template(e,c),h.queries=e.queries.embeddedTView(c)),c}(c,u,l,e,n,s,r,i,o):u.data[c];Be(h,!1);const d=l[11].createComment("");Dr(u,l,d,h),ar(d,l),zi(l,l[c]=Oi(d,l,d,h)),ue(h)&&bi(u,l,h),null!=o&&vi(l,h,a)}function To(t,e=It.Default){const n=Oe();return null===n?fs(t,e):Ln(Pe(),n,ct(t),e)}function No(t,e,n){const s=Oe();return Io(s,He(),e)&&Ci(Le(),ln(),s,t,e,s[11],n,!1),No}function $o(t,e,n,s,r){const i=r?"class":"style";Xi(t,n,e.inputs[i],i,s)}function Ao(t,e,n,s){const r=Oe(),i=Le(),o=se+t,a=r[11],l=r[o]=_r(a,e,Fe.lFrame.currentNamespace),u=i.firstCreatePass?function(t,e,n,s,r,i,o){const a=e.consts,l=di(e,t,2,r,$e(a,i));return Ii(e,n,l,$e(a,o)),null!==l.attrs&&Zi(l,l.attrs,!1),null!==l.mergedAttrs&&Zi(l,l.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,l),l}(o,i,r,0,e,n,s):i.data[o];Be(u,!0);const c=u.mergedAttrs;null!==c&&bn(a,l,c);const h=u.classes;null!==h&&Wr(a,l,h);const d=u.styles;null!==d&&Vr(a,l,d),64!=(64&u.flags)&&Dr(i,r,l,u),0===Fe.lFrame.elementDepthCount&&ar(l,r),Fe.lFrame.elementDepthCount++,ue(u)&&(bi(i,r,u),function(t,e,n){if(ae(e)){const s=e.directiveEnd;for(let r=e.directiveStart;r<s;r++){const e=t.data[r];e.contentQueries&&e.contentQueries(1,n[r],r)}}}(i,u,r)),null!==s&&vi(r,u)}function Ro(){let t=Pe();Ve()?We():(t=t.parent,Be(t,!1));const e=t;Fe.lFrame.elementDepthCount--;const n=Le();n.firstCreatePass&&(cn(n,t),ae(t)&&n.queries.elementEnd(t)),null!=e.classesWithoutHost&&function(t){return 0!=(16&t.flags)}(e)&&$o(n,e,Oe(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function(t){return 0!=(32&t.flags)}(e)&&$o(n,e,Oe(),e.stylesWithoutHost,!1)}function Fo(t,e,n,s){Ao(t,e,n,s),Ro()}function Do(){return Oe()}function Oo(t){return!!t&&"function"==typeof t.then}const Lo=function(t){return!!t&&"function"==typeof t.subscribe};function Mo(t,e,n,s){const r=Oe(),i=Le(),o=Pe();return zo(i,r,r[11],o,t,e,!!n,s),Mo}function Po(t,e){const n=Pe(),s=Oe(),r=Le();return zo(r,s,qi(Ke(r.data),n,s),n,t,e,!1),Po}function zo(t,e,n,s,r,i,o,a){const l=ue(s),u=t.firstCreatePass&&Gi(t),c=Hi(e);let h=!0;if(3&s.type||a){const d=Ie(s,e),p=a?a(d):d,f=c.length,m=a?t=>a(ke(t[s.index])):s.index;if(xe(n)){let o=null;if(!a&&l&&(o=function(t,e,n,s){const r=t.cleanup;if(null!=r)for(let i=0;i<r.length-1;i+=2){const t=r[i];if(t===n&&r[i+1]===s){const t=e[7],n=r[i+2];return t.length>n?t[n]:null}"string"==typeof t&&(i+=2)}return null}(t,e,r,s.index)),null!==o)(o.__ngLastListenerFn__||o).__ngNextListenerFn__=i,o.__ngLastListenerFn__=i,h=!1;else{i=Vo(s,e,0,i,!1);const t=n.listen(p,r,i);c.push(i,t),u&&u.push(r,m,f,f+1)}}else i=Vo(s,e,0,i,!0),p.addEventListener(r,i,o),c.push(i),u&&u.push(r,m,f,o)}else i=Vo(s,e,0,i,!1);const d=s.outputs;let p;if(h&&null!==d&&(p=d[r])){const t=p.length;if(t)for(let n=0;n<t;n+=2){const t=e[p[n]][p[n+1]].subscribe(i),o=c.length;c.push(i,t),u&&u.push(r,s.index,o,-(o+1))}}}function Bo(t,e,n,s){try{return!1!==n(s)}catch(r){return Ki(t,r),!1}}function Vo(t,e,n,s,r){return function n(i){if(i===Function)return s;const o=2&t.flags?Ee(t.index,e):e;0==(32&e[2])&&Bi(o);let a=Bo(e,0,s,i),l=n.__ngNextListenerFn__;for(;l;)a=Bo(e,0,l,i)&&a,l=l.__ngNextListenerFn__;return r&&!1===a&&(i.preventDefault(),i.returnValue=!1),a}}function Wo(t=1){return function(t){return(Fe.lFrame.contextLView=function(t,e){for(;t>0;)e=e[15],t--;return e}(t,Fe.lFrame.contextLView))[8]}(t)}function Uo(t,e){let n=null;const s=function(t){const e=t.attrs;if(null!=e){const t=e.indexOf(5);if(0==(1&t))return e[t+1]}return null}(t);for(let r=0;r<e.length;r++){const i=e[r];if("*"!==i){if(null===s?Yr(t,i,!0):Qr(s,i))return r}else n=r}return n}function jo(t){const e=Oe()[16][6];if(!e.projection){const n=e.projection=ss(t?t.length:1,null),s=n.slice();let r=e.child;for(;null!==r;){const e=t?Uo(r,t):0;null!==e&&(s[e]?s[e].projectionNext=r:n[e]=r,s[e]=r),r=r.next}}}function Ho(t,e=0,n){const s=Oe(),r=Le(),i=di(r,se+t,16,null,n||null);null===i.projection&&(i.projection=e),We(),64!=(64&i.flags)&&function(t,e,n){Br(e[11],0,e,n,Er(t,n,e),Rr(n.parent||e[6],n,e))}(r,s,i)}function Go(t,e,n,s,r){const i=t[n+1],o=null===e;let a=s?ii(i):ai(i),l=!1;for(;0!==a&&(!1===l||o);){const n=t[a+1];qo(t[a],e)&&(l=!0,t[a+1]=s?ui(n):oi(n)),a=s?ii(n):ai(n)}l&&(t[n+1]=s?oi(i):ui(i))}function qo(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&os(t,e)>=0}function Ko(t,e,n){return Zo(t,e,n,!1),Ko}function Xo(t,e){return Zo(t,e,null,!0),Xo}function Zo(t,e,n,s){const r=Oe(),i=Le(),o=function(t){const e=Fe.lFrame,n=e.bindingIndex;return e.bindingIndex=e.bindingIndex+2,n}();i.firstUpdatePass&&function(t,e,n,s){const r=t.data;if(null===r[n+1]){const i=r[on()],o=function(t,e){return e>=t.expandoStartIndex}(t,n);(function(t,e){return 0!=(t.flags&(e?16:32))})(i,s)&&null===e&&!o&&(e=!1),e=function(t,e,n,s){const r=Ke(t);let i=s?e.residualClasses:e.residualStyles;if(null===r)0===(s?e.classBindings:e.styleBindings)&&(n=Qo(n=Yo(null,t,e,n,s),e.attrs,s),i=null);else{const o=e.directiveStylingLast;if(-1===o||t[o]!==r)if(n=Yo(r,t,e,n,s),null===i){let n=function(t,e,n){const s=n?e.classBindings:e.styleBindings;if(0!==ai(s))return t[ii(s)]}(t,e,s);void 0!==n&&Array.isArray(n)&&(n=Yo(null,t,e,n[1],s),n=Qo(n,e.attrs,s),function(t,e,n,s){t[ii(n?e.classBindings:e.styleBindings)]=s}(t,e,s,n))}else i=function(t,e,n){let s;const r=e.directiveEnd;for(let i=1+e.directiveStylingLast;i<r;i++)s=Qo(s,t[i].hostAttrs,n);return Qo(s,e.attrs,n)}(t,e,s)}return void 0!==i&&(s?e.residualClasses=i:e.residualStyles=i),n}(r,i,e,s),function(t,e,n,s,r,i){let o=i?e.classBindings:e.styleBindings,a=ii(o),l=ai(o);t[s]=n;let u,c=!1;if(Array.isArray(n)){const t=n;u=t[1],(null===u||os(t,u)>0)&&(c=!0)}else u=n;if(r)if(0!==l){const e=ii(t[a+1]);t[s+1]=ri(e,a),0!==e&&(t[e+1]=li(t[e+1],s)),t[a+1]=131071&t[a+1]|s<<17}else t[s+1]=ri(a,0),0!==a&&(t[a+1]=li(t[a+1],s)),a=s;else t[s+1]=ri(l,0),0===a?a=s:t[l+1]=li(t[l+1],s),l=s;c&&(t[s+1]=oi(t[s+1])),Go(t,u,s,!0),Go(t,u,s,!1),function(t,e,n,s,r){const i=r?t.residualClasses:t.residualStyles;null!=i&&"string"==typeof e&&os(i,e)>=0&&(n[s+1]=ui(n[s+1]))}(e,u,t,s,i),o=ri(a,l),i?e.classBindings=o:e.styleBindings=o}(r,i,e,n,o,s)}}(i,t,o,s),e!==ei&&Io(r,o,e)&&function(t,e,n,s,r,i,o,a){if(!(3&e.type))return;const l=t.data,u=l[a+1];ta(1==(1&u)?Jo(l,e,n,r,ai(u),o):void 0)||(ta(i)||function(t){return 2==(2&t)}(u)&&(i=Jo(l,null,n,r,a,o)),function(t,e,n,s,r){const i=xe(t);if(e)r?i?t.addClass(n,s):n.classList.add(s):i?t.removeClass(n,s):n.classList.remove(s);else{let e=-1===s.indexOf("-")?void 0:mr.DashCase;if(null==r)i?t.removeStyle(n,s,e):n.style.removeProperty(s);else{const o="string"==typeof r&&r.endsWith("!important");o&&(r=r.slice(0,-10),e|=mr.Important),i?t.setStyle(n,s,r,e):n.style.setProperty(s,r,o?"important":"")}}}(s,o,Ce(on(),n),r,i))}(i,i.data[on()],r,r[11],t,r[o+1]=function(t,e){return null==t||("string"==typeof e?t+=e:"object"==typeof t&&(t=ot(As(t)))),t}(e,n),s,o)}function Yo(t,e,n,s,r){let i=null;const o=n.directiveEnd;let a=n.directiveStylingLast;for(-1===a?a=n.directiveStart:a++;a<o&&(i=e[a],s=Qo(s,i.hostAttrs,r),i!==t);)a++;return null!==t&&(n.directiveStylingLast=a),s}function Qo(t,e,n){const s=n?1:2;let r=-1;if(null!==e)for(let i=0;i<e.length;i++){const o=e[i];"number"==typeof o?r=o:r===s&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),rs(t,o,!!n||e[++i]))}return void 0===t?null:t}function Jo(t,e,n,s,r,i){const o=null===e;let a;for(;r>0;){const e=t[r],i=Array.isArray(e),l=i?e[1]:e,u=null===l;let c=n[r+1];c===ei&&(c=u?Pt:void 0);let h=u?is(c,s):l===s?c:void 0;if(i&&!ta(h)&&(h=is(e,s)),ta(h)&&(a=h,o))return a;const d=t[r+1];r=o?ii(d):ai(d)}if(null!==e){let t=i?e.residualClasses:e.residualStyles;null!=t&&(a=is(t,s))}return a}function ta(t){return void 0!==t}function ea(t,e=""){const n=Oe(),s=Le(),r=t+se,i=s.firstCreatePass?di(s,r,1,e,null):s.data[r],o=n[r]=function(t,e){return xe(t)?t.createText(e):t.createTextNode(e)}(n[11],e);Dr(s,n,o,i),Be(i,!1)}function na(t,e,n){const s=Oe(),r=function(t,e,n,s){return Io(t,He(),n)?e+pt(n)+s:ei}(s,t,e,n);return r!==ei&&function(t,e,n){const s=Ce(e,t);!function(t,e,n){xe(t)?t.setValue(e,n):e.textContent=n}(t[11],s,n)}(s,on(),r),na}function sa(t,e,n){const s=Oe();return Io(s,He(),e)&&Ci(Le(),ln(),s,t,e,s[11],n,!0),sa}function ra(t,e,n){const s=Oe();if(Io(s,He(),e)){const r=Le(),i=ln();Ci(r,i,s,t,e,qi(Ke(r.data),i,s),n,!0)}return ra}const ia=void 0;var oa=["en",[["a","p"],["AM","PM"],ia],[["AM","PM"],ia,ia],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],ia,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],ia,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",ia,"{1} 'at' {0}",ia],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(t){let e=Math.floor(Math.abs(t)),n=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===n?1:5}];let aa={};function la(t){const e=function(t){return t.toLowerCase().replace(/_/g,"-")}(t);let n=ua(e);if(n)return n;const s=e.split("-")[0];if(n=ua(s),n)return n;if("en"===s)return oa;throw new Error(`Missing locale data for the locale "${t}".`)}function ua(t){return t in aa||(aa[t]=Lt.ng&&Lt.ng.common&&Lt.ng.common.locales&&Lt.ng.common.locales[t]),aa[t]}var ca=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}({});const ha="en-US";let da=ha;function pa(t){var e,n;n="Expected localeId to be defined",null==(e=t)&&function(t,e,n,s){throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`)}(n,e),"string"==typeof t&&(da=t.toLowerCase().replace(/_/g,"-"))}function fa(t,e,n,s,r){if(t=ct(t),Array.isArray(t))for(let i=0;i<t.length;i++)fa(t[i],e,n,s,r);else{const i=Le(),o=Oe();let a=co(t)?t:ct(t.provide),l=ao(t);const u=Pe(),c=1048575&u.providerIndexes,h=u.directiveStart,d=u.providerIndexes>>20;if(co(t)||!t.multi){const s=new yn(l,r,To),p=ya(a,e,r?c:c+d,h);-1===p?(Fn(Nn(u,o),i,a),ma(i,t,e.length),e.push(a),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),n.push(s),o.push(s)):(n[p]=s,o[p]=s)}else{const p=ya(a,e,c+d,h),f=ya(a,e,c,c+d),m=p>=0&&n[p],g=f>=0&&n[f];if(r&&!g||!r&&!m){Fn(Nn(u,o),i,a);const c=function(t,e,n,s,r){const i=new yn(t,n,To);return i.multi=[],i.index=e,i.componentProviders=0,ga(i,r,s&&!n),i}(r?va:ba,n.length,r,s,l);!r&&g&&(n[f].providerFactory=c),ma(i,t,e.length,0),e.push(a),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),n.push(c),o.push(c)}else ma(i,t,p>-1?p:f,ga(n[r?f:p],l,!r&&s));!r&&s&&g&&n[f].componentProviders++}}}function ma(t,e,n,s){const r=co(e);if(r||e.useClass){const i=(e.useClass||e).prototype.ngOnDestroy;if(i){const o=t.destroyHooks||(t.destroyHooks=[]);if(!r&&e.multi){const t=o.indexOf(n);-1===t?o.push(n,[s,i]):o[t+1].push(s,i)}else o.push(n,i)}}}function ga(t,e,n){return n&&t.componentProviders++,t.multi.push(e)-1}function ya(t,e,n,s){for(let r=n;r<s;r++)if(e[r]===t)return r;return-1}function ba(t,e,n,s){return wa(this.multi,[])}function va(t,e,n,s){const r=this.multi;let i;if(this.providerFactory){const t=this.providerFactory.componentProviders,e=Vn(n,n[1],this.providerFactory.index,s);i=e.slice(0,t),wa(r,i);for(let n=t;n<e.length;n++)i.push(e[n])}else i=[],wa(r,i);return i}function wa(t,e){for(let n=0;n<t.length;n++)e.push((0,t[n])());return e}function xa(t,e=[]){return n=>{n.providersResolver=(n,s)=>function(t,e,n){const s=Le();if(s.firstCreatePass){const r=ce(t);fa(n,s.data,s.blueprint,r,!0),fa(e,s.data,s.blueprint,r,!1)}}(n,s?s(t):t,e)}}class _a{}class ka{resolveComponentFactory(t){throw function(t){const e=Error(`No component factory found for ${ot(t)}. Did you add it to @NgModule.entryComponents?`);return e.ngComponent=t,e}(t)}}let Ca=(()=>{class t{}return t.NULL=new ka,t})();function Ia(...t){}function Sa(t,e){return new Ta(Ie(t,e))}const Ea=function(){return Sa(Pe(),Oe())};let Ta=(()=>{class t{constructor(t){this.nativeElement=t}}return t.__NG_ELEMENT_ID__=Ea,t})();function Na(t){return t instanceof Ta?t.nativeElement:t}class $a{}let Aa=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>Ra(),t})();const Ra=function(){const t=Oe(),e=Ee(Pe().index,t);return function(t){return t[11]}(ie(e)?e:t)};let Fa=(()=>{class t{}return t.\u0275prov=gt({token:t,providedIn:"root",factory:()=>null}),t})();class Da{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const Oa=new Da("12.0.4");class La{constructor(){}supports(t){return ko(t)}create(t){return new Pa(t)}}const Ma=(t,e)=>e;class Pa{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||Ma}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,s=0,r=null;for(;e||n;){const i=!n||e&&e.currentIndex<Wa(n,s,r)?e:n,o=Wa(i,s,r),a=i.currentIndex;if(i===n)s--,n=n._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{r||(r=[]);const t=o-s,e=a-s;if(t!=e){for(let n=0;n<t;n++){const s=n<r.length?r[n]:r[n]=0,i=s+n;e<=i&&i<t&&(r[n]=s+1)}r[i.previousIndex]=e-t}}o!==a&&t(i,o,a)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!ko(t))throw new Error(`Error trying to diff '${ot(t)}'. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e,n,s,r=this._itHead,i=!1;if(Array.isArray(t)){this.length=t.length;for(let e=0;e<this.length;e++)n=t[e],s=this._trackByFn(e,n),null!==r&&Object.is(r.trackById,s)?(i&&(r=this._verifyReinsertion(r,n,s,e)),Object.is(r.item,n)||this._addIdentityChange(r,n)):(r=this._mismatch(r,n,s,e),i=!0),r=r._next}else e=0,function(t,e){if(Array.isArray(t))for(let n=0;n<t.length;n++)e(t[n]);else{const n=t[xo()]();let s;for(;!(s=n.next()).done;)e(s.value)}}(t,t=>{s=this._trackByFn(e,t),null!==r&&Object.is(r.trackById,s)?(i&&(r=this._verifyReinsertion(r,t,s,e)),Object.is(r.item,t)||this._addIdentityChange(r,t)):(r=this._mismatch(r,t,s,e),i=!0),r=r._next,e++}),this.length=e;return this._truncate(r),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,s){let r;return null===t?r=this._itTail:(r=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,r,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(n,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,r,s)):t=this._addAfter(new za(e,n),r,s),t}_verifyReinsertion(t,e,n,s){let r=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==r?t=this._reinsertAfter(r,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,r=t._nextRemoved;return null===s?this._removalsHead=r:s._nextRemoved=r,null===r?this._removalsTail=s:r._prevRemoved=s,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new Va),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,n=t._next;return null===e?this._itHead=n:e._next=n,null===n?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new Va),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class za{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class Ba{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===e||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){const e=t._prevDup,n=t._nextDup;return null===e?this._head=n:e._nextDup=n,null===n?this._tail=e:n._prevDup=e,null===this._head}}class Va{constructor(){this.map=new Map}put(t){const e=t.trackById;let n=this.map.get(e);n||(n=new Ba,this.map.set(e,n)),n.add(t)}get(t,e){const n=this.map.get(t);return n?n.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function Wa(t,e,n){const s=t.previousIndex;if(null===s)return s;let r=0;return n&&s<n.length&&(r=n[s]),s+e+r}class Ua{constructor(){}supports(t){return t instanceof Map||Co(t)}create(){return new ja}}class ja{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||Co(t)))throw new Error(`Error trying to diff '${ot(t)}'. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(t,n)=>{if(e&&e.key===n)this._maybeAddToChanges(e,t),this._appendAfter=e,e=e._next;else{const s=this._getOrCreateRecordForKey(n,t);e=this._insertBeforeOrAppend(e,s)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let t=e;null!==t;t=t._nextRemoved)t===this._mapHead&&(this._mapHead=null),this._records.delete(t.key),t._nextRemoved=t._next,t.previousValue=t.currentValue,t.currentValue=null,t._prev=null,t._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const n=t._prev;return e._next=t,e._prev=n,t._prev=e,n&&(n._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const n=this._records.get(t);this._maybeAddToChanges(n,e);const s=n._prev,r=n._next;return s&&(s._next=r),r&&(r._prev=s),n._next=null,n._prev=null,n}const n=new Ha(t);return this._records.set(t,n),n.currentValue=e,this._addToAdditions(n),n}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(n=>e(t[n],n))}}class Ha{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function Ga(){return new qa([new La])}let qa=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(null!=n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||Ga()),deps:[[t,new ws,new vs]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(null!=e)return e;throw new Error(`Cannot find a differ supporting object '${t}' of type '${n=t,n.name||typeof n}'`);var n}}return t.\u0275prov=gt({token:t,providedIn:"root",factory:Ga}),t})();function Ka(){return new Xa([new Ua])}let Xa=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||Ka()),deps:[[t,new ws,new vs]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(e)return e;throw new Error(`Cannot find a differ supporting object '${t}'`)}}return t.\u0275prov=gt({token:t,providedIn:"root",factory:Ka}),t})();function Za(t,e,n,s,r=!1){for(;null!==n;){const i=e[n.index];if(null!==i&&s.push(ke(i)),oe(i))for(let t=re;t<i.length;t++){const e=i[t],n=e[1].firstChild;null!==n&&Za(e[1],e,n,s)}const o=n.type;if(8&o)Za(t,e,n.child,s);else if(32&o){const t=gr(n,e);let r;for(;r=t();)s.push(r)}else if(16&o){const t=Lr(e,n);if(Array.isArray(t))s.push(...t);else{const n=yr(e[16]);Za(n[1],n,t,s,!0)}}n=r?n.projectionNext:n.next}return s}class Ya{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Za(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(oe(t)){const e=t[8],n=e?e.indexOf(this):-1;n>-1&&(Cr(t,n),ns(e,n))}this._attachedToViewContainer=!1}Ir(this._lView[1],this._lView)}onDestroy(t){_i(this._lView[1],this._lView,null,t)}markForCheck(){Bi(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Vi(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(t,e,n){je(!0);try{Vi(t,e,n)}finally{je(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var t;this._appRef=null,zr(this._lView[1],t=this._lView,t[11],2,null,null)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=t}}class Qa extends Ya{constructor(t){super(t),this._view=t}detectChanges(){Wi(this._view)}checkNoChanges(){!function(t){je(!0);try{Wi(t)}finally{je(!1)}}(this._view)}get context(){return null}}const Ja=function(t){return function(t,e,n){if(le(t)&&!n){const n=Ee(t.index,e);return new Ya(n,n)}return 47&t.type?new Ya(e[16],e):null}(Pe(),Oe(),16==(16&t))};let tl=(()=>{class t{}return t.__NG_ELEMENT_ID__=Ja,t})();const el=[new Ua],nl=new qa([new La]),sl=new Xa(el),rl=function(){return ll(Pe(),Oe())};let il=(()=>{class t{}return t.__NG_ELEMENT_ID__=rl,t})();const ol=il,al=class extends ol{constructor(t,e,n){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=n}createEmbeddedView(t){const e=this._declarationTContainer.tViews,n=hi(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const s=this._declarationLView[19];return null!==s&&(n[19]=s.createEmbeddedView(e)),fi(e,n,t),new Ya(n)}};function ll(t,e){return 4&t.type?new al(e,t,Sa(t,e)):null}class ul{}class cl{}const hl=function(){return yl(Pe(),Oe())};let dl=(()=>{class t{}return t.__NG_ELEMENT_ID__=hl,t})();const pl=dl,fl=class extends pl{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=n}get element(){return Sa(this._hostTNode,this._hostLView)}get injector(){return new jn(this._hostTNode,this._hostLView)}get parentInjector(){const t=Rn(this._hostTNode,this._hostLView);if(kn(t)){const e=In(t,this._hostLView),n=Cn(t);return new jn(e[1].data[n+8],e)}return new jn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=ml(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-re}createEmbeddedView(t,e,n){const s=t.createEmbeddedView(e||{});return this.insert(s,n),s}createComponent(t,e,n,s,r){const i=n||this.parentInjector;if(!r&&null==t.ngModule&&i){const t=i.get(ul,null);t&&(r=t)}const o=t.create(i,s,void 0,r);return this.insert(o.hostView,e),o}insert(t,e){const n=t._lView,s=n[1];if(oe(n[3])){const e=this.indexOf(t);if(-1!==e)this.detach(e);else{const e=n[3],s=new fl(e,e[6],e[3]);s.detach(s.indexOf(t))}}const r=this._adjustIndex(e),i=this._lContainer;!function(t,e,n,s){const r=re+s,i=n.length;s>0&&(n[r-1][4]=e),s<i-re?(e[4]=n[r],es(n,re+s,e)):(n.push(e),e[4]=null),e[3]=n;const o=e[17];null!==o&&n!==o&&function(t,e){const n=t[9];e[16]!==e[3][3][16]&&(t[2]=!0),null===n?t[9]=[e]:n.push(e)}(o,e);const a=e[19];null!==a&&a.insertView(t),e[2]|=128}(s,n,i,r);const o=Mr(r,i),a=n[11],l=Ar(a,i[7]);return null!==l&&function(t,e,n,s,r,i){s[0]=r,s[6]=e,zr(t,s,n,1,r,i)}(s,i[6],a,n,l,o),t.attachToViewContainerRef(),es(gl(i),r,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=ml(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),n=Cr(this._lContainer,e);n&&(ns(gl(this._lContainer),e),Ir(n[1],n))}detach(t){const e=this._adjustIndex(t,-1),n=Cr(this._lContainer,e);return n&&null!=ns(gl(this._lContainer),e)?new Ya(n):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function ml(t){return t[8]}function gl(t){return t[8]||(t[8]=[])}function yl(t,e){let n;const s=e[t.index];if(oe(s))n=s;else{let r;if(8&t.type)r=ke(s);else{const n=e[11];r=n.createComment("");const s=Ie(t,e);Tr(n,Ar(n,s),r,function(t,e){return xe(t)?t.nextSibling(e):e.nextSibling}(n,s),!1)}e[t.index]=n=Oi(s,e,r,t),zi(e,n)}return new fl(n,t,e)}const bl={};class vl extends Ca{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=ee(t);return new _l(e,this.ngModule)}}function wl(t){const e=[];for(let n in t)t.hasOwnProperty(n)&&e.push({propName:t[n],templateName:n});return e}const xl=new Zn("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>pr});class _l extends _a{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=t.selectors.map(ti).join(","),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return wl(this.componentDef.inputs)}get outputs(){return wl(this.componentDef.outputs)}create(t,e,n,s){const r=(s=s||this.ngModule)?function(t,e){return{get:(n,s,r)=>{const i=t.get(n,bl,r);return i!==bl||s===bl?i:e.get(n,s,r)}}}(t,s.injector):t,i=r.get($a,_e),o=r.get(Fa,null),a=i.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",u=n?function(t,e,n){if(xe(t))return t.selectRootElement(e,n===At.ShadowDom);let s="string"==typeof e?t.querySelector(e):e;return s.textContent="",s}(a,n,this.componentDef.encapsulation):_r(i.createRenderer(null,this.componentDef),l,function(t){const e=t.toLowerCase();return"svg"===e?be:"math"===e?"http://www.w3.org/1998/MathML/":null}(l)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:pr,clean:ji,playerHandler:null,flags:0},d=xi(0,null,null,1,0,null,null,null,null,null),p=hi(null,d,h,c,null,null,i,a,o,r);let f,m;Je(p);try{const t=function(t,e,n,s,r,i){const o=n[1];n[20]=t;const a=di(o,20,2,"#host",null),l=a.mergedAttrs=e.hostAttrs;null!==l&&(Zi(a,l,!0),null!==t&&(bn(r,t,l),null!==a.classes&&Wr(r,t,a.classes),null!==a.styles&&Vr(r,t,a.styles)));const u=s.createRenderer(t,e),c=hi(n,wi(e),null,e.onPush?64:16,n[20],a,s,u,null,null);return o.firstCreatePass&&(Fn(Nn(a,n),o,e.type),Ti(o,a),$i(a,n.length,1)),zi(n,c),n[20]=c}(u,this.componentDef,p,i,a);if(u)if(n)bn(a,u,["ng-version",Oa.full]);else{const{attrs:t,classes:e}=function(t){const e=[],n=[];let s=1,r=2;for(;s<t.length;){let i=t[s];if("string"==typeof i)2===r?""!==i&&e.push(i,t[++s]):8===r&&n.push(i);else{if(!Xr(r))break;r=i}s++}return{attrs:e,classes:n}}(this.componentDef.selectors[0]);t&&bn(a,u,t),e&&e.length>0&&Wr(a,u,e.join(" "))}if(m=Se(d,se),void 0!==e){const t=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const s=e[n];t.push(null!=s?Array.from(s):null)}}f=function(t,e,n,s,r){const i=n[1],o=function(t,e,n){const s=Pe();t.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Ai(t,s,e,pi(t,e,1,null),n));const r=Vn(e,t,s.directiveStart,s);ar(r,e);const i=Ie(s,e);return i&&ar(i,e),r}(i,n,e);if(s.components.push(o),t[8]=o,r&&r.forEach(t=>t(o,e)),e.contentQueries){const t=Pe();e.contentQueries(1,o,t.directiveStart)}const a=Pe();return!i.firstCreatePass||null===e.hostBindings&&null===e.hostAttrs||(an(a.index),Si(n[1],a,0,a.directiveStart,a.directiveEnd,e),Ei(e,o)),o}(t,this.componentDef,p,h,[fo]),fi(d,p,null)}finally{rn()}return new kl(this.componentType,f,Sa(m,p),p,m)}}class kl extends class{}{constructor(t,e,n,s,r){super(),this.location=n,this._rootLView=s,this._tNode=r,this.instance=e,this.hostView=this.changeDetectorRef=new Qa(s),this.componentType=t}get injector(){return new jn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}const Cl=new Map;class Il extends ul{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new vl(this);const n=ne(t),s=t[Ut]||null;s&&pa(s),this._bootstrapComponents=fr(n.bootstrap),this._r3Injector=ro(t,e,[{provide:ul,useValue:this},{provide:Ca,useValue:this.componentFactoryResolver}],ot(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=po.THROW_IF_NOT_FOUND,n=It.Default){return t===po||t===ul||t===Yi?this:this._r3Injector.get(t,e,n)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Sl extends cl{constructor(t){super(),this.moduleType=t,null!==ne(t)&&function(t){const e=new Set;!function t(n){const s=ne(n,!0),r=s.id;null!==r&&(function(t,e,n){if(e&&e!==n)throw new Error(`Duplicate module registered for ${t} - ${ot(e)} vs ${ot(e.name)}`)}(r,Cl.get(r),n),Cl.set(r,n));const i=fr(s.imports);for(const o of i)e.has(o)||(e.add(o),t(o))}(t)}(t)}create(t){return new Il(this.moduleType,t)}}function El(t,e,n){const s=t+se,r=Oe(),i=function(t,e){return t[e]}(r,s);return function(t,e){return _o.isWrapped(e)&&(e=_o.unwrap(e),t[Fe.lFrame.bindingIndex]=ei),e}(r,function(t,e){return t[1].data[e].pure}(r,s)?function(t,e,n,s,r,i){const o=e+n;return Io(t,o,r)?function(t,e,n){return t[e]=n}(t,o+1,i?s.call(i,r):s(r)):function(t,e){const n=t[e];return n===ei?void 0:n}(t,o+1)}(r,function(){const t=Fe.lFrame;let e=t.bindingRootIndex;return-1===e&&(e=t.bindingRootIndex=t.tView.bindingStartIndex),e}(),e,i.transform,n,i):i.transform(n))}function Tl(t){return e=>{setTimeout(t,void 0,e)}}const Nl=class extends E{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,n){var s,r,i;let o=t,a=e||(()=>null),l=n;if(t&&"object"==typeof t){const e=t;o=null===(s=e.next)||void 0===s?void 0:s.bind(e),a=null===(r=e.error)||void 0===r?void 0:r.bind(e),l=null===(i=e.complete)||void 0===i?void 0:i.bind(e)}this.__isAsync&&(a=Tl(a),o&&(o=Tl(o)),l&&(l=Tl(l)));const u=super.subscribe({next:o,error:a,complete:l});return t instanceof m&&t.add(u),u}};function $l(){return this._results[xo()]()}class Al{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=xo(),n=Al.prototype;n[e]||(n[e]=$l)}get changes(){return this._changes||(this._changes=new Nl)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const n=this;n.dirty=!1;const s=Jn(t);(this._changesDetected=!function(t,e,n){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++){let r=t[s],i=e[s];if(n&&(r=n(r),i=n(i)),i!==r)return!1}return!0}(n._results,s,e))&&(n._results=s,n.length=s.length,n.last=s[this.length-1],n.first=s[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class Rl{constructor(t){this.queryList=t,this.matches=null}clone(){return new Rl(this.queryList)}setDirty(){this.queryList.setDirty()}}class Fl{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const n=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let t=0;t<n;t++){const n=e.getByIndex(t);s.push(this.queries[n.indexInDeclarationView].clone())}return new Fl(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==ql(t,e).matches&&this.queries[e].setDirty()}}class Dl{constructor(t,e,n=null){this.predicate=t,this.flags=e,this.read=n}}class Ol{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){const s=null!==e?e.length:0,r=this.getByIndex(n).embeddedTView(t,s);r&&(r.indexInDeclarationView=n,null!==e?e.push(r):e=[r])}return null!==e?new Ol(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class Ll{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new Ll(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let n=t.parent;for(;null!==n&&8&n.type&&n.index!==e;)n=n.parent;return e===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const n=this.metadata.predicate;if(Array.isArray(n))for(let s=0;s<n.length;s++){const r=n[s];this.matchTNodeWithReadOption(t,e,Ml(e,r)),this.matchTNodeWithReadOption(t,e,Bn(e,t,r,!1,!1))}else n===il?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,Bn(e,t,n,!1,!1))}matchTNodeWithReadOption(t,e,n){if(null!==n){const s=this.metadata.read;if(null!==s)if(s===Ta||s===dl||s===il&&4&e.type)this.addMatch(e.index,-2);else{const n=Bn(e,t,s,!1,!1);null!==n&&this.addMatch(e.index,n)}else this.addMatch(e.index,n)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function Ml(t,e){const n=t.localNames;if(null!==n)for(let s=0;s<n.length;s+=2)if(n[s]===e)return n[s+1];return null}function Pl(t,e,n,s){return-1===n?function(t,e){return 11&t.type?Sa(t,e):4&t.type?ll(t,e):null}(e,t):-2===n?function(t,e,n){return n===Ta?Sa(e,t):n===il?ll(e,t):n===dl?yl(e,t):void 0}(t,e,s):Vn(t,t[1],n,e)}function zl(t,e,n,s){const r=e[19].queries[s];if(null===r.matches){const s=t.data,i=n.matches,o=[];for(let t=0;t<i.length;t+=2){const r=i[t];o.push(r<0?null:Pl(e,s[r],i[t+1],n.metadata.read))}r.matches=o}return r.matches}function Bl(t,e,n,s){const r=t.queries.getByIndex(n),i=r.matches;if(null!==i){const o=zl(t,e,r,n);for(let t=0;t<i.length;t+=2){const n=i[t];if(n>0)s.push(o[t/2]);else{const r=i[t+1],o=e[-n];for(let t=re;t<o.length;t++){const e=o[t];e[17]===e[3]&&Bl(e[1],e,r,s)}if(null!==o[9]){const t=o[9];for(let e=0;e<t.length;e++){const n=t[e];Bl(n[1],n,r,s)}}}}}return s}function Vl(t){const e=Oe(),n=Le(),s=Xe();Ze(s+1);const r=ql(n,s);if(t.dirty&&Te(e)===(2==(2&r.metadata.flags))){if(null===r.matches)t.reset([]);else{const i=r.crossesNgTemplate?Bl(n,e,s,[]):zl(n,e,r,s);t.reset(i,Na),t.notifyOnChanges()}return!0}return!1}function Wl(t,e,n){const s=Le();s.firstCreatePass&&(Gl(s,new Dl(t,e,n),-1),2==(2&e)&&(s.staticViewQueries=!0)),Hl(s,Oe(),e)}function Ul(t,e,n,s){const r=Le();if(r.firstCreatePass){const i=Pe();Gl(r,new Dl(e,n,s),i.index),function(t,e){const n=t.contentQueries||(t.contentQueries=[]);e!==(n.length?n[n.length-1]:-1)&&n.push(t.queries.length-1,e)}(r,t),2==(2&n)&&(r.staticContentQueries=!0)}Hl(r,Oe(),n)}function jl(){return t=Oe(),e=Xe(),t[19].queries[e].queryList;var t,e}function Hl(t,e,n){const s=new Al(4==(4&n));_i(t,e,s,s.destroy),null===e[19]&&(e[19]=new Fl),e[19].queries.push(new Rl(s))}function Gl(t,e,n){null===t.queries&&(t.queries=new Ol),t.queries.track(new Ll(e,n))}function ql(t,e){return t.queries.getByIndex(e)}const Kl=new Zn("Application Initializer");let Xl=(()=>{class t{constructor(t){this.appInits=t,this.resolve=Ia,this.reject=Ia,this.initialized=!1,this.done=!1,this.donePromise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}runInitializers(){if(this.initialized)return;const t=[],e=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const e=this.appInits[n]();if(Oo(e))t.push(e);else if(Lo(e)){const n=new Promise((t,n)=>{e.subscribe({complete:t,error:n})});t.push(n)}}Promise.all(t).then(()=>{e()}).catch(t=>{this.reject(t)}),0===t.length&&e(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(fs(Kl,8))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const Zl=new Zn("AppId"),Yl={provide:Zl,useFactory:function(){return`${Ql()}${Ql()}${Ql()}`},deps:[]};function Ql(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const Jl=new Zn("Platform Initializer"),tu=new Zn("Platform ID"),eu=new Zn("appBootstrapListener");let nu=(()=>{class t{log(t){console.log(t)}warn(t){console.warn(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const su=new Zn("LocaleId"),ru=new Zn("DefaultCurrencyCode");class iu{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const ou=function(t){return new Sl(t)},au=ou,lu=function(t){return Promise.resolve(ou(t))},uu=function(t){const e=ou(t),n=fr(ne(t).declarations).reduce((t,e)=>{const n=ee(e);return n&&t.push(new _l(n)),t},[]);return new iu(e,n)},cu=uu,hu=function(t){return Promise.resolve(uu(t))};let du=(()=>{class t{constructor(){this.compileModuleSync=au,this.compileModuleAsync=lu,this.compileModuleAndAllComponentsSync=cu,this.compileModuleAndAllComponentsAsync=hu}clearCache(){}clearCacheFor(t){}getModuleId(t){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const pu=(()=>Promise.resolve(0))();function fu(t){"undefined"==typeof Zone?pu.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class mu{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Nl(!1),this.onMicrotaskEmpty=new Nl(!1),this.onStable=new Nl(!1),this.onError=new Nl(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!n&&e,s.shouldCoalesceRunChangeDetection=n,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function(){let t=Lt.requestAnimationFrame,e=Lt.cancelAnimationFrame;if("undefined"!=typeof Zone&&t&&e){const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n);const s=e[Zone.__symbol__("OriginalDelegate")];s&&(e=s)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function(t){const e=()=>{!function(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(Lt,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,bu(t),t.isCheckStableRunning=!0,yu(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),bu(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,s,r,i,o,a)=>{try{return vu(t),n.invokeTask(r,i,o,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||t.shouldCoalesceRunChangeDetection)&&e(),wu(t)}},onInvoke:(n,s,r,i,o,a,l)=>{try{return vu(t),n.invoke(r,i,o,a,l)}finally{t.shouldCoalesceRunChangeDetection&&e(),wu(t)}},onHasTask:(e,n,s,r)=>{e.hasTask(s,r),n===s&&("microTask"==r.change?(t._hasPendingMicrotasks=r.microTask,bu(t),yu(t)):"macroTask"==r.change&&(t.hasPendingMacrotasks=r.macroTask))},onHandleError:(e,n,s,r)=>(e.handleError(s,r),t.runOutsideAngular(()=>t.onError.emit(r)),!1)})}(s)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!mu.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(mu.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,s){const r=this._inner,i=r.scheduleEventTask("NgZoneEvent: "+s,t,gu,Ia,Ia);try{return r.runTask(i,e,n)}finally{r.cancelTask(i)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}}const gu={};function yu(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function bu(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function vu(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function wu(t){t._nesting--,yu(t)}class xu{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Nl,this.onMicrotaskEmpty=new Nl,this.onStable=new Nl,this.onError=new Nl}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,s){return t.apply(e,n)}}let _u=(()=>{class t{constructor(t){this._ngZone=t,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),t.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{mu.assertNotInAngularZone(),fu(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())fu(()=>{for(;0!==this._callbacks.length;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb(this._didWork)}this._didWork=!1});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(e=>!e.updateCb||!e.updateCb(t)||(clearTimeout(e.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,e,n){let s=-1;e&&e>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(t=>t.timeoutId!==s),t(this._didWork,this.getPendingTasks())},e)),this._callbacks.push({doneCb:t,timeoutId:s,updateCb:n})}whenStable(t,e,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(t,e,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(t,e,n){return[]}}return t.\u0275fac=function(e){return new(e||t)(fs(mu))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),ku=(()=>{class t{constructor(){this._applications=new Map,Su.addToWindow(this)}registerApplication(t,e){this._applications.set(t,e)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,e=!0){return Su.findTestabilityInTree(this,t,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();class Cu{addToWindow(t){}findTestabilityInTree(t,e,n){return null}}let Iu,Su=new Cu,Eu=!0,Tu=!1;function Nu(){return Tu=!0,Eu}const $u=new Zn("AllowMultipleToken");class Au{constructor(t,e){this.name=t,this.token=e}}function Ru(t,e,n=[]){const s=`Platform: ${e}`,r=new Zn(s);return(e=[])=>{let i=Fu();if(!i||i.injector.get($u,!1))if(t)t(n.concat(e).concat({provide:r,useValue:!0}));else{const t=n.concat(e).concat({provide:r,useValue:!0},{provide:Ji,useValue:"platform"});!function(t){if(Iu&&!Iu.destroyed&&!Iu.injector.get($u,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");Iu=t.get(Du);const e=t.get(Jl,null);e&&e.forEach(t=>t())}(po.create({providers:t,name:s}))}return function(t){const e=Fu();if(!e)throw new Error("No platform exists!");if(!e.injector.get(t,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return e}(r)}}function Fu(){return Iu&&!Iu.destroyed?Iu:null}let Du=(()=>{class t{constructor(t){this._injector=t,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(t,e){const n=function(t,e){let n;return n="noop"===t?new xu:("zone.js"===t?void 0:t)||new mu({enableLongStackTrace:Nu(),shouldCoalesceEventChangeDetection:!!(null==e?void 0:e.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==e?void 0:e.ngZoneRunCoalescing)}),n}(e?e.ngZone:void 0,{ngZoneEventCoalescing:e&&e.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:e&&e.ngZoneRunCoalescing||!1}),s=[{provide:mu,useValue:n}];return n.run(()=>{const e=po.create({providers:s,parent:this.injector,name:t.moduleType.name}),r=t.create(e),i=r.injector.get(dr,null);if(!i)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const t=n.onError.subscribe({next:t=>{i.handleError(t)}});r.onDestroy(()=>{Mu(this._modules,r),t.unsubscribe()})}),function(t,e,n){try{const s=n();return Oo(s)?s.catch(n=>{throw e.runOutsideAngular(()=>t.handleError(n)),n}):s}catch(s){throw e.runOutsideAngular(()=>t.handleError(s)),s}}(i,n,()=>{const t=r.injector.get(Xl);return t.runInitializers(),t.donePromise.then(()=>(pa(r.injector.get(su,ha)||ha),this._moduleDoBootstrap(r),r))})})}bootstrapModule(t,e=[]){const n=Ou({},e);return function(t,e,n){const s=new Sl(n);return Promise.resolve(s)}(0,0,t).then(t=>this.bootstrapModuleFactory(t,n))}_moduleDoBootstrap(t){const e=t.injector.get(Lu);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(t=>e.bootstrap(t));else{if(!t.instance.ngDoBootstrap)throw new Error(`The module ${ot(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);t.instance.ngDoBootstrap(e)}this._modules.push(t)}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(t=>t.destroy()),this._destroyListeners.forEach(t=>t()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(fs(po))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();function Ou(t,e){return Array.isArray(e)?e.reduce(Ou,t):Object.assign(Object.assign({},t),e)}let Lu=(()=>{class t{constructor(t,e,n,s,r){this._zone=t,this._injector=e,this._exceptionHandler=n,this._componentFactoryResolver=s,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new _(t=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{t.next(this._stable),t.complete()})}),o=new _(t=>{let e;this._zone.runOutsideAngular(()=>{e=this._zone.onStable.subscribe(()=>{mu.assertNotInAngularZone(),fu(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,t.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{mu.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{t.next(!1)}))});return()=>{e.unsubscribe(),n.unsubscribe()}});this.isStable=X(i,o.pipe(st()))}bootstrap(t,e){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=t instanceof _a?t:this._componentFactoryResolver.resolveComponentFactory(t),this.componentTypes.push(n.componentType);const s=n.isBoundToModule?void 0:this._injector.get(ul),r=n.create(po.NULL,[],e||n.selector,s),i=r.location.nativeElement,o=r.injector.get(_u,null),a=o&&r.injector.get(ku);return o&&a&&a.registerApplication(i,o),r.onDestroy(()=>{this.detachView(r.hostView),Mu(this.components,r),a&&a.unregisterApplication(i)}),this._loadComponent(r),r}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let t of this._views)t.detectChanges()}catch(t){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(t))}finally{this._runningTick=!1}}attachView(t){const e=t;this._views.push(e),e.attachToAppRef(this)}detachView(t){const e=t;Mu(this._views,e),e.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(eu,[]).concat(this._bootstrapListeners).forEach(e=>e(t))}ngOnDestroy(){this._views.slice().forEach(t=>t.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return t.\u0275fac=function(e){return new(e||t)(fs(mu),fs(po),fs(dr),fs(Ca),fs(Xl))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();function Mu(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class Pu{}class zu{}const Bu={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let Vu=(()=>{class t{constructor(t,e){this._compiler=t,this._config=e||Bu}load(t){return this.loadAndCompile(t)}loadAndCompile(t){let[e,s]=t.split("#");return void 0===s&&(s="default"),n(255)(e).then(t=>t[s]).then(t=>Wu(t,e,s)).then(t=>this._compiler.compileModuleAsync(t))}loadFactory(t){let[e,s]=t.split("#"),r="NgFactory";return void 0===s&&(s="default",r=""),n(255)(this._config.factoryPathPrefix+e+this._config.factoryPathSuffix).then(t=>t[s+r]).then(t=>Wu(t,e,s))}}return t.\u0275fac=function(e){return new(e||t)(fs(du),fs(zu,8))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();function Wu(t,e,n){if(!t)throw new Error(`Cannot find '${n}' in '${e}'`);return t}const Uu=Ru(null,"core",[{provide:tu,useValue:"unknown"},{provide:Du,deps:[po]},{provide:ku,deps:[]},{provide:nu,deps:[]}]),ju=[{provide:Lu,useClass:Lu,deps:[mu,po,dr,Ca,Xl]},{provide:xl,deps:[mu],useFactory:function(t){let e=[];return t.onStable.subscribe(()=>{for(;e.length;)e.pop()()}),function(t){e.push(t)}}},{provide:Xl,useClass:Xl,deps:[[new vs,Kl]]},{provide:du,useClass:du,deps:[]},Yl,{provide:qa,useFactory:function(){return nl},deps:[]},{provide:Xa,useFactory:function(){return sl},deps:[]},{provide:su,useFactory:function(t){return pa(t=t||"undefined"!=typeof $localize&&$localize.locale||ha),t},deps:[[new bs(su),new vs,new ws]]},{provide:ru,useValue:"USD"}];let Hu=(()=>{class t{constructor(t){}}return t.\u0275fac=function(e){return new(e||t)(fs(Lu))},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:ju}),t})(),Gu=null;function qu(){return Gu}const Ku=new Zn("DocumentToken");let Xu=(()=>{class t{historyGo(t){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:Zu,token:t,providedIn:"platform"}),t})();function Zu(){return fs(Qu)}const Yu=new Zn("Location Initialized");let Qu=(()=>{class t extends Xu{constructor(t){super(),this._doc=t,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return qu().getBaseHref(this._doc)}onPopState(t){const e=qu().getGlobalEventTarget(this._doc,"window");return e.addEventListener("popstate",t,!1),()=>e.removeEventListener("popstate",t)}onHashChange(t){const e=qu().getGlobalEventTarget(this._doc,"window");return e.addEventListener("hashchange",t,!1),()=>e.removeEventListener("hashchange",t)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(t){this.location.pathname=t}pushState(t,e,n){Ju()?this._history.pushState(t,e,n):this.location.hash=n}replaceState(t,e,n){Ju()?this._history.replaceState(t,e,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}historyGo(t=0){this._history.go(t)}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku))},t.\u0275prov=gt({factory:tc,token:t,providedIn:"platform"}),t})();function Ju(){return!!window.history.pushState}function tc(){return new Qu(fs(Ku))}function ec(t,e){if(0==t.length)return e;if(0==e.length)return t;let n=0;return t.endsWith("/")&&n++,e.startsWith("/")&&n++,2==n?t+e.substring(1):1==n?t+e:t+"/"+e}function nc(t){const e=t.match(/#|\?|$/),n=e&&e.index||t.length;return t.slice(0,n-("/"===t[n-1]?1:0))+t.slice(n)}function sc(t){return t&&"?"!==t[0]?"?"+t:t}let rc=(()=>{class t{historyGo(t){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:ic,token:t,providedIn:"root"}),t})();function ic(t){const e=fs(Ku).location;return new ac(fs(Xu),e&&e.origin||"")}const oc=new Zn("appBaseHref");let ac=(()=>{class t extends rc{constructor(t,e){if(super(),this._platformLocation=t,this._removeListenerFns=[],null==e&&(e=this._platformLocation.getBaseHrefFromDOM()),null==e)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=e}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(t){this._removeListenerFns.push(this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t))}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return ec(this._baseHref,t)}path(t=!1){const e=this._platformLocation.pathname+sc(this._platformLocation.search),n=this._platformLocation.hash;return n&&t?`${e}${n}`:e}pushState(t,e,n,s){const r=this.prepareExternalUrl(n+sc(s));this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,s){const r=this.prepareExternalUrl(n+sc(s));this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(t=0){var e,n;null===(n=(e=this._platformLocation).historyGo)||void 0===n||n.call(e,t)}}return t.\u0275fac=function(e){return new(e||t)(fs(Xu),fs(oc,8))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),lc=(()=>{class t extends rc{constructor(t,e){super(),this._platformLocation=t,this._baseHref="",this._removeListenerFns=[],null!=e&&(this._baseHref=e)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(t){this._removeListenerFns.push(this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t))}getBaseHref(){return this._baseHref}path(t=!1){let e=this._platformLocation.hash;return null==e&&(e="#"),e.length>0?e.substring(1):e}prepareExternalUrl(t){const e=ec(this._baseHref,t);return e.length>0?"#"+e:e}pushState(t,e,n,s){let r=this.prepareExternalUrl(n+sc(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,s){let r=this.prepareExternalUrl(n+sc(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(t=0){var e,n;null===(n=(e=this._platformLocation).historyGo)||void 0===n||n.call(e,t)}}return t.\u0275fac=function(e){return new(e||t)(fs(Xu),fs(oc,8))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),uc=(()=>{class t{constructor(t,e){this._subject=new Nl,this._urlChangeListeners=[],this._platformStrategy=t;const n=this._platformStrategy.getBaseHref();this._platformLocation=e,this._baseHref=nc(hc(n)),this._platformStrategy.onPopState(t=>{this._subject.emit({url:this.path(!0),pop:!0,state:t.state,type:t.type})})}path(t=!1){return this.normalize(this._platformStrategy.path(t))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(t,e=""){return this.path()==this.normalize(t+sc(e))}normalize(e){return t.stripTrailingSlash(function(t,e){return t&&e.startsWith(t)?e.substring(t.length):e}(this._baseHref,hc(e)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._platformStrategy.prepareExternalUrl(t)}go(t,e="",n=null){this._platformStrategy.pushState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+sc(e)),n)}replaceState(t,e="",n=null){this._platformStrategy.replaceState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+sc(e)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(t=0){var e,n;null===(n=(e=this._platformStrategy).historyGo)||void 0===n||n.call(e,t)}onUrlChange(t){this._urlChangeListeners.push(t),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(t=>{this._notifyUrlChangeListeners(t.url,t.state)}))}_notifyUrlChangeListeners(t="",e){this._urlChangeListeners.forEach(n=>n(t,e))}subscribe(t,e,n){return this._subject.subscribe({next:t,error:e,complete:n})}}return t.\u0275fac=function(e){return new(e||t)(fs(rc),fs(Xu))},t.normalizeQueryParams=sc,t.joinWithSlash=ec,t.stripTrailingSlash=nc,t.\u0275prov=gt({factory:cc,token:t,providedIn:"root"}),t})();function cc(){return new uc(fs(rc),fs(Xu))}function hc(t){return t.replace(/\/index.html$/,"")}var dc=function(t){return t[t.Decimal=0]="Decimal",t[t.Percent=1]="Percent",t[t.Currency=2]="Currency",t[t.Scientific=3]="Scientific",t}({}),pc=function(t){return t[t.Zero=0]="Zero",t[t.One=1]="One",t[t.Two=2]="Two",t[t.Few=3]="Few",t[t.Many=4]="Many",t[t.Other=5]="Other",t}({}),fc=function(t){return t[t.Decimal=0]="Decimal",t[t.Group=1]="Group",t[t.List=2]="List",t[t.PercentSign=3]="PercentSign",t[t.PlusSign=4]="PlusSign",t[t.MinusSign=5]="MinusSign",t[t.Exponential=6]="Exponential",t[t.SuperscriptingExponent=7]="SuperscriptingExponent",t[t.PerMille=8]="PerMille",t[t[1/0]=9]="Infinity",t[t.NaN=10]="NaN",t[t.TimeSeparator=11]="TimeSeparator",t[t.CurrencyDecimal=12]="CurrencyDecimal",t[t.CurrencyGroup=13]="CurrencyGroup",t}({});function mc(t,e){const n=la(t),s=n[ca.NumberSymbols][e];if(void 0===s){if(e===fc.CurrencyDecimal)return n[ca.NumberSymbols][fc.Decimal];if(e===fc.CurrencyGroup)return n[ca.NumberSymbols][fc.Group]}return s}const gc=/^(\d+)?\.((\d+)(-(\d+))?)?$/,yc=".",bc="0";function vc(t){const e=parseInt(t);if(isNaN(e))throw new Error("Invalid integer literal when parsing "+t);return e}class wc{}let xc=(()=>{class t extends wc{constructor(t){super(),this.locale=t}getPluralCategory(t,e){switch(function(t){return la(t)[ca.PluralCase]}(e||this.locale)(t)){case pc.Zero:return"zero";case pc.One:return"one";case pc.Two:return"two";case pc.Few:return"few";case pc.Many:return"many";default:return"other"}}}return t.\u0275fac=function(e){return new(e||t)(fs(su))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),_c=(()=>{class t{constructor(t,e){this._viewContainer=t,this._context=new kc,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=e}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){Cc("ngIfThen",t),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){Cc("ngIfElse",t),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(To(dl),To(il))},t.\u0275dir=Jt({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),t})();class kc{constructor(){this.$implicit=null,this.ngIf=null}}function Cc(t,e){if(e&&!e.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${ot(e)}'.`)}class Ic{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let Sc=(()=>{class t{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(t){this._ngSwitch=t,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(t){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(t)}_matchCase(t){const e=t==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||e,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),e}_updateDefaultCases(t){if(this._defaultViews&&t!==this._defaultUsed){this._defaultUsed=t;for(let e=0;e<this._defaultViews.length;e++)this._defaultViews[e].enforceState(t)}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Jt({type:t,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"}}),t})(),Ec=(()=>{class t{constructor(t,e,n){this.ngSwitch=n,n._addCase(),this._view=new Ic(t,e)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return t.\u0275fac=function(e){return new(e||t)(To(dl),To(il),To(Sc,9))},t.\u0275dir=Jt({type:t,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"}}),t})(),Tc=(()=>{class t{constructor(t){this._locale=t}transform(e,n,s){if(!function(t){return!(null==t||""===t||t!=t)}(e))return null;s=s||this._locale;try{return function(t,e,n){return function(t,e,n,s,r,i,o=!1){let a="",l=!1;if(isFinite(t)){let u=function(t){let e,n,s,r,i,o=Math.abs(t)+"",a=0;for((n=o.indexOf(yc))>-1&&(o=o.replace(yc,"")),(s=o.search(/e/i))>0?(n<0&&(n=s),n+=+o.slice(s+1),o=o.substring(0,s)):n<0&&(n=o.length),s=0;o.charAt(s)===bc;s++);if(s===(i=o.length))e=[0],n=1;else{for(i--;o.charAt(i)===bc;)i--;for(n-=s,e=[],r=0;s<=i;s++,r++)e[r]=Number(o.charAt(s))}return n>22&&(e=e.splice(0,21),a=n-1,n=1),{digits:e,exponent:a,integerLen:n}}(t);o&&(u=function(t){if(0===t.digits[0])return t;const e=t.digits.length-t.integerLen;return t.exponent?t.exponent+=2:(0===e?t.digits.push(0,0):1===e&&t.digits.push(0),t.integerLen+=2),t}(u));let c=e.minInt,h=e.minFrac,d=e.maxFrac;if(i){const t=i.match(gc);if(null===t)throw new Error(`${i} is not a valid digit info`);const e=t[1],n=t[3],s=t[5];null!=e&&(c=vc(e)),null!=n&&(h=vc(n)),null!=s?d=vc(s):null!=n&&h>d&&(d=h)}!function(t,e,n){if(e>n)throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${n}).`);let s=t.digits,r=s.length-t.integerLen;const i=Math.min(Math.max(e,r),n);let o=i+t.integerLen,a=s[o];if(o>0){s.splice(Math.max(t.integerLen,o));for(let t=o;t<s.length;t++)s[t]=0}else{r=Math.max(0,r),t.integerLen=1,s.length=Math.max(1,o=i+1),s[0]=0;for(let t=1;t<o;t++)s[t]=0}if(a>=5)if(o-1<0){for(let e=0;e>o;e--)s.unshift(0),t.integerLen++;s.unshift(1),t.integerLen++}else s[o-1]++;for(;r<Math.max(0,i);r++)s.push(0);let l=0!==i;const u=e+t.integerLen,c=s.reduceRight(function(t,e,n,s){return s[n]=(e+=t)<10?e:e-10,l&&(0===s[n]&&n>=u?s.pop():l=!1),e>=10?1:0},0);c&&(s.unshift(c),t.integerLen++)}(u,h,d);let p=u.digits,f=u.integerLen;const m=u.exponent;let g=[];for(l=p.every(t=>!t);f<c;f++)p.unshift(0);for(;f<0;f++)p.unshift(0);f>0?g=p.splice(f,p.length):(g=p,p=[0]);const y=[];for(p.length>=e.lgSize&&y.unshift(p.splice(-e.lgSize,p.length).join(""));p.length>e.gSize;)y.unshift(p.splice(-e.gSize,p.length).join(""));p.length&&y.unshift(p.join("")),a=y.join(mc(n,s)),g.length&&(a+=mc(n,r)+g.join("")),m&&(a+=mc(n,fc.Exponential)+"+"+m)}else a=mc(n,fc.Infinity);return a=t<0&&!l?e.negPre+a+e.negSuf:e.posPre+a+e.posSuf,a}(t,function(t,e="-"){const n={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},s=t.split(";"),r=s[0],i=s[1],o=-1!==r.indexOf(yc)?r.split(yc):[r.substring(0,r.lastIndexOf(bc)+1),r.substring(r.lastIndexOf(bc)+1)],a=o[0],l=o[1]||"";n.posPre=a.substr(0,a.indexOf("#"));for(let c=0;c<l.length;c++){const t=l.charAt(c);t===bc?n.minFrac=n.maxFrac=c+1:"#"===t?n.maxFrac=c+1:n.posSuf+=t}const u=a.split(",");if(n.gSize=u[1]?u[1].length:0,n.lgSize=u[2]||u[1]?(u[2]||u[1]).length:0,i){const t=r.length-n.posPre.length-n.posSuf.length,e=i.indexOf("#");n.negPre=i.substr(0,e).replace(/'/g,""),n.negSuf=i.substr(e+t).replace(/'/g,"")}else n.negPre=e+n.posPre,n.negSuf=n.posSuf;return n}(function(t,e){return la(t)[ca.NumberFormats][e]}(e,dc.Percent),mc(e,fc.MinusSign)),e,fc.Group,fc.Decimal,n,!0).replace(new RegExp("%","g"),mc(e,fc.PercentSign))}(function(t){if("string"==typeof t&&!isNaN(Number(t)-parseFloat(t)))return Number(t);if("number"!=typeof t)throw new Error(`${t} is not a number`);return t}(e),s,n)}catch(r){throw function(t,e){return Error(`InvalidPipeArgument: '${e}' for pipe '${ot(t)}'`)}(t,r.message)}}}return t.\u0275fac=function(e){return new(e||t)(To(su,16))},t.\u0275pipe=te({name:"percent",type:t,pure:!0}),t})(),Nc=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[{provide:wc,useClass:xc}]}),t})(),$c=(()=>{class t{}return t.\u0275prov=gt({token:t,providedIn:"root",factory:()=>new Ac(fs(Ku),window)}),t})();class Ac{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function(t,e){const n=t.getElementById(e)||t.getElementsByName(e)[0];if(n)return n;if("function"==typeof t.createTreeWalker&&t.body&&(t.body.createShadowRoot||t.body.attachShadow)){const n=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let s=n.currentNode;for(;s;){const t=s.shadowRoot;if(t){const n=t.getElementById(e)||t.querySelector(`[name="${e}"]`);if(n)return n}s=n.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),this.attemptFocus(e))}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),n=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,r=this.offset();this.window.scrollTo(n-r[0],s-r[1])}attemptFocus(t){return t.focus(),this.document.activeElement===t}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=Rc(this.window.history)||Rc(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(t){return!1}}}function Rc(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class Fc extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){var t;t=new Fc,Gu||(Gu=t)}onAndCancel(t,e,n){return t.addEventListener(e,n,!1),()=>{t.removeEventListener(e,n,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=(Oc=Oc||document.querySelector("base"),Oc?Oc.getAttribute("href"):null);return null==e?null:function(t){Dc=Dc||document.createElement("a"),Dc.setAttribute("href",t);const e=Dc.pathname;return"/"===e.charAt(0)?e:`/${e}`}(e)}resetBaseElement(){Oc=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function(t,e){e=encodeURIComponent(e);for(const n of t.split(";")){const t=n.indexOf("="),[s,r]=-1==t?[n,""]:[n.slice(0,t),n.slice(t+1)];if(s.trim()===e)return decodeURIComponent(r)}return null}(document.cookie,t)}}let Dc,Oc=null;const Lc=new Zn("TRANSITION_ID"),Mc=[{provide:Kl,useFactory:function(t,e,n){return()=>{n.get(Xl).donePromise.then(()=>{const n=qu();Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e=>e.getAttribute("ng-transition")===t).forEach(t=>n.remove(t))})}},deps:[Lc,Ku,po],multi:!0}];class Pc{static init(){var t;t=new Pc,Su=t}addToWindow(t){Lt.getAngularTestability=(e,n=!0)=>{const s=t.findTestabilityInTree(e,n);if(null==s)throw new Error("Could not find testability for element.");return s},Lt.getAllAngularTestabilities=()=>t.getAllTestabilities(),Lt.getAllAngularRootElements=()=>t.getAllRootElements(),Lt.frameworkStabilizers||(Lt.frameworkStabilizers=[]),Lt.frameworkStabilizers.push(t=>{const e=Lt.getAllAngularTestabilities();let n=e.length,s=!1;const r=function(e){s=s||e,n--,0==n&&t(s)};e.forEach(function(t){t.whenStable(r)})})}findTestabilityInTree(t,e,n){if(null==e)return null;const s=t.getTestability(e);return null!=s?s:n?qu().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}let zc=(()=>{class t{build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const Bc=new Zn("EventManagerPlugins");let Vc=(()=>{class t{constructor(t,e){this._zone=e,this._eventNameToPlugin=new Map,t.forEach(t=>t.manager=this),this._plugins=t.slice().reverse()}addEventListener(t,e,n){return this._findPluginFor(e).addEventListener(t,e,n)}addGlobalEventListener(t,e,n){return this._findPluginFor(e).addGlobalEventListener(t,e,n)}getZone(){return this._zone}_findPluginFor(t){const e=this._eventNameToPlugin.get(t);if(e)return e;const n=this._plugins;for(let s=0;s<n.length;s++){const e=n[s];if(e.supports(t))return this._eventNameToPlugin.set(t,e),e}throw new Error(`No event manager plugin found for event ${t}`)}}return t.\u0275fac=function(e){return new(e||t)(fs(Bc),fs(mu))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();class Wc{constructor(t){this._doc=t}addGlobalEventListener(t,e,n){const s=qu().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,n)}}let Uc=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(t){const e=new Set;t.forEach(t=>{this._stylesSet.has(t)||(this._stylesSet.add(t),e.add(t))}),this.onStylesAdded(e)}onStylesAdded(t){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),jc=(()=>{class t extends Uc{constructor(t){super(),this._doc=t,this._hostNodes=new Map,this._hostNodes.set(t.head,[])}_addStylesToHost(t,e,n){t.forEach(t=>{const s=this._doc.createElement("style");s.textContent=t,n.push(e.appendChild(s))})}addHost(t){const e=[];this._addStylesToHost(this._stylesSet,t,e),this._hostNodes.set(t,e)}removeHost(t){const e=this._hostNodes.get(t);e&&e.forEach(Hc),this._hostNodes.delete(t)}onStylesAdded(t){this._hostNodes.forEach((e,n)=>{this._addStylesToHost(t,n,e)})}ngOnDestroy(){this._hostNodes.forEach(t=>t.forEach(Hc))}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();function Hc(t){qu().remove(t)}const Gc={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},qc=/%COMP%/g;function Kc(t,e,n){for(let s=0;s<e.length;s++){let r=e[s];Array.isArray(r)?Kc(t,r,n):(r=r.replace(qc,t),n.push(r))}return n}function Xc(t){return e=>{if("__ngUnwrap__"===e)return t;!1===t(e)&&(e.preventDefault(),e.returnValue=!1)}}let Zc=(()=>{class t{constructor(t,e,n){this.eventManager=t,this.sharedStylesHost=e,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new Yc(t)}createRenderer(t,e){if(!t||!e)return this.defaultRenderer;switch(e.encapsulation){case At.Emulated:{let n=this.rendererByCompId.get(e.id);return n||(n=new Qc(this.eventManager,this.sharedStylesHost,e,this.appId),this.rendererByCompId.set(e.id,n)),n.applyToHost(t),n}case 1:case At.ShadowDom:return new Jc(this.eventManager,this.sharedStylesHost,t,e);default:if(!this.rendererByCompId.has(e.id)){const t=Kc(e.id,e.styles,[]);this.sharedStylesHost.addStyles(t),this.rendererByCompId.set(e.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(fs(Vc),fs(jc),fs(Zl))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();class Yc{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(Gc[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,n){t&&t.insertBefore(e,n)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let n="string"==typeof t?document.querySelector(t):t;if(!n)throw new Error(`The selector "${t}" did not match any elements`);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,s){if(s){e=s+":"+e;const r=Gc[s];r?t.setAttributeNS(r,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){const s=Gc[n];s?t.removeAttributeNS(s,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,s){s&(mr.DashCase|mr.Important)?t.style.setProperty(e,n,s&mr.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&mr.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t[e]=n}setValue(t,e){t.nodeValue=e}listen(t,e,n){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,Xc(n)):this.eventManager.addEventListener(t,e,Xc(n))}}class Qc extends Yc{constructor(t,e,n,s){super(t),this.component=n;const r=Kc(s+"-"+n.id,n.styles,[]);e.addStyles(r),this.contentAttr="_ngcontent-%COMP%".replace(qc,s+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(qc,s+"-"+n.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}}class Jc extends Yc{constructor(t,e,n,s){super(t),this.sharedStylesHost=e,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const r=Kc(s.id,s.styles,[]);for(let i=0;i<r.length;i++){const t=document.createElement("style");t.textContent=r[i],this.shadowRoot.appendChild(t)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let th=(()=>{class t extends Wc{constructor(t){super(t)}supports(t){return!0}addEventListener(t,e,n){return t.addEventListener(e,n,!1),()=>this.removeEventListener(t,e,n)}removeEventListener(t,e,n){return t.removeEventListener(e,n)}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const eh=["alt","control","meta","shift"],nh={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},sh={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},rh={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let ih=(()=>{class t extends Wc{constructor(t){super(t)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,n,s){const r=t.parseEventName(n),i=t.eventCallback(r.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>qu().onAndCancel(e,r.domEventName,i))}static parseEventName(e){const n=e.toLowerCase().split("."),s=n.shift();if(0===n.length||"keydown"!==s&&"keyup"!==s)return null;const r=t._normalizeKey(n.pop());let i="";if(eh.forEach(t=>{const e=n.indexOf(t);e>-1&&(n.splice(e,1),i+=t+".")}),i+=r,0!=n.length||0===r.length)return null;const o={};return o.domEventName=s,o.fullKey=i,o}static getEventFullKey(t){let e="",n=function(t){let e=t.key;if(null==e){if(e=t.keyIdentifier,null==e)return"Unidentified";e.startsWith("U+")&&(e=String.fromCharCode(parseInt(e.substring(2),16)),3===t.location&&sh.hasOwnProperty(e)&&(e=sh[e]))}return nh[e]||e}(t);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),eh.forEach(s=>{s!=n&&(0,rh[s])(t)&&(e+=s+".")}),e+=n,e}static eventCallback(e,n,s){return r=>{t.getEventFullKey(r)===e&&s.runGuarded(()=>n(r))}}static _normalizeKey(t){switch(t){case"esc":return"escape";default:return t}}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),oh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:function(){return fs(lh)},token:t,providedIn:"root"}),t})();function ah(t){return new lh(t.get(Ku))}let lh=(()=>{class t extends oh{constructor(t){super(),this._doc=t}sanitize(t,e){if(null==e)return null;switch(t){case sr.NONE:return e;case sr.HTML:return Rs(e,"HTML")?As(e):er(this._doc,String(e)).toString();case sr.STYLE:return Rs(e,"Style")?As(e):e;case sr.SCRIPT:if(Rs(e,"Script"))return As(e);throw new Error("unsafe value used in a script context");case sr.URL:return Fs(e),Rs(e,"URL")?As(e):Ps(String(e));case sr.RESOURCE_URL:if(Rs(e,"ResourceURL"))return As(e);throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");default:throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`)}}bypassSecurityTrustHtml(t){return new Ss(t)}bypassSecurityTrustStyle(t){return new Es(t)}bypassSecurityTrustScript(t){return new Ts(t)}bypassSecurityTrustUrl(t){return new Ns(t)}bypassSecurityTrustResourceUrl(t){return new $s(t)}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku))},t.\u0275prov=gt({factory:function(){return ah(fs(Yi))},token:t,providedIn:"root"}),t})();const uh=Ru(Uu,"browser",[{provide:tu,useValue:"browser"},{provide:Jl,useValue:function(){Fc.makeCurrent(),Pc.init()},multi:!0},{provide:Ku,useFactory:function(){return function(t){ve=t}(document),document},deps:[]}]),ch=[[],{provide:Ji,useValue:"root"},{provide:dr,useFactory:function(){return new dr},deps:[]},{provide:Bc,useClass:th,multi:!0,deps:[Ku,mu,tu]},{provide:Bc,useClass:ih,multi:!0,deps:[Ku]},[],{provide:Zc,useClass:Zc,deps:[Vc,jc,Zl]},{provide:$a,useExisting:Zc},{provide:Uc,useExisting:jc},{provide:jc,useClass:jc,deps:[Ku]},{provide:_u,useClass:_u,deps:[mu]},{provide:Vc,useClass:Vc,deps:[Bc,mu]},{provide:class{},useClass:zc,deps:[]},[]];let hh=(()=>{class t{constructor(t){if(t)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:t,providers:[{provide:Zl,useValue:e.appId},{provide:Lc,useExisting:Zl},Mc]}}}return t.\u0275fac=function(e){return new(e||t)(fs(t,12))},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:ch,imports:[Nc,Hu]}),t})();function dh(...t){if(1===t.length){const e=t[0];if(d(e))return ph(e,null);if(p(e)&&Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);return ph(t.map(t=>e[t]),t)}}if("function"==typeof t[t.length-1]){const e=t.pop();return ph(t=1===t.length&&d(t[0])?t[0]:t,null).pipe($(t=>e(...t)))}return ph(t,null)}function ph(t,e){return new _(n=>{const s=t.length;if(0===s)return void n.complete();const r=new Array(s);let i=0,o=0;for(let a=0;a<s;a++){const l=B(t[a]);let u=!1;n.add(l.subscribe({next:t=>{u||(u=!0,o++),r[a]=t},error:t=>n.error(t),complete:()=>{i++,i!==s&&u||(o===s&&n.next(e?e.reduce((t,e,n)=>(t[e]=r[n],t),{}):r),n.complete())}}))}})}"undefined"!=typeof window&&window;let fh=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this.onChange=t=>{},this.onTouched=()=>{}}setProperty(t,e){this._renderer.setProperty(this._elementRef.nativeElement,t,e)}registerOnTouched(t){this.onTouched=t}registerOnChange(t){this.onChange=t}setDisabledState(t){this.setProperty("disabled",t)}}return t.\u0275fac=function(e){return new(e||t)(To(Aa),To(Ta))},t.\u0275dir=Jt({type:t}),t})(),mh=(()=>{class t extends fh{}return t.\u0275fac=function(){let e;return function(n){return(e||(e=Hn(t)))(n||t)}}(),t.\u0275dir=Jt({type:t,features:[mo]}),t})();const gh=new Zn("NgValueAccessor"),yh={provide:gh,useExisting:ut(()=>vh),multi:!0},bh=new Zn("CompositionEventMode");let vh=(()=>{class t extends fh{constructor(t,e,n){super(t,e),this._compositionMode=n,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function(){const t=qu()?qu().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(t){this.setProperty("value",null==t?"":t)}_handleInput(t){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(t)}_compositionStart(){this._composing=!0}_compositionEnd(t){this._composing=!1,this._compositionMode&&this.onChange(t)}}return t.\u0275fac=function(e){return new(e||t)(To(Aa),To(Ta),To(bh,8))},t.\u0275dir=Jt({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(t,e){1&t&&Mo("input",function(t){return e._handleInput(t.target.value)})("blur",function(){return e.onTouched()})("compositionstart",function(){return e._compositionStart()})("compositionend",function(t){return e._compositionEnd(t.target.value)})},features:[xa([yh]),mo]}),t})();const wh=new Zn("NgValidators"),xh=new Zn("NgAsyncValidators");function _h(t){return null!=t}function kh(t){const e=Oo(t)?B(t):t;return Lo(e),e}function Ch(t){let e={};return t.forEach(t=>{e=null!=t?Object.assign(Object.assign({},e),t):e}),0===Object.keys(e).length?null:e}function Ih(t,e){return e.map(e=>e(t))}function Sh(t){return t.map(t=>function(t){return!t.validate}(t)?t:e=>t.validate(e))}function Eh(t){return null!=t?function(t){if(!t)return null;const e=t.filter(_h);return 0==e.length?null:function(t){return Ch(Ih(t,e))}}(Sh(t)):null}function Th(t){return null!=t?function(t){if(!t)return null;const e=t.filter(_h);return 0==e.length?null:function(t){return dh(Ih(t,e).map(kh)).pipe($(Ch))}}(Sh(t)):null}function Nh(t,e){return null===t?[e]:Array.isArray(t)?[...t,e]:[t,e]}function $h(t){return t._rawValidators}function Ah(t){return t._rawAsyncValidators}let Rh=(()=>{class t{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=Eh(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=Th(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Jt({type:t}),t})(),Fh=(()=>{class t extends Rh{get formDirective(){return null}get path(){return null}}return t.\u0275fac=function(){let e;return function(n){return(e||(e=Hn(t)))(n||t)}}(),t.\u0275dir=Jt({type:t,features:[mo]}),t})();class Dh extends Rh{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class Oh{constructor(t){this._cd=t}is(t){var e,n;return!!(null===(n=null===(e=this._cd)||void 0===e?void 0:e.control)||void 0===n?void 0:n[t])}}let Lh=(()=>{class t extends Oh{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(To(Dh,2))},t.\u0275dir=Jt({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(t,e){2&t&&Xo("ng-untouched",e.is("untouched"))("ng-touched",e.is("touched"))("ng-pristine",e.is("pristine"))("ng-dirty",e.is("dirty"))("ng-valid",e.is("valid"))("ng-invalid",e.is("invalid"))("ng-pending",e.is("pending"))},features:[mo]}),t})(),Mh=(()=>{class t extends Oh{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(To(Fh,10))},t.\u0275dir=Jt({type:t,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:14,hostBindings:function(t,e){2&t&&Xo("ng-untouched",e.is("untouched"))("ng-touched",e.is("touched"))("ng-pristine",e.is("pristine"))("ng-dirty",e.is("dirty"))("ng-valid",e.is("valid"))("ng-invalid",e.is("invalid"))("ng-pending",e.is("pending"))},features:[mo]}),t})();function Ph(t,e){Vh(t,e),e.valueAccessor.writeValue(t.value),function(t,e){e.valueAccessor.registerOnChange(n=>{t._pendingValue=n,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&Uh(t,e)})}(t,e),function(t,e){const n=(t,n)=>{e.valueAccessor.writeValue(t),n&&e.viewToModelUpdate(t)};t.registerOnChange(n),e._registerOnDestroy(()=>{t._unregisterOnChange(n)})}(t,e),function(t,e){e.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&Uh(t,e),"submit"!==t.updateOn&&t.markAsTouched()})}(t,e),function(t,e){if(e.valueAccessor.setDisabledState){const n=t=>{e.valueAccessor.setDisabledState(t)};t.registerOnDisabledChange(n),e._registerOnDestroy(()=>{t._unregisterOnDisabledChange(n)})}}(t,e)}function zh(t,e,n=!0){const s=()=>{};e.valueAccessor&&(e.valueAccessor.registerOnChange(s),e.valueAccessor.registerOnTouched(s)),Wh(t,e),t&&(e._invokeOnDestroyCallbacks(),t._registerOnCollectionChange(()=>{}))}function Bh(t,e){t.forEach(t=>{t.registerOnValidatorChange&&t.registerOnValidatorChange(e)})}function Vh(t,e){const n=$h(t);null!==e.validator?t.setValidators(Nh(n,e.validator)):"function"==typeof n&&t.setValidators([n]);const s=Ah(t);null!==e.asyncValidator?t.setAsyncValidators(Nh(s,e.asyncValidator)):"function"==typeof s&&t.setAsyncValidators([s]);const r=()=>t.updateValueAndValidity();Bh(e._rawValidators,r),Bh(e._rawAsyncValidators,r)}function Wh(t,e){let n=!1;if(null!==t){if(null!==e.validator){const s=$h(t);if(Array.isArray(s)&&s.length>0){const r=s.filter(t=>t!==e.validator);r.length!==s.length&&(n=!0,t.setValidators(r))}}if(null!==e.asyncValidator){const s=Ah(t);if(Array.isArray(s)&&s.length>0){const r=s.filter(t=>t!==e.asyncValidator);r.length!==s.length&&(n=!0,t.setAsyncValidators(r))}}}const s=()=>{};return Bh(e._rawValidators,s),Bh(e._rawAsyncValidators,s),n}function Uh(t,e){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function jh(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}const Hh="VALID",Gh="INVALID",qh="PENDING",Kh="DISABLED";function Xh(t){return(Jh(t)?t.validators:t)||null}function Zh(t){return Array.isArray(t)?Eh(t):t||null}function Yh(t,e){return(Jh(e)?e.asyncValidators:t)||null}function Qh(t){return Array.isArray(t)?Th(t):t||null}function Jh(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}class td{constructor(t,e){this._hasOwnPendingAsyncValidator=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=t,this._rawAsyncValidators=e,this._composedValidatorFn=Zh(this._rawValidators),this._composedAsyncValidatorFn=Qh(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===Hh}get invalid(){return this.status===Gh}get pending(){return this.status==qh}get disabled(){return this.status===Kh}get enabled(){return this.status!==Kh}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._rawValidators=t,this._composedValidatorFn=Zh(t)}setAsyncValidators(t){this._rawAsyncValidators=t,this._composedAsyncValidatorFn=Qh(t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(t=>{t.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(t=>{t.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=qh,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Kh,this.errors=null,this._forEachChild(e=>{e.disable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Hh,this._forEachChild(e=>{e.enable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),this.status!==Hh&&this.status!==qh||this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Kh:Hh}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=qh,this._hasOwnPendingAsyncValidator=!0;const e=kh(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(e=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(e,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){return function(t,e,n){if(null==e)return null;if(Array.isArray(e)||(e=e.split(".")),Array.isArray(e)&&0===e.length)return null;let s=t;return e.forEach(t=>{s=s instanceof nd?s.controls.hasOwnProperty(t)?s.controls[t]:null:s instanceof sd&&s.at(t)||null}),s}(this,t)}getError(t,e){const n=e?this.get(e):this;return n&&n.errors?n.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new Nl,this.statusChanges=new Nl}_calculateStatus(){return this._allControlsDisabled()?Kh:this.errors?Gh:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(qh)?qh:this._anyControlsHaveStatus(Gh)?Gh:Hh}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_isBoxedValue(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){Jh(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}}class ed extends td{constructor(t=null,e,n){super(Xh(e),Yh(n,e)),this._onChange=[],this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(t=>t(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=null,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){jh(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){jh(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){this._isBoxedValue(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}}class nd extends td{constructor(t,e,n){super(Xh(e),Yh(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e,n={}){this.registerControl(t,e),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}removeControl(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(t,e,n={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){this._checkAllValuesPresent(t),Object.keys(t).forEach(n=>{this._throwIfControlMissing(n),this.controls[n].setValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(n=>{this.controls[n]&&this.controls[n].patchValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((n,s)=>{n.reset(t[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,n)=>(t[n]=e instanceof ed?e.value:e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(t,e)=>!!e._syncPendingControls()||t);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!Object.keys(this.controls).length)throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.controls[t])throw new Error(`Cannot find form control with name: ${t}.`)}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const n=this.controls[e];n&&t(n,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const e of Object.keys(this.controls)){const n=this.controls[e];if(this.contains(e)&&t(n))return!0}return!1}_reduceValue(){return this._reduceChildren({},(t,e,n)=>((e.enabled||this.disabled)&&(t[n]=e.value),t))}_reduceChildren(t,e){let n=t;return this._forEachChild((t,s)=>{n=e(n,t,s)}),n}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control with name: '${n}'.`)})}}class sd extends td{constructor(t,e,n){super(Xh(e),Yh(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}at(t){return this.controls[t]}push(t,e={}){this.controls.push(t),this._registerControl(t),this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}insert(t,e,n={}){this.controls.splice(t,0,e),this._registerControl(e),this.updateValueAndValidity({emitEvent:n.emitEvent})}removeAt(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),this.updateValueAndValidity({emitEvent:e.emitEvent})}setControl(t,e,n={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),e&&(this.controls.splice(t,0,e),this._registerControl(e)),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(t,e={}){this._checkAllValuesPresent(t),t.forEach((t,n)=>{this._throwIfControlMissing(n),this.at(n).setValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(t.forEach((t,n)=>{this.at(n)&&this.at(n).patchValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t=[],e={}){this._forEachChild((n,s)=>{n.reset(t[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this.controls.map(t=>t instanceof ed?t.value:t.getRawValue())}clear(t={}){this.controls.length<1||(this._forEachChild(t=>t._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:t.emitEvent}))}_syncPendingControls(){let t=this.controls.reduce((t,e)=>!!e._syncPendingControls()||t,!1);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!this.controls.length)throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.at(t))throw new Error(`Cannot find form control at index ${t}`)}_forEachChild(t){this.controls.forEach((e,n)=>{t(e,n)})}_updateValue(){this.value=this.controls.filter(t=>t.enabled||this.disabled).map(t=>t.value)}_anyControls(t){return this.controls.some(e=>e.enabled&&t(e))}_setUpControls(){this._forEachChild(t=>this._registerControl(t))}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control at index: ${n}.`)})}_allControlsDisabled(){for(const t of this.controls)if(t.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(t){t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)}}let rd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Jt({type:t,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),t})(),id=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})();const od=new Zn("NgModelWithFormControlWarning"),ad={provide:Fh,useExisting:ut(()=>ld)};let ld=(()=>{class t extends Fh{constructor(t,e){super(),this.validators=t,this.asyncValidators=e,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new Nl,this._setValidators(t),this._setAsyncValidators(e)}ngOnChanges(t){this._checkFormPresent(),t.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(Wh(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(t){const e=this.form.get(t.path);return Ph(e,t),e.updateValueAndValidity({emitEvent:!1}),this.directives.push(t),e}getControl(t){return this.form.get(t.path)}removeControl(t){zh(t.control||null,t,!1),jh(this.directives,t)}addFormGroup(t){this._setUpFormContainer(t)}removeFormGroup(t){this._cleanUpFormContainer(t)}getFormGroup(t){return this.form.get(t.path)}addFormArray(t){this._setUpFormContainer(t)}removeFormArray(t){this._cleanUpFormContainer(t)}getFormArray(t){return this.form.get(t.path)}updateModel(t,e){this.form.get(t.path).setValue(e)}onSubmit(t){return this.submitted=!0,e=this.directives,this.form._syncPendingControls(),e.forEach(t=>{const e=t.control;"submit"===e.updateOn&&e._pendingChange&&(t.viewToModelUpdate(e._pendingValue),e._pendingChange=!1)}),this.ngSubmit.emit(t),!1;var e}onReset(){this.resetForm()}resetForm(t){this.form.reset(t),this.submitted=!1}_updateDomValue(){this.directives.forEach(t=>{const e=t.control,n=this.form.get(t.path);e!==n&&(zh(e||null,t),n instanceof ed&&(Ph(n,t),t.control=n))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(t){const e=this.form.get(t.path);(function(t,e){Vh(t,e)})(e,t),e.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(t){if(this.form){const e=this.form.get(t.path);e&&function(t,e){return Wh(t,e)}(e,t)&&e.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){Vh(this.form,this),this._oldForm&&Wh(this._oldForm,this)}_checkFormPresent(){}}return t.\u0275fac=function(e){return new(e||t)(To(wh,10),To(xh,10))},t.\u0275dir=Jt({type:t,selectors:[["","formGroup",""]],hostBindings:function(t,e){1&t&&Mo("submit",function(t){return e.onSubmit(t)})("reset",function(){return e.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[xa([ad]),mo,pe]}),t})();const ud={provide:Dh,useExisting:ut(()=>cd)};let cd=(()=>{class t extends Dh{constructor(t,e,n,s,r){super(),this._ngModelWarningConfig=r,this._added=!1,this.update=new Nl,this._ngModelWarningSent=!1,this._parent=t,this._setValidators(e),this._setAsyncValidators(n),this.valueAccessor=function(t,e){if(!e)return null;let n,s,r;return Array.isArray(e),e.forEach(t=>{t.constructor===vh?n=t:Object.getPrototypeOf(t.constructor)===mh?s=t:r=t}),r||s||n||null}(0,s)}set isDisabled(t){}ngOnChanges(t){this._added||this._setUpControl(),function(t,e){if(!t.hasOwnProperty("model"))return!1;const n=t.model;return!!n.isFirstChange()||!Object.is(e,n.currentValue)}(t,this.viewModel)&&(this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}viewToModelUpdate(t){this.viewModel=t,this.update.emit(t)}get path(){return t=null==this.name?this.name:this.name.toString(),[...this._parent.path,t];var t}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}_setUpControl(){this._checkParentType(),this.control=this.formDirective.addControl(this),this.control.disabled&&this.valueAccessor.setDisabledState&&this.valueAccessor.setDisabledState(!0),this._added=!0}}return t.\u0275fac=function(e){return new(e||t)(To(Fh,13),To(wh,10),To(xh,10),To(gh,10),To(od,8))},t.\u0275dir=Jt({type:t,selectors:[["","formControlName",""]],inputs:{isDisabled:["disabled","isDisabled"],name:["formControlName","name"],model:["ngModel","model"]},outputs:{update:"ngModelChange"},features:[xa([ud]),mo,pe]}),t._ngModelWarningSentOnce=!1,t})(),hd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[id]]}),t})(),dd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[hd]}),t})(),pd=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:od,useValue:e.warnOnNgModelWithFormControl}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[hd]}),t})();function fd(...t){let e=t[t.length-1];return N(e)?(t.pop(),z(t,e)):K(t)}class md extends E{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&&!e.closed&&t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new C;return this._value}next(t){super.next(this._value=t)}}class gd extends b{notifyNext(t,e,n,s,r){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}class yd extends b{constructor(t,e,n){super(),this.parent=t,this.outerValue=e,this.outerIndex=n,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function bd(t,e,n,s,r=new yd(t,n,s)){if(!r.closed)return e instanceof _?e.subscribe(r):P(e)(r)}const vd={};class wd{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new xd(t,this.resultSelector))}}class xd extends gd{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(vd),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let n=0;n<e;n++)this.add(bd(this,t[n],void 0,n))}}notifyComplete(t){0==(this.active-=1)&&this.destination.complete()}notifyNext(t,e,n){const s=this.values,r=this.toRespond?s[n]===vd?--this.toRespond:this.toRespond:0;s[n]=e,0===r&&(this.resultSelector?this._tryResultSelector(s):this.destination.next(s.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const _d=(()=>{function t(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return t.prototype=Object.create(Error.prototype),t})();function kd(...t){return q(1)(fd(...t))}const Cd=new _(t=>t.complete());function Id(t){return t?function(t){return new _(e=>t.schedule(()=>e.complete()))}(t):Cd}function Sd(t){return new _(e=>{let n;try{n=t()}catch(s){return void e.error(s)}return(n?B(n):Id()).subscribe(e)})}function Ed(t,e){return"function"==typeof e?n=>n.pipe(Ed((n,s)=>B(t(n,s)).pipe($((t,r)=>e(n,t,s,r))))):e=>e.lift(new Td(t))}class Td{constructor(t){this.project=t}call(t,e){return e.subscribe(new Nd(t,this.project))}}class Nd extends W{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(s){return void this.destination.error(s)}this._innerSub(e)}_innerSub(t){const e=this.innerSubscription;e&&e.unsubscribe();const n=new V(this),s=this.destination;s.add(n),this.innerSubscription=U(t,n),this.innerSubscription!==n&&s.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;t&&!t.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(t){this.destination.next(t)}}const $d=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})();function Ad(t){return e=>0===t?Id():e.lift(new Rd(t))}class Rd{constructor(t){if(this.total=t,this.total<0)throw new $d}call(t,e){return e.subscribe(new Fd(t,this.total))}}class Fd extends b{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,n=++this.count;n<=e&&(this.destination.next(t),n===e&&(this.destination.complete(),this.unsubscribe()))}}function Dd(...t){const e=t[t.length-1];return N(e)?(t.pop(),n=>kd(t,n,e)):e=>kd(t,e)}function Od(t,e){let n=!1;return arguments.length>=2&&(n=!0),function(s){return s.lift(new Ld(t,e,n))}}class Ld{constructor(t,e,n=!1){this.accumulator=t,this.seed=e,this.hasSeed=n}call(t,e){return e.subscribe(new Md(t,this.accumulator,this.seed,this.hasSeed))}}class Md extends b{constructor(t,e,n,s){super(t),this.accumulator=e,this._seed=n,this.hasSeed=s,this.index=0}get seed(){return this._seed}set seed(t){this.hasSeed=!0,this._seed=t}_next(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)}_tryNext(t){const e=this.index++;let n;try{n=this.accumulator(this.seed,t,e)}catch(s){this.destination.error(s)}this.seed=n,this.destination.next(n)}}function Pd(t,e){return function(n){return n.lift(new zd(t,e))}}class zd{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new Bd(t,this.predicate,this.thisArg))}}class Bd extends b{constructor(t,e,n){super(t),this.predicate=e,this.thisArg=n,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}e&&this.destination.next(t)}}function Vd(t){return function(e){const n=new Wd(t),s=e.lift(n);return n.caught=s}}class Wd{constructor(t){this.selector=t}call(t,e){return e.subscribe(new Ud(t,this.selector,this.caught))}}class Ud extends W{constructor(t,e,n){super(t),this.selector=e,this.caught=n}error(t){if(!this.isStopped){let n;try{n=this.selector(t,this.caught)}catch(e){return void super.error(e)}this._unsubscribeAndRecycle();const s=new V(this);this.add(s);const r=U(n,s);r!==s&&this.add(r)}}}function jd(t,e){return j(t,e,1)}function Hd(t){return function(e){return 0===t?Id():e.lift(new Gd(t))}}class Gd{constructor(t){if(this.total=t,this.total<0)throw new $d}call(t,e){return e.subscribe(new qd(t,this.total))}}class qd extends b{constructor(t,e){super(t),this.total=e,this.ring=new Array,this.count=0}_next(t){const e=this.ring,n=this.total,s=this.count++;e.length<n?e.push(t):e[s%n]=t}_complete(){const t=this.destination;let e=this.count;if(e>0){const n=this.count>=this.total?this.total:this.count,s=this.ring;for(let r=0;r<n;r++){const r=e++%n;t.next(s[r])}}t.complete()}}function Kd(t=Yd){return e=>e.lift(new Xd(t))}class Xd{constructor(t){this.errorFactory=t}call(t,e){return e.subscribe(new Zd(t,this.errorFactory))}}class Zd extends b{constructor(t,e){super(t),this.errorFactory=e,this.hasValue=!1}_next(t){this.hasValue=!0,this.destination.next(t)}_complete(){if(this.hasValue)return this.destination.complete();{let e;try{e=this.errorFactory()}catch(t){e=t}this.destination.error(e)}}}function Yd(){return new _d}function Qd(t=null){return e=>e.lift(new Jd(t))}class Jd{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new tp(t,this.defaultValue))}}class tp extends b{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function ep(t,e){const n=arguments.length>=2;return s=>s.pipe(t?Pd((e,n)=>t(e,n,s)):x,Ad(1),n?Qd(e):Kd(()=>new _d))}function np(){}function sp(t,e,n){return function(s){return s.lift(new rp(t,e,n))}}class rp{constructor(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}call(t,e){return e.subscribe(new ip(t,this.nextOrObserver,this.error,this.complete))}}class ip extends b{constructor(t,e,n,s){super(t),this._tapNext=np,this._tapError=np,this._tapComplete=np,this._tapError=n||np,this._tapComplete=s||np,a(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||np,this._tapError=e.error||np,this._tapComplete=e.complete||np)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}function op(t){return e=>e.lift(new ap(t))}class ap{constructor(t){this.callback=t}call(t,e){return e.subscribe(new lp(t,this.callback))}}class lp extends b{constructor(t,e){super(t),this.add(new m(e))}}class up{constructor(t,e){this.id=t,this.url=e}}class cp extends up{constructor(t,e,n="imperative",s=null){super(t,e),this.navigationTrigger=n,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class hp extends up{constructor(t,e,n){super(t,e),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class dp extends up{constructor(t,e,n){super(t,e),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class pp extends up{constructor(t,e,n){super(t,e),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class fp extends up{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class mp extends up{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class gp extends up{constructor(t,e,n,s,r){super(t,e),this.urlAfterRedirects=n,this.state=s,this.shouldActivate=r}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class yp extends up{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class bp extends up{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class vp{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class wp{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class xp{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class _p{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class kp{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Cp{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Ip{constructor(t,e,n){this.routerEvent=t,this.position=e,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const Sp="primary";class Ep{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Tp(t){return new Ep(t)}function Np(t){const e=Error("NavigationCancelingError: "+t);return e.ngNavigationCancelingError=!0,e}function $p(t,e,n){const s=n.path.split("/");if(s.length>t.length)return null;if("full"===n.pathMatch&&(e.hasChildren()||s.length<t.length))return null;const r={};for(let i=0;i<s.length;i++){const e=s[i],n=t[i];if(e.startsWith(":"))r[e.substring(1)]=n;else if(e!==n.path)return null}return{consumed:t.slice(0,s.length),posParams:r}}function Ap(t,e){const n=t?Object.keys(t):void 0,s=e?Object.keys(e):void 0;if(!n||!s||n.length!=s.length)return!1;let r;for(let i=0;i<n.length;i++)if(r=n[i],!Rp(t[r],e[r]))return!1;return!0}function Rp(t,e){if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;const n=[...t].sort(),s=[...e].sort();return n.every((t,e)=>s[e]===t)}return t===e}function Fp(t){return Array.prototype.concat.apply([],t)}function Dp(t){return t.length>0?t[t.length-1]:null}function Op(t,e){for(const n in t)t.hasOwnProperty(n)&&e(t[n],n)}function Lp(t){return Lo(t)?t:Oo(t)?B(Promise.resolve(t)):fd(t)}const Mp={exact:function t(e,n,s){if(!Gp(e.segments,n.segments))return!1;if(!Wp(e.segments,n.segments,s))return!1;if(e.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children){if(!e.children[r])return!1;if(!t(e.children[r],n.children[r],s))return!1}return!0},subset:Bp},Pp={exact:function(t,e){return Ap(t,e)},subset:function(t,e){return Object.keys(e).length<=Object.keys(t).length&&Object.keys(e).every(n=>Rp(t[n],e[n]))},ignored:()=>!0};function zp(t,e,n){return Mp[n.paths](t.root,e.root,n.matrixParams)&&Pp[n.queryParams](t.queryParams,e.queryParams)&&!("exact"===n.fragment&&t.fragment!==e.fragment)}function Bp(t,e,n){return Vp(t,e,e.segments,n)}function Vp(t,e,n,s){if(t.segments.length>n.length){const r=t.segments.slice(0,n.length);return!!Gp(r,n)&&!e.hasChildren()&&!!Wp(r,n,s)}if(t.segments.length===n.length){if(!Gp(t.segments,n))return!1;if(!Wp(t.segments,n,s))return!1;for(const n in e.children){if(!t.children[n])return!1;if(!Bp(t.children[n],e.children[n],s))return!1}return!0}{const r=n.slice(0,t.segments.length),i=n.slice(t.segments.length);return!!Gp(t.segments,r)&&!!Wp(t.segments,r,s)&&!!t.children.primary&&Vp(t.children.primary,e,i,s)}}function Wp(t,e,n){return e.every((e,s)=>Pp[n](t[s].parameters,e.parameters))}class Up{constructor(t,e,n){this.root=t,this.queryParams=e,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Tp(this.queryParams)),this._queryParamMap}toString(){return Xp.serialize(this)}}class jp{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Op(e,(t,e)=>t.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Zp(this)}}class Hp{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Tp(this.parameters)),this._parameterMap}toString(){return sf(this)}}function Gp(t,e){return t.length===e.length&&t.every((t,n)=>t.path===e[n].path)}class qp{}class Kp{parse(t){const e=new uf(t);return new Up(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){var e;return`/${Yp(t.root,!0)}${function(t){const e=Object.keys(t).map(e=>{const n=t[e];return Array.isArray(n)?n.map(t=>`${Jp(e)}=${Jp(t)}`).join("&"):`${Jp(e)}=${Jp(n)}`}).filter(t=>!!t);return e.length?`?${e.join("&")}`:""}(t.queryParams)}${"string"==typeof t.fragment?`#${e=t.fragment,encodeURI(e)}`:""}`}}const Xp=new Kp;function Zp(t){return t.segments.map(t=>sf(t)).join("/")}function Yp(t,e){if(!t.hasChildren())return Zp(t);if(e){const e=t.children.primary?Yp(t.children.primary,!1):"",n=[];return Op(t.children,(t,e)=>{e!==Sp&&n.push(`${e}:${Yp(t,!1)}`)}),n.length>0?`${e}(${n.join("//")})`:e}{const e=function(t,e){let n=[];return Op(t.children,(t,s)=>{s===Sp&&(n=n.concat(e(t,s)))}),Op(t.children,(t,s)=>{s!==Sp&&(n=n.concat(e(t,s)))}),n}(t,(e,n)=>n===Sp?[Yp(t.children.primary,!1)]:[`${n}:${Yp(e,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children.primary?`${Zp(t)}/${e[0]}`:`${Zp(t)}/(${e.join("//")})`}}function Qp(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Jp(t){return Qp(t).replace(/%3B/gi,";")}function tf(t){return Qp(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function ef(t){return decodeURIComponent(t)}function nf(t){return ef(t.replace(/\+/g,"%20"))}function sf(t){return`${tf(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${tf(t)}=${tf(e[t])}`).join("")}`;var e}const rf=/^[^\/()?;=#]+/;function of(t){const e=t.match(rf);return e?e[0]:""}const af=/^[^=?&#]+/,lf=/^[^?&#]+/;class uf{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new jp([],{}):new jp([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(n.primary=new jp(t,e)),n}parseSegment(){const t=of(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new Hp(ef(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=of(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=of(this.remaining);t&&(n=t,this.capture(n))}t[ef(e)]=ef(n)}parseQueryParam(t){const e=function(t){const e=t.match(af);return e?e[0]:""}(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=function(t){const e=t.match(lf);return e?e[0]:""}(this.remaining);t&&(n=t,this.capture(n))}const s=nf(e),r=nf(n);if(t.hasOwnProperty(s)){let e=t[s];Array.isArray(e)||(e=[e],t[s]=e),e.push(r)}else t[s]=r}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=of(this.remaining),s=this.remaining[n.length];if("/"!==s&&")"!==s&&";"!==s)throw new Error(`Cannot parse url '${this.url}'`);let r;n.indexOf(":")>-1?(r=n.substr(0,n.indexOf(":")),this.capture(r),this.capture(":")):t&&(r=Sp);const i=this.parseChildren();e[r]=1===Object.keys(i).length?i.primary:new jp([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class cf{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=hf(t,this._root);return e?e.children.map(t=>t.value):[]}firstChild(t){const e=hf(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=df(t,this._root);return e.length<2?[]:e[e.length-2].children.map(t=>t.value).filter(e=>e!==t)}pathFromRoot(t){return df(t,this._root).map(t=>t.value)}}function hf(t,e){if(t===e.value)return e;for(const n of e.children){const e=hf(t,n);if(e)return e}return null}function df(t,e){if(t===e.value)return[e];for(const n of e.children){const s=df(t,n);if(s.length)return s.unshift(e),s}return[]}class pf{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function ff(t){const e={};return t&&t.children.forEach(t=>e[t.value.outlet]=t),e}class mf extends cf{constructor(t,e){super(t),this.snapshot=e,xf(this,t)}toString(){return this.snapshot.toString()}}function gf(t,e){const n=function(t,e){const n=new vf([],{},{},"",{},Sp,e,null,t.root,-1,{});return new wf("",new pf(n,[]))}(t,e),s=new md([new Hp("",{})]),r=new md({}),i=new md({}),o=new md({}),a=new md(""),l=new yf(s,r,o,a,i,Sp,e,n.root);return l.snapshot=n.root,new mf(new pf(l,[]),n)}class yf{constructor(t,e,n,s,r,i,o,a){this.url=t,this.params=e,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=i,this.component=o,this._futureSnapshot=a}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe($(t=>Tp(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe($(t=>Tp(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function bf(t,e="emptyOnly"){const n=t.pathFromRoot;let s=0;if("always"!==e)for(s=n.length-1;s>=1;){const t=n[s],e=n[s-1];if(t.routeConfig&&""===t.routeConfig.path)s--;else{if(e.component)break;s--}}return function(t){return t.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(s))}class vf{constructor(t,e,n,s,r,i,o,a,l,u,c){this.url=t,this.params=e,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=i,this.component=o,this.routeConfig=a,this._urlSegment=l,this._lastPathIndex=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Tp(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Tp(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class wf extends cf{constructor(t,e){super(e),this.url=t,xf(this,e)}toString(){return _f(this._root)}}function xf(t,e){e.value._routerState=t,e.children.forEach(e=>xf(t,e))}function _f(t){const e=t.children.length>0?` { ${t.children.map(_f).join(", ")} } `:"";return`${t.value}${e}`}function kf(t){if(t.snapshot){const e=t.snapshot,n=t._futureSnapshot;t.snapshot=n,Ap(e.queryParams,n.queryParams)||t.queryParams.next(n.queryParams),e.fragment!==n.fragment&&t.fragment.next(n.fragment),Ap(e.params,n.params)||t.params.next(n.params),function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;++n)if(!Ap(t[n],e[n]))return!1;return!0}(e.url,n.url)||t.url.next(n.url),Ap(e.data,n.data)||t.data.next(n.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function Cf(t,e){var n,s;return Ap(t.params,e.params)&&Gp(n=t.url,s=e.url)&&n.every((t,e)=>Ap(t.parameters,s[e].parameters))&&!(!t.parent!=!e.parent)&&(!t.parent||Cf(t.parent,e.parent))}function If(t,e,n){if(n&&t.shouldReuseRoute(e.value,n.value.snapshot)){const s=n.value;s._futureSnapshot=e.value;const r=function(t,e,n){return e.children.map(e=>{for(const s of n.children)if(t.shouldReuseRoute(e.value,s.value.snapshot))return If(t,e,s);return If(t,e)})}(t,e,n);return new pf(s,r)}{if(t.shouldAttach(e.value)){const n=t.retrieve(e.value);if(null!==n){const t=n.route;return Sf(e,t),t}}const n=new yf(new md((s=e.value).url),new md(s.params),new md(s.queryParams),new md(s.fragment),new md(s.data),s.outlet,s.component,s),r=e.children.map(e=>If(t,e));return new pf(n,r)}var s}function Sf(t,e){if(t.value.routeConfig!==e.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(t.children.length!==e.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");e.value._futureSnapshot=t.value;for(let n=0;n<t.children.length;++n)Sf(t.children[n],e.children[n])}function Ef(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function Tf(t){return"object"==typeof t&&null!=t&&t.outlets}function Nf(t,e,n,s,r){let i={};return s&&Op(s,(t,e)=>{i[e]=Array.isArray(t)?t.map(t=>`${t}`):`${t}`}),new Up(n.root===t?e:$f(n.root,t,e),i,r)}function $f(t,e,n){const s={};return Op(t.children,(t,r)=>{s[r]=t===e?n:$f(t,e,n)}),new jp(t.segments,s)}class Af{constructor(t,e,n){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=n,t&&n.length>0&&Ef(n[0]))throw new Error("Root segment cannot have matrix parameters");const s=n.find(Tf);if(s&&s!==Dp(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Rf{constructor(t,e,n){this.segmentGroup=t,this.processChildren=e,this.index=n}}function Ff(t,e,n){if(t||(t=new jp([],{})),0===t.segments.length&&t.hasChildren())return Df(t,e,n);const s=function(t,e,n){let s=0,r=e;const i={match:!1,pathIndex:0,commandIndex:0};for(;r<t.segments.length;){if(s>=n.length)return i;const e=t.segments[r],o=n[s];if(Tf(o))break;const a=`${o}`,l=s<n.length-1?n[s+1]:null;if(r>0&&void 0===a)break;if(a&&l&&"object"==typeof l&&void 0===l.outlets){if(!Pf(a,l,e))return i;s+=2}else{if(!Pf(a,{},e))return i;s++}r++}return{match:!0,pathIndex:r,commandIndex:s}}(t,e,n),r=n.slice(s.commandIndex);if(s.match&&s.pathIndex<t.segments.length){const e=new jp(t.segments.slice(0,s.pathIndex),{});return e.children.primary=new jp(t.segments.slice(s.pathIndex),t.children),Df(e,0,r)}return s.match&&0===r.length?new jp(t.segments,{}):s.match&&!t.hasChildren()?Of(t,e,n):s.match?Df(t,0,r):Of(t,e,n)}function Df(t,e,n){if(0===n.length)return new jp(t.segments,{});{const s=function(t){return Tf(t[0])?t[0].outlets:{[Sp]:t}}(n),r={};return Op(s,(n,s)=>{"string"==typeof n&&(n=[n]),null!==n&&(r[s]=Ff(t.children[s],e,n))}),Op(t.children,(t,e)=>{void 0===s[e]&&(r[e]=t)}),new jp(t.segments,r)}}function Of(t,e,n){const s=t.segments.slice(0,e);let r=0;for(;r<n.length;){const i=n[r];if(Tf(i)){const t=Lf(i.outlets);return new jp(s,t)}if(0===r&&Ef(n[0])){s.push(new Hp(t.segments[e].path,Mf(n[0]))),r++;continue}const o=Tf(i)?i.outlets.primary:`${i}`,a=r<n.length-1?n[r+1]:null;o&&a&&Ef(a)?(s.push(new Hp(o,Mf(a))),r+=2):(s.push(new Hp(o,{})),r++)}return new jp(s,{})}function Lf(t){const e={};return Op(t,(t,n)=>{"string"==typeof t&&(t=[t]),null!==t&&(e[n]=Of(new jp([],{}),0,t))}),e}function Mf(t){const e={};return Op(t,(t,n)=>e[n]=`${t}`),e}function Pf(t,e,n){return t==n.path&&Ap(e,n.parameters)}class zf{constructor(t,e,n,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=n,this.forwardEvent=s}activate(t){const e=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,n,t),kf(this.futureState.root),this.activateChildRoutes(e,n,t)}deactivateChildRoutes(t,e,n){const s=ff(e);t.children.forEach(t=>{const e=t.value.outlet;this.deactivateRoutes(t,s[e],n),delete s[e]}),Op(s,(t,e)=>{this.deactivateRouteAndItsChildren(t,n)})}deactivateRoutes(t,e,n){const s=t.value,r=e?e.value:null;if(s===r)if(s.component){const r=n.getContext(s.outlet);r&&this.deactivateChildRoutes(t,e,r.children)}else this.deactivateChildRoutes(t,e,n);else r&&this.deactivateRouteAndItsChildren(e,n)}deactivateRouteAndItsChildren(t,e){this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const n=e.getContext(t.value.outlet);if(n&&n.outlet){const e=n.outlet.detach(),s=n.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:e,route:t,contexts:s})}}deactivateRouteAndOutlet(t,e){const n=e.getContext(t.value.outlet),s=n&&t.value.component?n.children:e,r=ff(t);for(const i of Object.keys(r))this.deactivateRouteAndItsChildren(r[i],s);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(t,e,n){const s=ff(e);t.children.forEach(t=>{this.activateRoutes(t,s[t.value.outlet],n),this.forwardEvent(new Cp(t.value.snapshot))}),t.children.length&&this.forwardEvent(new _p(t.value.snapshot))}activateRoutes(t,e,n){const s=t.value,r=e?e.value:null;if(kf(s),s===r)if(s.component){const r=n.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,r.children)}else this.activateChildRoutes(t,e,n);else if(s.component){const e=n.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const t=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),e.children.onOutletReAttached(t.contexts),e.attachRef=t.componentRef,e.route=t.route.value,e.outlet&&e.outlet.attach(t.componentRef,t.route.value),Bf(t.route)}else{const n=function(t){for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig;if(t&&t.component)return null}return null}(s.snapshot),r=n?n.module.componentFactoryResolver:null;e.attachRef=null,e.route=s,e.resolver=r,e.outlet&&e.outlet.activateWith(s,r),this.activateChildRoutes(t,null,e.children)}}else this.activateChildRoutes(t,null,n)}}function Bf(t){kf(t.value),t.children.forEach(Bf)}class Vf{constructor(t,e){this.routes=t,this.module=e}}function Wf(t){return"function"==typeof t}function Uf(t){return t instanceof Up}const jf=Symbol("INITIAL_VALUE");function Hf(){return Ed(t=>function(...t){let e,n;return N(t[t.length-1])&&(n=t.pop()),"function"==typeof t[t.length-1]&&(e=t.pop()),1===t.length&&d(t[0])&&(t=t[0]),K(t,n).lift(new wd(e))}(t.map(t=>t.pipe(Ad(1),Dd(jf)))).pipe(Od((t,e)=>{let n=!1;return e.reduce((t,s,r)=>{if(t!==jf)return t;if(s===jf&&(n=!0),!n){if(!1===s)return s;if(r===e.length-1||Uf(s))return s}return t},t)},jf),Pd(t=>t!==jf),$(t=>Uf(t)?t:!0===t),Ad(1)))}let Gf=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=qt({type:t,selectors:[["ng-component"]],decls:1,vars:0,template:function(t,e){1&t&&Fo(0,"router-outlet")},directives:function(){return[Bm]},encapsulation:2}),t})();function qf(t,e=""){for(let n=0;n<t.length;n++){const s=t[n];Kf(s,Xf(e,s))}}function Kf(t,e){t.children&&qf(t.children,e)}function Xf(t,e){return e?t||e.path?t&&!e.path?`${t}/`:!t&&e.path?e.path:`${t}/${e.path}`:"":t}function Zf(t){const e=t.children&&t.children.map(Zf),n=e?Object.assign(Object.assign({},t),{children:e}):Object.assign({},t);return!n.component&&(e||n.loadChildren)&&n.outlet&&n.outlet!==Sp&&(n.component=Gf),n}function Yf(t){return t.outlet||Sp}function Qf(t,e){const n=t.filter(t=>Yf(t)===e);return n.push(...t.filter(t=>Yf(t)!==e)),n}const Jf={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function tm(t,e,n){var s;if(""===e.path)return"full"===e.pathMatch&&(t.hasChildren()||n.length>0)?Object.assign({},Jf):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const r=(e.matcher||$p)(n,t,e);if(!r)return Object.assign({},Jf);const i={};Op(r.posParams,(t,e)=>{i[e]=t.path});const o=r.consumed.length>0?Object.assign(Object.assign({},i),r.consumed[r.consumed.length-1].parameters):i;return{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:o,positionalParamSegments:null!==(s=r.posParams)&&void 0!==s?s:{}}}function em(t,e,n,s,r="corrected"){if(n.length>0&&function(t,e,n){return n.some(n=>nm(t,e,n)&&Yf(n)!==Sp)}(t,n,s)){const r=new jp(e,function(t,e,n,s){const r={};r.primary=s,s._sourceSegment=t,s._segmentIndexShift=e.length;for(const i of n)if(""===i.path&&Yf(i)!==Sp){const n=new jp([],{});n._sourceSegment=t,n._segmentIndexShift=e.length,r[Yf(i)]=n}return r}(t,e,s,new jp(n,t.children)));return r._sourceSegment=t,r._segmentIndexShift=e.length,{segmentGroup:r,slicedSegments:[]}}if(0===n.length&&function(t,e,n){return n.some(n=>nm(t,e,n))}(t,n,s)){const i=new jp(t.segments,function(t,e,n,s,r,i){const o={};for(const a of s)if(nm(t,n,a)&&!r[Yf(a)]){const n=new jp([],{});n._sourceSegment=t,n._segmentIndexShift="legacy"===i?t.segments.length:e.length,o[Yf(a)]=n}return Object.assign(Object.assign({},r),o)}(t,e,n,s,t.children,r));return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}const i=new jp(t.segments,t.children);return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}function nm(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path}function sm(t,e,n,s){return!!(Yf(t)===s||s!==Sp&&nm(e,n,t))&&("**"===t.path||tm(e,t,n).matched)}function rm(t,e,n){return 0===e.length&&!t.children[n]}class im{constructor(t){this.segmentGroup=t||null}}class om{constructor(t){this.urlTree=t}}function am(t){return new _(e=>e.error(new im(t)))}function lm(t){return new _(e=>e.error(new om(t)))}function um(t){return new _(e=>e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`)))}class cm{constructor(t,e,n,s,r){this.configLoader=e,this.urlSerializer=n,this.urlTree=s,this.config=r,this.allowRedirects=!0,this.ngModule=t.get(ul)}apply(){const t=em(this.urlTree.root,[],[],this.config).segmentGroup,e=new jp(t.segments,t.children);return this.expandSegmentGroup(this.ngModule,this.config,e,Sp).pipe($(t=>this.createUrlTree(hm(t),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Vd(t=>{if(t instanceof om)return this.allowRedirects=!1,this.match(t.urlTree);if(t instanceof im)throw this.noMatchError(t);throw t}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,Sp).pipe($(e=>this.createUrlTree(hm(e),t.queryParams,t.fragment))).pipe(Vd(t=>{if(t instanceof im)throw this.noMatchError(t);throw t}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,n){const s=t.segments.length>0?new jp([],{[Sp]:t}):t;return new Up(s,e,n)}expandSegmentGroup(t,e,n,s){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(t,e,n).pipe($(t=>new jp([],t))):this.expandSegment(t,n,e,n.segments,s,!0)}expandChildren(t,e,n){const s=[];for(const r of Object.keys(n.children))"primary"===r?s.unshift(r):s.push(r);return B(s).pipe(jd(s=>{const r=n.children[s],i=Qf(e,s);return this.expandSegmentGroup(t,i,r,s).pipe($(t=>({segment:t,outlet:s})))}),Od((t,e)=>(t[e.outlet]=e.segment,t),{}),function(t,e){const n=arguments.length>=2;return s=>s.pipe(t?Pd((e,n)=>t(e,n,s)):x,Hd(1),n?Qd(e):Kd(()=>new _d))}())}expandSegment(t,e,n,s,r,i){return B(n).pipe(jd(o=>this.expandSegmentAgainstRoute(t,e,n,o,s,r,i).pipe(Vd(t=>{if(t instanceof im)return fd(null);throw t}))),ep(t=>!!t),Vd((t,n)=>{if(t instanceof _d||"EmptyError"===t.name){if(rm(e,s,r))return fd(new jp([],{}));throw new im(e)}throw t}))}expandSegmentAgainstRoute(t,e,n,s,r,i,o){return sm(s,e,r,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,r,i):o&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i):am(e):am(e)}expandSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,n,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,n,s){const r=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?lm(r):this.lineralizeSegments(n,r).pipe(j(n=>{const r=new jp(n,{});return this.expandSegment(t,r,e,n,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i){const{matched:o,consumedSegments:a,lastChild:l,positionalParamSegments:u}=tm(e,s,r);if(!o)return am(e);const c=this.applyRedirectCommands(a,s.redirectTo,u);return s.redirectTo.startsWith("/")?lm(c):this.lineralizeSegments(s,c).pipe(j(s=>this.expandSegment(t,e,n,s.concat(r.slice(l)),i,!1)))}matchSegmentAgainstRoute(t,e,n,s,r){if("**"===n.path)return n.loadChildren?(n._loadedConfig?fd(n._loadedConfig):this.configLoader.load(t.injector,n)).pipe($(t=>(n._loadedConfig=t,new jp(s,{})))):fd(new jp(s,{}));const{matched:i,consumedSegments:o,lastChild:a}=tm(e,n,s);if(!i)return am(e);const l=s.slice(a);return this.getChildConfig(t,n,s).pipe(j(t=>{const s=t.module,i=t.routes,{segmentGroup:a,slicedSegments:u}=em(e,o,l,i),c=new jp(a.segments,a.children);if(0===u.length&&c.hasChildren())return this.expandChildren(s,i,c).pipe($(t=>new jp(o,t)));if(0===i.length&&0===u.length)return fd(new jp(o,{}));const h=Yf(n)===r;return this.expandSegment(s,c,i,u,h?Sp:r,!0).pipe($(t=>new jp(o.concat(t.segments),t.children)))}))}getChildConfig(t,e,n){return e.children?fd(new Vf(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?fd(e._loadedConfig):this.runCanLoadGuards(t.injector,e,n).pipe(j(n=>n?this.configLoader.load(t.injector,e).pipe($(t=>(e._loadedConfig=t,t))):function(t){return new _(e=>e.error(Np(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)))}(e))):fd(new Vf([],t))}runCanLoadGuards(t,e,n){const s=e.canLoad;return s&&0!==s.length?fd(s.map(s=>{const r=t.get(s);let i;if(function(t){return t&&Wf(t.canLoad)}(r))i=r.canLoad(e,n);else{if(!Wf(r))throw new Error("Invalid CanLoad guard");i=r(e,n)}return Lp(i)})).pipe(Hf(),sp(t=>{if(!Uf(t))return;const e=Np(`Redirecting to "${this.urlSerializer.serialize(t)}"`);throw e.url=t,e}),$(t=>!0===t)):fd(!0)}lineralizeSegments(t,e){let n=[],s=e.root;for(;;){if(n=n.concat(s.segments),0===s.numberOfChildren)return fd(n);if(s.numberOfChildren>1||!s.children.primary)return um(t.redirectTo);s=s.children.primary}}applyRedirectCommands(t,e,n){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,n)}applyRedirectCreatreUrlTree(t,e,n,s){const r=this.createSegmentGroup(t,e.root,n,s);return new Up(r,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const n={};return Op(t,(t,s)=>{if("string"==typeof t&&t.startsWith(":")){const r=t.substring(1);n[s]=e[r]}else n[s]=t}),n}createSegmentGroup(t,e,n,s){const r=this.createSegments(t,e.segments,n,s);let i={};return Op(e.children,(e,r)=>{i[r]=this.createSegmentGroup(t,e,n,s)}),new jp(r,i)}createSegments(t,e,n,s){return e.map(e=>e.path.startsWith(":")?this.findPosParam(t,e,s):this.findOrReturn(e,n))}findPosParam(t,e,n){const s=n[e.path.substring(1)];if(!s)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return s}findOrReturn(t,e){let n=0;for(const s of e){if(s.path===t.path)return e.splice(n),s;n++}return t}}function hm(t){const e={};for(const n of Object.keys(t.children)){const s=hm(t.children[n]);(s.segments.length>0||s.hasChildren())&&(e[n]=s)}return function(t){if(1===t.numberOfChildren&&t.children.primary){const e=t.children.primary;return new jp(t.segments.concat(e.segments),e.children)}return t}(new jp(t.segments,e))}class dm{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class pm{constructor(t,e){this.component=t,this.route=e}}function fm(t,e,n){const s=t._root;return gm(s,e?e._root:null,n,[s.value])}function mm(t,e,n){const s=function(t){if(!t)return null;for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig}return null}(e);return(s?s.module.injector:n).get(t)}function gm(t,e,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=ff(e);return t.children.forEach(t=>{!function(t,e,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=t.value,o=e?e.value:null,a=n?n.getContext(t.value.outlet):null;if(o&&i.routeConfig===o.routeConfig){const l=function(t,e,n){if("function"==typeof n)return n(t,e);switch(n){case"pathParamsChange":return!Gp(t.url,e.url);case"pathParamsOrQueryParamsChange":return!Gp(t.url,e.url)||!Ap(t.queryParams,e.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Cf(t,e)||!Ap(t.queryParams,e.queryParams);case"paramsChange":default:return!Cf(t,e)}}(o,i,i.routeConfig.runGuardsAndResolvers);l?r.canActivateChecks.push(new dm(s)):(i.data=o.data,i._resolvedData=o._resolvedData),gm(t,e,i.component?a?a.children:null:n,s,r),l&&a&&a.outlet&&a.outlet.isActivated&&r.canDeactivateChecks.push(new pm(a.outlet.component,o))}else o&&ym(e,a,r),r.canActivateChecks.push(new dm(s)),gm(t,null,i.component?a?a.children:null:n,s,r)}(t,i[t.value.outlet],n,s.concat([t.value]),r),delete i[t.value.outlet]}),Op(i,(t,e)=>ym(t,n.getContext(e),r)),r}function ym(t,e,n){const s=ff(t),r=t.value;Op(s,(t,s)=>{ym(t,r.component?e?e.children.getContext(s):null:e,n)}),n.canDeactivateChecks.push(new pm(r.component&&e&&e.outlet&&e.outlet.isActivated?e.outlet.component:null,r))}class bm{}function vm(t){return new _(e=>e.error(t))}class wm{constructor(t,e,n,s,r,i){this.rootComponentType=t,this.config=e,this.urlTree=n,this.url=s,this.paramsInheritanceStrategy=r,this.relativeLinkResolution=i}recognize(){const t=em(this.urlTree.root,[],[],this.config.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,Sp);if(null===e)return null;const n=new vf([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},Sp,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new pf(n,e),r=new wf(this.url,s);return this.inheritParamsAndData(r._root),r}inheritParamsAndData(t){const e=t.value,n=bf(e,this.paramsInheritanceStrategy);e.params=Object.freeze(n.params),e.data=Object.freeze(n.data),t.children.forEach(t=>this.inheritParamsAndData(t))}processSegmentGroup(t,e,n){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,n)}processChildren(t,e){const n=[];for(const r of Object.keys(e.children)){const s=e.children[r],i=Qf(t,r),o=this.processSegmentGroup(i,s,r);if(null===o)return null;n.push(...o)}const s=_m(n);return s.sort((t,e)=>t.value.outlet===Sp?-1:e.value.outlet===Sp?1:t.value.outlet.localeCompare(e.value.outlet)),s}processSegment(t,e,n,s){for(const r of t){const t=this.processSegmentAgainstRoute(r,e,n,s);if(null!==t)return t}return rm(e,n,s)?[]:null}processSegmentAgainstRoute(t,e,n,s){if(t.redirectTo||!sm(t,e,n,s))return null;let r,i=[],o=[];if("**"===t.path){const s=n.length>0?Dp(n).parameters:{};r=new vf(n,s,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Im(t),Yf(t),t.component,t,km(e),Cm(e)+n.length,Sm(t))}else{const s=tm(e,t,n);if(!s.matched)return null;i=s.consumedSegments,o=n.slice(s.lastChild),r=new vf(i,s.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Im(t),Yf(t),t.component,t,km(e),Cm(e)+i.length,Sm(t))}const a=function(t){return t.children?t.children:t.loadChildren?t._loadedConfig.routes:[]}(t),{segmentGroup:l,slicedSegments:u}=em(e,i,o,a.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution);if(0===u.length&&l.hasChildren()){const t=this.processChildren(a,l);return null===t?null:[new pf(r,t)]}if(0===a.length&&0===u.length)return[new pf(r,[])];const c=Yf(t)===s,h=this.processSegment(a,l,u,c?Sp:s);return null===h?null:[new pf(r,h)]}}function xm(t){const e=t.value.routeConfig;return e&&""===e.path&&void 0===e.redirectTo}function _m(t){const e=[],n=new Set;for(const s of t){if(!xm(s)){e.push(s);continue}const t=e.find(t=>s.value.routeConfig===t.value.routeConfig);void 0!==t?(t.children.push(...s.children),n.add(t)):e.push(s)}for(const s of n){const t=_m(s.children);e.push(new pf(s.value,t))}return e.filter(t=>!n.has(t))}function km(t){let e=t;for(;e._sourceSegment;)e=e._sourceSegment;return e}function Cm(t){let e=t,n=e._segmentIndexShift?e._segmentIndexShift:0;for(;e._sourceSegment;)e=e._sourceSegment,n+=e._segmentIndexShift?e._segmentIndexShift:0;return n-1}function Im(t){return t.data||{}}function Sm(t){return t.resolve||{}}function Em(t){return Ed(e=>{const n=t(e);return n?B(n).pipe($(()=>e)):fd(e)})}class Tm extends class{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}{}const Nm=new Zn("ROUTES");class $m{constructor(t,e,n,s){this.loader=t,this.compiler=e,this.onLoadStartListener=n,this.onLoadEndListener=s}load(t,e){if(e._loader$)return e._loader$;this.onLoadStartListener&&this.onLoadStartListener(e);const n=this.loadModuleFactory(e.loadChildren).pipe($(n=>{this.onLoadEndListener&&this.onLoadEndListener(e);const s=n.create(t);return new Vf(Fp(s.injector.get(Nm,void 0,It.Self|It.Optional)).map(Zf),s)}),Vd(t=>{throw e._loader$=void 0,t}));return e._loader$=new J(n,()=>new E).pipe(Z()),e._loader$}loadModuleFactory(t){return"string"==typeof t?B(this.loader.load(t)):Lp(t()).pipe(j(t=>t instanceof cl?fd(t):B(this.compiler.compileModuleAsync(t))))}}class Am{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new Rm,this.attachRef=null}}class Rm{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const n=this.getOrCreateContext(t);n.outlet=e,this.contexts.set(t,n)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new Am,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}class Fm{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function Dm(t){throw t}function Om(t,e,n){return e.parse("/")}function Lm(t,e){return fd(null)}const Mm={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Pm={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let zm=(()=>{class t{constructor(t,e,n,s,r,i,o,a){this.rootComponentType=t,this.urlSerializer=e,this.rootContexts=n,this.location=s,this.config=a,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new E,this.errorHandler=Dm,this.malformedUriErrorHandler=Om,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:Lm,afterPreactivation:Lm},this.urlHandlingStrategy=new Fm,this.routeReuseStrategy=new Tm,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.ngModule=r.get(ul),this.console=r.get(nu);const l=r.get(mu);this.isNgZoneEnabled=l instanceof mu&&mu.isInAngularZone(),this.resetConfig(a),this.currentUrlTree=new Up(new jp([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new $m(i,o,t=>this.triggerEvent(new vp(t)),t=>this.triggerEvent(new wp(t))),this.routerState=gf(this.currentUrlTree,this.rootComponentType),this.transitions=new md({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(t){const e=this.events;return t.pipe(Pd(t=>0!==t.id),$(t=>Object.assign(Object.assign({},t),{extractedUrl:this.urlHandlingStrategy.extract(t.rawUrl)})),Ed(t=>{let n=!1,s=!1;return fd(t).pipe(sp(t=>{this.currentNavigation={id:t.id,initialUrl:t.currentRawUrl,extractedUrl:t.extractedUrl,trigger:t.source,extras:t.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Ed(t=>{const n=!this.navigated||t.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl))return fd(t).pipe(Ed(t=>{const n=this.transitions.getValue();return e.next(new cp(t.id,this.serializeUrl(t.extractedUrl),t.source,t.restoredState)),n!==this.transitions.getValue()?Cd:Promise.resolve(t)}),function(t,e,n,s){return Ed(r=>function(t,e,n,s,r){return new cm(t,e,n,s,r).apply()}(t,e,n,r.extractedUrl,s).pipe($(t=>Object.assign(Object.assign({},r),{urlAfterRedirects:t}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),sp(t=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:t.urlAfterRedirects})}),function(t,e,n,s,r){return j(i=>function(t,e,n,s,r="emptyOnly",i="legacy"){try{const o=new wm(t,e,n,s,r,i).recognize();return null===o?vm(new bm):fd(o)}catch(o){return vm(o)}}(t,e,i.urlAfterRedirects,n(i.urlAfterRedirects),s,r).pipe($(t=>Object.assign(Object.assign({},i),{targetSnapshot:t}))))}(this.rootComponentType,this.config,t=>this.serializeUrl(t),this.paramsInheritanceStrategy,this.relativeLinkResolution),sp(t=>{"eager"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(t.urlAfterRedirects,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects);const n=new fp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);e.next(n)}));if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:s,source:r,restoredState:i,extras:o}=t,a=new cp(n,this.serializeUrl(s),r,i);e.next(a);const l=gf(s,this.rootComponentType).snapshot;return fd(Object.assign(Object.assign({},t),{targetSnapshot:l,urlAfterRedirects:s,extras:Object.assign(Object.assign({},o),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=t.rawUrl,this.browserUrlTree=t.urlAfterRedirects,t.resolve(null),Cd}),Em(t=>{const{targetSnapshot:e,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:i,replaceUrl:o}}=t;return this.hooks.beforePreactivation(e,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!i,replaceUrl:!!o})}),sp(t=>{const e=new mp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),$(t=>Object.assign(Object.assign({},t),{guards:fm(t.targetSnapshot,t.currentSnapshot,this.rootContexts)})),function(t,e){return j(n=>{const{targetSnapshot:s,currentSnapshot:r,guards:{canActivateChecks:i,canDeactivateChecks:o}}=n;return 0===o.length&&0===i.length?fd(Object.assign(Object.assign({},n),{guardsResult:!0})):function(t,e,n,s){return B(t).pipe(j(t=>function(t,e,n,s,r){const i=e&&e.routeConfig?e.routeConfig.canDeactivate:null;return i&&0!==i.length?fd(i.map(i=>{const o=mm(i,e,r);let a;if(function(t){return t&&Wf(t.canDeactivate)}(o))a=Lp(o.canDeactivate(t,e,n,s));else{if(!Wf(o))throw new Error("Invalid CanDeactivate guard");a=Lp(o(t,e,n,s))}return a.pipe(ep())})).pipe(Hf()):fd(!0)}(t.component,t.route,n,e,s)),ep(t=>!0!==t,!0))}(o,s,r,t).pipe(j(n=>n&&"boolean"==typeof n?function(t,e,n,s){return B(e).pipe(jd(e=>kd(function(t,e){return null!==t&&e&&e(new xp(t)),fd(!0)}(e.route.parent,s),function(t,e){return null!==t&&e&&e(new kp(t)),fd(!0)}(e.route,s),function(t,e,n){const s=e[e.length-1],r=e.slice(0,e.length-1).reverse().map(t=>function(t){const e=t.routeConfig?t.routeConfig.canActivateChild:null;return e&&0!==e.length?{node:t,guards:e}:null}(t)).filter(t=>null!==t).map(e=>Sd(()=>fd(e.guards.map(r=>{const i=mm(r,e.node,n);let o;if(function(t){return t&&Wf(t.canActivateChild)}(i))o=Lp(i.canActivateChild(s,t));else{if(!Wf(i))throw new Error("Invalid CanActivateChild guard");o=Lp(i(s,t))}return o.pipe(ep())})).pipe(Hf())));return fd(r).pipe(Hf())}(t,e.path,n),function(t,e,n){const s=e.routeConfig?e.routeConfig.canActivate:null;return s&&0!==s.length?fd(s.map(s=>Sd(()=>{const r=mm(s,e,n);let i;if(function(t){return t&&Wf(t.canActivate)}(r))i=Lp(r.canActivate(e,t));else{if(!Wf(r))throw new Error("Invalid CanActivate guard");i=Lp(r(e,t))}return i.pipe(ep())}))).pipe(Hf()):fd(!0)}(t,e.route,n))),ep(t=>!0!==t,!0))}(s,i,t,e):fd(n)),$(t=>Object.assign(Object.assign({},n),{guardsResult:t})))})}(this.ngModule.injector,t=>this.triggerEvent(t)),sp(t=>{if(Uf(t.guardsResult)){const e=Np(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`);throw e.url=t.guardsResult,e}const e=new gp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot,!!t.guardsResult);this.triggerEvent(e)}),Pd(t=>{if(!t.guardsResult){this.resetUrlToCurrentUrlTree();const n=new dp(t.id,this.serializeUrl(t.extractedUrl),"");return e.next(n),t.resolve(!1),!1}return!0}),Em(t=>{if(t.guards.canActivateChecks.length)return fd(t).pipe(sp(t=>{const e=new yp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),Ed(t=>{let n=!1;return fd(t).pipe((s=this.paramsInheritanceStrategy,r=this.ngModule.injector,j(t=>{const{targetSnapshot:e,guards:{canActivateChecks:n}}=t;if(!n.length)return fd(t);let i=0;return B(n).pipe(jd(t=>function(t,e,n,s){return function(t,e,n,s){const r=Object.keys(t);if(0===r.length)return fd({});const i={};return B(r).pipe(j(r=>function(t,e,n,s){const r=mm(t,e,s);return Lp(r.resolve?r.resolve(e,n):r(e,n))}(t[r],e,n,s).pipe(sp(t=>{i[r]=t}))),Hd(1),j(()=>Object.keys(i).length===r.length?fd(i):Cd))}(t._resolve,t,e,s).pipe($(e=>(t._resolvedData=e,t.data=Object.assign(Object.assign({},t.data),bf(t,n).resolve),null)))}(t.route,e,s,r)),sp(()=>i++),Hd(1),j(e=>i===n.length?fd(t):Cd))})),sp({next:()=>n=!0,complete:()=>{if(!n){const n=new dp(t.id,this.serializeUrl(t.extractedUrl),"At least one route resolver didn't emit any value.");e.next(n),t.resolve(!1)}}}));var s,r}),sp(t=>{const e=new bp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}))}),Em(t=>{const{targetSnapshot:e,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:i,replaceUrl:o}}=t;return this.hooks.afterPreactivation(e,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!i,replaceUrl:!!o})}),$(t=>{const e=function(t,e,n){const s=If(t,e._root,n?n._root:void 0);return new mf(s,e)}(this.routeReuseStrategy,t.targetSnapshot,t.currentRouterState);return Object.assign(Object.assign({},t),{targetRouterState:e})}),sp(t=>{this.currentUrlTree=t.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.rawUrl),this.routerState=t.targetRouterState,"deferred"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),(r=this.rootContexts,i=this.routeReuseStrategy,o=t=>this.triggerEvent(t),$(t=>(new zf(i,t.targetRouterState,t.currentRouterState,o).activate(r),t))),sp({next(){n=!0},complete(){n=!0}}),op(()=>{if(!n&&!s){this.resetUrlToCurrentUrlTree();const n=new dp(t.id,this.serializeUrl(t.extractedUrl),`Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);e.next(n),t.resolve(!1)}this.currentNavigation=null}),Vd(n=>{if(s=!0,(r=n)&&r.ngNavigationCancelingError){const s=Uf(n.url);s||(this.navigated=!0,this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl));const r=new dp(t.id,this.serializeUrl(t.extractedUrl),n.message);e.next(r),s?setTimeout(()=>{const e=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(e,"imperative",null,{skipLocationChange:t.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:t.resolve,reject:t.reject,promise:t.promise})},0):t.resolve(!1)}else{this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl);const s=new pp(t.id,this.serializeUrl(t.extractedUrl),n);e.next(s);try{t.resolve(this.errorHandler(n))}catch(i){t.reject(i)}}var r;return Cd}));var r,i,o}))}resetRootComponentType(t){this.rootComponentType=t,this.routerState.root.component=this.rootComponentType}getTransition(){const t=this.transitions.value;return t.urlAfterRedirects=this.browserUrlTree,t}setTransition(t){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),t))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(t=>{const e=this.extractLocationChangeInfoFromEvent(t);this.shouldScheduleNavigation(this.lastLocationChangeInfo,e)&&setTimeout(()=>{const{source:t,state:n,urlTree:s}=e,r={replaceUrl:!0};if(n){const t=Object.assign({},n);delete t.navigationId,0!==Object.keys(t).length&&(r.state=t)}this.scheduleNavigation(s,t,n,r)},0),this.lastLocationChangeInfo=e}))}extractLocationChangeInfoFromEvent(t){var e;return{source:"popstate"===t.type?"popstate":"hashchange",urlTree:this.parseUrl(t.url),state:(null===(e=t.state)||void 0===e?void 0:e.navigationId)?t.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(t,e){if(!t)return!0;const n=e.urlTree.toString()===t.urlTree.toString();return!(e.transitionId===t.transitionId&&n&&("hashchange"===e.source&&"popstate"===t.source||"popstate"===e.source&&"hashchange"===t.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(t){this.events.next(t)}resetConfig(t){qf(t),this.config=t.map(Zf),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(t,e={}){const{relativeTo:n,queryParams:s,fragment:r,queryParamsHandling:i,preserveFragment:o}=e,a=n||this.routerState.root,l=o?this.currentUrlTree.fragment:r;let u=null;switch(i){case"merge":u=Object.assign(Object.assign({},this.currentUrlTree.queryParams),s);break;case"preserve":u=this.currentUrlTree.queryParams;break;default:u=s||null}return null!==u&&(u=this.removeEmptyProps(u)),function(t,e,n,s,r){if(0===n.length)return Nf(e.root,e.root,e,s,r);const i=function(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new Af(!0,0,t);let e=0,n=!1;const s=t.reduce((t,s,r)=>{if("object"==typeof s&&null!=s){if(s.outlets){const e={};return Op(s.outlets,(t,n)=>{e[n]="string"==typeof t?t.split("/"):t}),[...t,{outlets:e}]}if(s.segmentPath)return[...t,s.segmentPath]}return"string"!=typeof s?[...t,s]:0===r?(s.split("/").forEach((s,r)=>{0==r&&"."===s||(0==r&&""===s?n=!0:".."===s?e++:""!=s&&t.push(s))}),t):[...t,s]},[]);return new Af(n,e,s)}(n);if(i.toRoot())return Nf(e.root,new jp([],{}),e,s,r);const o=function(t,e,n){if(t.isAbsolute)return new Rf(e.root,!0,0);if(-1===n.snapshot._lastPathIndex){const t=n.snapshot._urlSegment;return new Rf(t,t===e.root,0)}const s=Ef(t.commands[0])?0:1;return function(t,e,n){let s=t,r=e,i=n;for(;i>r;){if(i-=r,s=s.parent,!s)throw new Error("Invalid number of '../'");r=s.segments.length}return new Rf(s,!1,r-i)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+s,t.numberOfDoubleDots)}(i,e,t),a=o.processChildren?Df(o.segmentGroup,o.index,i.commands):Ff(o.segmentGroup,o.index,i.commands);return Nf(o.segmentGroup,a,e,s,r)}(a,this.currentUrlTree,t,u,null!=l?l:null)}navigateByUrl(t,e={skipLocationChange:!1}){const n=Uf(t)?t:this.parseUrl(t),s=this.urlHandlingStrategy.merge(n,this.rawUrlTree);return this.scheduleNavigation(s,"imperative",null,e)}navigate(t,e={skipLocationChange:!1}){return function(t){for(let e=0;e<t.length;e++){const n=t[e];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${e}`)}}(t),this.navigateByUrl(this.createUrlTree(t,e),e)}serializeUrl(t){return this.urlSerializer.serialize(t)}parseUrl(t){let e;try{e=this.urlSerializer.parse(t)}catch(n){e=this.malformedUriErrorHandler(n,this.urlSerializer,t)}return e}isActive(t,e){let n;if(n=!0===e?Object.assign({},Mm):!1===e?Object.assign({},Pm):e,Uf(t))return zp(this.currentUrlTree,t,n);const s=this.parseUrl(t);return zp(this.currentUrlTree,s,n)}removeEmptyProps(t){return Object.keys(t).reduce((e,n)=>{const s=t[n];return null!=s&&(e[n]=s),e},{})}processNavigations(){this.navigations.subscribe(t=>{this.navigated=!0,this.lastSuccessfulId=t.id,this.events.next(new hp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,t.resolve(!0)},t=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(t,e,n,s,r){if(this.disposed)return Promise.resolve(!1);const i=this.getTransition(),o="imperative"!==e&&"imperative"===(null==i?void 0:i.source),a=(this.lastSuccessfulId===i.id||this.currentNavigation?i.rawUrl:i.urlAfterRedirects).toString()===t.toString();if(o&&a)return Promise.resolve(!0);let l,u,c;r?(l=r.resolve,u=r.reject,c=r.promise):c=new Promise((t,e)=>{l=t,u=e});const h=++this.navigationId;return this.setTransition({id:h,source:e,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:t,extras:s,resolve:l,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(t=>Promise.reject(t))}setBrowserUrl(t,e,n,s){const r=this.urlSerializer.serialize(t);s=s||{},this.location.isCurrentPathEqualTo(r)||e?this.location.replaceState(r,"",Object.assign(Object.assign({},s),{navigationId:n})):this.location.go(r,"",Object.assign(Object.assign({},s),{navigationId:n}))}resetStateAndUrl(t,e,n){this.routerState=t,this.currentUrlTree=e,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return t.\u0275fac=function(e){return new(e||t)(fs(Qn),fs(qp),fs(Rm),fs(uc),fs(po),fs(Pu),fs(du),fs(void 0))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),Bm=(()=>{class t{constructor(t,e,n,s,r){this.parentContexts=t,this.location=e,this.resolver=n,this.changeDetector=r,this.activated=null,this._activatedRoute=null,this.activateEvents=new Nl,this.deactivateEvents=new Nl,this.name=s||Sp,t.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const t=this.parentContexts.getContext(this.name);t&&t.route&&(t.attachRef?this.attach(t.attachRef,t.route):this.activateWith(t.route,t.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const t=this.activated;return this.activated=null,this._activatedRoute=null,t}attach(t,e){this.activated=t,this._activatedRoute=e,this.location.insert(t.hostView)}deactivate(){if(this.activated){const t=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(t)}}activateWith(t,e){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=t;const n=(e=e||this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),s=this.parentContexts.getOrCreateContext(this.name).children,r=new Vm(t,s,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,r),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)(To(Rm),To(dl),To(Ca),qn("name"),To(tl))},t.\u0275dir=Jt({type:t,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),t})();class Vm{constructor(t,e,n){this.route=t,this.childContexts=e,this.parent=n}get(t,e){return t===yf?this.route:t===Rm?this.childContexts:this.parent.get(t,e)}}class Wm{}class Um{preload(t,e){return fd(null)}}let jm=(()=>{class t{constructor(t,e,n,s,r){this.router=t,this.injector=s,this.preloadingStrategy=r,this.loader=new $m(e,n,e=>t.triggerEvent(new vp(e)),e=>t.triggerEvent(new wp(e)))}setUpPreloading(){this.subscription=this.router.events.pipe(Pd(t=>t instanceof hp),jd(()=>this.preload())).subscribe(()=>{})}preload(){const t=this.injector.get(ul);return this.processRoutes(t,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(t,e){const n=[];for(const s of e)if(s.loadChildren&&!s.canLoad&&s._loadedConfig){const t=s._loadedConfig;n.push(this.processRoutes(t.module,t.routes))}else s.loadChildren&&!s.canLoad?n.push(this.preloadConfig(t,s)):s.children&&n.push(this.processRoutes(t,s.children));return B(n).pipe(q(),$(t=>{}))}preloadConfig(t,e){return this.preloadingStrategy.preload(e,()=>(e._loadedConfig?fd(e._loadedConfig):this.loader.load(t.injector,e)).pipe(j(t=>(e._loadedConfig=t,this.processRoutes(t.module,t.routes)))))}}return t.\u0275fac=function(e){return new(e||t)(fs(zm),fs(Pu),fs(du),fs(po),fs(Wm))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),Hm=(()=>{class t{constructor(t,e,n={}){this.router=t,this.viewportScroller=e,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(t=>{t instanceof cp?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=t.navigationTrigger,this.restoredId=t.restoredState?t.restoredState.navigationId:0):t instanceof hp&&(this.lastId=t.id,this.scheduleScrollEvent(t,this.router.parseUrl(t.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(t=>{t instanceof Ip&&(t.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(t.position):t.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(t.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(t,e){this.router.triggerEvent(new Ip(t,"popstate"===this.lastSource?this.store[this.restoredId]:null,e))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(fs(zm),fs($c),fs(void 0))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const Gm=new Zn("ROUTER_CONFIGURATION"),qm=new Zn("ROUTER_FORROOT_GUARD"),Km=[uc,{provide:qp,useClass:Kp},{provide:zm,useFactory:function(t,e,n,s,r,i,o,a={},l,u){const c=new zm(null,t,e,n,s,r,i,Fp(o));return l&&(c.urlHandlingStrategy=l),u&&(c.routeReuseStrategy=u),function(t,e){t.errorHandler&&(e.errorHandler=t.errorHandler),t.malformedUriErrorHandler&&(e.malformedUriErrorHandler=t.malformedUriErrorHandler),t.onSameUrlNavigation&&(e.onSameUrlNavigation=t.onSameUrlNavigation),t.paramsInheritanceStrategy&&(e.paramsInheritanceStrategy=t.paramsInheritanceStrategy),t.relativeLinkResolution&&(e.relativeLinkResolution=t.relativeLinkResolution),t.urlUpdateStrategy&&(e.urlUpdateStrategy=t.urlUpdateStrategy)}(a,c),a.enableTracing&&c.events.subscribe(t=>{var e,n;null===(e=console.group)||void 0===e||e.call(console,`Router Event: ${t.constructor.name}`),console.log(t.toString()),console.log(t),null===(n=console.groupEnd)||void 0===n||n.call(console)}),c},deps:[qp,Rm,uc,po,Pu,du,Nm,Gm,[class{},new vs],[class{},new vs]]},Rm,{provide:yf,useFactory:function(t){return t.routerState.root},deps:[zm]},{provide:Pu,useClass:Vu},jm,Um,class{preload(t,e){return e().pipe(Vd(()=>fd(null)))}},{provide:Gm,useValue:{enableTracing:!1}}];function Xm(){return new Au("Router",zm)}let Zm=(()=>{class t{constructor(t,e){}static forRoot(e,n){return{ngModule:t,providers:[Km,tg(e),{provide:qm,useFactory:Jm,deps:[[zm,new vs,new ws]]},{provide:Gm,useValue:n||{}},{provide:rc,useFactory:Qm,deps:[Xu,[new bs(oc),new vs],Gm]},{provide:Hm,useFactory:Ym,deps:[zm,$c,Gm]},{provide:Wm,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:Um},{provide:Au,multi:!0,useFactory:Xm},[eg,{provide:Kl,multi:!0,useFactory:ng,deps:[eg]},{provide:rg,useFactory:sg,deps:[eg]},{provide:eu,multi:!0,useExisting:rg}]]}}static forChild(e){return{ngModule:t,providers:[tg(e)]}}}return t.\u0275fac=function(e){return new(e||t)(fs(qm,8),fs(zm,8))},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})();function Ym(t,e,n){return n.scrollOffset&&e.setOffset(n.scrollOffset),new Hm(t,e,n)}function Qm(t,e,n={}){return n.useHash?new lc(t,e):new ac(t,e)}function Jm(t){return"guarded"}function tg(t){return[{provide:Yn,multi:!0,useValue:t},{provide:Nm,multi:!0,useValue:t}]}let eg=(()=>{class t{constructor(t){this.injector=t,this.initNavigation=!1,this.resultOfPreactivationDone=new E}appInitializer(){return this.injector.get(Yu,Promise.resolve(null)).then(()=>{let t=null;const e=new Promise(e=>t=e),n=this.injector.get(zm),s=this.injector.get(Gm);return"disabled"===s.initialNavigation?(n.setUpLocationChangeListener(),t(!0)):"enabled"===s.initialNavigation||"enabledBlocking"===s.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?fd(null):(this.initNavigation=!0,t(!0),this.resultOfPreactivationDone),n.initialNavigation()):t(!0),e})}bootstrapListener(t){const e=this.injector.get(Gm),n=this.injector.get(jm),s=this.injector.get(Hm),r=this.injector.get(zm),i=this.injector.get(Lu);t===i.components[0]&&("enabledNonBlocking"!==e.initialNavigation&&void 0!==e.initialNavigation||r.initialNavigation(),n.setUpPreloading(),s.init(),r.resetRootComponentType(i.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return t.\u0275fac=function(e){return new(e||t)(fs(po))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();function ng(t){return t.appInitializer.bind(t)}function sg(t){return t.bootstrapListener.bind(t)}const rg=new Zn("Router Initializer"),ig=[];let og=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Zm.forRoot(ig)],Zm]}),t})();function ag(t,e,n,s,r,i,o){try{var a=t[i](o),l=a.value}catch(u){return void n(u)}a.done?e(l):Promise.resolve(l).then(s,r)}function lg(t){return function(){var e=this,n=arguments;return new Promise(function(s,r){var i=t.apply(e,n);function o(t){ag(i,s,r,o,a,"next",t)}function a(t){ag(i,s,r,o,a,"throw",t)}o(void 0)})}}const ug="https://isthischae.herokuapp.com";class cg{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class hg{refCount(t){return dg("refCount")}incRef(t){return dg("incRef")}timerAvailable(){return!0}time(t){return dg("time")}read(t){return dg("read")}readSync(t){return dg("readSync")}numDataIds(){return dg("numDataIds")}disposeData(t,e){return dg("disposeData")}write(t,e,n){return dg("write")}move(t,e,n,s,r){return dg("move")}memory(){return dg("memory")}floatPrecision(){return dg("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return dg("dispose")}}function dg(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function pg(t){let e=t.length,n=0,s=0;for(;e>0;)s=Math.random()*e|0,e--,n=t[e],t[e]=t[s],t[s]=n}function fg(t,e,n){return Math.max(t,Math.min(e,n))}function mg(t){return t%2==0?t:t+1}function gg(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function yg(t,e,n=""){gg(xg(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function bg(t){gg(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function vg(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||Rg(t)&&!n)for(let s=0;s<t.length;++s)vg(t[s],e,n);else e.push(t);return e}function wg(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function xg(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function _g(t){return t%1==0}function kg(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Cg(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function Ig(t,e=(t=>0),n){return new Promise((s,r)=>{let i=0;const o=()=>{if(t())return void s();i++;const a=e(i);null!=n&&i>=n?r():setTimeout(o,a)};o()})}function Sg(t,e){let n=1,s=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(-1===t[i]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(-1===s){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function Eg(t,e){const n=e.length;return gg((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),gg(t.every(t=>_g(t)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(t=>t<0?n+t:t)}function Tg(t,e){const n=[],s=[],r=null!=e&&Array.isArray(e)&&0===e.length,i=null==e||r?null:Eg(e,t).sort();let o=0;for(let a=0;a<t.length;++a){if(null!=i){if(i[o]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===t[a]&&(n.push(t[a]),s.push(a)),i[o]<=a&&o++}1!==t[a]&&(n.push(t[a]),s.push(a))}return{newShape:n,keptDims:s}}function Ng(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function $g(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function Ag(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function Rg(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function Fg(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function Dg(t){return"string"==typeof t||t instanceof String}function Og(t){return"number"==typeof t}function Lg(t){return Array.isArray(t)?Lg(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":Og(t)?"float32":Dg(t)?"string":"boolean"==typeof t?"bool":"float32"}function Mg(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Pg(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function zg(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function Bg(t,e,n,s=!1){const r=new Array;if(1===e.length){const i=e[0]*(s?2:1);for(let e=0;e<i;e++)r[e]=n[t+e]}else{const i=e[0],o=e.slice(1),a=o.reduce((t,e)=>t*e)*(s?2:1);for(let e=0;e<i;e++)r[e]=Bg(t+e*a,o,n,s)}return r}function Vg(t,e,n=!1){if(0===t.length)return e[0];const s=t.reduce((t,e)=>t*e)*(n?2:1);if(0===s)return[];if(s!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Bg(0,t,e,n)}function Wg(t,e){const n=Ug(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function Ug(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function jg(t,e){const n=t.reduce((t,e)=>t*e,1);if(null==e||"float32"===e)return Vg(t,new Float32Array(n));if("int32"===e)return Vg(t,new Int32Array(n));if("bool"===e)return Vg(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function Hg(t){t.forEach(e=>{gg(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Gg(t,e,n){if(0===e)return 0;if(1===e)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function qg(t,e,n){if(0===e)return[];if(1===e)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function Kg(t){return t&&t.then&&"function"==typeof t.then}class Xg{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Zg,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}getAsync(t){var e=this;return lg(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Kg(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function Zg(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}function Yg(){return Jg}let Qg,Jg=null;function ty(){if(null==Qg){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Qg=t}return Qg}function ey(t,e){const n=function(){const t=ty();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const ny="Abs",sy="Acos",ry="Acosh",iy="Add",oy="AddN",ay="All",ly="Any",uy="ArgMax",cy="ArgMin",hy="Asin",dy="Asinh",py="Atan",fy="Atanh",my="Atan2",gy="AvgPool",yy="AvgPoolGrad",by="AvgPool3D",vy="AvgPool3DGrad",wy="BatchMatMul",xy="BatchToSpaceND",_y="Bincount",ky="Cast",Cy="Ceil",Iy="ClipByValue",Sy="Complex",Ey="ComplexAbs",Ty="Concat",Ny="Conv2D",$y="Conv2DBackpropFilter",Ay="Conv2DBackpropInput",Ry="Conv3D",Fy="Conv3DBackpropFilterV2",Dy="Conv3DBackpropInputV2",Oy="Cos",Ly="Cosh",My="Cumsum",Py="CropAndResize",zy="DenseBincount",By="DepthToSpace",Vy="DepthwiseConv2dNative",Wy="DepthwiseConv2dNativeBackpropFilter",Uy="DepthwiseConv2dNativeBackpropInput",jy="Diag",Hy="Dilation2D",Gy="Dilation2DBackpropInput",qy="Dilation2DBackpropFilter",Ky="RealDiv",Xy="Einsum",Zy="Elu",Yy="EluGrad",Qy="Erf",Jy="Equal",tb="Exp",eb="ExpandDims",nb="Expm1",sb="FFT",rb="Fill",ib="FlipLeftRight",ob="Floor",ab="FloorDiv",lb="FusedBatchNorm",ub="GatherV2",cb="GatherNd",hb="Greater",db="GreaterEqual",pb="Identity",fb="IFFT",mb="Imag",gb="IsFinite",yb="IsInf",bb="IsNan",vb="LeakyRelu",wb="Less",xb="LessEqual",_b="LinSpace",kb="Log",Cb="Log1p",Ib="LogicalAnd",Sb="LogicalNot",Eb="LogicalOr",Tb="LRN",Nb="LRNGrad",$b="Max",Ab="Maximum",Rb="MaxPool",Fb="MaxPoolGrad",Db="MaxPool3D",Ob="MaxPool3DGrad",Lb="MaxPoolWithArgmax",Mb="Mean",Pb="Min",zb="Minimum",Bb="MirrorPad",Vb="Mod",Wb="Multinomial",Ub="Multiply",jb="Neg",Hb="NotEqual",Gb="NonMaxSuppressionV3",qb="NonMaxSuppressionV4",Kb="NonMaxSuppressionV5",Xb="OnesLike",Zb="OneHot",Yb="Pack",Qb="PadV2",Jb="Pow",tv="Prelu",ev="Prod",nv="Range",sv="Real",rv="Reciprocal",iv="Relu",ov="Reshape",av="ResizeNearestNeighbor",lv="ResizeNearestNeighborGrad",uv="ResizeBilinear",cv="ResizeBilinearGrad",hv="Relu6",dv="Reverse",pv="Round",fv="Rsqrt",mv="ScatterNd",gv="Select",yv="Selu",bv="Slice",vv="Sin",wv="Sinh",xv="Sign",_v="Sigmoid",kv="Softplus",Cv="Sqrt",Iv="Sum",Sv="SpaceToBatchND",Ev="SplitV",Tv="Softmax",Nv="SparseFillEmptyRows",$v="SparseReshape",Av="SparseSegmentMean",Rv="SparseSegmentSum",Fv="SparseToDense",Dv="SquaredDifference",Ov="Square",Lv="StridedSlice",Mv="StringNGrams",Pv="StringSplit",zv="StringToHashBucketFast",Bv="Sub",Vv="Tan",Wv="Tanh",Uv="Tile",jv="TopK",Hv="Transform",Gv="Transpose",qv="Unique",Kv="Unpack",Xv="UnsortedSegmentSum",Zv="ZerosLike",Yv="Step",Qv="FromPixels",Jv="RotateWithOffset",tw="_FusedMatMul",ew="FusedConv2D",nw="FusedDepthwiseConv2D",sw=ey("kernelRegistry",()=>new Map),rw=ey("gradRegistry",()=>new Map);function iw(t,e){const n=cw(t,e);return sw.get(n)}function ow(t){return rw.get(t)}function aw(t){const e=sw.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===t&&n.push(o)}return n}function lw(t){const{kernelName:e,backendName:n}=t,s=cw(e,n);sw.has(s)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),sw.set(s,t)}function uw(t){const{kernelName:e}=t;rw.has(e)&&Yg().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),rw.set(e,t)}function cw(t,e){return`${e}_${t}`}var hw=n(929);const dw=n.n(hw)()||hw;function pw(t){return dw.fromString(t,!0,16)}const fw=pw("c3a5c85c97cb3127"),mw=pw("b492b66fbe98f273"),gw=pw("9ae16a3b2f90404f");function yw(t){return t.xor(t.shru(47))}function bw(t,e,n){const s=t.slice(e,e+n);return dw.fromBytes(Array.from(s),!0,!0)}function vw(t,e){return bw(t,e,8)}function ww(t,e){return bw(t,e,4)}function xw(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function _w(t,e,n=pw("9ddfea08eb382d69")){let s=t.xor(e).mul(n);s=s.xor(s.shru(47));let r=e.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function kw(t,e,n,s){return function(t,e,n,s,r,i){r=r.add(t),i=xw(i.add(r).add(s),21);const o=r;return r=(r=r.add(e)).add(n),i=i.add(xw(r,44)),[r.add(s),i.add(o)]}(vw(t,e),vw(t,e+8),vw(t,e+16),vw(t,e+24),n,s)}function Cw(t,e=t.length){const n=dw.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=gw.add(2*e),s=vw(t,0).add(gw),r=vw(t,e-8);return _w(xw(r,37).mul(n).add(s),xw(s,25).add(r).mul(n),n)}if(e>=4){const n=gw.add(2*e);return _w(ww(t,0).shl(3).add(e),ww(t,e-4),n)}if(e>0){const n=e+(t[e-1]<<2);return yw(gw.mul(t[0]+(t[e>>1]<<8)).xor(fw.mul(n))).mul(gw)}return gw}(t,e):function(t,e=t.length){const n=gw.add(2*e),s=vw(t,0).mul(mw),r=vw(t,8),i=vw(t,e-8).mul(n),o=vw(t,e-16).mul(gw);return _w(xw(s.add(r),43).add(xw(i,30)).add(o),s.add(xw(r.add(gw),18)).add(i),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=gw.add(2*e),s=vw(t,0).mul(gw),r=vw(t,8),i=vw(t,e-8).mul(n),o=vw(t,e-16).mul(gw),a=xw(s.add(r),43).add(xw(i,30)).add(o),l=_w(a,s.add(xw(r.add(gw),18)).add(i),n),u=vw(t,16).mul(n),c=vw(t,24),h=a.add(vw(t,e-32)).mul(n),d=l.add(vw(t,e-24)).mul(n);return _w(xw(u.add(c),43).add(xw(h,30)).add(d),u.add(xw(c.add(s),18)).add(h),n)}(t,e);let s=n,r=n.mul(mw).add(113),i=yw(r.mul(gw).add(113)).mul(gw),o=[dw.UZERO,dw.UZERO],a=[dw.UZERO,dw.UZERO];s=s.mul(gw).add(vw(t,0));let l=0;const u=64*(e-1>>6),c=u+(e-1&63)-63;do{s=xw(s.add(r).add(o[0]).add(vw(t,l+8)),37).mul(mw),r=xw(r.add(o[1]).add(vw(t,l+48)),42).mul(mw),s=s.xor(a[1]),r=r.add(o[0]).add(vw(t,l+40)),i=xw(i.add(a[0]),33).mul(mw),o=kw(t,l,o[1].mul(mw),s.add(a[0])),a=kw(t,l+32,i.add(a[1]),r.add(vw(t,l+16))),[i,s]=[s,i],l+=64}while(l!==u);const h=mw.add(i.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=xw(s.add(r).add(o[0]).add(vw(t,l+8)),37).mul(h),r=xw(r.add(o[1]).add(vw(t,l+48)),42).mul(h),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(vw(t,l+40))),i=xw(i.add(a[0]),33).mul(h),o=kw(t,l,o[1].mul(h),s.add(a[0])),a=kw(t,l+32,i.add(a[1]),r.add(vw(t,l+16))),[i,s]=[s,i],_w(_w(o[0],a[0],h).add(yw(r).mul(fw)).add(i),_w(o[1],a[1],h).add(s),h)}function Iw(t,e){return"string"===e?Tw(t):Sw([t],e)}function Sw(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=vg(t)),Yg().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function Ew(){return Yg().platform.now()}function Tw(t,e="utf-8"){return e=e||"utf-8",Yg().platform.encode(t,e)}function Nw(t,e="utf-8"){return e=e||"utf-8",Yg().platform.decode(t,e)}class $w{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Rw)}profileKernel(t,e,n){let s;const r=()=>{s=n()};let i;const o=Ew();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(r);else{r();for(const t of s)t.dataSync();i=Promise.resolve({kernelMs:Ew()-o})}if(Yg().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let a=0;a<s.length;a++){const e=s[a];e.data().then(n=>{Aw(n,e.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:i.then(t=>t.kernelMs),extraInfo:i.then(t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:s,inputs:r,extraInfo:i}=t;n.forEach(t=>{Promise.all([t.data(),s,i]).then(n=>{this.logger.logKernelProfile(e,t,n[0],n[1],r,n[2])})})}}function Aw(t,e,n){if("float32"!==e)return!1;for(let s=0;s<t.length;s++){const e=t[s];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}return!1}class Rw{logKernelProfile(t,e,n,s,r,i){const o="number"==typeof s?Cg(`${s}ms`,9):s.error,a=Cg(t,25),l=e.rank,u=e.size,c=Cg(e.shape.toString(),14);let h="";for(const d in r){const t=r[d];if(null!=t){const n=t.shape||e.shape,s=n.length;h+=`${d}: ${s}D ${s>0?n:""} `}}console.log(`%c${a}\t%c${o}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Fw(t,e,n,s){const r=zg(e),i=function(t,e,n,s){const r=wg(e),i=s[s.length-1],o=new Array(i).fill(0),a=e.length,l="complex64"===n?Mw(t):t;if(a>1)for(let u=0;u<r/i;u++){const t=u*i;for(let e=0;e<i;e++)o[e]=Math.max(o[e],Dw(l[t+e],0,n).length)}return o}(t,e,n,r),o=e.length,a=Lw(t,e,n,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(t=>"    "+t).join("\n")),l.join("\n")}function Dw(t,e,n){let s;return s=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:Dg(t)?`'${t}'`:"bool"===n?Ow(t):parseFloat(t.toFixed(7)).toString(),Cg(s,e)}function Ow(t){return 0===t?"false":"true"}function Lw(t,e,n,s,r,i=!0){const o="complex64"===n?2:1,a=e[0],l=e.length;if(0===l)return"complex64"===n?[Dw(Mw(t)[0],0,n)]:"bool"===n?[Ow(t[0])]:[t[0].toString()];if(1===l){if(a>20){let e=Array.from(t.slice(0,3*o)),s=Array.from(t.slice((a-3)*o,a*o));return"complex64"===n&&(e=Mw(e),s=Mw(s)),["["+e.map((t,e)=>Dw(t,r[e],n)).join(", ")+", ..., "+s.map((t,e)=>Dw(t,r[a-3+e],n)).join(", ")+"]"]}return["["+("complex64"===n?Mw(t):Array.from(t)).map((t,e)=>Dw(t,r[e],n)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*o,d=[];if(a>20){for(let e=0;e<3;e++){const s=e*h;d.push(...Lw(t.slice(s,s+h),u,n,c,r,!1))}d.push("...");for(let e=a-3;e<a;e++){const s=e*h;d.push(...Lw(t.slice(s,s+h),u,n,c,r,e===a-1))}}else for(let m=0;m<a;m++){const e=m*h;d.push(...Lw(t.slice(e,e+h),u,n,c,r,m===a-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function Mw(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Pw{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=wg(t),null!=n){const t=n.length;gg(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||$g(e,this.size),this.strides=zg(t)}set(t,...e){0===e.length&&(e=[0]),gg(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return zw().makeTensor(this.values,this.shape,this.dtype)}}let zw=null,Bw=null,Vw=null;class Ww{constructor(t,e,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=wg(t),this.strides=zg(t),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return lg(function*(){const e=yield t.data();return Bw.buffer(t.shape,t.dtype,e)})()}bufferSync(){return Bw.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return lg(function*(){const e=yield t.data();return Vg(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return Vg(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return lg(function*(){t.throwIfDisposed();const e=zw().read(t.dataId);if("string"===t.dtype){const t=yield e;try{return t.map(t=>Nw(t))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataSync(){this.throwIfDisposed();const t=zw().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>Nw(t))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return lg(function*(){t.throwIfDisposed();const e=yield zw().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(zw().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Bw.print(this,t)}clone(){return this.throwIfDisposed(),Bw.clone(this)}toString(t=!1){return Fw(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Bw.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),zw().makeVariable(this,t,e,n)}}function Uw(){return ey("Tensor",()=>Ww)}Object.defineProperty(Ww,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),Uw();class jw extends Ww{constructor(t,e,n,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!xg(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);zw().disposeTensor(this),this.dataId=t.dataId,zw().incRef(this,null)}dispose(){zw().disposeVariable(this),this.isDisposedInternal=!0}}var Hw,Gw,qw,Kw,Xw;Object.defineProperty(jw,Symbol.hasInstance,{value:t=>t instanceof Ww&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Hw||(Hw={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Gw||(Gw={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(qw||(qw={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Kw||(Kw={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Xw||(Xw={}));const Zw={float32:Kw,int32:Gw,bool:qw,complex64:Xw};function Yw(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Zw[t][e]}function Qw(t){return Yw(t,"int32")}function Jw(t,e){if(t.dtype===e.dtype)return[t,e];const n=Yw(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function tx(t,e){return e.some(e=>e.id===t.id)}function ex(t){const e=[];return nx(t,e,new Set),e}function nx(t,e,n){if(null==t)return;if(t instanceof Ww)return void e.push(t);if(s=t,!Array.isArray(s)&&"object"!=typeof s)return;var s;const r=t;for(const i in r){const t=r[i];n.has(t)||(n.add(t),nx(t,e,n))}}function sx(t){return null!=t.kernelName}class rx{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class ix{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new rx}ready(){var t=this;return lg(function*(){if(null!=t.pendingBackendInit)return t.pendingBackendInit.then(()=>{});if(null!=t.backendInstance)return;const e=t.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n];if(yield t.initializeBackend(s).success)return void(yield t.setBackend(s))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}setBackend(t){var e=this;return lg(function*(){if(null==e.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(e.backendName=t,null==e.registry[t]){e.backendInstance=null;const{success:n,asyncInit:s}=e.initializeBackend(t);if(!(s?yield n:n))return!1}return e.backendInstance=e.registry[t],e.setupRegisteredKernels(),e.profiler=new $w(e.backendInstance),!0})()}setupRegisteredKernels(){aw(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){aw(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof hg||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,s=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:s,asyncInit:r}=this.initializeBackend(n);if(r||s)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),s=n.backend,r=this.readSync(e),i=s.refCount(e);s.disposeData(e,!0),n.backend=t,t.move(e,r,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,s=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(s){throw e(),s}}nextTensorId(){return ix.nextTensorId++}nextVariableId(){return ix.nextVariableId++}clone(t){const e=ax.runKernel(pb,{x:t});return this.addTapeNode(this.state.activeScope.name,{x:t},[e],t=>({x:()=>ax.runKernel(ky,{x:t},{dtype:"float32"})}),[],{}),e}runKernel(t,e,n){if(null==iw(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const s=this.backend.numDataIds();let r=0;n.forEach(t=>{r+="complex64"===t.dtype?3:1});const i=s-e-r-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const s=this.isTapeOn(),r=this.state.numBytes,i=this.state.numTensors;let o,a;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const l=sx(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(sx(t)){const{kernelName:e,inputs:r,attrs:i}=t,l=iw(e,this.backendName);gg(null!=l,()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`),o=()=>{const t=this.backend.numDataIds();a=l.kernelFunc({inputs:r,attrs:i,backend:this.backend});const o=Array.isArray(a)?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const u=o.map(t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:s}=t;return this.makeTensorFromDataId(e,n,s)});if(s){const t=this.getTensorsForGradient(e,r,u);n=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:e}=t,r=t=>{s&&(n=t.map(t=>this.keep(this.clone(t))))};o=()=>{const t=this.backend.numDataIds();a=this.tidy(()=>e(this.backend,r));const n=Array.isArray(a)?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:u,attrs:c}=t,h=sx(t)?null:t.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=o()}),s&&this.addTapeNode(l,u,e,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(t=>null!=u[t]?u[t].shape:null),outputShapes:e.map(t=>t.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(a)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const s=ow(t);if(null!=s){const t=s.inputsToSave||[],r=s.outputsToSave||[];let i;s.saveAllInputs?(gg(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(t=>e[t])):i=t.map(t=>e[t]);const o=n.filter((t,e)=>r[e]);return i.concat(o)}return[]}makeTensor(t,e,n,s){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");s=s||this.backend;let r=t;"string"===(n=n||"float32")&&Dg(t[0])&&(r=t.map(t=>Tw(t)));const i=s.write(r,e,n),o=new Ww(e,n,i,this.nextTensorId());if(this.trackTensor(o,s),"string"===n){const t=this.state.tensorInfo.get(i),e=function(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}(r);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,s){const r=new Ww(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(r,s),r}makeVariable(t,e=!0,n,s){n=n||this.nextVariableId().toString(),null!=s&&s!==t.dtype&&(t=t.cast(s));const r=new jw(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*Fg(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof jw||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*Fg(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}profile(t){var e=this;return lg(function*(){e.state.profiling=!0;const n=e.state.numBytes,s=e.state.numTensors;e.state.activeProfile.kernels=[],e.state.activeProfile.result=yield t(),e.state.profiling=!1,e.state.activeProfile.peakBytes=Math.max(...e.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),e.state.activeProfile.newBytes=e.state.numBytes-n,e.state.activeProfile.newTensors=e.state.numTensors-s;for(const t of e.state.activeProfile.kernels)t.kernelTimeMs=yield t.kernelTimeMs,t.extraInfo=yield t.extraInfo;return e.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,s,r,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:r},a=ow(t);null!=a&&(s=a.gradFunc),null!=s&&(o.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],s=Ug(t.size,t.dtype);return this.makeTensor(s,t.shape,t.dtype)}return t}),s(t.length>1?t:t[0],r,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=ex(t),n=new Set(e.map(t=>t.id));for(let r=0;r<this.state.activeScope.track.length;r++){const t=this.state.activeScope.track[r];t.kept||n.has(t.id)||t.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==s.id||this.track(t)})}gradients(t,e,n,s=!1){if(gg(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));gg(r instanceof Ww,()=>"The result y returned by f() must be a tensor.");const i=function(t,e,n){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],i=n.inputs;for(const t in i){const o=i[t];let a=!1;for(let t=0;t<e.length;t++)if(s[o.id]){n.outputs.forEach(t=>s[t.id]=!0),a=!0,r[n.id]=!0;break}if(a)break}}const i={};i[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(i[e.outputs[t].id]){for(const t in n)i[n[t].id]=!0,o[e.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const e=t[l];if(r[e.id]&&o[e.id]){const t={};for(const r in e.inputs){const n=e.inputs[r];s[n.id]&&(t[r]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,a.push(n)}}return a}(this.state.activeTape,e,r);if(!s&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[r.id]=null==n?function(t){const e=Wg(wg(t),"float32");return ax.makeTensor(e,t,"float32")}(r.shape):n,function(t,e,n,s){for(let r=e.length-1;r>=0;r--){const i=e[r],o=[];if(i.outputs.forEach(e=>{const n=t[e.id];o.push(null!=n?n:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const e in i.inputs){if(!(e in a))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(a)}.`);const r=n(()=>a[e]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${r.dtype}'`);const o=i.inputs[e];if(!xg(r.shape,o.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${e}' has shape '${r.shape}', which does not match the shape of the input '${o.shape}'`);if(null==t[o.id])t[o.id]=r;else{const e=t[o.id];t[o.id]=s(e,r),e.dispose()}}}}(t,i,t=>this.tidy(t),lx);const s=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:r,grads:s}})}customGrad(t){return gg(Mg(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;gg(e.every(t=>t instanceof Ww),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return e.forEach((t,e)=>{s[e]=t}),this.runKernelFunc({forwardFunc:(s,r)=>(n=t(...e,r),gg(n.value instanceof Ww,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),gg(Mg(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(t,s)=>{const r=n.gradFunc(t,s),i=Array.isArray(r)?r:[r];gg(i.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),gg(i.every(t=>t instanceof Ww),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const o={};return i.forEach((t,e)=>{o[e]=()=>t}),o},inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}time(t){var e=this;return lg(function*(){const n=Ew(),s=yield e.backend.time(t);return s.wallMs=Ew()-n,s})()}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new rx;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function ox(){const t=ty();if(null==t._tfengine){const e=new Xg(t);t._tfengine=new ix(e)}return Jg=t._tfengine.ENV,zw=()=>t._tfengine,t._tfengine}ix.nextTensorId=0,ix.nextVariableId=0;const ax=ox();function lx(t,e){return ax.runKernel(iy,{a:t,b:e})}function ux(t){if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function cx(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const hx=Yg();function dx(t,e){let n=t;if(Rg(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||Rg(n)&&"string"!==e;)s.push(n.length),n=n[0];return Array.isArray(t)&&Yg().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&px(t,s,[]),s}function px(t,e,n){if(n=n||[],!Array.isArray(t)&&!Rg(t))return void gg(0===e.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);gg(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),gg(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)px(t[r],s,n.concat(r))}function fx(t,e,n,s){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function mx(t,e,n,s="numeric"){if(t instanceof Ww)return fx(s,t.dtype,e,n),t;let r=Lg(t);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),fx(s,r,e,n),null==t||!Rg(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const i=dx(t,r);Rg(t)||Array.isArray(t)||(t=[t]);const o="string"!==r?Sw(t,r):vg(t,[],!0);return ax.makeTensor(o,i,r)}function gx(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>mx(t,`${e}[${r}]`,n,s))}function yx(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...t)=>{ax.startScope(n);try{const e=s(...t);return Kg(e)&&console.error("Cannot return a Promise inside of tidy."),ax.endScope(e),e}catch(e){throw ax.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}hx.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),hx.registerFlag("IS_BROWSER",()=>cx()),hx.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),hx.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),hx.registerFlag("PROD",()=>!1),hx.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>hx.getBool("DEBUG")),hx.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),hx.registerFlag("IS_TEST",()=>!1),hx.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),hx.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const bx=yx({complex_:function(t,e){const n=mx(t,"real","complex"),s=mx(e,"imag","complex");return yg(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`),ax.runKernel(Sy,{real:n,imag:s})}});function vx(t,e,n,s){if(null==s&&(s=Lg(t)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Rg(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Hg(e);const t=wg(e),s=wg(n);gg(t===s,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${s}`);for(let r=0;r<n.length;++r){const t=n[r],s=r!==n.length-1||t!==wg(e.slice(r));gg(n[r]===e[r]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return Rg(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==s?Sw(t,s):vg(t,[],!0),ax.makeTensor(t,e,s)}function wx(t,e,n){return vx(t,e,dx(t,n),n)}const xx={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function _x(t,e){return kx.apply(this,arguments)}function kx(){return(kx=lg(function*(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let i=0;i<r.length;++i){const o=r[i],a=Array.isArray(t)?t[i].tensor:t[o];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${a.dtype}`);const l={name:o,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise(function(){var t=lg(function*(t){const e=yield a.bytes(),n=e.reduce((t,e)=>t+e.length,0)+4*e.length,s=new Uint8Array(n);let r=0;for(let i=0;i<e.length;i++){const t=e[i],n=new Uint8Array(new Uint32Array([t.length]).buffer);s.set(n,r),r+=4,s.set(t,r),r+=t.length}t(s)});return function(e){return t.apply(this,arguments)}}());s.push(t)}else s.push(a.data());null!=e&&(l.group=e),n.push(l)}return{data:Cx(yield Promise.all(s)),specs:n}})).apply(this,arguments)}function Cx(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(t=>{s.set(new Uint8Array(t.buffer),r),r+=t.byteLength}),s.buffer}const Ix="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Sx(t){return Ix?Buffer.byteLength(t):new Blob([t]).size}function Ex(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let s=0;return t.forEach(t=>{n.set(new Uint8Array(t),s),s+=t.byteLength}),n.buffer}function Tx(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Sx(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Sx(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function Nx(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const r=s[o];i[o]=t[n[r>>10]+(1023&r)]+e[r>>10]}return new Float32Array(r)}}class $x{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==$x.instance&&($x.instance=new $x),$x.instance}static registerSaveRouter(t){$x.getInstance().saveRouters.push(t)}static registerLoadRouter(t){$x.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return $x.getHandlers(t,"save")}static getLoadHandlers(t,e){return $x.getHandlers(t,"load",e)}static getHandlers(t,e,n){const s=[];return("load"===e?$x.getInstance().loadRouters:$x.getInstance().saveRouters).forEach(e=>{const r=e(t,n);null!==r&&s.push(r)}),s}}const Ax=(t,e)=>$x.getLoadHandlers(t,e),Rx="tensorflowjs",Fx="models_store",Dx="model_info_store";function Ox(){if(!Yg().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Lx(t){const e=t.result;e.createObjectStore(Fx,{keyPath:"modelPath"}),e.createObjectStore(Dx,{keyPath:"modelPath"})}class Mx{constructor(t){if(this.indexedDB=Ox(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}save(t){var e=this;return lg(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return e.databaseAction(e.modelPath,t)})()}load(){var t=this;return lg(function*(){return t.databaseAction(t.modelPath)})()}databaseAction(t,e){return new Promise((t,n)=>{const s=this.indexedDB.open(Rx,1);s.onupgradeneeded=()=>Lx(s),s.onsuccess=()=>{const r=s.result;if(null==e){const e=r.transaction(Fx,"readonly"),s=e.objectStore(Fx).get(this.modelPath);s.onsuccess=()=>{if(null==s.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(s.result.modelArtifacts)},s.onerror=t=>(r.close(),n(s.error)),e.oncomplete=()=>r.close()}else{const s=Tx(e),i=r.transaction(Dx,"readwrite");let o=i.objectStore(Dx);const a=o.put({modelPath:this.modelPath,modelArtifactsInfo:s});let l;a.onsuccess=()=>{l=r.transaction(Fx,"readwrite");const a=l.objectStore(Fx).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:s});a.onsuccess=()=>t({modelArtifactsInfo:s}),a.onerror=t=>{o=i.objectStore(Dx);const e=o.delete(this.modelPath);e.onsuccess=()=>(r.close(),n(a.error)),e.onerror=t=>(r.close(),n(a.error))}},a.onerror=t=>(r.close(),n(a.error)),i.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}}},s.onerror=t=>n(s.error)})}}Mx.URL_SCHEME="indexeddb://";const Px=t=>{return Yg().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Mx.URL_SCHEME)?(e=t.slice(Mx.URL_SCHEME.length),new Mx(e)):null;var e};$x.registerSaveRouter(Px),$x.registerLoadRouter(Px);class zx{constructor(){this.indexedDB=Ox()}listModels(){var t=this;return lg(function*(){return new Promise((e,n)=>{const s=t.indexedDB.open(Rx,1);s.onupgradeneeded=()=>Lx(s),s.onsuccess=()=>{const t=s.result,r=t.transaction(Dx,"readonly"),i=r.objectStore(Dx).getAll();i.onsuccess=()=>{const t={};for(const e of i.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},i.onerror=e=>(t.close(),n(i.error)),r.oncomplete=()=>t.close()},s.onerror=t=>n(s.error)})})()}removeModel(t){var e=this;return lg(function*(){var n;return t=(n=t).startsWith(Mx.URL_SCHEME)?n.slice(Mx.URL_SCHEME.length):n,new Promise((n,s)=>{const r=e.indexedDB.open(Rx,1);r.onupgradeneeded=()=>Lx(r),r.onsuccess=()=>{const e=r.result,i=e.transaction(Dx,"readwrite"),o=i.objectStore(Dx),a=o.get(t);let l;a.onsuccess=()=>{if(null==a.result)return e.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=o.delete(t),i=()=>{l=e.transaction(Fx,"readwrite");const r=l.objectStore(Fx).delete(t);r.onsuccess=()=>n(a.result.modelArtifactsInfo),r.onerror=t=>s(a.error)};r.onsuccess=i,r.onerror=t=>(i(),e.close(),s(a.error))}},a.onerror=t=>(e.close(),s(a.error)),i.oncomplete=()=>{null==l?e.close():l.oncomplete=()=>e.close()}},r.onerror=t=>s(r.error)})})()}}const Bx="/",Vx="tensorflowjs_models",Wx="info",Ux="model_topology",jx="weight_specs",Hx="weight_data",Gx="model_metadata";function qx(t){return{info:[Vx,t,Wx].join(Bx),topology:[Vx,t,Ux].join(Bx),weightSpecs:[Vx,t,jx].join(Bx),weightData:[Vx,t,Hx].join(Bx),modelMetadata:[Vx,t,Gx].join(Bx)}}function Kx(t){const e=t.split(Bx);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Bx)}class Xx{constructor(t){if(!Yg().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=qx(this.modelPath)}save(t){var e=this;return lg(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),i=Tx(t);try{e.LS.setItem(e.keys.info,JSON.stringify(i)),e.LS.setItem(e.keys.topology,s),e.LS.setItem(e.keys.weightSpecs,r),e.LS.setItem(e.keys.weightData,function(t){if(Ix)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}(t.weightData));const n={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),e.LS.setItem(e.keys.modelMetadata,JSON.stringify(n)),{modelArtifactsInfo:i}}catch(n){throw e.LS.removeItem(e.keys.info),e.LS.removeItem(e.keys.topology),e.LS.removeItem(e.keys.weightSpecs),e.LS.removeItem(e.keys.weightData),e.LS.removeItem(e.keys.modelMetadata),new Error(`Failed to save model '${e.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var t=this;return lg(function*(){const e=JSON.parse(t.LS.getItem(t.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${t.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(t.LS.getItem(t.keys.topology));if(null==s)throw new Error(`In local storage, the topology of model '${t.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(t.LS.getItem(t.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${t.modelPath}' are missing.`);n.weightSpecs=r;const i=t.LS.getItem(t.keys.modelMetadata);if(null!=i){const t=JSON.parse(i);n.format=t.format,n.generatedBy=t.generatedBy,n.convertedBy=t.convertedBy,null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer)}const o=t.LS.getItem(t.keys.weightData);if(null==o)throw new Error(`In local storage, the binary weight values of model '${t.modelPath}' are missing.`);return n.weightData=function(t){if(Ix){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}(o),n})()}}Xx.URL_SCHEME="localstorage://";const Zx=t=>{return Yg().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Xx.URL_SCHEME)?(e=t.slice(Xx.URL_SCHEME.length),new Xx(e)):null;var e};$x.registerSaveRouter(Zx),$x.registerLoadRouter(Zx);class Yx{constructor(){gg(Yg().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),gg("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return lg(function*(){const e={},n=Vx+Bx,s=Bx+Wx;for(let r=0;r<t.LS.length;++r){const i=t.LS.key(r);i.startsWith(n)&&i.endsWith(s)&&(e[Kx(i)]=JSON.parse(t.LS.getItem(i)))}return e})()}removeModel(t){var e=this;return lg(function*(){var n;const s=qx(t=(n=t).startsWith(Xx.URL_SCHEME)?n.slice(Xx.URL_SCHEME.length):n);if(null==e.LS.getItem(s.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(e.LS.getItem(s.info));return e.LS.removeItem(s.info),e.LS.removeItem(s.topology),e.LS.removeItem(s.weightSpecs),e.LS.removeItem(s.weightData),r})()}}class Qx{constructor(){this.managers={}}static getInstance(){return null==Qx.instance&&(Qx.instance=new Qx),Qx.instance}static registerManager(t,e){gg(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),gg(t.length>0,()=>"scheme must not be an empty string.");const n=Qx.getInstance();gg(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}class Jx{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(Yg().get("IS_BROWSER")){Yg().setPlatform("browser",new Jx);try{Qx.registerManager(Xx.URL_SCHEME,new Yx)}catch(X3){}try{Qx.registerManager(Mx.URL_SCHEME,new zx)}catch(X3){}}let t_;function e_(t,e="float32",n){return e=e||"float32",Hg(t),new Pw(t,e,n)}Yg().get("IS_NODE")&&Yg().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Yg().global.fetch?Yg().global.fetch(t,e):(null==t_&&(t_=n(410)),t_(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const n_=yx({cast_:function(t,e){const n=mx(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return ax.runKernel(ky,{x:n},{dtype:e})}}),s_=yx({clone_:function(t){const e=mx(t,"x","clone","string_or_numeric");return ax.runKernel(pb,{x:e})}});function r_(t){return new Promise(t=>setTimeout(t)).then(t)}ox(),Bw={buffer:e_,cast:n_,clone:s_,print:function(t,e=!1){console.log(t.toString(e))}};class i_{constructor(t){if(!Yg().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(i_.URL_SCHEME)&&(t=t.slice(i_.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}save(t){var e=this;return lg(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./"+e.weightDataFileName],weights:t.weightSpecs}]};null!=t.signature&&(s.signature=t.signature),null!=t.userDefinedMetadata&&(s.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(s.modelInitializer=t.modelInitializer);const r=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),i=null==e.jsonAnchor?document.createElement("a"):e.jsonAnchor;if(i.download=e.modelTopologyFileName,i.href=r,yield r_(()=>i.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==e.weightDataAnchor?document.createElement("a"):e.weightDataAnchor;t.download=e.weightDataFileName,t.href=n,yield r_(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Tx(t)}}})()}}function o_(t,e,n,s){!function(t){gg(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){gg(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`),gg(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`),gg(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`)}(n=null==n?0:n,s=null==s?1:s);let r=0;return Promise.all(t.map(i=>(i.then(i=>{const o=n+ ++r/t.length*(s-n);return e(o),i}),i)))}function a_(t,e){return l_.apply(this,arguments)}function l_(){return(l_=lg(function*(t,e){null==e&&(e={});const n=null==e.fetchFunc?Yg().platform.fetch:e.fetchFunc,s=t.map(t=>n(t,e.requestInit,{isBinary:!0})),r=(null==e.onProgress?yield Promise.all(s):yield o_(s,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?yield Promise.all(r):yield o_(r,e.onProgress,.5,1)})).apply(this,arguments)}i_.URL_SCHEME="downloads://",$x.registerSaveRouter(t=>Yg().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(i_.URL_SCHEME)?function(t="model"){return new i_(t)}(t.slice(i_.URL_SCHEME.length)):null);class u_{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(gg("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=Yg().platform.fetch,gg(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&gg(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}save(t){var e=this;return lg(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:e.DEFAULT_METHOD},e.requestInit);n.body=new FormData;const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:t.weightSpecs}]};null!=t.signature&&(s.signature=t.signature),null!=t.userDefinedMetadata&&(s.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(s.modelInitializer=t.modelInitializer),n.body.append("model.json",new Blob([JSON.stringify(s)],{type:"application/json"}),"model.json"),null!=t.weightData&&n.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=yield e.fetch(e.path,n);if(r.ok)return{modelArtifactsInfo:Tx(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)})()}load(){var t=this;return lg(function*(){const e=yield t.fetch(t.path,t.requestInit);if(!e.ok)throw new Error(`Request to ${t.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield e.json()}catch(f){let e=`Failed to parse model JSON of response from ${t.path}.`;throw t.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const s=n.modelTopology,r=n.weightsManifest,i=n.generatedBy,o=n.convertedBy,a=n.format,l=n.signature,u=n.userDefinedMetadata;if(null==s&&null==r)throw new Error(`The JSON from HTTP path ${t.path} contains neither model topology or manifest for weights.`);let c,h;if(null!=r){const e=yield t.loadWeights(r);[c,h]=e}const d={modelTopology:s,weightSpecs:c,weightData:h,generatedBy:i,convertedBy:o,format:a};null!=l&&(d.signature=l),null!=u&&(d.userDefinedMetadata=u);const p=n.modelInitializer;return p&&(d.modelInitializer=p),d})()}loadWeights(t){var e=this;return lg(function*(){const n=Array.isArray(e.path)?e.path[1]:e.path,[s,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(n),i=e.weightPathPrefix||s,o=[];for(const e of t)o.push(...e.weights);const a=[],l=[];for(const u of t)for(const t of u.paths)null!=e.weightUrlConverter?l.push(e.weightUrlConverter(t)):a.push(i+t+r);return e.weightUrlConverter&&a.push(...yield Promise.all(l)),[o,Ex(yield a_(a,{requestInit:e.requestInit,fetchFunc:e.fetch,onProgress:e.onProgress}))]})()}}function c_(t){return null!=t.match(u_.URL_SCHEME_REGEX)}u_.URL_SCHEME_REGEX=/^https?:\/\//;const h_=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>c_(t)):c_(t),n)return d_(t,e)}return null};function d_(t,e){return new u_(t,e)}function p_(t,e){return d_(t,e)}let f_;function m_(){return(m_=lg(function*(t,e){let n=mx(t,"img","toPixels");if(!(t instanceof Ww)){const t=n;n=n_(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[s,r]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2];if(i>4||2===i)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${i}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const o=yield n.data(),a="float32"===n.dtype?255:1,l=new Uint8ClampedArray(r*s*4);for(let u=0;u<s*r;++u){const t=[0,0,0,255];for(let s=0;s<i;s++){const e=o[u*i+s];if("float32"===n.dtype){if(e<0||e>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${e}.`)}else if("int32"===n.dtype&&(e<0||e>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${e}.`);1===i?(t[0]=e*a,t[1]=e*a,t[2]=e*a):t[s]=e*a}const e=4*u;l[e+0]=Math.round(t[0]),l[e+1]=Math.round(t[1]),l[e+2]=Math.round(t[2]),l[e+3]=Math.round(t[3])}if(null!=e){e.width=r,e.height=s;const t=e.getContext("2d"),n=new ImageData(l,r,s);t.putImageData(n,0,0)}return n!==t&&n.dispose(),l})).apply(this,arguments)}$x.registerSaveRouter(h_),$x.registerLoadRouter(h_);const g_=yx({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,i=!1,o=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)s=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)i=!0;else if(null!=t.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);a=!0}if(r){const e=2;if(r&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=iw(Qv,ax.backendName))return ax.runKernel(Qv,{pixels:t},{numChannels:e});const[l,u]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let c,h;if(o?c=t.getContext("2d").getImageData(0,0,l,u).data:s||n?c=t.data:(i||r||a)&&(null==f_&&(f_=document.createElement("canvas").getContext("2d")),f_.canvas.width=l,f_.canvas.height=u,f_.drawImage(t,0,0,l,u),c=f_.getImageData(0,0,l,u).data),4===e)h=new Int32Array(c);else{const t=l*u;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=c[4*n+t]}return function(t,e,n){if(bg(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const s=dx(t,n);if(3!==s.length&&1!==s.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return vx(t,e,s,n)}(h,[u,l,e],"int32")}});function y_(t,e,n){const s=t.shape.length;gg(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),gg(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)gg(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function b_(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function v_(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function w_(t,e,n,s){const r=[...t];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<n;i++)0===i?r[e]=1:(r.splice(e,0,1),r.pop());return r}function x_(t,e,n){return n<=t?n:n-(e-1)}function __(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function k_(t,e,n,s,r,i,o,a,l){const u=t.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&n>0){const l=e[0],u=n+1;c=C_(o,l,u,s,t),h=I_(a,l,u,r,t),d=w_(i,l,u,t)}else for(let p=0;p<u;p++)c[p]=E_(o,s,i,t,p,l),h[p]=T_(a,r,i,t,p,l),d[p]=S_(i,p,l);return{begin:c,end:h,strides:d}}function C_(t,e,n,s,r){const i=[...r],o=__(n,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const r=x_(e,n,a);let o=s[r];t&1<<r&&(o=0),i[a]=o}return i}function I_(t,e,n,s,r){const i=[...r],o=__(n,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const r=x_(e,n,a);let o=s[r];t&1<<r&&(o=Number.MAX_SAFE_INTEGER),i[a]=o}for(let a=0;a<i.length;a++){const t=r[a];i[a]<0&&(i[a]+=t),i[a]=fg(0,i[a],r[a])}return i}function S_(t,e,n){let s=t[e];return(n&1<<e||null==s)&&(s=1),s}function E_(t,e,n,s,r,i){let o=e[r];(t&1<<r||i&1<<r||null==o)&&(o=(n[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const a=s[r];return o<0&&(o+=a),o=fg(0,o,a-1),o}function T_(t,e,n,s,r,i){let o=e[r];const a=n[r]||1;(t&1<<r||i&1<<r||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=a>0?fg(0,o,l):fg(-1,o,l-1),o}function N_(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function $_(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function A_(t,e,n){let s;const r=t.shape.length;let i;return s="number"==typeof e?[e,...new Array(r-1).fill(0)]:e.length<r?e.concat(new Array(r-e.length).fill(0)):e.slice(),s.forEach(t=>{gg(-1!==t,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,i=i.map((e,n)=>e>=0?e:(gg(-1===e,()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`),t.shape[n]-s[n])),[s,i]}function R_(t,e,n,s,r,i,o,a,l){let u=e.slice(),c=n.slice(),h=s;null==s&&(h=new Array(u.length));const d=b_(o);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==o&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==o&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=t.length-u.length,f=b_(a),m=t.slice();f.forEach(t=>{u[t]=0,c[t]=1,m.splice(t,0,1)});const{begin:g,end:y,strides:b}=k_(m,d,p,u,c,h,r,i,o);u=g,c=y,h=b;const v=b_(l);v.forEach(t=>{c[t]=u[t]+1,h[t]=1});const w=v_(u,c,h),x=w.filter((t,e)=>-1===v.indexOf(e));return{nonStrided:h.every(t=>1===t),$begin:u,$end:c,$strides:h,size:w,newShape:m,outShape:x}}class F_{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class D_{constructor(){this.classNameMap={}}static getMap(){return null==D_.instance&&(D_.instance=new D_),D_.instance}static register(t){D_.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function O_(t){gg(null!=t.className,()=>"Class being registered does not have the static className property defined."),gg("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),gg(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),D_.register(t)}function L_(){return ax}function M_(){return ax.memory()}function P_(t,e){return ax.tidy(t,e)}function z_(t){ex(t).forEach(t=>t.dispose())}function B_(t){return ax.keep(t)}function V_(t,e,n=1){return ax.registerBackend(t,e,n)}function W_(t){return ax.customGrad(t)}function U_(t,e){if((Rg(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&Rg(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return vx(t,[],[],e)}Vw=function(t){Yg().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class j_ extends F_{minimize(t,e=!1,n){const{value:s,grads:r}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:r[t.name]}));this.applyGradients(t)}else this.applyGradients(r);return z_(r),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){gg(Mg(t),()=>"The f passed in variableGrads(f) must be a function"),gg(null==e||Array.isArray(e)&&e.every(t=>t instanceof jw),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in ax.registeredVariables)e.push(ax.registeredVariables[t])}const s=n?e.filter(t=>!t.trainable):null,r=e.length;gg((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:i,grads:o}=ax.gradients(t,e,null,!0);gg(o.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),gg(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const a={};return e.forEach((t,e)=>{null!=o[e]&&(a[t.name]=o[e])}),null!=s&&s.forEach(t=>a[t.name]=null),{value:i,grads:a}}(t,e)}dispose(){null!=this.iterations_&&z_(this.iterations_)}saveIterations(){var t=this;return lg(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:U_(t.iterations_,"int32")}})()}getWeights(){return lg(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return lg(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return lg(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(j_,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const H_=yx({abs_:function(t){const e=mx(t,"x","abs");return ax.runKernel("complex64"===e.dtype?Ey:ny,{x:e})}}),G_=yx({add_:function(t,e){let n=mx(t,"a","add"),s=mx(e,"b","add");return[n,s]=Jw(n,s),ax.runKernel(iy,{a:n,b:s})}}),q_=yx({all_:function(t,e=null,n=!1){const s=mx(t,"x","all","bool");return ax.runKernel(ay,{x:s},{axis:e,keepDims:n})}}),K_=yx({any_:function(t,e=null,n=!1){const s=mx(t,"x","any","bool");return ax.runKernel(ly,{x:s},{axis:e,keepDims:n})}}),X_=yx({argMax_:function(t,e=0){const n=mx(t,"x","argMax");return ax.runKernel(uy,{x:n},{axis:e})}});function Z_(t,e,n,s,r="NHWC",i){return J_(t,[...e,t[3]],n,i,s,null,null,lk(r))}function Y_(t,e,n,s,r,i,o="channelsLast"){const[a,l]=nk(e);let u;if("channelsLast"===o)u=[a,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);u=[a,l,t[1],t[1]]}return J_(t,u,n,s,r,i,!1,o)}function Q_(t,e,n,s,r,i,o="NDHWC"){const[a,l,u]=sk(e);let c,h;if("NDHWC"===o)h="channelsLast",c=[a,l,u,t[4],t[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);h="channelsFirst",c=[a,l,u,t[1],t[1]]}return tk(t,c,n,s,r,!1,h,i)}function J_(t,e,n,s,r,i,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,h,u,c]=t}const[d,p,,f]=e,[m,g]=nk(n),[y,b]=nk(s),v=rk(d,y),w=rk(p,b),{padInfo:x,outHeight:_,outWidth:k}=function(t,e,n,s,r,i,o,a,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const r=function(t,e,n,s,r){null==s&&(s=ek(t,e,n));const i=t[1];return[ik((t[0]-e+2*s)/n+1,r),ik((i-e+2*s)/n+1,r)]}([e,n],i,s,t,a);c=r[0],h=r[1]}else if("same"===t){c=Math.ceil(e/s),h=Math.ceil(n/r);const t=Math.max(0,(c-1)*s+i-e),a=Math.max(0,(h-1)*r+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(a/2);u={top:l,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/s),h=Math.ceil((n-o+1)/r);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=ik((e-i+d+p)/s+1,a),h=ik((n-o+f+m)/r+1,a)}}return{padInfo:u,outHeight:c,outWidth:h}}(r,u,c,m,g,v,w,i,a),C=o?f*h:f;let I;return"channelsFirst"===a?I=[l,C,_,k]:"channelsLast"===a&&(I=[l,_,k,C]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:_,outWidth:k,outChannels:C,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:t,outShape:I,filterShape:e}}function tk(t,e,n,s,r,i=!1,o="channelsLast",a){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h,d]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c,h]=t}const[p,f,m,,g]=e,[y,b,v]=sk(n),[w,x,_]=sk(s),k=rk(p,w),C=rk(f,x),I=rk(m,_),{padInfo:S,outDepth:E,outHeight:T,outWidth:N}=function(t,e,n,s,r,i,o,a,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,s,r,i){null==r&&(r=ek(t,e,s));const o=t[1],a=t[2];return[ik((t[0]-e+2*r)/s+1,i),ik((o-e+2*r)/s+1,i),ik((a-e+2*r)/s+1,i),1]}([e,n,s,1],a,0,r,t,c);d=i[0],p=i[1],f=i[2]}else if("same"===t){d=Math.ceil(e/r),p=Math.ceil(n/i),f=Math.ceil(s/o);const t=(d-1)*r+a-e,c=(p-1)*i+l-n,m=(f-1)*o+u-s,g=Math.floor(t/2),y=t-g,b=Math.floor(c/2),v=c-b,w=Math.floor(m/2);h={top:b,bottom:v,left:w,right:m-w,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/r),p=Math.ceil((n-l+1)/i),f=Math.ceil((s-u+1)/o)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,u,c,h,y,b,v,k,C,I,a),$=i?g*d:g;let A;return"channelsFirst"===o?A=[l,$,E,T,N]:"channelsLast"===o&&(A=[l,E,T,N,$]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:E,outHeight:T,outWidth:N,outChannels:$,padInfo:S,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationDepth:w,dilationHeight:x,dilationWidth:_,inShape:t,outShape:A,filterShape:e}}function ek(t,e,n,s=1){const r=rk(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function nk(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function sk(t){return"number"==typeof t?[t,t,t]:t}function rk(t,e){return e<=1?t:t+(t-1)*(e-1)}function ik(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function ok(t){const[e,n,s]=nk(t);return 1===e&&1===n&&1===s}function ak(t,e){return ok(t)||ok(e)}function lk(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const uk=yx({reshape_:function(t,e){const n=mx(t,"x","reshape","string_or_numeric");return ax.runKernel(ov,{x:n},{shape:e})}}),ck=yx({avgPool_:function(t,e,n,s,r){const i=mx(t,"x","avgPool","float32");gg(ak(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let o=i,a=!1;3===i.rank&&(a=!0,o=uk(i,[1,i.shape[0],i.shape[1],i.shape[2]])),gg(4===o.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),null!=r&&gg(_g(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let l=ax.runKernel(gy,{x:o},{filterSize:e,strides:n,pad:s,dimRoundingMode:r});return l=n_(l,i.dtype),a?uk(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),hk=yx({avgPool3d_:function(t,e,n,s,r,i="NDHWC"){const o=mx(t,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=uk(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),gg(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),gg("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=r&&gg(_g(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let u=ax.runKernel(by,{x:a},{filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i});return u=n_(u,a.dtype),l?uk(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),dk=yx({batchNorm_:function(t,e,n,s,r,i){null==i&&(i=.001);const o=mx(t,"x","batchNorm"),a=mx(e,"mean","batchNorm"),l=mx(n,"variance","batchNorm");let u,c;null!=r&&(u=mx(r,"scale","batchNorm")),null!=s&&(c=mx(s,"offset","batchNorm")),gg(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),gg(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),gg(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(t){let e;return e=0===t.rank||1===t.rank?uk(t,[1,1,1,t.size]):2===t.rank?uk(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?uk(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),d=ax.runKernel(lb,{x:h,scale:u,offset:c,mean:a,variance:l},{varianceEpsilon:i});return uk(d,o.shape)}}),pk=yx({batchNorm2d_:function(t,e,n,s,r,i){const o=mx(t,"x","batchNorm"),a=mx(e,"mean","batchNorm"),l=mx(n,"variance","batchNorm");let u,c;return null!=r&&(u=mx(r,"scale","batchNorm")),null!=s&&(c=mx(s,"offset","batchNorm")),gg(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),gg(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),gg(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&gg(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&gg(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),dk(o,a,l,c,u,i)}}),fk=yx({batchNorm3d_:function(t,e,n,s,r,i){const o=mx(t,"x","batchNorm"),a=mx(e,"mean","batchNorm"),l=mx(n,"variance","batchNorm");let u,c;return null!=r&&(u=mx(r,"scale","batchNorm")),null!=s&&(c=mx(s,"offset","batchNorm")),gg(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),gg(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),gg(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&gg(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&gg(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),dk(o,a,l,c,u,i)}}),mk=yx({batchNorm4d_:function(t,e,n,s,r,i){const o=mx(t,"x","batchNorm"),a=mx(e,"mean","batchNorm"),l=mx(n,"variance","batchNorm");let u,c;return null!=r&&(u=mx(r,"scale","batchNorm")),null!=s&&(c=mx(s,"offset","batchNorm")),gg(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),gg(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),gg(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&gg(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&gg(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),dk(o,a,l,c,u,i)}}),gk=yx({clipByValue_:function(t,e,n){const s=mx(t,"x","clipByValue");return gg(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),ax.runKernel(Iy,{x:s},{clipValueMin:e,clipValueMax:n})}}),yk=yx({concat_:function(t,e=0){gg(t.length>=1,()=>"Pass at least one tensor to concat");const n=gx(t,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}),1===n.length?s_(n[0]):ax.runKernel(Ty,n,{axis:e})}}),bk=yx({concat1d_:function(t){return yk(t,0)}}),vk=yx({concat2d_:function(t,e){return yk(t,e)}}),wk=yx({concat3d_:function(t,e){return yk(t,e)}}),xk=yx({concat4d_:function(t,e){return yk(t,e)}}),_k=yx({conv2d_:function(t,e,n,s,r="NHWC",i=[1,1],o){const a=mx(t,"x","conv2d"),l=mx(e,"filter","conv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=uk(a,[1,a.shape[0],a.shape[1],a.shape[2]])),gg(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),gg(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=o&&gg(_g(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const h="NHWC"===r?u.shape[3]:u.shape[1];gg(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),gg(ak(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const d=ax.runKernel(Ny,{x:u,filter:l},{strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o});return c?uk(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),kk=yx({conv1d_:function(t,e,n,s,r="NWC",i=1,o){const a=mx(t,"x","conv1d"),l=mx(e,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=uk(a,[1,a.shape[0],a.shape[1]])),gg(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),gg(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=o&&gg(_g(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),gg(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),gg(ak(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),gg("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=uk(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=uk(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=_k(d,h,[1,n],s,"NHWC",[1,i],o);return uk(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),Ck=yx({conv2DBackpropInput_:function(t,e,n,s,r,i="NHWC",o){gg(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,u=!1;3===e.rank&&(u=!0,l=uk(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),gg(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),gg(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),gg(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===i?a[3]:a[1],h="NHWC"===i?l.shape[3]:l.shape[1];gg(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),gg(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=o&&gg(_g(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const d=ax.runKernel(Ay,{dy:l,filter:n},{strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a});return u?uk(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Ik=yx({conv2dTranspose_:function(t,e,n,s,r,i){const o=mx(t,"x","conv2dTranspose"),a=mx(e,"filter","conv2dTranspose");return Ck(n,o,a,s,r,"NHWC",i)}}),Sk=yx({conv3d_:function(t,e,n,s,r="NDHWC",i=[1,1,1]){const o=mx(t,"x","conv3d"),a=mx(e,"filter","conv3d");let l=o,u=!1;4===o.rank&&(u=!0,l=uk(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),gg(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),gg(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),gg(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),gg(ak(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),gg("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const c=ax.runKernel(Ry,{x:l,filter:a},{strides:n,pad:s,dataFormat:r,dilations:i});return u?uk(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),Ek=yx({conv3DBackpropInput_:function(t,e,n,s,r){gg(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,o=e,a=!1;4===e.rank&&(a=!0,o=uk(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=o.shape[4];gg(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),gg(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),gg(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),gg(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),gg(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c=ax.runKernel(Dy,{dy:o,filter:n},{pad:r,strides:s,inputShape:i});return a?uk(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),Tk=yx({conv3dTranspose_:function(t,e,n,s,r){const i=mx(t,"x","conv3dTranspose"),o=mx(e,"filter","conv3dTranspose");return Ek(n,i,o,s,r)}}),Nk=yx({depthwiseConv2d_:function(t,e,n,s,r="NHWC",i=[1,1],o){const a=mx(t,"x","depthwiseConv2d"),l=mx(e,"filter","depthwiseConv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=uk(a,[1,a.shape[0],a.shape[1],a.shape[2]])),gg(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),gg(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),gg(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=o&&gg(_g(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const h=ax.runKernel(Vy,{x:u,filter:l},{strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o});return c?uk(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),$k=yx({floorDiv_:function(t,e){let n=mx(t,"a","floorDiv"),s=mx(e,"b","floorDiv");return[n,s]=Jw(n,s),ax.runKernel(ab,{a:n,b:s})}}),Ak=yx({div_:function(t,e){let n=mx(t,"a","div"),s=mx(e,"b","div");return[n,s]=Jw(n,s),"int32"===n.dtype&&"int32"===s.dtype?$k(n,s):ax.runKernel(Ky,{a:n,b:s},{})}}),Rk=yx({elu_:function(t){const e=mx(t,"x","elu");return ax.runKernel(Zy,{x:e})}});function Fk(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const i=n-1-r,o=t[i]||1;(e[e.length-1-r]||1)>1&&1===o&&s.unshift(i)}return s}function Dk(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],i=e.length-s-1,o=e[i];(null==r||1===r&&o>1)&&n.unshift(i)}return n}function Ok(t,e){const n=[],s=Math.max(t.length,e.length);for(let r=0;r<s;r++){let s=t[t.length-r-1];null==s&&(s=1);let i=e[e.length-r-1];if(null==i&&(i=1),1===s)n.unshift(i);else if(1===i)n.unshift(s);else{if(s!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(s)}}return n}const Lk=yx({equal_:function(t,e){let n=mx(t,"a","equal","string_or_numeric"),s=mx(e,"b","equal","string_or_numeric");return[n,s]=Jw(n,s),Ok(n.shape,s.shape),ax.runKernel(Jy,{a:n,b:s})}}),Mk=yx({expandDims_:function(t,e=0){const n=mx(t,"x","expandDims","string_or_numeric");return gg(e<=n.rank,()=>"Axis must be <= rank of the tensor"),ax.runKernel(eb,{input:n},{dim:e})}}),Pk=yx({tile_:function(t,e){const n=mx(t,"x","tile","string_or_numeric");return gg(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`),ax.runKernel(Uv,{x:n},{reps:e})}}),zk=yx({eye_:function(t,e,n,s="float32"){null==e&&(e=t);const r=e_([t,e],s),i=t<=e?t:e;for(let a=0;a<i;++a)r.set(1,a,a);const o=uk(r.toTensor(),[t,e]);if(null==n)return o;if(1===n.length)return Pk(Mk(o,0),[n[0],1,1]);if(2===n.length)return Pk(Mk(Mk(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Pk(Mk(Mk(Mk(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function Bk(t,e,n){return ax.runKernel(rb,{},{shape:t,value:e,dtype:n})}const Vk=yx({floor_:function(t){const e=mx(t,"x","floor");return ax.runKernel(ob,{x:e})}}),Wk=yx({gather_:function(t,e,n=0,s=0){const r=mx(t,"x","gather"),i=mx(e,"indices","gather","int32");return ax.runKernel(ub,{x:r,indices:i},{axis:n,batchDims:s})}}),Uk=yx({greater_:function(t,e){let n=mx(t,"a","greater","string_or_numeric"),s=mx(e,"b","greater","string_or_numeric");return[n,s]=Jw(n,s),Ok(n.shape,s.shape),ax.runKernel(hb,{a:n,b:s})}}),jk=yx({greaterEqual_:function(t,e){let n=mx(t,"a","greaterEqual","string_or_numeric"),s=mx(e,"b","greaterEqual","string_or_numeric");return[n,s]=Jw(n,s),Ok(n.shape,s.shape),ax.runKernel(db,{a:n,b:s})}}),Hk=yx({leakyRelu_:function(t,e=.2){const n=mx(t,"x","leakyRelu");return ax.runKernel(vb,{x:n},{alpha:e})}}),Gk=yx({log_:function(t){const e=mx(t,"x","log");return ax.runKernel(kb,{x:e})}}),qk=yx({exp_:function(t){const e=mx(t,"x","exp");return ax.runKernel(tb,{x:e})}}),Kk=yx({max_:function(t,e=null,n=!1){const s=mx(t,"x","max");return ax.runKernel($b,{x:s},{reductionIndices:e,keepDims:n})}}),Xk=yx({mul_:function(t,e){let n=mx(t,"a","mul"),s=mx(e,"b","mul");return[n,s]=Jw(n,s),ax.runKernel(Ub,{a:n,b:s})}}),Zk=yx({sub_:function(t,e){let n=mx(t,"a","sub"),s=mx(e,"b","sub");return[n,s]=Jw(n,s),ax.runKernel(Bv,{a:n,b:s})}}),Yk=yx({sum_:function(t,e=null,n=!1){let s=mx(t,"x","sum");return"bool"===s.dtype&&(s=n_(s,"int32")),ax.runKernel(Iv,{x:s},{axis:e,keepDims:n})}}),Qk=yx({logSoftmax_:function(t,e=-1){const n=mx(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return W_((t,n)=>{const s=Kk(t,e,!0),r=Zk(t,s),i=Zk(n_(r,"float32"),Gk(Yk(qk(r),e,!0)));return n([i]),{value:i,gradFunc:(t,n)=>{const[s]=n,r=qk(s);return Zk(t,Xk(Yk(t,e,!0),r))}}})(n)}}),Jk=yx({logicalAnd_:function(t,e){const n=mx(t,"a","logicalAnd","bool"),s=mx(e,"b","logicalAnd","bool");return Ok(n.shape,s.shape),ax.runKernel(Ib,{a:n,b:s})}}),tC=yx({maxPool_:function(t,e,n,s,r){const i=mx(t,"x","maxPool");let o=i,a=!1;3===i.rank&&(a=!0,o=uk(i,[1,i.shape[0],i.shape[1],i.shape[2]])),gg(4===o.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),gg(ak(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=r&&gg(_g(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l=ax.runKernel(Rb,{x:o},{filterSize:e,strides:n,pad:s,dimRoundingMode:r});return a?uk(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),eC=yx({maxPool3d_:function(t,e=[1,1,1],n,s,r,i="NDHWC"){const o=mx(t,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=uk(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),gg(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),gg("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=r&&gg(_g(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const u=ax.runKernel(Db,{x:a},{filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i});return l?uk(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),nC=yx({maximum_:function(t,e){let n=mx(t,"a","maximum"),s=mx(e,"b","maximum");return[n,s]=Jw(n,s),"bool"===n.dtype&&(n=n_(n,"int32"),s=n_(s,"int32")),Ok(n.shape,s.shape),ax.runKernel(Ab,{a:n,b:s})}}),sC=yx({mean_:function(t,e=null,n=!1){const s=mx(t,"x","mean");return ax.runKernel(Mb,{x:s},{axis:e,keepDims:n})}}),rC=yx({minimum_:function(t,e){let n=mx(t,"a","minimum"),s=mx(e,"b","minimum");return[n,s]=Jw(n,s),"bool"===n.dtype&&(n=n_(n,"int32"),s=n_(s,"int32")),Ok(n.shape,s.shape),ax.runKernel(zb,{a:n,b:s})}});function iC(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function oC(t,e,n){const s=t.length+e.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)-1===n.indexOf(a)?r.push(t[i++]):r.push(e[o++]);return r}function aC(t,e){const n=[],s=t.length;for(let r=0;r<s;r++)-1===e.indexOf(r)&&n.push(t[r]);return[n,e.map(e=>t[e])]}function lC(t,e){return oC(t,e.map(t=>1),e)}function uC(t,e,n){gg(iC(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function cC(t,e){if(iC(t,e))return null;const n=[];for(let s=0;s<e;++s)-1===t.indexOf(s)&&n.push(s);return t.forEach(t=>n.push(t)),n}function hC(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function dC(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}const pC=yx({square_:function(t){const e=mx(t,"x","square");return ax.runKernel("Square",{x:e},{})}}),fC=yx({moments_:function(t,e=null,n=!1){const s=Eg(e,(t=mx(t,"x","moments")).shape),r=sC(t,s,n);let i=r.shape;n||(i=lC(r.shape,s));const o=pC(Zk(n_(t,"float32"),uk(r,i)));return{mean:r,variance:sC(o,s,n)}}}),mC=yx({neg_:function(t){const e=mx(t,"x","neg");return ax.runKernel(jb,{x:e})}}),gC=yx({notEqual_:function(t,e){let n=mx(t,"a","notEqual","string_or_numeric"),s=mx(e,"b","notEqual","string_or_numeric");return[n,s]=Jw(n,s),Ok(n.shape,s.shape),ax.runKernel(Hb,{a:n,b:s})}}),yC=yx({oneHot_:function(t,e,n=1,s=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const r=mx(t,"indices","oneHot","int32");return ax.runKernel(Zb,{indices:r},{depth:e,onValue:n,offValue:s})}});function bC(t,e="float32"){if("complex64"===e){const e=bC(t,"float32"),n=bC(t,"float32");return bx(e,n)}const n=Ug(wg(t),e);return ax.makeTensor(n,t,e)}function vC(t,e="float32"){if("complex64"===e){const e=vC(t,"float32"),n=bC(t,"float32");return bx(e,n)}const n=Wg(wg(t),e);return ax.makeTensor(n,t,e)}const wC=yx({onesLike_:function(t){const e=mx(t,"x","onesLike");return ax.runKernel(Xb,{x:e})}}),xC=yx({pad_:function(t,e,n=0){const s=mx(t,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return ax.runKernel(Qb,{x:s},{paddings:e,constantValue:n})}}),_C=yx({prelu_:function(t,e){const n=mx(t,"x","prelu"),s=mx(e,"alpha","prelu");return ax.runKernel(tv,{x:n,alpha:s})}});var kC=n(566);class CC{constructor(t,e,n,s,r){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=r||Math.random();this.random=kC.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let s,r,i;do{s=2*this.random()-1,r=2*this.random()-1,i=s*s+r*r}while(i>=1||0===i);const o=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*o,e=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class IC{constructor(t=0,e=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=kC.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const SC=yx({randomNormal_:function(t,e=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const i=new CC(e,n,s,!1,r),o=e_(t,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),EC=yx({randomUniform_:function(t,e=0,n=1,s="float32",r){const i=e_(t,s),o=new IC(e,n,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),TC=yx({relu_:function(t){const e=mx(t,"x","relu");return ax.runKernel(iv,{x:e})}}),NC=yx({reverse_:function(t,e){const n=mx(t,"x","reverse");return ax.runKernel(dv,{x:n},{dims:e})}}),$C=yx({selu_:function(t){const e=mx(t,"x","selu");return ax.runKernel(yv,{x:e})}}),AC=yx({separableConv2d_:function(t,e,n,s,r,i=[1,1],o="NHWC"){const a=mx(t,"x","separableConv2d"),l=mx(e,"depthwiseFilter","separableConv2d"),u=mx(n,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(3===a.rank&&(h=!0,c=uk(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");gg(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),gg(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),gg(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),gg(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),gg(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];gg(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=Nk(c,l,s,r,o,i),m=_k(f,u,1,"valid",o);return h?uk(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),RC=yx({sigmoid_:function(t){const e=mx(t,"x","sigmoid");return ax.runKernel(_v,{x:e})}}),FC=yx({slice_:function(t,e,n){const s=mx(t,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");return ax.runKernel(bv,{x:s},{begin:e,size:n})}}),DC=yx({slice1d_:function(t,e,n){const s=mx(t,"x","slice1d");return gg(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),FC(s,[e],[n])}}),OC=yx({slice2d_:function(t,e,n){const s=mx(t,"x","slice2d");return gg(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),FC(s,e,n)}}),LC=yx({slice3d_:function(t,e,n){const s=mx(t,"x","slice3d");return gg(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),FC(s,e,n)}}),MC=yx({slice4d_:function(t,e,n){const s=mx(t,"x","slice4d");return gg(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),FC(s,e,n)}}),PC=yx({softmax_:function(t,e=-1){const n=mx(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);return ax.runKernel(Tv,{logits:n},{dim:e})}}),zC=yx({softplus_:function(t){const e=mx(t,"x","softplus");return ax.runKernel(kv,{x:e})}}),BC=yx({split_:function(t,e,n=0){const s=mx(t,"x","split");return ax.runKernel(Ev,{x:s},{numOrSizeSplits:e,axis:n})}}),VC=yx({sqrt_:function(t){const e=mx(t,"x","sqrt");return ax.runKernel(Cv,{x:e})}}),WC=yx({squeeze_:function(t,e){const n=mx(t,"x","squeeze");return uk(n,Tg(n.shape,e).newShape)}}),UC=yx({stack_:function(t,e=0){const n=gx(t,"tensors","stack","string_or_numeric");return gg(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&gg(e<=n[0].rank,()=>"Axis must be <= rank of the tensor"),ax.runKernel(Yb,n,{axis:e})}}),jC=yx({tanh_:function(t){const e=mx(t,"x","tanh");return ax.runKernel(Wv,{x:e})}});function HC(t,e){bg(t);const n=dx(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return vx(t,null,n,e)}const GC=yx({truncatedNormal_:function(t,e=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const i=new CC(e,n,s,!0,r),o=e_(t,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),qC=yx({unstack_:function(t,e=0){const n=mx(t,"x","unstack","string_or_numeric");return gg(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`),ax.runKernel(Kv,{value:n},{axis:e})}}),KC=yx({broadcastTo_:function(t,e){let n=mx(t,"broadcastTo","x");const s=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=uk(n,t)}const r=n.shape,i=Array.from(e);for(let o=e.length-1;o>=0;o--)if(r[o]===e[o])i[o]=1;else if(1!==n.shape[o])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);return 0===i.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length?s_(n):ax.runKernel(Uv,{x:n},{reps:i})}}),XC=yx({where_:function(t,e,n){const s=mx(e,"a","where"),r=mx(n,"b","where"),i=mx(t,"condition","where","bool"),o=Ok(Ok(i.shape,s.shape),r.shape),a=KC(i,o),l=KC(s,o),u=KC(r,o);return ax.runKernel(gv,{condition:a,t:l,e:u})}}),ZC=yx({zerosLike_:function(t){const e=mx(t,"x","zerosLike");return ax.runKernel(Zv,{x:e})}}),YC=yx({transpose_:function(t,e){const n=mx(t,"x","transpose");return null==e&&(e=n.shape.map((t,e)=>e).reverse()),gg(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{gg(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`)}),n.rank<=1?n.clone():ax.runKernel(Gv,{x:n},{perm:e})}}),QC=yx({dropout_:function(t,e,n,s){const r=mx(t,"x","dropout");if(gg("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),gg(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof Ww?r.clone():r;const i=function(t,e){if(null==e)return t.shape.slice();if(xg(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)n.push(null==e[s]&&null!=t.shape[s]?t.shape[s]:e[s]);return n}return e}(r,n),o=1-e,a=Ak(Vk(G_(EC(i,0,1,"float32",s),o)),o);return Xk(r,a)}}),JC=yx({imag_:function(t){const e=mx(t,"input","imag");return ax.runKernel(mb,{input:e})}}),tI=yx({real_:function(t){const e=mx(t,"input","real");return ax.runKernel(sv,{input:e})}}),eI=yx({fft_:function(t){return gg("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),ax.runKernel(sb,{input:t})}}),nI=yx({rfft_:function(t,e){gg("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(null!=e&&e<n){const s=t.shape.map(t=>0),i=t.shape.map(t=>t);i[t.shape.length-1]=e,r=FC(t,s,i),n=e}else if(null!=e&&e>n){const s=t.shape.map(t=>t);s[t.shape.length-1]=e-n,r=yk([t,bC(s)],t.shape.length-1),n=e}else r=t;const i=ZC(r),o=uk(bx(r,i),[s,n]),a=eI(o),l=Math.floor(n/2)+1,u=tI(a),c=JC(a),h=BC(u,[l,n-l],u.shape.length-1),d=BC(c,[l,n-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,uk(bx(h[0],d[0]),p)}}),sI=yx({ifft_:function(t){return gg("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),ax.runKernel(fb,{input:t})}}),rI=yx({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=uk(t,[n,e]);s=sI(r)}else{const r=[n,2*(e-1)],i=uk(tI(t),[n,e]),o=uk(JC(t),[n,e]),a=NC(FC(i,[0,1],[n,e-2]),1),l=Xk(NC(FC(o,[0,1],[n,e-2]),1),U_(-1)),u=yk([i,a],1),c=yk([o,l],1),h=uk(bx(u,c),[r[0],r[1]]);s=sI(h)}if(s=tI(s),3===t.rank&&0!==t.shape[0]){const e=s,n=t.shape[0];s=uk(s,[n,s.shape[0]/n,s.shape[1]]),e.dispose()}return s}}),iI=yx({conv2DBackpropFilter_:function(t,e,n,s,r,i="NHWC",o){let a=t;3===t.rank&&(a=uk(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=uk(e,[1,e.shape[0],e.shape[1],e.shape[2]])),gg(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),gg(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),gg(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u="NHWC"===i?a.shape[3]:a.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];return gg(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),gg(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=o&&gg(_g(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),ax.runKernel($y,{x:a,dy:l},{strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:n})}}),oI=yx({relu6_:function(t){const e=mx(t,"x","relu6");return ax.runKernel(hv,{x:e})}}),aI=yx({step_:function(t,e=0){const n=mx(t,"x","step");return ax.runKernel(Yv,{x:n},{alpha:e})}});function lI(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return Xk(t,aI(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function uI(t,e){let n=e;const s=Dk(t.shape,e.shape);return s.length>0&&(n=Yk(n,s)),uk(n,t.shape)}function cI(t,e,n,s){if("linear"===e)return t;if("relu"===e)return TC(t);if("elu"===e)return Rk(t);if("relu6"===e)return oI(t);if("prelu"===e)return _C(t,n);if("leakyrelu"===e)return Hk(t,s);if("sigmoid"===e)return RC(t);throw new Error(`Unknown fused activation ${e}.`)}const hI=(t,e)=>!(t>0)||"linear"===e,dI=yx({fusedConv2d_:function({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===hI(ax.state.gradientDepth,l=l||"linear")){let h=_k(t,e,n,s,r,i,o);return null!=a&&(h=G_(h,a)),cI(h,l,u,c)}const h=mx(t,"x","conv2d"),d=mx(e,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=uk(h,[1,h.shape[0],h.shape[1],h.shape[2]])),gg(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),gg(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=o&&gg(_g(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),gg(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),gg(ak(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),gg("NHWC"===r,()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=J_(p.shape,d.shape,n,i,s,o);let g,y;null!=a&&(g=mx(a,"bias","fused conv2d"),[g]=Jw(g,h),Ok(m.outShape,g.shape)),null!=u&&(y=mx(u,"prelu weights","fused conv2d"));const b=(t,e)=>{const[r,o,a,u]=e,c=lI(t,a,l);gg(ok(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const h=[Ck(o.shape,c,r,n,s),iI(o,c,r.shape,n,s)];if(null!=u){const t=uI(u,c);h.push(t)}return h},v={x:p,filter:d,bias:g,preluActivationWeights:y},w={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return null==a?W_((t,e,n)=>{let s=ax.runKernel(ew,v,w);return n([e,t,s]),f&&(s=uk(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d):W_((t,e,n,s)=>{let r=ax.runKernel(ew,v,w);return s([e,t,r,n]),f&&(r=uk(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d,g)}}),pI=yx({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,s,r,i=[1,1],o){let a=t;3===t.rank&&(a=uk(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;return 3===l.rank&&(l=uk(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ax.runKernel(Wy,{x:a,dy:l},{strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:n})}}),fI=yx({depthwiseConv2dNativeBackpropInput_:function(t,e,n,s,r,i=[1,1],o){let a=e,l=!1;3===e.rank&&(l=!0,a=uk(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u=ax.runKernel(Uy,{dy:a,filter:n},{strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:t});return l?uk(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});yx({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===hI(ax.state.gradientDepth,l)){let h=Nk(t,e,n,s,r,i,o);return null!=a&&(h=G_(h,a)),cI(h,l,u,c)}const h=mx(t,"x","depthwiseConv2d"),d=mx(e,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=uk(h,[1,h.shape[0],h.shape[1],h.shape[2]])),gg(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),gg(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),gg(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==i&&(i=[1,1]),gg(ak(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),null!=o&&gg(_g(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${s}.`);const m=J_(p.shape,d.shape,n,i,s,o,!0);let g,y;null!=a&&(g=mx(a,"bias","fused conv2d"),[g]=Jw(g,h),Ok(m.outShape,g.shape)),null!=u&&(y=mx(u,"prelu weights","fused depthwiseConv2d"));const b=(t,e)=>{gg(ok(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[r,a,u,c]=e,h=lI(t,u,l),d=fI(a.shape,h,r,n,s,i,o),p=pI(a,h,r.shape,n,s,i,o);return null!=c?[d,p,uI(g,h)]:[d,p]},v={x:p,filter:d,bias:g,preluActivationWeights:y},w={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return null==a?W_((t,e,n)=>{let s=ax.runKernel(nw,v,w);return n([e,t,s]),f&&(s=uk(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d):W_((t,e,n,s)=>{let r=ax.runKernel(nw,v,w);return s([e,t,r,n]),f&&(r=uk(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d,g)}});const mI=yx({matMul_:function(t,e,n=!1,s=!1){let r=mx(t,"a","matMul"),i=mx(e,"b","matMul");return[r,i]=Jw(r,i),ax.runKernel(wy,{a:r,b:i},{transposeA:n,transposeB:s})}}),gI=yx({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a}){if(!1===hI(ax.state.gradientDepth,i)){let l=mI(t,e,n,s);return null!=r&&(l=G_(l,r)),cI(l,i,o,a)}let l=mx(t,"a","fused matMul"),u=mx(e,"b","fused matMul");[l,u]=Jw(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=wg(f),y=wg(m);gg(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),gg(xg(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),gg(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${s} must match.`);const b=l.shape.slice(0,-2).concat([d,p]),v=uk(l,n?[g,c,d]:[g,d,c]),w=uk(u,s?[y,p,h]:[y,h,p]);let x,_;null!=r&&(x=mx(r,"bias","fused matMul"),[x]=Jw(x,l),Ok(b,x.shape)),null!=o&&(_=mx(o,"prelu weights","fused matMul"));const k=(t,e)=>{const[o,a,l,u]=e,c=lI(uk(t,l.shape),l,i);let h,d;return n||s?!n&&s?(h=mI(c,a,!1,!1),d=mI(c,o,!0,!1)):n&&!s?(h=mI(a,c,!1,!0),d=mI(o,c,!1,!1)):(h=mI(a,c,!0,!0),d=mI(c,o,!0,!0)):(h=mI(c,a,!1,!0),d=mI(o,c,!0,!1)),null!=r?[h,d,uI(u,c)]:[h,d]},C={a:v,b:w,bias:x,preluActivationWeights:_},I={transposeA:n,transposeB:s,activation:i,leakyreluAlpha:a};return null==r?W_((t,e,n)=>{const s=ax.runKernel(tw,C,I);return n([t,e,s]),{value:uk(s,b),gradFunc:k}})(v,w):W_((t,e,n,s)=>{const r=ax.runKernel(tw,C,I);return s([t,e,r,n]),{value:uk(r,b),gradFunc:k}})(v,w,x)}});function yI(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let i=0;i<t;++i){const o=2*Math.PI*i/(t+s-1);r[i]=e-n*Math.cos(o)}return HC(r,"float32")}yx({hammingWindow_:function(t){return yI(t,.54,.46)}});const bI=yx({hannWindow_:function(t){return yI(t,.5,.5)}});function vI(t,e,n){if(bg(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const s=dx(t,n);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return vx(t,e,s,n)}const wI=yx({frame_:function(t,e,n,s=!1,r=0){let i=0;const o=[];for(;i+e<=t.size;)o.push(FC(t,i,e)),i+=n;if(s)for(;i<t.size;){const s=i+e-t.size,a=yk([FC(t,i,e-s),Bk([s],r)]);o.push(a),i+=n}return 0===o.length?vI([],[0,e]):uk(yk(o),[o.length,e])}});function xI(t,e,n,s,r,i){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=t.shape[0];return n=Math.min(n,o),gg(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),gg(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),gg(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),gg(1===e.rank,()=>"scores must be a 1D tensor"),gg(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),gg(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function _I(t,e,n){const s=function(t,e,n){return function(t,e,n){let s=0,r=t.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=n(e,t[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}(t,e,n||kI)}(t,e,n);t.splice(s<0?-(s+1):s,0,e)}function kI(t,e){return t>e?1:t<e?-1:0}function CI(t,e,n,s,r){return EI(t,e,n,s,r,0)}function II(t,e,n,s,r,i){return EI(t,e,n,s,r,0,!1,i,!0)}function SI(t,e,n,s,r,i){return EI(t,e,n,s,r,i,!0)}function EI(t,e,n,s,r,i,o=!1,a=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>r&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort($I);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:o}=e;if(n<r)break;let a=!1;for(let l=h.length-1;l>=o;--l){const n=TI(t,i,h[l]);if(n>=s){a=!0;break}if(e.score=e.score*NI(s,c,n),e.score<=r)break}e.suppressBeginIndex=h.length,a||(e.score===n?(h.push(i),d.push(e.score)):e.score>r&&_I(u,e,$I))}const p=h.length,f=n-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function TI(t,e,n){const s=t.subarray(4*e,4*e+4),r=t.subarray(4*n,4*n+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-i)*(l-o),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(i,u),g=Math.max(o,c),y=Math.min(a,h),b=Math.min(l,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function NI(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function $I(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}yx({stft_:function(t,e,n,s,r=bI){null==s&&(s=Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2)))));const i=wI(t,e,n),o=Xk(i,r(e));return nI(o,s)}}),yx({cropAndResize_:function(t,e,n,s,r="bilinear",i=0){const o=mx(t,"image","cropAndResize"),a=mx(e,"boxes","cropAndResize","float32"),l=mx(n,"boxInd","cropAndResize","int32"),u=a.shape[0];return gg(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),gg(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),gg(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),gg(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),gg(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),gg("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),ax.runKernel(Py,{image:o,boxes:a,boxInd:l},{method:r,extrapolationValue:i,cropSize:s})}}),yx({flipLeftRight_:function(t){const e=mx(t,"image","flipLeftRight","float32");return gg(4===e.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`),ax.runKernel(ib,{image:e},{})}}),yx({rotateWithOffset_:function(t,e,n=0,s=.5){const r=mx(t,"image","rotateWithOffset","float32");return gg(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),ax.runKernel(Jv,{image:r},{radians:e,fillValue:n,center:s})}}),yx({nonMaxSuppression_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=mx(t,"boxes","nonMaxSuppression"),o=mx(e,"scores","nonMaxSuppression"),a=xI(i,o,n,s,r);return ax.runKernel(Gb,{boxes:i,scores:o},{maxOutputSize:n=a.maxOutputSize,iouThreshold:s=a.iouThreshold,scoreThreshold:r=a.scoreThreshold})}}),yx({nonMaxSuppressionWithScore_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=mx(t,"boxes","nonMaxSuppression"),a=mx(e,"scores","nonMaxSuppression"),l=xI(o,a,n,s,r,i),u=ax.runKernel(Kb,{boxes:o,scores:a},{maxOutputSize:n=l.maxOutputSize,iouThreshold:s=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:u[0],selectedScores:u[1]}}}),yx({nonMaxSuppressionPadded_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=mx(t,"boxes","nonMaxSuppression"),a=mx(e,"scores","nonMaxSuppression"),l=xI(o,a,n,s,r,null),u=ax.runKernel(qb,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:u[0],validOutputs:u[1]}}});const AI=yx({resizeBilinear_:function(t,e,n=!1,s=!1){const r=mx(t,"images","resizeBilinear");gg(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),gg(2===e.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),gg(!1===s||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;3===r.rank&&(o=!0,i=uk(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,a=ax.runKernel(uv,{images:i},{alignCorners:n,halfPixelCenters:s,size:e});return o?uk(a,[a.shape[1],a.shape[2],a.shape[3]]):a}}),RI=yx({resizeNearestNeighbor_:function(t,e,n=!1,s=!1){const r=mx(t,"images","resizeNearestNeighbor");gg(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),gg(2===e.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),gg("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),gg(!1===s||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;3===r.rank&&(o=!0,i=uk(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,a=ax.runKernel(av,{images:i},{alignCorners:n,halfPixelCenters:s,size:e});return o?uk(a,[a.shape[1],a.shape[2],a.shape[3]]):a}}),FI=yx({bincount_:function(t,e,n){const s=mx(t,"x","bincount"),r=mx(e,"weights","bincount");return gg("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),gg(n>=0,()=>`size must be non-negative, but got ${n}.`),gg(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),ax.runKernel(_y,{x:s,weights:r},{size:n})}}),DI=yx({lessEqual_:function(t,e){let n=mx(t,"a","lessEqual","string_or_numeric"),s=mx(e,"b","lessEqual","string_or_numeric");return[n,s]=Jw(n,s),Ok(n.shape,s.shape),ax.runKernel(xb,{a:n,b:s})}}),OI=yx({round_:function(t){const e=mx(t,"x","round");return ax.runKernel(pv,{x:e})}});function LI(t,e,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");return ax.runKernel(nv,{},{start:t,stop:e,step:n,dtype:s})}yx({threshold_:function(t,e="binary",n=!1,s=.5){const r=mx(t,"image","threshold"),i=r.shape[0]*r.shape[1];let o,a,l,u,c=Xk(HC([s]),255);if(gg(3===r.rank,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),gg(3===r.shape[2]||1===r.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),gg("int32"===r.dtype||"float32"===r.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),gg("otsu"===e||"binary"===e,()=>`Method must be binary or otsu, but was ${e}`),3===r.shape[2]){[o,a,l]=BC(r,[1,1,1],-1);const t=Xk(o,.2989),e=Xk(a,.587),n=Xk(l,.114);u=G_(G_(t,e),n)}else u=t;"otsu"===e&&(c=function(t,e){let n,s,r,i,o,a,l=HC([-1]),u=HC([0]),c=HC([0]);for(let h=0;h<t.size-1;h++){n=FC(t,0,h+1),s=FC(t,h+1),o=Ak(Yk(n),e),a=Ak(Yk(s),e);const d=Yk(Xk(n,LI(0,n.size)));r=Ak(d,Yk(n));const p=Bk(s.shape,n.size),f=G_(LI(0,s.size),p),m=Xk(s,f);i=Ak(Yk(m),Yk(s));const g=Zk(r,i),y=Zk(r,i),b=Xk(o,a);c=Xk(Xk(b,g),y);const v=Uk(c,u);u=XC(v,c,u),l=XC(v,HC([h]),l)}return l}(FI(n_(OI(u),"int32"),wx([]),256),i));const h=n?DI(u,c):Uk(u,c);return n_(Xk(h,255),"int32")}}),yx({transform_:function(t,e,n="nearest",s="constant",r=0,i){const o=mx(t,"image","transform","float32"),a=mx(e,"transforms","transform","float32");return gg(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),gg(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),gg(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),ax.runKernel(Hv,{image:o,transforms:a},{interpolation:n,fillMode:s,fillValue:r,outputShape:i})}});const MI=yx({bandPart_:function(t,e,n){gg(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),gg(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=mx(t,"a","bandPart");gg(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=i),n<0&&(n=o);const a=uk(LI(0,i,1,"int32"),[-1,1]),l=LI(0,o,1,"int32"),u=Zk(a,l),c=Jk(DI(u,U_(+e,"int32")),jk(u,U_(-n,"int32"))),h=bC([i,o],s.dtype);return uk(UC(qC(uk(s,[-1,i,o])).map(t=>XC(c,t,h))),r)}}),PI=yx({min_:function(t,e=null,n=!1){const s=mx(t,"x","min");return ax.runKernel(Pb,{x:s},{axis:e,keepDims:n})}}),zI=yx({pow_:function(t,e){let n=mx(t,"base","pow"),s=mx(e,"exp","pow");return[n,s]=Jw(n,s),ax.runKernel(Jb,{a:n,b:s})}});function BI(t,e,n=null){if(0===t.rank)return H_(t);if(1!==t.rank&&null===n)return BI(uk(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return Yk(H_(t),n);if(e===1/0)return Kk(H_(t),n);if(e===-1/0)return PI(H_(t),n);if("euclidean"===e||2===e)return VC(Yk(zI(H_(t),U_(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return Kk(Yk(H_(t),n[0]),n[1]-1);if(e===1/0)return Kk(Yk(H_(t),n[1]),n[0]);if(e===-1/0)return PI(Yk(H_(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return VC(Yk(pC(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const VI=yx({norm_:function(t,e="euclidean",n=null,s=!1){const r=BI(t=mx(t,"x","norm"),e,n);let i=r.shape;if(s){const e=Eg(n,t.shape);i=lC(r.shape,e)}return uk(r,i)}}),WI=yx({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,gg(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)gg(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=BC(t,t.shape[0],0).map(t=>WC(t,[0]));gg(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(ax.tidy(()=>{let t=s[r];if(r>0)for(let e=0;e<r;++e){const s=Xk(Yk(Xk(n[e],t)),n[e]);t=Zk(t,s)}return Ak(t,VI(t,"euclidean"))}));return e?UC(n,0):n}});function UI(t,e=!1){return ax.tidy(()=>{gg(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=zk(n),i=s_(t);const o=vI([[1]],[1,1]);let a=s_(o);const l=n>=s?s:n;for(let t=0;t<l;++t){const e=i,l=a,u=r;[a,i,r]=ax.tidy(()=>{const e=FC(i,[t,t],[n-t,1]),l=VI(e),u=FC(i,[t,t],[1,1]),c=XC(Uk(u,0),vI([[-1]]),vI([[1]])),h=Zk(u,Xk(c,l)),d=Ak(e,h);a=1===d.shape[0]?s_(o):yk([o,FC(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=mC(Ak(mI(c,h),l)),f=FC(i,[t,0],[n-t,s]),m=Xk(p,a),g=YC(a);if(0===t)i=Zk(f,mI(m,mI(g,f)));else{const e=Zk(f,mI(m,mI(g,f)));i=yk([FC(i,[0,0],[t,s]),e],0)}const y=YC(m),b=FC(r,[0,t],[n,r.shape[1]-t]);if(0===t)r=Zk(b,mI(mI(b,a),y));else{const e=Zk(b,mI(mI(b,a),y));r=yk([FC(r,[0,0],[n,t]),e],1)}return[a,i,r]}),z_([e,l,u])}return!e&&n>s&&(r=FC(r,[0,0],[n,s]),i=FC(i,[0,0],[s,s])),[r,i]})}const jI=yx({qr_:function(t,e=!1){if(gg(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return UI(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),s=qC(uk(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],i=[];return s.forEach(t=>{const[n,s]=UI(t,e);r.push(n),i.push(s)}),[uk(UC(r,0),t.shape),uk(UC(i,0),t.shape)]}}});var HI;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(HI||(HI={}));const GI=yx({computeWeightedLoss_:function(t,e,n=HI.SUM_BY_NONZERO_WEIGHTS){const s=mx(t,"losses","computeWeightedLoss");let r=null;null!=e&&(r=mx(e,"weights","computeWeightedLoss"));const i=null==r?s:Xk(s,r);if(n===HI.NONE)return i;if(n===HI.SUM)return Yk(i);if(n===HI.MEAN){if(null==r)return sC(i);{const t=s.size/r.size,e=Ak(Yk(i),Yk(r));return t>1?Ak(e,U_(t)):e}}if(n===HI.SUM_BY_NONZERO_WEIGHTS){if(null==r)return Ak(Yk(i),U_(s.size));{const t=Xk(r,vC(s.shape)),e=n_(Yk(gC(t,U_(0))),"float32");return Ak(Yk(i),e)}}throw Error(`Unknown reduction: ${n}`)}});yx({absoluteDifference_:function(t,e,n,s=HI.SUM_BY_NONZERO_WEIGHTS){const r=mx(t,"labels","absoluteDifference"),i=mx(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=mx(n,"weights","absoluteDifference")),yg(r.shape,i.shape,"Error in absoluteDifference: ");const a=H_(Zk(r,i));return GI(a,o,s)}}),yx({cosineDistance_:function(t,e,n,s,r=HI.SUM_BY_NONZERO_WEIGHTS){const i=mx(t,"labels","cosineDistance"),o=mx(e,"predictions","cosineDistance");let a=null;null!=s&&(a=mx(s,"weights","cosineDistance")),yg(i.shape,o.shape,"Error in cosineDistance: ");const l=U_(1),u=Zk(l,Yk(Xk(i,o),n,!0));return GI(u,a,r)}}),yx({hingeLoss_:function(t,e,n,s=HI.SUM_BY_NONZERO_WEIGHTS){let r=mx(t,"labels","hingeLoss");const i=mx(e,"predictions","hingeLoss");let o=null;null!=n&&(o=mx(n,"weights","hingeLoss")),yg(r.shape,i.shape,"Error in hingeLoss: ");const a=U_(1);r=Zk(Xk(U_(2),r),a);const l=TC(Zk(a,Xk(r,i)));return GI(l,o,s)}}),yx({huberLoss_:function(t,e,n,s=1,r=HI.SUM_BY_NONZERO_WEIGHTS){const i=mx(t,"labels","huberLoss"),o=mx(e,"predictions","huberLoss");let a=null;null!=n&&(a=mx(n,"weights","huberLoss")),yg(i.shape,o.shape,"Error in huberLoss: ");const l=U_(s),u=H_(Zk(o,i)),c=rC(u,l),h=Zk(u,c),d=G_(Xk(U_(.5),pC(c)),Xk(l,h));return GI(d,a,r)}}),yx({logLoss_:function(t,e,n,s=1e-7,r=HI.SUM_BY_NONZERO_WEIGHTS){const i=mx(t,"labels","logLoss"),o=mx(e,"predictions","logLoss");let a=null;null!=n&&(a=mx(n,"weights","logLoss")),yg(i.shape,o.shape,"Error in logLoss: ");const l=U_(1),u=U_(s),c=mC(Xk(i,Gk(G_(o,u)))),h=Xk(Zk(l,i),Gk(G_(Zk(l,o),u))),d=Zk(c,h);return GI(d,a,r)}});const qI=yx({squaredDifference_:function(t,e){let n=mx(t,"a","squaredDifference"),s=mx(e,"b","squaredDifference");return[n,s]=Jw(n,s),Ok(n.shape,s.shape),ax.runKernel(Dv,{a:n,b:s},{})}});yx({meanSquaredError_:function(t,e,n,s=HI.SUM_BY_NONZERO_WEIGHTS){const r=mx(t,"labels","meanSquaredError"),i=mx(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=mx(n,"weights","meanSquaredError")),yg(r.shape,i.shape,"Error in meanSquaredError: ");const a=qI(r,i);return GI(a,o,s)}});const KI=yx({log1p_:function(t){const e=mx(t,"x","log1p");return ax.runKernel(Cb,{x:e})}});yx({sigmoidCrossEntropy_:function(t,e,n,s=0,r=HI.SUM_BY_NONZERO_WEIGHTS){let i=mx(t,"multiClassLabels","sigmoidCrossEntropy");const o=mx(e,"logits","sigmoidCrossEntropy");let a=null;if(null!=n&&(a=mx(n,"weights","sigmoidCrossEntropy")),yg(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const t=U_(s),e=U_(1),n=U_(.5);i=G_(Xk(i,Zk(e,t)),Xk(n,t))}const l=function(t,e){const n=mx(t,"labels","sigmoidCrossEntropyWithLogits"),s=mx(e,"logits","sigmoidCrossEntropyWithLogits");yg(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=TC(s),i=Xk(s,n),o=KI(qk(mC(H_(s))));return G_(Zk(r,i),o)}(i,o);return GI(l,a,r)}});const XI=yx({logSumExp_:function(t,e=null,n=!1){const s=mx(t,"x","logSumExp"),r=Eg(e,s.shape),i=Kk(s,r,!0),o=Zk(s,i),a=qk(o),l=Yk(a,r),u=Gk(l),c=G_(uk(i,u.shape),u);if(n){const t=lC(c.shape,r);return uk(c,t)}return c}});yx({softmaxCrossEntropy_:function(t,e,n,s=0,r=HI.SUM_BY_NONZERO_WEIGHTS){let i=mx(t,"onehotLabels","softmaxCrossEntropy");const o=mx(e,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=mx(n,"weights","softmaxCrossEntropy")),yg(i.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const t=U_(s),e=U_(1),n=U_(i.shape[1]);i=G_(Xk(i,Zk(e,t)),Ak(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return W_((t,e,s)=>{const r=XI(e,[n],!0),i=Zk(n_(e,"float32"),r);s([t,i]);const o=mC(Xk(i,t));return{value:Yk(o,[n]),gradFunc:(t,e)=>{const[s,r]=e,i=lC(t.shape,[n]);return[Xk(uk(t,i),Zk(n_(s,"float32"),qk(r))),Xk(uk(t,i),Zk(qk(r),n_(s,"float32")))]}}})(t,e)}(i,o);return GI(l,a,r)}}),yx({sparseFillEmptyRows_:function(t,e,n,s){const r=mx(t,"indices","sparseFillEmptyRows"),i=mx(e,"values","sparseFillEmptyRows"),o=mx(n,"denseShape","sparseFillEmptyRows"),a=mx(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==r.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l=ax.runKernel(Nv,{indices:r,values:i,denseShape:o,defaultValue:a});return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),yx({sparseReshape_:function(t,e,n){const s=mx(t,"inputIndices","sparseReshape"),r=mx(e,"inputShape","sparseReshape"),i=mx(n,"newShape","sparseReshape");if(2!==s.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==r.rank)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o=ax.runKernel($v,{inputIndices:s,inputShape:r,newShape:i});return{outputIndices:o[0],outputShape:o[1]}}}),yx({sparseSegmentMean_:function(t,e,n){const s=mx(t,"data","sparseSegmentMean"),r=mx(e,"indices","sparseSegmentMean"),i=mx(n,"segmentIds","sparseSegmentMean");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return ax.runKernel(Av,{data:s,indices:r,segmentIds:i})}}),yx({sparseSegmentSum_:function(t,e,n){const s=mx(t,"data","sparseSegmentSum"),r=mx(e,"indices","sparseSegmentSum"),i=mx(n,"segmentIds","sparseSegmentSum");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return ax.runKernel(Rv,{data:s,indices:r,segmentIds:i})}}),yx({stringNGrams_:function(t,e,n,s,r,i,o,a){const l=mx(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=mx(e,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c=ax.runKernel(Mv,{data:l,dataSplits:u},{separator:n,nGramWidths:s,leftPad:r,rightPad:i,padWidth:o,preserveShortSequences:a});return{nGrams:c[0],nGramsSplits:c[1]}}}),yx({stringSplit_:function(t,e,n=!0){const s=mx(t,"input","stringSplit","string"),r=mx(e,"delimiter","stringSplit","string");if(1!==s.rank)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(0!==r.rank)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i=ax.runKernel(Pv,{input:s,delimiter:r},{skipEmpty:n});return{indices:i[0],values:i[1],shape:i[2]}}}),yx({stringToHashBucketFast_:function(t,e){const n=mx(t,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");return ax.runKernel(zv,{input:n},s)}});const ZI={bandPart:MI,gramSchmidt:WI,qr:jI};class YI extends j_{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=ax.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=ax.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:P_(()=>ZC(s).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:P_(()=>ZC(s).variable(!1))});const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;P_(()=>{const t=G_(Xk(i,this.rho),Xk(pC(r),1-this.rho)),e=Xk(Ak(VC(G_(o,this.epsilon)),VC(G_(i,this.epsilon))),r),n=G_(Xk(o,this.rho),Xk(pC(e),1-this.rho));i.assign(t),o.assign(n);const a=G_(Xk(e,-this.learningRate),s);s.assign(a)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(z_(this.accumulatedGrads.map(t=>t.variable)),z_(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return lg(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return lg(function*(){const n=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,n).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(n,2*n).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}YI.className="Adadelta",O_(YI);class QI extends j_{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=ax.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:P_(()=>Bk(s.shape,this.initialAccumulatorValue).variable(t))}}const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedGrads[n].variable;P_(()=>{const t=G_(i,pC(r));i.assign(t);const e=G_(Xk(Ak(r,VC(G_(t,ax.backend.epsilon()))),-this.learningRate),s);s.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&z_(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return lg(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return lg(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}QI.className="Adagrad",O_(QI);class JI extends j_{constructor(t,e,n,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],P_(()=>{this.accBeta1=U_(e).variable(),this.accBeta2=U_(n).variable()}),null==s&&(this.epsilon=ax.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);P_(()=>{const n=Zk(1,this.accBeta1),s=Zk(1,this.accBeta2);e.forEach((e,r)=>{const i=ax.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:P_(()=>ZC(i).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${e}/v`,variable:P_(()=>ZC(i).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=G_(Xk(a,this.beta1),Xk(o,1-this.beta1)),c=G_(Xk(l,this.beta2),Xk(pC(o),1-this.beta2)),h=Ak(u,n),d=Ak(c,s);a.assign(u),l.assign(c);const p=G_(Xk(Ak(h,G_(VC(d),this.epsilon)),-this.learningRate),i);i.assign(p)}),this.accBeta1.assign(Xk(this.accBeta1,this.beta1)),this.accBeta2.assign(Xk(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&z_(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&z_(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return lg(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return lg(function*(){t=yield e.extractIterations(t),P_(()=>{e.accBeta1.assign(zI(e.beta1,e.iterations_+1)),e.accBeta2.assign(zI(e.beta2,e.iterations_+1))});const n=t.length/2;e.accumulatedFirstMoment=t.slice(0,n).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(n,2*n).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}JI.className="Adam",O_(JI);class tS extends j_{constructor(t,e,n,s=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],P_(()=>{this.iteration=U_(0).variable(),this.accBeta1=U_(e).variable()}),null==s&&(this.epsilon=ax.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);P_(()=>{const n=Zk(1,this.accBeta1),s=Ak(-this.learningRate,G_(Xk(this.iteration,this.decay),1));e.forEach((e,r)=>{const i=ax.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:ZC(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${e}/v`,variable:ZC(i).variable(!1)});const o=Array.isArray(t)?t[r].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=G_(Xk(a,this.beta1),Xk(o,1-this.beta1)),c=Xk(l,this.beta2),h=H_(o),d=nC(c,h);a.assign(u),l.assign(d);const p=G_(Xk(Ak(s,n),Ak(u,G_(d,this.epsilon))),i);i.assign(p)}),this.iteration.assign(G_(this.iteration,1)),this.accBeta1.assign(Xk(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&z_(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&z_(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return lg(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return lg(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}tS.className="Adamax",O_(tS);class eS extends j_{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const r=ax.registeredVariables[e];P_(()=>{const t=G_(Xk(this.c,s),r);r.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=B_(U_(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return lg(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return lg(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}eS.className="SGD",O_(eS);class nS extends eS{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=U_(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=ax.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:P_(()=>ZC(s).variable(t))}}const r=this.accumulations[n].variable,i=Array.isArray(t)?t[n].tensor:t[e];null!=i&&P_(()=>{let t;const e=G_(Xk(this.m,r),i);t=G_(Xk(this.c,this.useNesterov?G_(i,Xk(e,this.m)):e),s),r.assign(e),s.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&z_(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return lg(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return lg(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}nS.className="Momentum",O_(nS);class sS extends j_{constructor(t,e=.9,n=0,s=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==s&&(this.epsilon=ax.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=ax.registeredVariables[e],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:P_(()=>ZC(s).variable(r))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:P_(()=>ZC(s).variable(r))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:P_(()=>ZC(s).variable(r))});const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const o=this.accumulatedMeanSquares[n].variable,a=this.accumulatedMoments[n].variable;P_(()=>{const t=G_(Xk(o,this.decay),Xk(pC(i),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,r=G_(Xk(e,this.decay),Xk(i,1-this.decay)),l=Ak(Xk(i,this.learningRate),VC(Zk(t,G_(pC(r),this.epsilon)))),u=G_(Xk(a,this.momentum),l);o.assign(t),e.assign(r),a.assign(u);const c=Zk(s,u);s.assign(c)}else{const t=G_(Xk(o,this.decay),Xk(pC(i),1-this.decay)),e=G_(Xk(a,this.momentum),Ak(Xk(i,this.learningRate),VC(G_(t,this.epsilon))));o.assign(t),a.assign(e);const n=Zk(s,e);s.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&z_(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&z_(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&z_(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return lg(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return lg(function*(){t=yield e.extractIterations(t);const n=e.centered?t.length/3:t.length/2,s=!1;e.accumulatedMeanSquares=t.slice(0,n).map(t=>({originalName:t.name,variable:t.tensor.variable(s)})),e.accumulatedMoments=t.slice(n,2*n).map(t=>({originalName:t.name,variable:t.tensor.variable(s)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*n,3*n).map(t=>({originalName:t.name,variable:t.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}sS.className="RMSProp",O_(sS);class rS{static sgd(t){return new eS(t)}static momentum(t,e,n=!1){return new nS(t,e,n)}static rmsprop(t,e=.9,n=0,s=null,r=!1){return new sS(t,e,n,s,r)}static adam(t=.001,e=.9,n=.999,s=null){return new JI(t,e,n,s)}static adadelta(t=.001,e=.95,n=null){return new YI(t,e,n)}static adamax(t=.002,e=.9,n=.999,s=null,r=0){return new tS(t,e,n,s,r)}static adagrad(t,e=.1){return new QI(t,e)}}const iS={sgd:rS.sgd,momentum:rS.momentum,adadelta:rS.adadelta,adagrad:rS.adagrad,rmsprop:rS.rmsprop,adamax:rS.adamax,adam:rS.adam},oS="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function aS(){return new Promise(t=>oS(()=>t()))}function lS(t,e){const n=t[0].length;t.forEach((t,e)=>{gg(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),gg(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((t,r)=>{for(let i=0;i<n;i++)gg(i===e||t[i]===s[i],()=>`Error in concat${n}D: Shape of tensors[${r}] (${t}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function uS(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}const cS=30;function hS(t){return t<=cS?t:Pg(t,Math.floor(Math.sqrt(t)))}function dS(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function pS(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let s=0;s<n;++s)r=r.concat([t[s+1]/e[s],e[s]]);r=r.concat(t.slice(n+1))}return r}function fS(t,e,n=!0){const s=[];if(n){s.push(e);for(let n=e+1;n<t;++n)n<=2*e?(s.push(n),s.push(n-(e+1))):s.push(n)}else{const n=[],r=[];for(let s=1;s<t;++s)s>=2*e+1||s%2==1?r.push(s):n.push(s);s.push(...n),s.push(0),s.push(...r)}return s}function mS(t,e,n,s=!0){const r=[];r.push(s?t[0]/n:t[0]*n);for(let i=1;i<t.length;++i)r.push(i<=e.length?s?e[i-1]*t[i]:t[i]/e[i-1]:t[i]);return r}function gS(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function yS(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}function bS(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(0===wg(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,i=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const a=t.shape,l=r.slice();l.pop();let u=1;for(let h=i;h<n;++h)u*=a[h],l.push(a[h]);const c=[...zg(t.shape).map(t=>t/u),1].slice(0,i);return[l,o,u,c]}function vS(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(i+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(i+" update.rank != "+(r+t.length-s));for(let o=0;o<r;++o)if(n.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==t[o+s])throw new Error(i+` updates.shape[${o+r}] (${n.shape[o+r]}) != shape[${o+r}] (${t[o+r]})`)}function wS(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}vS(n,e,t)}function xS(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=n.length;let o=1;for(let l=r;l<i;++l)o*=n[l];const a=r<1?1:r;return{sliceRank:r,numUpdates:wg(e.shape)/a,sliceSize:o,strides:[...zg(n.slice(0,r)),1],outputSize:wg(n)}}const _S=1.7580993408473768,kS=1.0507009873554805,CS=.3275911,IS=.254829592,SS=-.284496736,ES=1.421413741,TS=-1.453152027,NS=1.061405429;function $S(...t){Yg().getBool("IS_TEST")||console.warn(...t)}function AS(...t){Yg().getBool("IS_TEST")||console.log(...t)}function RS(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function FS(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function DS(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function OS(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function LS(t,e){return{real:t[2*e],imag:t[2*e+1]}}function MS(t,e,n,s){t[2*s]=e,t[2*s+1]=n}function PS(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const i=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:n,imag:s}}function zS(t,e,n){const s=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(s),imag:Math.sin(s)}}const BS=/->/g;function VS(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(BS,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[s,r]=t.split("->");gg(-1===s.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const i=s.split(","),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<r.length;++h){const t=r[h];if(!i.some(e=>-1!==e.indexOf(t)))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===a.indexOf(t)&&a.push(t)}for(let h=0;h<s.length;++h){const t=s[h];-1===a.indexOf(t)&&","!==t&&a.push(t)}const l=new Array(i.length);for(let h=0;h<o;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let t=0;t<i[h].length;++t)l[h].push(a.indexOf(i[h][t]))}const u=a.length,c=[];for(let h=r.length;h<u;++h)c.push(h);return{allDims:a,summedDims:c,idDims:l}}function WS(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const s=[];for(let r=0;r<t;++r)-1===n[r]&&s.push(r);return n=n.filter(t=>-1!==t),{permutationIndices:n,expandDims:s}}function US(t,e,n){const s=new Array(t);for(let r=0;r<n.length;++r){const t=n[r].shape;for(let n=0;n<e[r].length;++n)void 0===s[e[r][n]]?s[e[r][n]]=t[n]:gg(s[e[r][n]]===t[n],()=>`Expected dimension ${s[e[r][n]]} at axis ${n} of input shaped ${JSON.stringify(t)}, but got dimension ${t[n]}`)}}function jS(t,e){const n=t,s=[];let r=0;0===t.length&&n.push(-1),r=t.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<n.length;++o){const t=GS(e,n[o]);for(const e of t)-1===i.indexOf(e)&&(s[o].push(e),i.push(e))}return{path:n,steps:s}}function HS(t){return t.every((t,e)=>t===e)}function GS(t,e){const n=[];for(let s=0;s<t.length;++s)0!==t[s].length&&-1===t[s].indexOf(e)&&-1!==e||n.push(s);return n}function qS(t,e,n=0){let s=[];if("number"==typeof e)gg(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{gg(e.reduce((t,e)=>(-1===e&&(t+=1),t),0)<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(-1!==r){const s=e.reduce((t,e)=>e>0?t+e:t);e[r]=t.shape[n]-s}gg(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function KS(t,e){let n,s=!1;for(t<=cS?(n=t,s=!0):n=Pg(t,Math.floor(Math.sqrt(t)));!s;)n>e||n===t?s=!0:n=Pg(t,n+1);return n}function XS(t,e,n){const s=[],r=t.length;for(let i=0;i<r;i++)s.push(i!==e?t[i]:n);return s}function ZS(t,e,n,s){const r=e.shape.length,i=t.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${i}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=t.shape[n],a=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)a.push(t.shape[h]),l*=t.shape[h];for(let h=s;h<n;h++)a.push(t.shape[h]),u*=t.shape[h];for(let h=s;h<r;h++)a.push(e.shape[h]);for(let h=n+1;h<i;h++)a.push(t.shape[h]),c*=t.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:a}}function YS(t){try{return t.map(t=>Nw(t))}catch(X3){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${X3}`)}}function QS(t){return t.map(t=>Tw(t))}function JS(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const s=e_(t,"int32"),r=e_([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const e=s.indexToLoc(n[i]);r.values.set(e,i*t.length)}return r.toTensor()}const tE={kernelName:ny,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(t,aI(n_(n,"float32"),-1))}}},eE={kernelName:sy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=pC(n_(n,"float32")),s=VC(Zk(U_(1),e));return mC(Ak(t,s))}}}},nE={kernelName:ry,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=VC(Zk(pC(n_(n,"float32")),1));return Ak(t,e)}}}},sE={kernelName:iy,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Ok(n.shape,s.shape);return{a:()=>{let e=t;const s=Dk(n.shape,r);return s.length>0&&(e=Yk(e,s)),uk(e,n.shape)},b:()=>{let e=t;const n=Dk(s.shape,r);return n.length>0&&(e=Yk(e,n)),uk(e,s.shape)}}}},rE={kernelName:oy,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((e,s)=>{n[s]=()=>t.clone()}),n}},iE={kernelName:uy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ZC(n)}}},oE={kernelName:cy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ZC(n)}}},aE={kernelName:hy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ak(t,VC(Zk(U_(1),pC(n_(n,"float32")))))}}},lE={kernelName:dy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=VC(G_(U_(1),pC(n_(n,"float32"))));return Ak(t,e)}}}},uE={kernelName:my,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Ok(n.shape,s.shape);return{a:()=>{const e=G_(pC(n),pC(s));let i=Xk(t,Ak(s,e));const o=Dk(n.shape,r);return o.length>0&&(i=Yk(i,o)),uk(i,n.shape)},b:()=>{const e=G_(pC(n),pC(s));let i=mC(Xk(t,Ak(n,e)));const o=Dk(s.shape,r);return o.length>0&&(i=Yk(i,o)),uk(i,s.shape)}}}},cE={kernelName:py,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ak(t,G_(pC(n_(n,"float32")),1))}}},hE={kernelName:fy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ak(t,Zk(U_(1),pC(n_(n,"float32"))))}}},dE=yx({avgPool3dGrad_:function(t,e,n,s,r,i){const o=mx(t,"dy","avgPool3dGrad"),a=mx(e,"input","avgPool3dGrad");let l=o,u=a,c=!1;4===a.rank&&(c=!0,l=uk(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=uk(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),gg(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),gg(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),null!=i&&gg(_g(r),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h=ax.runKernel(vy,{dy:l,input:u},{filterSize:n,strides:s,pad:r,dimRoundingMode:i});return c?uk(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),pE={kernelName:by,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=n;return{x:()=>dE(t,s,r,i,o,a)}}},fE=yx({avgPoolGrad_:function(t,e,n,s,r){const i=mx(t,"dy","avgPoolGrad"),o=mx(e,"input","avgPoolGrad");gg(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,u=!1;3===o.rank&&(u=!0,a=uk(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=uk(i,[1,i.shape[0],i.shape[1],i.shape[2]])),gg(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),gg(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c=ax.runKernel(yy,{dy:l,input:a},{filterSize:n,strides:s,pad:r});return u?uk(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),mE={kernelName:gy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:o}=n;return{x:()=>fE(t,s,r,i,o)}}},gE={kernelName:wy,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:i,transposeB:o}=n;return i||o?!i&&o?{a:()=>mI(t,r,!1,!1),b:()=>mI(t,s,!0,!1)}:i&&!o?{a:()=>mI(r,t,!1,!0),b:()=>mI(s,t,!1,!1)}:{a:()=>mI(r,t,!0,!0),b:()=>mI(t,s,!0,!0)}:{a:()=>mI(t,r,!1,!0),b:()=>mI(s,t,!0,!1)}}},yE=yx({spaceToBatchND_:function(t,e,n){const s=mx(t,"x","spaceToBatchND");return gg(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),gg(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),gg(s.shape.reduce((t,s,r)=>r>0&&r<=e.length?t&&(s+n[r-1][0]+n[r-1][1])%e[r-1]==0:t,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`),ax.runKernel(Sv,{x:s},{blockShape:e,paddings:n})}}),bE={kernelName:xy,gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>yE(t,s,r)}}},vE={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const s=n.inputShape,r=n.shape,i=Array.from(r);for(let a=s.length-1;a>=0;a--)if(s[a]===r[a])i[a]=1;else if(1!==s[a])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${r}].`);const o=[];for(let a=0;a<i.length;a++)i[a]>1&&o.push(a);return{x:()=>Yk(t,o,!0)}}},wE={kernelName:ky,gradFunc:t=>({x:()=>t.clone()})},xE={kernelName:Cy,gradFunc:t=>({x:()=>ZC(t)})},_E={kernelName:Iy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=n;return{x:()=>XC(Jk(jk(s,r),DI(s,i)),t,ZC(t))}}},kE={kernelName:Ey,inputsToSave:["x"],gradFunc:tE.gradFunc},CE={kernelName:Ty,saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(t=>t.shape),{axis:r}=n,i=Eg(r,e[0].shape)[0],o=s.map(t=>t[i]);return BC(t,o,i).map(t=>()=>t)}},IE={kernelName:Ny,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=n;return gg(ok(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>Ck(s.shape,t,r,o,a,l),filter:()=>iI(s,t,r.shape,o,a,l)}}},SE={kernelName:Ay,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>_k(t,r,i,o,a,1,l),filter:()=>iI(t,s,r.shape,i,o,a,l)}}},EE=yx({conv3DBackpropFilter_:function(t,e,n,s,r){let i=t;4===t.rank&&(i=uk(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;return 4===o.rank&&(o=uk(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),gg(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),gg(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),gg(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),gg(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),gg(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`),ax.runKernel(Fy,{x:i,dy:o},{strides:s,pad:r,filterShape:n})}}),TE={kernelName:Ry,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i}=n;gg(ok(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=e;return{x:()=>Ek(o.shape,t,a,r,i),filter:()=>EE(o,t,a.shape,r,i)}}},NE=yx({sin_:function(t){const e=mx(t,"x","sin");return ax.runKernel(vv,{x:e})}}),$E={kernelName:Oy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(mC(NE(n_(n,"float32"))),t)}}},AE=yx({sinh_:function(t){const e=mx(t,"x","sinh");return ax.runKernel(wv,{x:e})}}),RE={kernelName:Ly,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(AE(n_(n,"float32")),t)}}},FE=yx({cumsum_:function(t,e=0,n=!1,s=!1){const r=mx(t,"x","cumsum");return ax.runKernel(My,{x:r},{axis:e,exclusive:n,reverse:s})}}),DE={kernelName:My,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:i,reverse:o}=n;return{x:()=>{const e=cC([r],s.rank);let n=FE(t,r,i,!o);return null!=e&&(n=YC(n,e)),n}}}},OE={kernelName:Vy,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=n,a=null==s?[1,1]:s;gg(ok(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;return gg(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),gg(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),gg(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),gg(ak(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),null!=o&&gg(_g(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`),{x:()=>fI(l.shape,t,u,r,i,s,o),filter:()=>pI(l,t,u.shape,r,i,s,o)}}},LE={kernelName:Hy,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,i={x:s,filter:r,dy:t},o={x:s,filter:r,dy:t};return{x:()=>ax.runKernel(Gy,i,n),filter:()=>ax.runKernel(qy,o,n)}}},ME={kernelName:Zy,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>ax.runKernel(Yy,s)}}},PE={kernelName:Qy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=Xk(qk(mC(pC(n))),2/Math.sqrt(Math.PI));return{x:()=>Xk(t,s)}}},zE={kernelName:tb,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(t,n)}}},BE={kernelName:eb,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>uk(t,n.shape)}}},VE={kernelName:nb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(t,qk(n))}}},WE={kernelName:ob,gradFunc:t=>({x:()=>ZC(t)})},UE={kernelName:ab,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Ok(n.shape,s.shape);return{a:()=>{const e=Ak(t,n_(s,"float32")),i=Dk(n.shape,r);return i.length>0?uk(Yk(e,i),n.shape):e},b:()=>{let e=Xk(t,n_(n,"float32"));const i=Dk(s.shape,r);i.length>0&&(e=uk(Yk(e,i),s.shape));const o=pC(s);return mC(Ak(e,n_(o,"float32")))}}}},jE=yx({rsqrt_:function(t){const e=mx(t,"x","rsqrt");return ax.runKernel(fv,{x:e})}}),HE={kernelName:lb,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,i,o,a]=e,l=null==a?U_(1):a,u=Dk(i.shape,r.shape),c=[];if(1===i.rank){for(let t=0;t<r.shape.length-1;++t)c.push(r.shape[t]);c.push(1)}const h=Zk(r,i),d=Xk(t,l),p=jE(G_(o,U_(s))),f=Xk(Xk(Xk(p,p),p),U_(-.5));return{x:()=>uk(Xk(Xk(t,1===i.rank?Pk(uk(p,[1,1,1,i.shape[0]]),c):p),l),r.shape),mean:()=>{let t=Xk(Xk(p,U_(-1)),d);return 1===i.rank&&(t=Yk(t,u)),uk(t,i.shape)},variance:()=>{let t=Xk(Xk(f,h),d);return 1===i.rank&&(t=Yk(t,u)),uk(t,i.shape)},scale:()=>{const e=Xk(h,p);let n=Xk(t,e);return 1===i.rank&&(n=Yk(n,u)),uk(n,i.shape)},offset:()=>{let e=t;return 1===i.rank&&(e=Yk(e,u)),uk(e,i.shape)}}}},GE=yx({unsortedSegmentSum_:function(t,e,n){const s=mx(t,"x","unsortedSegmentSum"),r=mx(e,"segmentIds","unsortedSegmentSum","int32");return gg(_g(n),()=>"numSegments must be of dtype int"),ax.runKernel(Xv,{x:s,segmentIds:r},{numSegments:n})}}),qE={kernelName:ub,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:i}=n,o=Eg(i,s.shape)[0];return{x:()=>{const e=s.shape,n=r.size,a=e.slice(0,o),l=a.length,u=e.slice(i,e.length).slice(1),c=u.length,h=KE(0,l),d=KE(l+1,l+1+c),p=XE([a,[n],u]),f=uk(t,p),m=uk(r,[n]),g=XE([[l],h,d]),y=YC(f,g);let b=GE(y,m,s.shape[o]);const v=hC(g);return b=YC(b,v),b},indices:()=>r}}};function KE(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function XE(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}const ZE={kernelName:db,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>ZC(n),b:()=>ZC(s)}}},YE={kernelName:pb,gradFunc:t=>({x:()=>n_(t,"float32")})},QE={kernelName:gb,gradFunc:t=>({x:()=>ZC(t)})},JE={kernelName:yb,gradFunc:t=>({x:()=>ZC(t)})},tT={kernelName:bb,gradFunc:t=>({x:()=>ZC(t)})},eT={kernelName:vb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,i=Uk(s,0);return{x:()=>XC(i,t,Xk(t,r))}}},nT={kernelName:Cb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ak(t,G_(n,1))}}},sT={kernelName:kb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ak(t,n_(n,"float32"))}}},rT={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const e=qk(s);return Zk(t,Xk(Yk(t,r,!0),e))}}}},iT=yx({localResponseNormalizationBackprop_:function(t,e,n,s=5,r=1,i=1,o=.5){return ax.runKernel(Nb,{x:t,y:e,dy:n},{depthRadius:s,bias:r,alpha:i,beta:o})}}),oT={kernelName:Tb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=n;return{x:()=>iT(s,r,t,i,o,a,l)}}};function aT(t,e,n,s){return e.rank<n.rank&&(e=uk(e,lC(e.shape,s))),t.rank<n.rank&&(t=uk(t,lC(t.shape,s))),{x:()=>Xk(t,n_(Lk(n,e),t.dtype))}}const lT={kernelName:$b,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,i=e[0],o=aT(t,e[1],i,Eg(r,i.shape));return{x:()=>o.x()}}},uT=yx({less_:function(t,e){let n=mx(t,"a","less","string_or_numeric"),s=mx(e,"b","less","string_or_numeric");return[n,s]=Jw(n,s),Ok(n.shape,s.shape),ax.runKernel(wb,{a:n,b:s})}}),cT={kernelName:Ab,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Xk(t,n_(jk(n,s),"float32")),b:()=>Xk(t,n_(uT(n,s),"float32"))}}},hT=yx({maxPool3dGrad_:function(t,e,n,s,r,i,o){const a=mx(t,"dy","maxPool3dGrad"),l=mx(e,"input","maxPool3dGrad"),u=mx(n,"output","maxPool3dGrad");let c=a,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=uk(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=uk(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=uk(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),gg(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),gg(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),gg(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),null!=o&&gg(_g(i),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`);const f=ax.runKernel(Ob,{dy:c,input:h,output:d},{filterSize:s,strides:r,pad:i,dimRoundingMode:o});return p?uk(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),dT={kernelName:Db,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=n;return{x:()=>hT(t,s,r,i,o,a,l)}}},pT=yx({maxPoolGrad_:function(t,e,n,s,r,i,o){const a=mx(t,"dy","maxPoolGrad"),l=mx(e,"input","maxPoolGrad"),u=mx(n,"output","maxPoolGrad");return gg(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),gg(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),gg(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),null!=o&&gg(_g(i),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`),ax.runKernel(Fb,{dy:a,input:l,output:u},{filterSize:s,strides:r,pad:i,dimRoundingMode:o})}}),fT={kernelName:Rb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a}=n;return{x:()=>pT(t,s,r,i,o,a)}}},mT={kernelName:Mb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,i=Eg(r,s.shape),o=wg(aC(s.shape,i)[1]);return{x:()=>{const e=s.shape.slice();i.forEach(t=>{e[t]=1});const n=uk(t,e);return Ak(Xk(n,vC(s.shape,"float32")),o)}}}},gT={kernelName:Pb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[i,o]=e,a=aT(t,o,i,Eg(r,i.shape));return{x:()=>a.x()}}},yT={kernelName:zb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Xk(t,n_(DI(n,s),"float32")),b:()=>Xk(t,n_(Uk(n,s),"float32"))}}},bT={kernelName:Bb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(t=>t[0]);return{x:()=>FC(t,i,s.shape)}}},vT={kernelName:Vb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Ok(n.shape,s.shape);return{a:()=>{const e=Dk(n.shape,r);return e.length>0?uk(Yk(t,e),n.shape):t},b:()=>{const e=Xk(t,mC(Vk(Ak(n,s)))),i=Dk(s.shape,r);return i.length>0?uk(Yk(e,i),s.shape):e}}}},wT={kernelName:Ub,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Ok(n.shape,s.shape);return{a:()=>{const e=Xk(t,n_(s,"float32")),i=Dk(n.shape,r);return i.length>0?uk(Yk(e,i),n.shape):e},b:()=>{const e=Xk(t,n_(n,"float32")),i=Dk(s.shape,r);return i.length>0?uk(Yk(e,i),s.shape):e}}}},xT={kernelName:jb,gradFunc:t=>({x:()=>mC(t)})},_T={kernelName:Zb,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>bC(n.shape,"float32")}}},kT={kernelName:Xb,gradFunc:t=>({x:()=>ZC(t)})},CT={kernelName:Yb,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return qC(t,s).map(t=>()=>t)}},IT={kernelName:Qb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(t=>t[0]);return{x:()=>FC(t,i,s.shape)}}},ST={kernelName:Jb,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,i=n,o=s,a=Ok(i.shape,o.shape);return{a:()=>{const e=n_(o,"float32");let n=Xk(t,Xk(e,zI(i,Zk(e,U_(1)))));const s=Dk(i.shape,a);return s.length>0&&(n=Yk(n,s)),uk(n,i.shape)},b:()=>{const e=Uk(i,0),n=XC(e,Gk(i),ZC(i));let s=Xk(t,Xk(r,n));const l=Dk(o.shape,a);return l.length>0&&(s=Yk(s,l)),uk(s,o.shape)}}}},ET={kernelName:tv,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=Uk(n,0);return{x:()=>XC(r,t,Xk(t,s)),alpha:()=>{let e=XC(r,ZC(t),Xk(t,n));const i=Dk(s.shape,t.shape);return i.length>0&&(e=Yk(e,i)),uk(e,s.shape)}}}},TT={kernelName:Ky,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Ok(n.shape,s.shape);return{a:()=>{const e=Ak(t,n_(s,"float32")),i=Dk(n.shape,r);return i.length>0?uk(Yk(e,i),n.shape):e},b:()=>{let e=Xk(t,n_(n,"float32"));const i=Dk(s.shape,r);i.length>0&&(e=uk(Yk(e,i),s.shape));const o=pC(s);return mC(Ak(e,n_(o,"float32")))}}}},NT={kernelName:rv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ak(t,mC(pC(n)))}}},$T={kernelName:hv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=Xk(DI(n,6),aI(n));return{x:()=>Xk(t,n_(s,"float32"))}}},AT={kernelName:iv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(t,n_(aI(n),"float32"))}}},RT={kernelName:ov,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>uk(t,n.shape)}}},FT={kernelName:uv,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ax.runKernel(cv,r,n)}}},DT={kernelName:av,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ax.runKernel(lv,r,n)}}},OT={kernelName:dv,gradFunc:(t,e,n)=>{const{dims:s}=n,r=Eg(s,t.shape);return{x:()=>NC(t,r)}}},LT={kernelName:pv,gradFunc:t=>({x:()=>ZC(t)})},MT={kernelName:fv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mC(Ak(t,Xk(zI(n,1.5),2)))}}},PT=yx({logicalNot_:function(t){const e=mx(t,"x","logicalNot","bool");return ax.runKernel(Sb,{x:e})}}),zT={kernelName:gv,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>n_(ZC(n),"float32"),t:()=>Xk(t,n_(n,t.dtype)),e:()=>Xk(t,n_(PT(n),t.dtype))}}},BT={kernelName:yv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=Uk(n,U_(0)),s=U_(_S),r=U_(kS),i=Xk(t,r),o=Xk(Xk(t,s),qk(n_(n,"float32")));return XC(e,i,o)}}}},VT={kernelName:_v,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(t,Xk(n,Zk(U_(1),n)))}}},WT={kernelName:xv,gradFunc:t=>({x:()=>ZC(t)})},UT=yx({cos_:function(t){const e=mx(t,"x","cos");return ax.runKernel(Oy,{x:e})}}),jT={kernelName:vv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(UT(n_(n,"float32")),t)}}},HT=yx({cosh_:function(t){const e=mx(t,"x","cosh");return ax.runKernel(Ly,{x:e})}}),GT={kernelName:wv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(HT(n_(n,"float32")),t)}}},qT={kernelName:bv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:i}=n,o=s.shape,[a,l]=A_(s,r,i),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],o[c]-a[c]-l[c]]);return{x:()=>xC(t,u)}}},KT={kernelName:Tv,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,i=Xk(t,s);return{logits:()=>Zk(i,Xk(Yk(i,[r],!0),s))}}},XT={kernelName:kv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(t,RC(n))}}},ZT=yx({batchToSpaceND_:function(t,e,n){const s=mx(t,"x","batchToSpaceND"),r=e.reduce((t,e)=>t*e);return gg(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),gg(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),gg(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`),ax.runKernel(xy,{x:s},{blockShape:e,crops:n})}}),YT={kernelName:Sv,gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>ZT(t,s,r)}}},QT={kernelName:Ev,gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>yk(t,s)}}},JT=[tE,eE,nE,sE,rE,iE,oE,aE,lE,uE,cE,hE,pE,mE,gE,bE,vE,wE,xE,_E,kE,CE,SE,IE,TE,$E,RE,DE,OE,LE,TT,ME,PE,zE,BE,VE,UE,WE,HE,qE,ZE,YE,QE,JE,tT,eT,nT,sT,rT,oT,lT,lT,cT,dT,fT,mT,gT,yT,bT,vT,wT,xT,_T,kT,CT,IT,IT,ST,ET,NT,$T,AT,RT,FT,DT,OT,LT,MT,zT,BT,VT,WT,jT,GT,qT,KT,XT,YT,YT,QT,QT,{kernelName:Cv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ak(t,Xk(VC(n_(n,"float32")),2))}}},{kernelName:Dv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=U_(2);return{a:()=>Xk(t,Xk(r,Zk(n,s))),b:()=>Xk(t,Xk(r,Zk(s,n)))}}},{kernelName:Ov,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(t,Xk(n_(n,"float32"),2))}}},{kernelName:Yv,gradFunc:t=>({x:()=>ZC(t)})},{kernelName:Bv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Ok(n.shape,s.shape);return{a:()=>{let e=t;const s=Dk(n.shape,r);return s.length>0&&(e=Yk(e,s)),uk(e,n.shape)},b:()=>{let e=t;const n=Dk(s.shape,r);return n.length>0&&(e=Yk(e,n)),uk(mC(e),s.shape)}}}},{kernelName:Iv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:i}=n;Eg(i,s.shape).forEach(t=>{r[t]=1});const o=uk(t,r),a=Xk(o,vC(s.shape,"float32"));return{x:()=>a}}},{kernelName:Vv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ak(t,pC(UT(n)))}}},{kernelName:Wv,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Xk(Zk(U_(1),pC(n)),t)}}},{kernelName:Uv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let e=ZC(s);if(1===s.rank)for(let n=0;n<r[0];++n)e=G_(e,FC(t,[n*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)e=G_(e,FC(t,[n*s.shape[0],i*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let o=0;o<r[2];++o)e=G_(e,FC(t,[n*s.shape[0],i*s.shape[1],o*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let o=0;o<r[2];++o)for(let a=0;a<r[3];++a)e=G_(e,FC(t,[n*s.shape[0],i*s.shape[1],o*s.shape[2],a*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return e}}}},{kernelName:Gv,gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,i=hC(r);return{x:()=>YC(t,i)}}},{kernelName:Kv,gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>UC(t,r)}}},{kernelName:Xv,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=nC(e,ZC(e)),s=Wk(t,n);let r=jk(e,U_(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=Mk(r,a+1);r=Jk(r,vC(s.shape,"bool"));const o=ZC(s);return XC(r,s,o)}(t,n)}}},{kernelName:Zv,gradFunc:t=>({x:()=>ZC(t)})}];for(const Y3 of JT)uw(Y3);Uw().prototype.abs=function(){return this.throwIfDisposed(),H_(this)};const tN=yx({acos_:function(t){const e=mx(t,"x","acos");return ax.runKernel(sy,{x:e})}});Uw().prototype.acos=function(){return this.throwIfDisposed(),tN(this)};const eN=yx({acosh_:function(t){const e=mx(t,"x","acosh");return ax.runKernel(ry,{x:e})}});Uw().prototype.acosh=function(){return this.throwIfDisposed(),eN(this)},Uw().prototype.add=function(t){return this.throwIfDisposed(),G_(this,t)},Uw().prototype.all=function(t,e){return this.throwIfDisposed(),q_(this,t,e)},Uw().prototype.any=function(t,e){return this.throwIfDisposed(),K_(this,t,e)},Uw().prototype.argMax=function(t){return this.throwIfDisposed(),X_(this,t)};const nN=yx({argMin_:function(t,e=0){const n=mx(t,"x","argMin");return ax.runKernel(cy,{x:n},{axis:e})}});Uw().prototype.argMin=function(t){return this.throwIfDisposed(),nN(this,t)},Uw().prototype.asScalar=function(){return this.throwIfDisposed(),gg(1===this.size,()=>"The array must have only 1 element."),uk(this,[])},Uw().prototype.asType=function(t){return this.throwIfDisposed(),n_(this,t)},Uw().prototype.as1D=function(){return this.throwIfDisposed(),uk(this,[this.size])},Uw().prototype.as2D=function(t,e){return this.throwIfDisposed(),uk(this,[t,e])},Uw().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),uk(this,[t,e,n])},Uw().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),uk(this,[t,e,n,s])},Uw().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),uk(this,[t,e,n,s,r])};const sN=yx({asin_:function(t){const e=mx(t,"x","asin");return ax.runKernel(hy,{x:e})}});Uw().prototype.asin=function(){return this.throwIfDisposed(),sN(this)};const rN=yx({asinh_:function(t){const e=mx(t,"x","asinh");return ax.runKernel(dy,{x:e})}});Uw().prototype.asinh=function(){return this.throwIfDisposed(),rN(this)};const iN=yx({atan_:function(t){const e=mx(t,"x","atan");return ax.runKernel(py,{x:e})}});Uw().prototype.atan=function(){return this.throwIfDisposed(),iN(this)};const oN=yx({atan2_:function(t,e){let n=mx(t,"a","atan2"),s=mx(e,"b","atan2");return[n,s]=Jw(n,s),ax.runKernel(my,{a:n,b:s})}});Uw().prototype.atan2=function(t){return this.throwIfDisposed(),oN(this,t)};const aN=yx({atanh_:function(t){const e=mx(t,"x","atanh");return ax.runKernel(fy,{x:e})}});Uw().prototype.atanh=function(){return this.throwIfDisposed(),aN(this)},Uw().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),ck(this,t,e,n,s)},Uw().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),ZT(this,t,e)},Uw().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),dk(this,t,e,n,s,r)},Uw().prototype.broadcastTo=function(t){return this.throwIfDisposed(),KC(this,t)},Uw().prototype.cast=function(t){return this.throwIfDisposed(),n_(this,t)};const lN=yx({ceil_:function(t){const e=mx(t,"x","ceil");return ax.runKernel(Cy,{x:e})}});Uw().prototype.ceil=function(){return this.throwIfDisposed(),lN(this)},Uw().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),gk(this,t,e)},Uw().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Ww&&(t=[t]),yk([this,...t],e)},Uw().prototype.conv1d=function(t,e,n,s,r,i){return this.throwIfDisposed(),kk(this,t,e,n,s,r,i)},Uw().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),Ik(this,t,e,n,s,r)},Uw().prototype.conv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),_k(this,t,e,n,s,r,i)},Uw().prototype.cos=function(){return this.throwIfDisposed(),UT(this)},Uw().prototype.cosh=function(){return this.throwIfDisposed(),HT(this)},Uw().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),FE(this,t,e,n)};const uN=yx({depthToSpace_:function(t,e,n="NHWC"){const s=mx(t,"x","depthToSpace"),r="NHWC"===n?s.shape[1]:s.shape[2],i="NHWC"===n?s.shape[2]:s.shape[3],o="NHWC"===n?s.shape[3]:s.shape[1];return gg(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${e}  for depthToSpace with input shape\n    ${s.shape}`),gg(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e} for depthToSpace with input shape\n        ${s.shape}`),gg(o%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`),ax.runKernel(By,{x:s},{blockSize:e,dataFormat:n})}});Uw().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),uN(this,t,e)},Uw().prototype.depthwiseConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),Nk(this,t,e,n,s,r,i)};const cN=yx({dilation2d_:function(t,e,n,s,r=[1,1],i="NHWC"){const o=mx(t,"x","dilation2d"),a=mx(e,"filter","dilation2d");gg(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),gg(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),gg("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,u=!1;3===o.rank&&(l=uk(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0);const c=ax.runKernel(Hy,{x:l,filter:a},{strides:n,pad:s,dilations:r});return u?uk(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});Uw().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),cN(this,t,e,n,s,r)};const hN=yx({divNoNan_:function(t,e){let n=mx(t,"a","div"),s=mx(e,"b","div");[n,s]=Jw(n,s);const r=Ak(n,s),i=ZC(r),o=Lk(s,i);return XC(o,i,r)}});Uw().prototype.divNoNan=function(t){return this.throwIfDisposed(),hN(this,t)},Uw().prototype.div=function(t){return this.throwIfDisposed(),Ak(this,t)};const dN=yx({dot_:function(t,e){const n=mx(t,"t1","dot"),s=mx(e,"t2","dot");gg(!(1!==n.rank&&2!==n.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=1===n.rank?n.size:n.shape[1],i=1===s.rank?s.size:s.shape[0];if(gg(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),1===n.rank&&1===s.rank){const t=uk(n,[1,-1]),e=uk(s,[-1,1]),r=mI(t,e);return uk(r,[])}if(1===n.rank&&2===s.rank){const t=uk(n,[1,-1]),e=uk(s,[s.shape[0],s.shape[1]]),r=mI(t,e);return uk(r,[r.size])}if(2===n.rank&&1===s.rank){const t=uk(s,[-1,1]),e=mI(n,t);return uk(e,[e.size])}{const t=uk(s,[s.shape[0],s.shape[1]]);return mI(n,t)}}});Uw().prototype.dot=function(t){return this.throwIfDisposed(),dN(this,t)},Uw().prototype.elu=function(){return this.throwIfDisposed(),Rk(this)},Uw().prototype.equal=function(t){return this.throwIfDisposed(),Lk(this,t)};const pN=yx({erf_:function(t){let e=mx(t,"x","erf");return gg("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=n_(e,"float32")),ax.runKernel(Qy,{x:e})}});Uw().prototype.erf=function(){return this.throwIfDisposed(),pN(this)},Uw().prototype.exp=function(){return this.throwIfDisposed(),qk(this)},Uw().prototype.expandDims=function(t){return this.throwIfDisposed(),Mk(this,t)};const fN=yx({expm1_:function(t){const e=mx(t,"x","expm1");return ax.runKernel(nb,{x:e})}});Uw().prototype.expm1=function(){return this.throwIfDisposed(),fN(this)},Uw().prototype.fft=function(){return this.throwIfDisposed(),eI(this)},Uw().prototype.flatten=function(){return this.throwIfDisposed(),uk(this,[this.size])},Uw().prototype.floor=function(){return this.throwIfDisposed(),Vk(this)},Uw().prototype.floorDiv=function(t){return this.throwIfDisposed(),$k(this,t)},Uw().prototype.gather=function(t,e){return this.throwIfDisposed(),Wk(this,t,e)},Uw().prototype.greaterEqual=function(t){return this.throwIfDisposed(),jk(this,t)},Uw().prototype.greater=function(t){return this.throwIfDisposed(),Uk(this,t)},Uw().prototype.ifft=function(){return this.throwIfDisposed(),sI(this)},Uw().prototype.irfft=function(){return this.throwIfDisposed(),rI(this)};const mN=yx({isFinite_:function(t){const e=mx(t,"x","isFinite");return ax.runKernel(gb,{x:e})}});Uw().prototype.isFinite=function(){return this.throwIfDisposed(),mN(this)};const gN=yx({isInf_:function(t){const e=mx(t,"x","isInf");return ax.runKernel(yb,{x:e})}});Uw().prototype.isInf=function(){return this.throwIfDisposed(),gN(this)};const yN=yx({isNaN_:function(t){const e=mx(t,"x","isNaN");return ax.runKernel(bb,{x:e})}});Uw().prototype.isNaN=function(){return this.throwIfDisposed(),yN(this)},Uw().prototype.leakyRelu=function(t){return this.throwIfDisposed(),Hk(this,t)},Uw().prototype.lessEqual=function(t){return this.throwIfDisposed(),DI(this,t)},Uw().prototype.less=function(t){return this.throwIfDisposed(),uT(this,t)};const bN=yx({localResponseNormalization_:function(t,e=5,n=1,s=1,r=.5){const i=mx(t,"x","localResponseNormalization");gg(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),gg(_g(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=uk(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l=ax.runKernel(Tb,{x:o},{depthRadius:e,bias:n,alpha:s,beta:r});return a?uk(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});Uw().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),bN(this,t,e,n,s)};const vN=yx({logSigmoid_:function(t){const e=mx(t,"x","logSigmoid");return W_(t=>({value:mC(zC(mC(t))),gradFunc:e=>Xk(e,RC(mC(t)))}))(e)}});Uw().prototype.logSigmoid=function(){return this.throwIfDisposed(),vN(this)},Uw().prototype.logSoftmax=function(t){return this.throwIfDisposed(),Qk(this,t)},Uw().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),XI(this,t,e)},Uw().prototype.log=function(){return this.throwIfDisposed(),Gk(this)},Uw().prototype.log1p=function(){return this.throwIfDisposed(),KI(this)},Uw().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Jk(this,t)},Uw().prototype.logicalNot=function(){return this.throwIfDisposed(),PT(this)};const wN=yx({logicalOr_:function(t,e){const n=mx(t,"a","logicalOr","bool"),s=mx(e,"b","logicalOr","bool");return Ok(n.shape,s.shape),ax.runKernel(Eb,{a:n,b:s})}});Uw().prototype.logicalOr=function(t){return this.throwIfDisposed(),wN(this,t)};const xN=yx({logicalXor_:function(t,e){const n=mx(t,"a","logicalXor","bool"),s=mx(e,"b","logicalXor","bool");return Ok(n.shape,s.shape),Jk(wN(t,e),PT(Jk(t,e)))}});Uw().prototype.logicalXor=function(t){return this.throwIfDisposed(),xN(this,t)},Uw().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),mI(this,t,e,n)},Uw().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),tC(this,t,e,n,s)},Uw().prototype.max=function(t,e){return this.throwIfDisposed(),Kk(this,t,e)},Uw().prototype.maximum=function(t){return this.throwIfDisposed(),nC(this,t)},Uw().prototype.mean=function(t,e){return this.throwIfDisposed(),sC(this,t,e)},Uw().prototype.min=function(t,e){return this.throwIfDisposed(),PI(this,t,e)},Uw().prototype.minimum=function(t){return this.throwIfDisposed(),rC(this,t)};const _N=yx({mirrorPad_:function(t,e,n){gg("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=mx(t,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");gg(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r="reflect"===n?1:0;for(let i=0;i<s.rank;i++)gg(2===e[i].length,()=>"Invalid number of paddings. Must be length of 2 each."),gg(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);return ax.runKernel(Bb,{x:s},{paddings:e,mode:n})}});Uw().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),_N(this,t,e)};const kN=yx({mod_:function(t,e){let n=mx(t,"a","mod"),s=mx(e,"b","mod");return[n,s]=Jw(n,s),ax.runKernel(Vb,{a:n,b:s})}});Uw().prototype.mod=function(t){return this.throwIfDisposed(),kN(this,t)},Uw().prototype.mul=function(t){return this.throwIfDisposed(),Xk(this,t)},Uw().prototype.neg=function(){return this.throwIfDisposed(),mC(this)},Uw().prototype.norm=function(t,e,n){return this.throwIfDisposed(),VI(this,t,e,n)},Uw().prototype.notEqual=function(t){return this.throwIfDisposed(),gC(this,t)},Uw().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),yC(this,t,e,n)},Uw().prototype.onesLike=function(){return this.throwIfDisposed(),wC(this)},Uw().prototype.pad=function(t,e){return this.throwIfDisposed(),xC(this,t,e)};const CN=yx({pool_:function(t,e,n,s,r,i){null==r&&(r=[1,1]),null==i&&(i=1),0===s&&(s="valid");const o=mx(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=uk(o,[1,o.shape[0],o.shape[1],o.shape[2]])),gg(ak(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const u=Y_(a.shape,e,i,r,s),c=[u.dilationHeight,u.dilationWidth];let h;h="same"===s?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),s=n.map(t=>Math.floor(t/2)),r=n.map((t,e)=>t-s[e]);return n.map((t,e)=>[s[e],r[e]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(t,e,n){const s=n.map(t=>t[0]),r=n.map(t=>t[1]),i=t.concat(s,r),o=e.map((t,e)=>(t-i[e]%t)%t),a=r.map((t,e)=>t+o[e]);return[e.map((t,e)=>[s[e],a[e]]),e.map((t,e)=>[0,o[e]])]}([u.inHeight,u.inWidth],c,h),m=d?s:"valid",g=d?a:yE(a,c,p),y=("avg"===n?()=>ck(g,e,i,m):()=>tC(g,e,i,m))(),b=d?y:ZT(y,c,f);return l?uk(b,[b.shape[1],b.shape[2],b.shape[3]]):b}});Uw().prototype.pool=function(t,e,n,s,r){return this.throwIfDisposed(),CN(this,t,e,n,s,r)},Uw().prototype.pow=function(t){return this.throwIfDisposed(),zI(this,t)},Uw().prototype.prelu=function(t){return this.throwIfDisposed(),_C(this,t)};const IN=yx({prod_:function(t,e=null,n=!1){let s=mx(t,"x","prod");return"bool"===s.dtype&&(s=n_(s,"int32")),ax.runKernel(ev,{x:s},{axis:e,keepDims:n})}});Uw().prototype.prod=function(t,e){return this.throwIfDisposed(),IN(this,t,e)};const SN=yx({reciprocal_:function(t){const e=mx(t,"x","reciprocal");return ax.runKernel(rv,{x:e})}});Uw().prototype.reciprocal=function(){return this.throwIfDisposed(),SN(this)},Uw().prototype.relu=function(){return this.throwIfDisposed(),TC(this)},Uw().prototype.relu6=function(){return this.throwIfDisposed(),oI(this)},Uw().prototype.reshapeAs=function(t){return this.throwIfDisposed(),uk(this,t.shape)},Uw().prototype.reshape=function(t){return this.throwIfDisposed(),uk(this,t)},Uw().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),AI(this,t,e,n)},Uw().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),RI(this,t,e,n)},Uw().prototype.reverse=function(t){return this.throwIfDisposed(),NC(this,t)},Uw().prototype.rfft=function(){return this.throwIfDisposed(),nI(this)},Uw().prototype.round=function(){return this.throwIfDisposed(),OI(this)},Uw().prototype.rsqrt=function(){return this.throwIfDisposed(),jE(this)},Uw().prototype.selu=function(){return this.throwIfDisposed(),$C(this)},Uw().prototype.separableConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),AC(this,t,e,n,s,r,i)},Uw().prototype.sigmoid=function(){return this.throwIfDisposed(),RC(this)};const EN=yx({sign_:function(t){const e=mx(t,"x","sign");return ax.runKernel(xv,{x:e})}});Uw().prototype.sign=function(){return this.throwIfDisposed(),EN(this)},Uw().prototype.sin=function(){return this.throwIfDisposed(),NE(this)},Uw().prototype.sinh=function(){return this.throwIfDisposed(),AE(this)},Uw().prototype.slice=function(t,e){return this.throwIfDisposed(),FC(this,t,e)},Uw().prototype.softmax=function(t){return this.throwIfDisposed(),PC(this,t)},Uw().prototype.softplus=function(){return this.throwIfDisposed(),zC(this)},Uw().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),yE(this,t,e)},Uw().prototype.split=function(t,e){return this.throwIfDisposed(),BC(this,t,e)},Uw().prototype.sqrt=function(){return this.throwIfDisposed(),VC(this)},Uw().prototype.square=function(){return this.throwIfDisposed(),pC(this)},Uw().prototype.squaredDifference=function(t){return this.throwIfDisposed(),qI(this,t)},Uw().prototype.squeeze=function(t){return this.throwIfDisposed(),WC(this,t)},Uw().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Ww?[this,t]:[this,...t];return UC(n,e)},Uw().prototype.step=function(t){return this.throwIfDisposed(),aI(this,t)};const TN=yx({stridedSlice_:function(t,e,n,s,r=0,i=0,o=0,a=0,l=0){const u=mx(t,"x","stridedSlice","string_or_numeric");return ax.runKernel(Lv,{x:u},{begin:e,end:n,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}});Uw().prototype.stridedSlice=function(t,e,n,s,r,i,o,a){return this.throwIfDisposed(),TN(this,t,e,n,s,r,i,o,a)},Uw().prototype.sub=function(t){return this.throwIfDisposed(),Zk(this,t)},Uw().prototype.sum=function(t,e){return this.throwIfDisposed(),Yk(this,t,e)};const NN=yx({tan_:function(t){const e=mx(t,"x","tan");return ax.runKernel(Vv,{x:e})}});Uw().prototype.tan=function(){return this.throwIfDisposed(),NN(this)},Uw().prototype.tanh=function(){return this.throwIfDisposed(),jC(this)},Uw().prototype.tile=function(t){return this.throwIfDisposed(),Pk(this,t)},Uw().prototype.toBool=function(){return this.throwIfDisposed(),n_(this,"bool")},Uw().prototype.toFloat=function(){return this.throwIfDisposed(),n_(this,"float32")},Uw().prototype.toInt=function(){return this.throwIfDisposed(),n_(this,"int32")};const $N=yx({topk_:function(t,e=1,n=!0){const s=mx(t,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},o={k:e,sorted:n},[a,l]=ax.runKernel(jv,i,o);return{values:a,indices:l}}});Uw().prototype.topk=function(t,e){return this.throwIfDisposed(),$N(this,t,e)},Uw().prototype.transpose=function(t){return this.throwIfDisposed(),YC(this,t)};const AN=yx({unique_:function(t,e=0){const n=mx(t,"x","unique","string_or_numeric");gg(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[i,o]=ax.runKernel(qv,s,r);return{values:i,indices:o}}});let RN;function FN(){return null==RN&&(RN=ax.backend.epsilon()),RN}Uw().prototype.unique=function(t){return this.throwIfDisposed(),AN(this,t)},Uw().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),GE(this,t,e)},Uw().prototype.unstack=function(t){return this.throwIfDisposed(),qC(this,t)},Uw().prototype.where=function(t,e){return this.throwIfDisposed(),XC(t,this,e)},Uw().prototype.zerosLike=function(){return this.throwIfDisposed(),ZC(this)};class DN extends Error{constructor(t){super(t),Object.setPrototypeOf(this,DN.prototype)}}class ON extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ON.prototype)}}class LN extends Error{constructor(t){super(t),Object.setPrototypeOf(this,LN.prototype)}}class MN extends Error{constructor(t){super(t),Object.setPrototypeOf(this,MN.prototype)}}class PN extends Error{constructor(t){super(t),Object.setPrototypeOf(this,PN.prototype)}}function zN(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function BN(t,e){if(!t)throw new PN(e)}function VN(t,e){let n=0;for(const s of t)s===e&&n++;return n}function WN(t){return 1===t.length?t[0]:t}function UN(t){return Array.isArray(t)?t:[t]}function jN(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function HN(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let GN={};function qN(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function KN(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(t=>KN(t));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?KN(e):t[n]=e.value)}}}function XN(t,e={},n={},s="object",r=!1){if("string"==typeof t){const r=t;let i;if(r in n)i=n[r];else if(r in GN)i=GN[r];else if(i=e[r],null==i)throw new LN(`Unknown ${s}: ${t}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=t;if(null==i.className||null==i.config)throw new LN(`${s}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const o=i.className;let a,l;if(o in n?[a,l]=n[o]:o in GN?[a,l]=GN.className:o in e&&([a,l]=e[o]),null==a)throw new LN(`Unknown ${s}: ${o}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const n of Object.keys(GN))t[n]=GN[n];for(const r of Object.keys(n))t[r]=n[r];i.config.customObjects=t;const e=Object.assign({},GN);for(const r of Object.keys(n))GN[r]=n[r];KN(i.config);const s=l(a,i.config,n,r);return GN=Object.assign({},e),s}{const t=Object.assign({},GN);for(const s of Object.keys(n))GN[s]=n[s];const e=new a(i.config);return GN=Object.assign({},t),e}}}function ZN(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function YN(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function QN(t){if(null==t)throw new LN(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function JN(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new LN(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function t$(t,e,n=0,s=1/0){return BN(n>=0),BN(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(t=>typeof t===e)}function e$(t,e){Array.isArray(t)?(gg(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((t,n)=>e$(t,`element ${n+1} of ${e}`))):gg(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${n$(t)}.`)}function n$(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>n$(t)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function s$(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function r$(t,e){return P_(()=>VC(Yk(Xk(t,t),e,!0)))}class i$ extends F_{getConfig(){return{}}}class o$ extends i${constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return P_(()=>{const e=r$(t,this.axis),n=gk(e,0,this.maxValue);return Xk(t,Ak(n,G_(FN(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}o$.className="MaxNorm",O_(o$);class a$ extends i${constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return P_(()=>Ak(t,G_(FN(),r$(t,this.axis))))}getConfig(){return{axis:this.axis}}}a$.className="UnitNorm",O_(a$);class l$ extends i${apply(t){return TC(t)}}l$.className="NonNeg",O_(l$);class u$ extends i${constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return P_(()=>{const e=r$(t,this.axis),n=G_(Xk(this.rate,gk(e,this.minValue,this.maxValue)),Xk(1-this.rate,e));return Xk(t,Ak(n,G_(FN(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}u$.className="MinMaxNorm",O_(u$);const c$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function h$(t){return qN(t)}function d$(t,e={}){return XN(t,D_.getMap().classNameMap,e,"constraint")}function p$(t){return null==t?null:"string"==typeof t?d$({className:t in c$?c$[t]:t,config:{}}):t instanceof i$?t:d$(t)}const f$=["channelsFirst","channelsLast"],m$=["nearest","bilinear"],g$=["valid","same","causal"],y$=["max","avg"],b$=["sum","mul","concat","ave"],v$=new Map;function w$(t){JN(f$,"DataFormat",t)}function x$(t){JN(g$,"PaddingMode",t)}function _$(t){JN(y$,"PoolMode",t)}const k$=[];function C$(t,e){k$.push(t);try{const t=e();return k$.pop(),t}catch(n){throw k$.pop(),n}}function I$(t){if(!T$(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===k$.length?"":k$.join("/")+"/")+t}function S$(t){if(!T$(t))throw new Error("Not a valid tensor name: '"+t+"'");v$.has(t)||v$.set(t,0);const e=v$.get(t);if(v$.set(t,v$.get(t)+1),e>0){const n=`${t}_${e}`;return v$.set(n,1),n}return t}const E$=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function T$(t){return!!t.match(E$)}function N$(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function $$(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s<e&&(e=s)}return e}function A$(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s>e&&(e=s)}return e}function R$(t,e){if(e<t)throw new LN(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}function F$(t,e){return t.asType(e)}function D$(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),t.reshape(n)}function O$(t,e,n){return P_(()=>{switch(t.rank){case 1:return DC(t,e,n);case 2:return OC(t,[e,0],[n,t.shape[1]]);case 3:return LC(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return MC(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return FC(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return FC(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new LN(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function L$(t,e,n){return P_(()=>{switch(t.rank){case 1:return DC(t,e,n);case 2:return OC(t,[0,e],[t.shape[0],n]);case 3:return LC(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return MC(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new LN(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function M$(t,e,n,s){return P_(()=>{switch(t.rank){case 1:return DC(t,e,n);case 2:switch(s){case 1:return O$(t,e,n);case 2:return L$(t,e,n);default:throw new LN(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return O$(t,e,n);case 2:return LC(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return L$(t,e,n);default:throw new LN(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return O$(t,e,n);case 2:return MC(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return MC(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return L$(t,e,n);default:throw new LN(`The axis is not within the rank of the tensor ${s}`)}default:throw new LN(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function P$(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),yk(t,e)}function z$(t,e){switch(t.rank){case 1:return bk([t,e]);case 2:return vk([t,e],0);case 3:return wk([t,e],0);case 4:return xk([t,e],0);default:throw new LN(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function B$(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new LN(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return Pk(t,e)}function V$(t,e=0,n=1,s,r){return SC(t,e,n,s,r)}function W$(t,e,n,s){if(t.rank<2||e.rank<2)throw new MN(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new MN(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);if(2===t.rank&&2===e.rank)return gI({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?H$(t.rank,s,"channelsLast"):null,activation:n});{const r=t.shape.slice(),i=r.pop();t=t.reshape([-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),u=[...o,a],c=Array.from({length:e.rank},(t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n);e=e.transpose(c).reshape([l,-1]);const h=[...r,...u];return gI({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?H$(t.rank,s,"channelsLast"):null,activation:n}).reshape(h)}}function U$(t,e,n){return P_(()=>(e=Array.isArray(e)?HC(e,"int32"):e.toInt(),Wk(t,e,n)))}function j$(t){return Xk(t,t)}function H$(t,e,n){const s=e.shape;if(1!==e.rank&&e.rank!==t)throw new LN(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,s[0]]:[1].concat(s))}else if(t<3)return e;throw new LN(`Unsupported input rank by biasAdd: ${e.rank}`)}function G$(t,e,n){return P_(()=>(null==n&&(n="channelsLast"),w$(n),t.add(H$(t.rank,e,n))))}function q$(t,e,n,s){return P_(()=>QC(t,e,n,s))}function K$(t,e,n=!1){return n?t():e()}const X$=["fanIn","fanOut","fanAvg"],Z$=["normal","uniform","truncatedNormal"];class Y$ extends F_{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Q$ extends Y${apply(t,e){return bC(t,e)}}Q$.className="Zeros",O_(Q$);class J$ extends Y${apply(t,e){return vC(t,e)}}J$.className="Ones",O_(J$);class tA extends Y${constructor(t){if(super(),"object"!=typeof t)throw new LN(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new LN(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return P_(()=>Xk(U_(this.value),vC(t,e)))}getConfig(){return{value:this.value}}}tA.className="Constant",O_(tA);class eA extends Y${constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return EC(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}eA.className="RandomUniform",O_(eA);class nA extends Y${constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new MN(`randomNormal does not support dType ${e}.`);return V$(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}nA.className="RandomNormal",O_(nA);class sA extends Y${constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new MN(`truncatedNormal does not support dType ${e}.`);return GC(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}sA.className="TruncatedNormal",O_(sA);class rA extends Y${constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return P_(()=>{if(2!==t.length||t[0]!==t[1])throw new LN("Identity matrix initializer can only be used for 2D square matrices.");return Xk(this.gain,zk(t[0]))})}getConfig(){return{gain:this.gain}}}rA.className="Identity",O_(rA);class iA extends Y${constructor(t){if(super(),t.scale<0)throw new LN(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,JN(X$,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,JN(Z$,"Distribution",this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,s;if(w$(e),2===t.length)n=t[0],s=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=N$(t,2);n=t[1]*e,s=t[0]*e}else if("channelsLast"===e){const e=N$(t,0,t.length-2);n=t[t.length-2]*e,s=t[t.length-1]*e}}else{const e=N$(t);n=Math.sqrt(e),s=Math.sqrt(e)}return[n,s]}(t),s=n[0],r=n[1];let i=this.scale;if(i/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,r):Math.max(1,(s+r)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new MN(`${this.getClassName()} does not support dType ${e}.`);return GC(t,0,n,e,this.seed)}{const n=Math.sqrt(3*i);return EC(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}iA.className="VarianceScaling",O_(iA);class oA extends iA{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return iA.className}}oA.className="GlorotUniform",O_(oA);class aA extends iA{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return iA.className}}aA.className="GlorotNormal",O_(aA);class lA extends iA{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return iA.className}}lA.className="HeNormal",O_(lA);class uA extends iA{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return iA.className}}uA.className="HeUniform",O_(uA);class cA extends iA{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return iA.className}}cA.className="LeCunNormal",O_(cA);class hA extends iA{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return iA.className}}hA.className="LeCunNormal",O_(hA);class dA extends Y${constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new MN("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return P_(()=>{if(t.length<2)throw new MN("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=V$(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=ZI.gramSchmidt(e);return t[0]>t[1]&&(n=n.transpose()),Xk(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}dA.className="Orthogonal",O_(dA);const pA={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function fA(t,e={}){return XN(t,D_.getMap().classNameMap,e,"initializer")}function mA(t){return qN(t)}function gA(t){if("string"==typeof t){const e=t in pA?pA[t]:t;if("GlorotNormal"===e)return new aA;if("GlorotUniform"===e)return new oA;if("HeNormal"===e)return new lA;if("HeUniform"===e)return new uA;if("LeCunNormal"===e)return new cA;if("LeCunUniform"===e)return new hA;{const t={};return t.className=e,t.config={},fA(t)}}return t instanceof Y$?t:fA(t)}let yA=0;function bA(){return yA++}const vA={};function wA(t=""){return t in vA||(vA[t]=0),vA[t]+=1,t+vA[t].toString()}function xA(t){return Array.isArray(t)&&Array.isArray(t[0])}function _A(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function kA(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new LN(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function CA(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new LN(`Expected exactly 1 Shape; got ${t.length}`)}return t}function IA(t){let e=0;for(const n of t)e+=0===n.shape.length?1:n.shape.reduce((t,e)=>t*e);return e}class SA{constructor(t,e="float32",n="Variable",s=!0,r=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=bA(),this.originalName=I$(n=null==n?"Variable":n),this.name=S$(this.originalName),this.trainable_=s,this.constraint=r,this.val=function(t,e=!0,n,s){return ax.makeVariable(t,e,n,s)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function EA(t){return t.map(t=>t.read())}function TA(t){t.forEach(t=>{t[0].write(t[1])})}class NA{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class $A{constructor(t,e,n,s,r,i,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=s,this.callArgs=r,this.outputTensorIndex=o,this.id=bA(),null!=i&&(this.originalName=I$(i),this.name=S$(this.originalName)),this.rank=e.length}}let AA=0;class RA{constructor(t,e){this.callArgs=e,this.id=AA++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let FA=0;class DA extends F_{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=FA++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=jN(t)+"_"+wA(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new ON(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new LN(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return WN(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return WN(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new DN(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new DN(`Layer ${this.name} is not connected, no input to return.`);return WN(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new DN(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new DN(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return WN(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=UN(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=UN(this.inputSpec);if(t.length!==e.length)throw new LN(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){const s=t[n],r=e[n];if(null==r)continue;const i=s.rank;if(null!=r.ndim&&i!==r.ndim)throw new LN(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${i}`);if(null!=r.maxNDim&&i>r.maxNDim)throw new LN(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${i}`);if(null!=r.minNDim&&i<r.minNDim)throw new LN(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${i}.`);if(null!=r.dtype&&s.dtype!==r.dtype)throw new LN(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${s.dtype}.`);if(r.axes){const t=s.shape;for(const e in r.axes){const s=Number(e),i=r.axes[e],o=s>=0?t[s]:t[t.length+s];if(null!=i&&-1===[i,null].indexOf(o))throw new LN(`Input ${n} is incompatible with layer ${this.name}: expected axis ${s} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const e=r.shape[t],i=s.shape[t];if(null!=e&&null!=i&&e!==i)throw new LN(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=UN(t);let s=!0;for(const i of n)if(!(i instanceof $A)){s=!1;break}let r=!0;for(const i of n)if(i instanceof $A){r=!1;break}if(s===r)throw new LN("Arguments to apply() must be all SymbolicTensors or all Tensors");return C$(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of UN(t))e.push(n.shape);this.build(WN(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(t),r){let s=this.call(t,e);const r=UN(s),i=[];for(let t of r)-1!==n.indexOf(t)&&(t=t.clone()),i.push(t);if(s=WN(i),null!=this.activityRegularizer)throw new MN("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}{const n=function(t){t=UN(t);const e=[];for(const n of t)e.push(n.shape);return WN(e)}(t),s=this.computeOutputShape(n);let r;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),r=null!=s&&s.length>0&&Array.isArray(s[0])?s.map((n,s)=>new $A(i,n,this,UN(t),e,this.name,s)):new $A(i,s,this,UN(t),e,this.name),this.addInboundNode(t,r,null,null,n,s,e),this._refCount++,null!=this.activityRegularizer)throw new MN("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,s)=>{null!=n&&null!=t[s]&&t[s]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new DN(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new DN(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ON(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return IA(this.weights)}build(t){this.built=!0}getWeights(t=!1){return EA(t?this.trainableWeights:this.weights)}setWeights(t){P_(()=>{const e=this.weights;if(e.length!==t.length)throw new LN(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],s=EA(e);for(let r=0;r<s.length;++r){const i=s[r],o=e[r],a=t[r];if(!xg(i.shape,a.shape))throw new LN(`Layer weight shape ${i.shape} not compatible with provided weight shape ${a.shape}`);n.push([o,a])}TA(n)})}addWeight(t,e,n,s,r,i,o){if(-1!==this._addedWeightNames.indexOf(t))throw new LN(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(s=gA("zeros"));const a=s.apply(e,n),l=new SA(a,n,t,i,o);return a.dispose(),null!=r&&this.addLoss(()=>r.apply(l.read())),null==i&&(i=!0),i?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=UN(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,n,s,r,i,o=null){const a=UN(t);e=UN(e),n=UN(n),s=UN(s),r=_A(r),i=_A(i);const l=[],u=[],c=[];for(const h of a)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new RA({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:a,outputTensors:e,inputMasks:n,outputMasks:s,inputShapes:r,outputShapes:i},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function OA(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const s=OA(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of s)-1===e.indexOf(t)&&e.push(t)}return e}}}class LA extends DA{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:wA("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new LN("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new LN("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new LN("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const s=new $A(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new RA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new LN(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function MA(t){return PA.apply(this,arguments)}function PA(){return(PA=lg(function*(t){if(null==t)return;const e=[],n=[],s=[];for(const r in t){const i=t[r];if("number"!=typeof i){const t=i;e.push(t.data()),n.push(r),s.push(t)}}if(e.length>0){const r=yield Promise.all(e);for(let e=0;e<r.length;++e)t[n[e]]=r[e][0];z_(s)}})).apply(this,arguments)}function zA(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var BA;LA.className="InputLayer",O_(LA),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(BA||(BA={}));class VA{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return lg(function*(){})()}onEpochEnd(t,e){return lg(function*(){})()}onBatchBegin(t,e){return lg(function*(){})()}onBatchEnd(t,e){return lg(function*(){})()}onTrainBegin(t){return lg(function*(){})()}onTrainEnd(t){return lg(function*(){})()}setModel(t){}}class WA{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var n=this;return lg(function*(){null==e&&(e={});for(const s of n.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var n=this;return lg(function*(){null==e&&(e={});for(const s of n.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var n=this;return lg(function*(){null==e&&(e={});for(const s of n.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var n=this;return lg(function*(){null==e&&(e={});for(const s of n.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return lg(function*(){null==t&&(t={});for(const n of e.callbacks)yield n.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return lg(function*(){null==t&&(t={});for(const n of e.callbacks)yield n.onTrainEnd(t)})()}}class UA extends VA{constructor(){super()}onEpochBegin(t){var e=this;return lg(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var n=this;return lg(function*(){null==e&&(e={});const t=null==e.size?0:e.size;n.seen+=t;for(const s in e){const r=e[s];if("number"==typeof r)n.totals.hasOwnProperty(s)||(n.totals[s]=0),n.totals[s]=n.totals[s]+r*t;else{let e;s in n.totals?e=n.totals[s]:n.totals[s]=0;const i=P_(()=>G_(n.totals[s],Xk(r,t)));n.totals[s]=i,null!=e&&e.dispose()}}})()}onEpochEnd(t,e){var n=this;return lg(function*(){if(null!=e)for(const t of n.params.metrics)null!=n.totals[t]&&("number"==typeof n.totals[t]?e[t]=n.totals[t]/n.seen:P_(()=>{const s=Xk(Ak(1,n.seen),n.totals[t]);e[t]=s,n.totals[t].dispose(),B_(e[t])}))})()}}class jA extends VA{onTrainBegin(t){var e=this;return lg(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var n=this;return lg(function*(){null==e&&(e={}),n.epoch.push(t);for(const t in e)null==n.history[t]&&(n.history[t]=[]),n.history[t].push(e[t])})()}syncData(){var t=this;return lg(function*(){const e=[],n=[],s=[];for(const i in t.history){const r=t.history[i];for(let t=0;t<r.length;++t)"number"!=typeof r[t]&&(e.push(r[t].data()),n.push(i),s.push(t))}const r=yield Promise.all(e);for(let i=0;i<r.length;++i)t.history[n[i]][s[i]].dispose(),t.history[n[i]][s[i]]=r[i][0]})()}}class HA extends VA{constructor(t,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Og(this.yieldEvery)&&(this.maybeWait=function(t,e){let n,s=Ew();return(...r)=>{const i=Ew();return i-s<e||(s=i,n=t(...r)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,n){var s=this;return lg(function*(){const r=[];null!=s.yield&&(yield MA(n),r.push(s.yield(t,e,n))),r.push(aS()),yield Promise.all(r)})()}onEpochBegin(t,e){var n=this;return lg(function*(){n.currentEpoch=t,null!=n.epochBegin&&(yield MA(e),yield n.epochBegin(t,e))})()}onEpochEnd(t,e){var n=this;return lg(function*(){const s=[];null!=n.epochEnd&&(yield MA(e),s.push(n.epochEnd(t,e))),"epoch"===n.yieldEvery&&s.push(aS()),yield Promise.all(s)})()}onBatchBegin(t,e){var n=this;return lg(function*(){null!=n.batchBegin&&(yield MA(e),yield n.batchBegin(t,e))})()}onBatchEnd(t,e){var n=this;return lg(function*(){const s=[];null!=n.batchEnd&&(yield MA(e),s.push(n.batchEnd(t,e))),"batch"===n.yieldEvery?s.push(aS()):Og(n.yieldEvery)&&s.push(n.maybeWait(n.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return lg(function*(){null!=e.trainBegin&&(yield MA(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return lg(function*(){null!=e.trainEnd&&(yield MA(t),yield e.trainEnd(t))})()}}function GA(t,e){return null==t&&(t={}),t instanceof VA?[t]:Array.isArray(t)&&t[0]instanceof VA?t:UN(t).map(t=>new HA(t,e))}class qA{constructor(){}static registerCallbackConstructor(t,e){gg(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),qA.checkForDuplicate(e),null==qA.constructors[t]&&(qA.constructors[t]=[]),qA.constructors[t].push(e)}static checkForDuplicate(t){for(const e in qA.constructors)qA.constructors[+e].forEach(e=>{if(e===t)throw new LN("Duplicate callback constructor.")})}static clear(){qA.constructors={}}static createCallbacks(t){const e=[];for(const n in qA.constructors){const s=+n;t>=s&&e.push(...qA.constructors[s])}return e.map(t=>new t)}}function KA(t,e,n,s,r,i,o,a,l){const u=new jA,c=[new UA,...qA.createCallbacks(e)];null!=t&&c.push(...t),c.push(u);const h=new WA(c);return h.setParams({epochs:n,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}function XA(t,e={},n=!1){return XN(t,D_.getMap().classNameMap,e,"layer",n)}function ZA(t,e){return P_(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const n=Yk(j$(t),e,!0),s=Bk(n.shape,FN()),r=VC(nC(n,s));return Ak(t,r)})}function YA(t,e){return P_(()=>sC(j$(Zk(e,t)),-1))}function QA(t,e){return P_(()=>sC(H_(Zk(e,t)),-1))}function JA(t,e){return P_(()=>{const n=Zk(t,e),s=gk(H_(t),FN(),Number.MAX_VALUE),r=H_(Ak(n,s));return Xk(100,sC(r,-1))})}function tR(t,e,n=!1){return P_(()=>{if(n)e=PC(e);else{const t=Yk(e,e.shape.length-1,!0);e=Ak(e,t)}return e=gk(e,FN(),1-FN()),mC(Yk(Xk(t.toFloat(),Gk(e)),e.shape.length-1))})}function eR(t,e,n=!1){return P_(()=>{const s=Vk(function(t){const e=[N$(t.shape)];return t.reshape(e)}(t)).toInt(),r=(e=gk(e,FN(),1-FN())).shape;return tR(yC(s,r[r.length-1]).reshape(r),e,n)})}function nR(t,e){return P_(()=>{let n;return n=gk(e,FN(),1-FN()),n=Gk(Ak(n,Zk(1,n))),sC(function(t,e){if(!xg(t.shape,e.shape))throw new LN(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return P_(()=>{const n=e.relu(),s=e.abs().neg();return n.sub(e.mul(t)).add(s.exp().log1p())})}(t,n),-1)})}function sR(t,e){return P_(()=>{const n=ZA(t,-1),s=ZA(e,-1),r=Xk(n,s);return mC(Yk(r,-1))})}qA.constructors={};const rR={meanSquaredError:YA,meanAbsoluteError:QA,meanAbsolutePercentageError:JA,meanSquaredLogarithmicError:function(t,e){return P_(()=>{const n=gk(e,FN(),Number.MAX_VALUE),s=Gk(G_(1,n)),r=gk(t,FN(),Number.MAX_VALUE),i=Gk(G_(1,r));return sC(j$(Zk(s,i)),-1)})},squaredHinge:function(t,e){return P_(()=>{const n=nC(0,Zk(1,Xk(t,e)));return sC(j$(n),-1)})},hinge:function(t,e){return P_(()=>{const n=nC(0,Zk(1,Xk(t,e)));return sC(n,-1)})},categoricalHinge:function(t,e){return P_(()=>{const n=Yk(Xk(t,e),-1),s=Kk(Xk(Zk(1,t),e),-1);return nC(0,G_(1,Zk(s,n)))})},logcosh:function(t,e){return P_(()=>{const n=Math.log(2),s=Zk(e,t),r=Zk(G_(s,zC(Xk(-2,s))),n);return sC(r,-1)})},categoricalCrossentropy:tR,sparseCategoricalCrossentropy:eR,binaryCrossentropy:nR,kullbackLeiblerDivergence:function(t,e){return P_(()=>{const n=gk(t,FN(),1),s=gk(e,FN(),1);return Yk(Xk(t,Gk(Ak(n,s))),-1)})},poisson:function(t,e){return P_(()=>{const n=Gk(G_(FN(),e));return sC(Zk(e,Xk(t,n)),-1)})},cosineProximity:sR};function iR(t){if("string"==typeof t){if(t in rR)return rR[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new LN(e)}return t}function oR(t,e){return P_(()=>{const n=Xk(.5,wC(e)),s=F$(Uk(e,n),t.dtype);return sC(Lk(t,s),-1)})}function aR(t,e){return P_(()=>F$(Lk(X_(t,-1),X_(e,-1)),"float32"))}function lR(t,e){return nR(t,e)}function uR(t,e){return t.rank===e.rank&&(t=t.squeeze([t.rank-1])),(e=e.argMax(-1)).dtype!==t.dtype&&(e=e.asType(t.dtype)),Lk(t,e).asType("float32")}const cR=tR,hR=eR,dR={binaryAccuracy:oR,categoricalAccuracy:aR,precision:function(t,e){return P_(()=>{const n=function(t,e){return P_(()=>Jk(t.equal(1),e.equal(1)).sum().cast("float32"))}(t,e),s=function(t,e){return P_(()=>Jk(t.equal(0),e.equal(1)).sum().cast("float32"))}(t,e),r=n.add(s);return XC(Uk(r,0),n.div(r),0).cast("float32")})},categoricalCrossentropy:cR,sparseCategoricalCrossentropy:hR,mse:YA,MSE:YA,mae:QA,MAE:QA,mape:JA,MAPE:JA,cosine:sR};function pR(t){if("string"==typeof t&&t in dR)return dR[t];if("string"!=typeof t&&null!=t)return t;throw new LN(`Unknown metric ${t}`)}function fR(t){if(BN(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(rR))if(rR[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(dR))if(dR[n]===t){e=n;break}return void 0!==e?e:t.name}}function mR(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!gR(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function gR(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!gR(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!gR(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function yR(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function bR(t,e,n){let s;try{s=JSON.stringify(t.outputShape)}catch(X3){s="multiple"}yR([`${t.name} (${t.getClassName()})`,s,t.countParams().toString()],e,n)}function vR(t,e,n,s){let r;try{r=JSON.stringify(t.outputShape)}catch(X3){r="multiple"}const i=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t)i.push(`${u.inboundLayers[t].name}[${u.nodeIndices[t]}][${u.tensorIndices[t]}]`);const o=t.name,a=t.getClassName(),l=0===i.length?"":i[0];yR([`${o} (${a})`,r,t.countParams().toString(),l],e,s);for(let u=1;u<i.length;++u)yR(["","","",i[u]],e,s)}function wR(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function xR(t,e){if(null===t)return null;if("string"==typeof t)return HN(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const s=t[r];wR(e,r,s)?n.push(s):n.push(xR(s,e))}return n}{const e={};for(const n of Object.keys(t)){const s=t[n];if("name"===n&&"string"==typeof s)e[n]=s;else{const t=HN(n);e[t]=xR(s,t)}}return e}}function _R(t,e){if(null==t)return null;if("string"==typeof t)return jN(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const s=t[r];wR(e,r,s)?n.push(s):n.push(_R(s,e))}return n}{const e={};for(const n of Object.keys(t)){const s=t[n];e[jN(n)]="name"!==n&&"className"!==n||"string"!=typeof s?_R(s,n):s}return e}}class kR{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof kR)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new LN(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return n_(e,t.dtype)}catch(X3){throw new LN(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof $A){if(null==this.id2Value[t.id])throw new LN(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new LN(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof $A){if(null==this.id2Value[t.id])throw new LN(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new LN(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&z_(this.id2Mask)}}const CR={},IR={};function SR(t,e,n,s){const r=null!=n&&n.training,i=Array.isArray(t),o=i?t:[t],a=o.map(t=>t.name),l=[],u=e.names();for(const f of a)-1!==u.indexOf(f)?l.push(e.getValue(f)):l.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=a.join(",")+"|"+e.names().join(",");let h,d;if(null==CR[c]){const t=function(t,e){gg(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(1===t.length){const r=TR(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of t){const{sorted:t,recipientMap:o}=TR(i,e);for(const e of t)r.has(e.name)||(n.push(e),r.add(e.name));for(const e in o)null==s[e]&&(s[e]=new Set),o[e].forEach(t=>s[e].add(t))}}return{sorted:n,recipientCounts:ER(s)}}(o,e);h=t.sorted,d=t.recipientCounts,CR[c]=h,IR[c]=d}h=CR[c],d={},r||Object.assign(d,IR[c]);const p=new kR(e);for(let f=0;f<h.length;++f){if(null!=s){const t=M_().numTensors;t>s.maxNumTensors&&(s.maxNumTensors=t),t<s.minNumTensors&&(s.minNumTensors=t)}const t=h[f],i=t.sourceLayer;if(i instanceof LA)continue;const o=[],u=[],c=[];let m=!1;for(const n of t.inputs){const t=p.getValue(n),s=p.getMask(n);o.push(t),u.push(s),null!=s&&(m=!0),r||(d[n.name]--,0!==d[n.name]||e.hasKey(n)||-1!==a.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||c.push(t))}m&&((n=n||{}).mask=u[0]);const g=UN(i.apply(o,n));let y=null;i.supportsMasking&&(y=i.computeMask(o,u));const b=NR(t),v=Array.isArray(b)?b:[b];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],g[e],Array.isArray(y)?y[0]:y);const t=a.indexOf(v[e].name);-1!==t&&(l[t]=g[e])}r||z_(c)}return p.disposeMasks(),i?l:l[0]}function ER(t){const e={};for(const n in t)e[n]=t[n].size;return e}function TR(t,e){const n=new Set,s=[],r={};for(const a of e.names())n.add(a);const i=[],o=[];for(i.push(t);i.length>0;){const t=i[i.length-1];if(n.has(t.name)){i.pop();continue}const e=o[o.length-1]===i.length-1;if(0===t.inputs.length||e)i.pop(),s.push(t),n.add(t.name),e&&o.pop();else{o.push(i.length-1);for(const e of t.inputs)null==r[e.name]&&(r[e.name]=new Set),r[e.name].add(t.name),n.has(e.name)||i.push(e)}}return{sorted:s,recipientMap:r}}function NR(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const s of t.sourceLayer.inboundNodes[e].outputTensors)if(s.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}class $R extends DA{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=wA(t)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],YN(this.inputs).length!==this.inputs.length)throw new LN(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(t=>t.name)}`);YN(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(t=>t.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const t=y.nodeIndex,e=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(e)}for(const y of this.inputs){const t=y.sourceLayer,e=y.nodeIndex,n=y.tensorIndex;BN(0===e,"input layer has >1 nodes"),BN(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const e=this.inputLayers[y];if(!(e instanceof LA))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const e={},n={},s={},r={},i={},o=[],a=(t,e,n,s,r,l)=>{null!=s&&null!=r&&null!=l||(s=t.sourceLayer,r=t.nodeIndex,l=t.tensorIndex);const u=s.inboundNodes[r];if(-1!==n.indexOf(u))throw new ON(`The tensor ${t.name} at layer "${s.name}" is part of a cycle.`);if(-1!==e.indexOf(u))return;this.containerNodes.add($R.nodeKey(s,r)),s.id in i||(i[s.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let i=0;i<c;i++)a(u.inputTensors[i],e,n,u.inboundLayers[i],u.nodeIndices[i],u.tensorIndices[i]);for(e.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);o.push(u)},l=[],u=[];for(const y of this.outputs)a(y,l,u);const c=o.slice().reverse();for(const y of c){n[y.id]=y,y.id in e||(e[y.id]=0);let t=e[y.id];t=Math.max(t,null==s[y.outboundLayer.id]?0:s[y.outboundLayer.id]),s[y.outboundLayer.id]=t,r[y.outboundLayer.id]=y.outboundLayer,e[y.id]=t;for(let s=0;s<y.inboundLayers.length;s++){const r=y.inboundLayers[s].inboundNodes[y.nodeIndices[s]];e[r.id]=Math.max(t+1,null==e[r.id]?0:e[r.id]),n[r.id]=r}}const h={};for(const y in e){const t=e[y];t in h||(h[t]=[]),h[t].push(n[y])}const d={};for(const y in s){const t=s[y];t in d||(d[t]=[]),d[t].push(r[y])}let p=Object.keys(d).map(t=>parseInt(t,10)).sort(ZN);this.layers=[];for(const y of p){const t=d[y];t.sort((t,e)=>{const n=i[t.id],s=i[e.id];return n<s?-1:n>s?1:0});for(const e of t)e instanceof $R&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(t=>parseInt(t,10)).sort(ZN);const f=this.inputs.slice(),m=[];for(const y of p)for(const t of h[y]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new ON(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(t=>t.name);for(const y of g){const t=g.filter(t=>t===y).length;if(1!==t)throw new ON(`The name "${y}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new RA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new LN("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let s=0;for(const i of this.layers)for(const t of i.weights){if(null!=n[t.originalName])throw new LN(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,s++}const r=[];for(const i in t){let s=i;if(null==n[i]){const t=i.split("/");s=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[s])r.push([n[s],t[i]]);else if(e)throw new LN(`Provided weight data has no target variable: ${i}`);delete n[s]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new LN(`${t.length} of ${s} weights are not set: ${t}`)}TA(r)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.7.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=_R(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return P_(()=>{t=UN(t);const n=new kR;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return SR(this.outputs,n,e)})}computeMask(t,e){return P_(()=>{let n;return t=UN(t),n=null==e?zN(null,t.length):UN(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=_A(t);if(e.length!==this.inputLayers.length)throw new LN(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let o=0;o<e.length;o++)n[this.inputLayers[o].name+"_0_0"]=e[o];const s=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(ZN);if(s.length>1)for(const o of s){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const s=[];for(let o=0;o<e.inboundLayers.length;o++)s.push(n[`${e.inboundLayers[o].name}_${e.nodeIndices[o]}_${e.tensorIndices[o]}`]);const r=_A(t.computeOutputShape(WN(s))),i=t.inboundNodes.indexOf(e);for(let e=0;e<r.length;e++)n[`${t.name}_${i}_${e}`]=r[e]}}const r=[],i=[];for(let o=0;o<this.outputLayers.length;o++)i.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<i.length;o++){const t=i[o];BN(t in n),r.push(n[t])}return WN(r)}runInternalGraph(t,e){null==e&&(e=zN(null,t.length));const n={};for(let a=0;a<this.inputs.length;++a)n[this.inputs[a].id]=[t[a],e[a]];const s=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(ZN);for(const a of s){const t=this.nodesByDepth[a];for(const e of t){const t=e.outboundLayer,s=e.inputTensors,r=e.outputTensors,i=new Array;for(const e of s)e.id in n&&i.push(n[e.id]);if(i.length===s.length){let s,o,a,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===i.length){const[e,n]=i[0];null==u.mask&&(u.mask=n),a=UN(t.call(e,u)),l=UN(t.computeMask(e,n)),s=[e],o=[n]}else s=i.map(t=>t[0]),o=i.map(t=>t[1]),null==u.mask&&(u.mask=o),a=UN(t.call(s,u)),l=UN(t.computeMask(s,o));if(t.activityRegularizer)throw new MN("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<r.length;++t)n[r[t].id]=[a[t],l[t]]}}}const r=[],i=[],o=[];for(const a of this.outputs){BN(a.id in n,`Could not compute output ${a.name} : ${a.id}`);const[t,e]=n[a.id];o.push(t.shape),r.push(t),i.push(e)}return[r,i,o]}buildNodeConversionMap(t){const e={};let n;for(const s of this.layers){n=s instanceof $R?1:0;for(let t=0;t<s.inboundNodes.length;t++){const r=$R.nodeKey(s,t);this.containerNodes.has(r)&&(e[r]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new LN(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new LN("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new LN(`No such layer: ${t}`)}calculateLosses(){return P_(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const s=$R.nodeKey(e,n);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const t=i.getClassName(),s=i.getConfig(),r=[];for(let n=0;n<i.inboundNodes.length;n++){const t=i.inboundNodes[n],s=$R.nodeKey(i,n);let o={};if(this.containerNodes.has(s)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(X3){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(t.inboundLayers.length>0){const n=[];for(let s=0;s<t.inboundLayers.length;s++){const r=t.inboundLayers[s],i=t.tensorIndices[s];let a=e[$R.nodeKey(r,t.nodeIndices[s])];null==a&&(a=0),n.push([r.name,a,i,o])}r.push(n)}}}const o={};o.name=i.name,o.className=t,o.config=s,o.inboundNodes=r,n.push(o)}t.layers=n;const s=[];for(let i=0;i<this.inputLayers.length;i++){const t=this.inputLayers[i],n=$R.nodeKey(t,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let r=e[n];null==r&&(r=0),s.push([t.name,r,this.inputLayersTensorIndices[i]])}t.inputLayers=s;const r=[];for(let i=0;i<this.outputLayers.length;i++){const t=this.outputLayers[i],n=$R.nodeKey(t,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let s=e[n];null==s&&(s=0),r.push([t.name,s,this.outputLayersTensorIndices[i]])}return t.outputLayers=r,t}static fromConfig(t,e,n={},s=!1){const r={},i={};function o(t,e){t.name in i?i[t.name].push(e):i[t.name]=[e]}function a(t,e){const n=[];let s;for(const i of e){const a=i[0],l=i[1],u=i[2];if(s=null==i[3]?{}:i[3],!(a in r))return void o(t,e);const c=r[a];if(c.inboundNodes.length<=l)return void o(t,e);n.push(c.inboundNodes[l].outputTensors[u])}n.length>0&&t.apply(WN(n),s)}function l(t){const n=t.name,i=XA(t,null!=e.customObjects?e.customObjects:{});i.setFastWeightInitDuringBuild(s),r[n]=i,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new LN(`Corrupted configuration, expected array for nodeData: ${t}`);o(i,t)})}const u=e.name,c=e.layers;for(const m of c)l(m);for(;!QN(i);)for(const t of c){const e=r[t.name];if(e.name in i){const t=i[e.name];delete i[e.name];for(const n of t)a(e,n)}}const h=[],d=[],p=e.inputLayers;for(const m of p){const t=m[0],e=m[1],n=m[2];BN(t in r),h.push(r[t].inboundNodes[e].outputTensors[n])}const f=e.outputLayers;for(const m of f){const t=m[0],e=m[1],n=m[2];BN(t in r),d.push(r[t].inboundNodes[e].outputTensors[n])}return new t({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new LN("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){P_(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function AR(t,e){return function(t,e,n){const s=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>null);if(1===s)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided classWeight is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach(e=>{n.push(e in t?t[e]:null)}),n}throw new Error(`The model has multiple (${s}) outputs, so classWeight must be either an array with ${s} elements or an object with ${e} keys. Provided classWeight not understood: ${JSON.stringify(t)}`)}(t,e)}function RR(t,e,n,s){return FR.apply(this,arguments)}function FR(){return(FR=lg(function*(t,e,n,s){if(null!=e||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=P_(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield e.data());z_(e);const r=[];return s.forEach(t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);r.push(n[t])}),HC(r,"float32")}return null})).apply(this,arguments)}function DR(t,e){return Xk(t,e)}function OR(t,e){let n,s;n=e.xs,s=e.ys,gg(null!=n&&null!=s,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const r=LR("input",t.inputNames,n),i=LR("output",t.outputNames,s),o=r[0].shape[0];gg(r.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),gg(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let a=0;a<r.length;a++)gg(r[a].shape[0]===o,()=>`Batch size mismatch: input ${t.inputNames[a]} has ${r[a].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);for(let a=0;a<i.length;a++)gg(i[a].shape[0]===o,()=>`Batch size mismatch: output ${t.outputNames[a]} has ${i[a].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);return{xs:r,ys:i}}function LR(t,e,n){if(n instanceof Ww)return[n];if(Array.isArray(n))return gg(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(null==n[r])throw new LN(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function MR(t){if(3===t.length)throw new MN("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}function PR(){return(PR=lg(function*(t,e,n){const s=null!=n.batchesPerEpoch;if(gg(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),gg(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),gg(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),gg(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),gg(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const r=null!=n.validationData;let i,o;if(r)if(BR(n.validationData))gg(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const t=MR(n.validationData);i=t.xs,o=t.ys}const a=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=r?l.slice().concat(l.map(t=>"val_"+t)):l.slice();const c=GA(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=KA(c,h,n.epochs,null,null,zR(e,n),null,r,u);d.setModel(t),t.history=p,yield d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=yield e.iterator();for(;f<n.epochs;){const u={};yield d.onEpochBegin(f);let c=0,h=0;for(s||(m=yield e.iterator());!s||c<n.batchesPerEpoch;){const e=yield m.next();if(s&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:s,ys:r}=OR(t,e.value),i={};i.batch=h,i.size=s[0].shape[0],yield d.onBatchBegin(h,i);const o=[];if(null!=n.classWeight){const e=AR(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(yield RR(r[t],null,e[t]))}const u=s.concat(r).concat(o),p=a(u);z_(u);for(let t=0;t<l.length;++t){const e=p[t];i[l[t]]=e,B_(e)}yield d.onBatchEnd(h,i),zA(i),h++,c++}if(s?c>=n.batchesPerEpoch:e.done){if(r){let e;e=BR(n.validationData)?UN(yield t.evaluateDataset(n.validationData,{batches:n.validationBatches})):UN(t.evaluate(i,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)u[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(yield d.onEpochEnd(f,u),f++,t.stopTraining_)break}return yield d.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})).apply(this,arguments)}function zR(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function BR(t){return"function"==typeof t.iterator}function VR(t){return"function"==typeof t.next}function WR(){return(WR=lg(function*(t,e,n){const s=null!=(n=n||{}).batches,r=t.testFunction;let i=[];if(n.verbose>0)throw new MN("Verbose mode is not implemented yet.");gg(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const o=VR(e)?e:yield e.iterator();let a=0,l=0;for(;!s||l<n.batches;){const e=yield o.next();if(i=P_(()=>{if(e.value){const{xs:n,ys:s}=OR(t,e.value),o=n.concat(s),u=P_(()=>r(o));if(z_(o),0===l)for(let t=0;t<u.length;++t)i.push(U_(0));const c=o[0].shape[0];for(let t=0;t<u.length;++t){const e=u[t],n=i[t];i[t]=P_(()=>G_(i[t],Xk(c,e))),l>0&&z_(n)}z_(u),a+=c,++l}return i}),e.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const t=i[u];i[u]=Ak(i[u],a),z_(t)}return WN(i)})).apply(this,arguments)}function UR(t){gg(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function jR(t,e,n){return null==t?[null]:Array.isArray(t)?t.map(t=>O$(t,e,n-e)):O$(t,e,n-e)}function HR(t,e){return P_(()=>null==t?null:Array.isArray(t)?t.map(t=>HR(t,e)):U$(t,"int32"===e.dtype?e:e.toInt()))}function GR(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function qR(t,e,n,s,r,i,o,a,l,u,c,h,d,p,f){return KR.apply(this,arguments)}function KR(){return(KR=lg(function*(t,e,n,s,r,i,o,a,l,u,c,h,d,p,f){null==r&&(r=32),null==i&&(i=1),null==c&&(c=!0),null==d&&(d=0);let m=!1;if(null!=l&&null!=u&&(m=!0),null!=f&&(m=!0,null==p))throw new LN("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=t.checkNumSamples(n,r,p,"steps_per_epoch");let y;null!=g&&(y=R$(0,g)),null==o&&(o=1);const{callbackList:b,history:v}=KA(a,o,i,d,g,p,r,m,h);b.setModel(t),t.history=v,yield b.onTrainBegin(),t.stopTraining_=!1;for(let w=d;w<i;++w){yield b.onEpochBegin(w);const i={};if(null!=p)throw new MN("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new MN("batch shuffling is not implemneted yet");c&&pg(y);const o=HC(y),a=GR(g,r);for(let c=0;c<a.length;++c){const h={};if(yield b.onBatchBegin(c,h),P_(()=>{const d=a[c][0],p=a[c][1],f=O$(o,d,p-d);h.batch=c,h.size=p-d;const g=HR(n,f),y=e(g);for(let t=0;t<s.length;++t){const e=y[t];h[s[t]]=e,B_(e)}if(c===a.length-1&&m){const e=t.testLoop(l,u,r);for(let t=0;t<s.length;++t){const n=s[t],r=e[t];B_(r),i["val_"+n]=r}}}),yield b.onBatchEnd(c,h),zA(h),t.stopTraining_)break}o.dispose()}if(yield b.onEpochEnd(w,i),t.stopTraining_)break}return yield b.onTrainEnd(),yield t.history.syncData(),t.history})).apply(this,arguments)}function XR(){return(XR=lg(function*(t,e,n,s={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,i,o,a,l,u,c;t.isTraining=!0;try{const h=null==s.batchSize?32:s.batchSize;UR(h);const d=!1,p=yield t.standardizeUserData(e,n,s.sampleWeight,s.classWeight,d,h);r=p[0],i=p[1],c=p[2];let f,m=!1;if(null!=s.validationData&&s.validationData.length>0){if(m=!0,2!==s.validationData.length)throw 3===s.validationData.length?new MN("validationData including sample weights is not supported yet."):new LN(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);o=s.validationData[0],a=s.validationData[1];const e=!0,n=yield t.standardizeUserData(o,a,null,null,e,h);l=n[0],u=n[1],f=l.concat(u)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){m=!0;const t=Math.floor(r[0].shape[0]*(1-s.validationSplit)),e=r[0].shape[0];l=jR(r,t,e),r=jR(r,0,t),u=jR(i,t,e),i=jR(i,0,t),f=l.concat(u)}else null!=s.validationSteps&&(m=!0);const g=r.concat(i).concat(c);t.checkTrainableWeightsConsistency();const y=t.makeTrainFunction(),b=t.getDedupedMetricsNames();let v,w;m?(t.makeTestFunction(),v=t.testFunction,w=b.slice().concat(b.map(t=>"val_"+t))):(v=null,f=[],w=b.slice());const x=GA(s.callbacks,s.yieldEvery);return yield qR(t,y,g,b,h,s.epochs,s.verbose,x,v,f,s.shuffle,w,s.initialEpoch,null,null)}finally{t.isTraining=!1,YR(r,e),YR(i,n),YR(l,o),YR(u,a),null!=c&&z_(c)}})).apply(this,arguments)}function ZR(t){const e=[];t instanceof Ww&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(1===s.rank)e.push(D$(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function YR(t,e){if(null==t)return;const n=[];if(e instanceof Ww)n.push(e.id);else if(Array.isArray(e))e.forEach(t=>n.push(t.id));else if(null!=e)for(const r in e)n.push(e[r].id);const s=[];if(t instanceof Ww)-1===n.indexOf(t.id)&&s.push(t);else if(Array.isArray(t))t.forEach(t=>{-1===n.indexOf(t.id)&&s.push(t)});else if(null!=t)for(const r in t){const e=t[r];-1===n.indexOf(e.id)&&s.push(e)}s.forEach(t=>{t.isDisposed||t.dispose()})}function QR(t){return Array.isArray(t)}function JR(t){return!function(t){return t instanceof Ww}(t)&&!QR(t)}function tF(t,e,n,s=!0,r=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(QR(t)&&t.length>0)e=!0;else if(JR(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new LN(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(null==t)return e.map(t=>null);let i;if(JR(t)){t=t,i=[];for(const n of e){if(null==t[n])throw new LN(`No data provided for "${n}". Need data for each key in: ${e}`);i.push(t[n])}}else if(QR(t)){if((t=t).length!==e.length)throw new LN(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);i=t}else{if(t=t,e.length>1)throw new LN(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);i=[t]}if(i=ZR(i),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=i[o];if(t.shape.length!==n[o].length)throw new LN(`Error when checking ${r}: expected ${e[o]} to have ${n[o].length} dimension(s). but got array with shape ${t.shape}`);for(let i=0;i<n[o].length;++i){if(0===i&&!s)continue;const a=t.shape[i],l=n[o][i];if(null!=l&&l>=0&&a!==l)throw new LN(`Error when checking ${r}: expected ${e[o]} to have shape [${n[o]}], but got array with shape [${t.shape}].`)}}return i}function eF(t,e,n,s=!0,r=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new LN(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new LN(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);i=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=i[o];if(t.shape.length!==n[o].length)throw new LN(`Error when checking ${r}: expected ${e[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(t.shape)}`);for(let i=0;i<n[o].length;++i){if(0===i&&!s)continue;const a=t.shape[i],l=n[o][i];if(null!=l&&l!==a)throw new LN(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(t.shape)}.`)}}}class nF extends $R{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new LN("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,s=console.log){const r=function(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let t=!1;for(const n of r.inboundNodes)if(-1!==s.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),i=["Layer (type)","Output shape","Param #"];let o;if(r?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(t=>Math.floor(e*t))),!r){i.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}s("_".repeat(e)),yR(i,n,s),s("=".repeat(e));const a=t.layers;for(let c=0;c<a.length;++c)r?bR(a[c],n,s):vR(a[c],n,o,s),s((c===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=IA(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),e}(t),u=IA(t.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>iS.adagrad(.01),Adadelta:()=>iS.adadelta(1,.95,FN()),Adam:()=>iS.adam(.001,.9,.999,FN()),Adamax:()=>iS.adamax(.002,.9,.999,FN(),0),RMSProp:()=>iS.rmsprop(.001,.9,0,FN()),SGD:()=>iS.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new LN(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof j_))throw new LN("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new LN(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(t=>iR(t))}else{const n=iR(t.loss);this.outputs.forEach(t=>{e.push(n)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new LN(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(iR(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const t=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[i])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],C$("loss",()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}});const s=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>[]);let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map(t=>n);{const t=[];for(const s of e){let e=n.hasOwnProperty(s)?n[s]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),r=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};C$("metric",()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,s,i;for(const o of e){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let r;1===e[e.length-1]||this.lossFunctions[t]===nR?-1!==["accuracy","acc"].indexOf(o)?s=oR:-1!==["crossentropy","ce"].indexOf(o)&&(s=lR):this.lossFunctions[t]===eR?-1!==["accuracy","acc"].indexOf(o)?s=uR:-1!==["crossentropy","ce"].indexOf(o)&&(s=hR):-1!==["accuracy","acc"].indexOf(o)?s=aR:-1!==["crossentropy","ce"].indexOf(o)&&(s=cR),-1!==["accuracy","acc"].indexOf(o)?r="acc":-1!==["crossentropy","ce"].indexOf(o)&&(r="ce"),i=s,n=""+r}else{const t=pR(o);i=t,n=""+fR(o)}let e;C$(n,()=>{e=i}),r(t,n,e)}})(s[t])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const s=null==n.batchSize?32:n.batchSize;UR(s);const r=this.standardizeUserDataXY(t,e,!0,s);try{const i=r[0].concat(r[1]);return this.makeTestFunction(),WN(this.testLoop(this.testFunction,i,s,n.verbose,n.steps))}finally{YR(r[0],t),YR(r[1],e)}}evaluateDataset(t,e){var n=this;return lg(function*(){return n.makeTestFunction(),function(t,e,n){return WR.apply(this,arguments)}(n,t,e)})()}checkNumSamples(t,e,n,s="steps"){let r;if(null!=n){if(r=null,null!=e)throw new LN(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new LN(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new LN("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),s=this.retrieveSymbolicTensors(n?e:[e]),r=new kR;if(t instanceof Ww&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new LN(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)r.add(this.inputs[e],t[e])}else for(const o of this.inputs){const e=t[o.name];if(null==e)throw new LN(`No value is provided for the model's input ${o.name}`);r.add(o,e)}const i=SR(s,r);return n?i:i[0]}retrieveSymbolicTensors(t){const e=zN(null,t.length);let n=t.length;for(const s of this.layers){const r=Array.isArray(s.output)?s.output:[s.output],i=r.map(t=>t.name);for(let s=0;s<t.length;++s){const o=i.indexOf(t[s]);if(-1!==o&&(e[s]=r[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach((e,s)=>{null==e&&n.push(t[s])}),new LN(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return P_(()=>{const s=this.checkNumSamples(t);if(n)throw new MN("Verbose predictLoop() is not implemented yet.");const r=GR(s,e),i=this.outputs.map(t=>[]);for(let e=0;e<r.length;++e)P_(()=>{const n=jR(t,r[e][0],r[e][1]),s=[];if(Array.isArray(n))for(let t=0;t<n.length;++t)s.push({key:this.inputs[t],value:n[t]});else s.push({key:this.inputs[0],value:n});const i=new kR(s);return SR(this.outputs,i)}).forEach((t,e)=>i[e].push(t));return WN(i.map(t=>yk(t,0)))})}predict(t,e={}){const n=ZR(t);eF(n,this.inputNames,this.feedInputShapes,!1);try{const s=null==e.batchSize?32:e.batchSize;return UR(s),this.predictLoop(n,s)}finally{YR(n,t)}}predictOnBatch(t){eF(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,s){if(null==this.optimizer_)throw new ON("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let i=0;i<this.feedOutputShapes.length;++i){const t=this.feedOutputShapes[i];r.push(this.feedLossFns[i]===eR?t.slice(0,t.length-1).concat([1]):t)}if(function(t,e,n){const s=YN(t.map(t=>t.shape[0]));s.sort();const r=YN(e.map(t=>t.shape[0]));if(r.sort(),s.length>1)throw new LN(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(t=>t.shape))}`);if(r.length>1)throw new LN(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(t=>t.shape))}`);if(s.length>0&&r.length>0&&!xg(s,r))throw new LN(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}(t=tF(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=tF(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const s=[YA,nR,tR];for(let r=0;r<t.length;++r){const i=t[r],o=e[r],a=n[r];if(null!=o){if(o===tR&&1===i.shape[i.shape.length-1])throw new LN(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(o)){const t=i.shape.slice(1),e=a.slice(1);for(let n=0;n<t.length;++n){const s=t[n],r=e[n];if(null!=r&&s!==r)throw new LN(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&t[0].shape[0]%s!=0)throw new LN(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}standardizeUserData(t,e,n,s,r=!0,i){var o=this;return lg(function*(){const[a,l]=o.standardizeUserDataXY(t,e,r,i);if(null!=n)throw new Error("sample weight is not supported yet.");let u=null;if(null!=s){const t=AR(s,o.outputNames);u=[];for(let e=0;e<t.length;++e)u.push(yield RR(l[e],null,t[e]))}return[a,l,u]})()}testLoop(t,e,n,s=0,r){return P_(()=>{const i=this.checkNumSamples(e,n,r,"steps"),o=[];if(s>0)throw new MN("Verbose mode is not implemented yet.");if(null!=r)throw new MN("steps mode in testLoop() is not implemented yet");{const s=GR(i,n),r=HC(R$(0,i));for(let n=0;n<s.length;++n){const i=s[n][0],a=s[n][1],l=O$(r,i,a-i),u=HR(e,l),c=t(u);if(0===n)for(let t=0;t<c.length;++t)o.push(U_(0));for(let t=0;t<c.length;++t)o[t]=G_(o[t],Xk(a-i,c[t]))}for(let t=0;t<o.length;++t)o[t]=Ak(o[t],i)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const s=t[n];let r=s;VN(t,s)>1&&(r+=`_${VN(t.slice(0,n),s)}`),e.push(r)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],o=this.collectedTrainableWeights.map(t=>t.read());return[this.optimizer_.minimize(()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new kR(t),a=SR(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(s[n],a[n]);null!=r[n]&&(t=DR(t,r[n]));const i=sC(t);e.push(i),l=0===n?t:G_(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][1];t=sC((0,this.metricsTensors[n][0])(s[e],a[e]))}B_(t),i.push(t)}return l=sC(l),this.calculateLosses().forEach(t=>{l=G_(l,t)}),l},!0,o)].concat(i)}}makeTestFunction(){this.testFunction=t=>P_(()=>{const e=[];let n;const s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let t=0;t<this.inputs.length;++t)i.push({key:this.inputs[t],value:s[t]});const o=new kR(i),a=SR(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const s=sC((0,this.lossFunctions[t])(r[t],a[t]));n=0===t?s:G_(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][1],s=sC((0,this.metricsTensors[t][0])(r[n],a[n]));e.push(s)}return e})}fit(t,e,n={}){var s=this;return lg(function*(){return function(t,e,n){return XR.apply(this,arguments)}(s,t,e,n)})()}fitDataset(t,e){var n=this;return lg(function*(){return function(t,e,n){return PR.apply(this,arguments)}(n,t,e)})()}trainOnBatch(t,e){var n=this;return lg(function*(){const s=yield n.standardizeUserData(t,e),r=s[0],i=s[1],o=n.makeTrainFunction()(r.concat(i)),a=[];for(const t of o){const e=yield t.data();a.push(e[0])}return z_(o),WN(a)})()}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,s=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let i=0;i<s.length;++i)n&&!s[i].trainable||e.push({name:s[i].originalName,tensor:r[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=M_().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-M_().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=jN(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(t=>jN(t))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const s of e){if("string"!=typeof n[s])throw new Error("Serialization of non-string loss is not supported.");t[s]=jN(n[s])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[jN(fR(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>jN(fR(t)));{const t={};for(const e in this.metrics)t[e]=jN(fR(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=XA(xR(t.optimizer_config));let n,s;if("string"==typeof t.loss)n=HN(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(t=>HN(t));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=HN(t.loss[e])}if(Array.isArray(t.metrics))s=t.metrics.map(t=>HN(t));else if(null!=t.metrics){s={};for(const e in t.metrics)s[e]=HN(t.metrics[e])}this.compile({loss:n,metrics:s,optimizer:e})}save(t,e){var n=this;return lg(function*(){if("string"==typeof t){const e=$x.getSaveHandlers(t);if(0===e.length)throw new LN(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new LN(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new LN("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=yield _x(n.getNamedWeights(e)),r={modelTopology:n.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.7.0",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=n.optimizer){r.trainingConfig=n.getTrainingConfig();const t="optimizer",{data:e,specs:i}=yield _x(yield n.optimizer.getWeights(),t);s.specs.push(...i),s.data=Ex([s.data,e])}return null!=n.userDefinedMetadata&&(mR(n.userDefinedMetadata,n.name,!0),r.userDefinedMetadata=n.userDefinedMetadata),r.weightData=s.data,r.weightSpecs=s.specs,t.save(r)})()}setUserDefinedMetadata(t){mR(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}nF.className="Model",O_(nF);class sF extends nF{}function rF(){return(rF=lg(function*(t,e){if(null==e&&(e={}),"string"==typeof t){const n=Ax(t,e);if(0===n.length)n.push(p_(t,e));else if(n.length>1)throw new LN(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return iF(t,void 0,e)})).apply(this,arguments)}function iF(t,e,n){return oF.apply(this,arguments)}function oF(){return(oF=lg(function*(t,e,n){if(null==n&&(n={}),null==t.load)throw new LN("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=yield t.load();let r=s.modelTopology;null!=r.model_config&&(r=r.model_config);const i=null==n.strict||n.strict,o=null!=s.weightData&&null!=s.weightSpecs&&i,a=XA(xR(r),e,o),l=s.trainingConfig;if(null!=l&&a.loadTrainingConfig(l),null!=s.userDefinedMetadata&&a.setUserDefinedMetadata(s.userDefinedMetadata),null!=s.weightData){if(null==s.weightSpecs)throw new LN("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=aF(s.weightData,s.weightSpecs);a.loadWeights(t,i),null!=a.optimizer&&e.length>0&&(yield a.optimizer.setWeights(e)),z_(t),z_(e.map(t=>t.tensor))}return a})).apply(this,arguments)}function aF(t,e){const n=function(t,e){const n={};let s,r=0;for(const i of e){const e=i.name,o=i.dtype,a=i.shape,l=wg(a);let u;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const a=xx[n.dtype],c=t.slice(r,r+l*a),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(h.length);for(let t=0;t<h.length;t++)u[t]=h[t]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===s&&(s=Nx()),u=s(h)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let t=0;t<h.length;t++)u[t]=Math.round(h[t]*n.scale+n.min)}r+=l*a}else if("string"===o){const e=wg(i.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(r,r+4))[0];r+=4;const n=new Uint8Array(t.slice(r,r+e));u.push(n),r+=e}}else{const s=xx[o],i=t.slice(r,r+l*s);if("float32"===o)u=new Float32Array(i);else if("int32"===o)u=new Int32Array(i);else if("bool"===o)u=new Uint8Array(i);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);{u=new Float32Array(i);const t=new Float32Array(u.length/2),s=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],s[e]=u[2*e+1];const r=wx(t,a,"float32"),o=wx(s,a,"float32");n[e]=bx(r,o),r.dispose(),o.dispose()}}r+=l*s}"complex64"!==o&&(n[e]=wx(u,a,o))}return n}(t,e),s={},r=[];return e.forEach(t=>{"optimizer"===t.group?r.push({name:t.name,tensor:n[t.name]}):s[t.name]=n[t.name]}),{modelWeights:s,optimizerWeights:r}}sF.className="Functional",O_(sF);class lF extends nF{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:wA("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new LN(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof lF||t instanceof nF;let n;if(e){if(n=t,1!==n.outputs.length)throw new LN("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new LN("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new LN("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new LN("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new LA({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new LN(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new LN("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=OA(this.outputs[0])}this.inboundNodes=[],new RA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:zN(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(CA(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new nF({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new ON("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}evaluateDataset(t,e){var n=this;return lg(function*(){if(!n.built)throw new ON("The model needs to be compiled before being used.");return n.model.evaluateDataset(t,e)})()}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}fit(t,e,n={}){var s=this;return lg(function*(){if(!s.built)throw new ON("The model needs to be compiled before being used.");return s.model.fit(t,e,n)})()}fitDataset(t,e){var n=this;return lg(function*(){if(!n.built)throw new ON("The model needs to be compiled before being used.");return n.model.fitDataset(t,e)})()}trainOnBatch(t,e){var n=this;return lg(function*(){return n.model.trainOnBatch(t,e)})()}static fromConfig(t,e,n={},s=!1){let r,i={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new LN("Legacy serialization format not supported yet.");r=e}else gg(null!=e.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=e.layers,delete e.layers,i=e;const o=new t(i);if(!(o instanceof lF))throw new MN(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const a of r){const t=XA(a,void 0,s);s&&t.setFastWeightInitDuringBuild(!0),o.add(t)}return o}set stopTraining(t){if(null==this.model)throw new LN("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new LN("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}lF.className="Sequential",O_(lF);class uF extends F_{getConfig(){return{}}}class cF extends uF{apply(t,e=1){return function(t,e=1){if(1!==e)throw new MN(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Rk(t)}(t,e)}}cF.className="elu",O_(cF);class hF extends uF{apply(t){return $C(t)}}hF.className="selu",O_(hF);class dF extends uF{apply(t){return TC(t)}}dF.className="relu",O_(dF);class pF extends uF{apply(t){return P_(()=>rC(6,TC(t)))}}pF.className="relu6",O_(pF);class fF extends uF{apply(t){return t}}fF.className="linear",O_(fF);class mF extends uF{apply(t){return RC(t)}}mF.className="sigmoid",O_(mF);class gF extends uF{apply(t){return function(t){return P_(()=>{const e=G_(.5,Xk(.2,t));return gk(e,0,1)})}(t)}}gF.className="hardSigmoid",O_(gF);class yF extends uF{apply(t){return zC(t)}}yF.className="softplus",O_(yF);class bF extends uF{apply(t){return function(t){return P_(()=>Ak(t,H_(t).add(1)))}(t)}}bF.className="softsign",O_(bF);class vF extends uF{apply(t){return jC(t)}}vF.className="tanh",O_(vF);class wF extends uF{apply(t,e=-1){return PC(t,e)}}wF.className="softmax",O_(wF);class xF extends uF{apply(t,e=-1){return Qk(t,e)}}xF.className="logSoftmax",O_(xF);class _F extends uF{apply(t,e=1){return P_(()=>RC(t.mul(e)).mul(t))}}_F.className="swish",O_(_F);class kF extends uF{apply(t){return P_(()=>Xk(t,jC(zC(t))))}}function CF(t){return t.getClassName()}function IF(t,e={}){return XN(t,D_.getMap().classNameMap,e,"activation")}function SF(t){if(null==t)return IF({className:"linear",config:{}});if("string"==typeof t){const e={};return e.className=t,e.config={},IF(e)}return t instanceof uF?t:IF(t)}kF.className="mish",O_(kF);class EF extends F_{}class TF extends EF{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return P_(()=>{let e=bC([1]);return this.hasL1&&(e=G_(e,Yk(Xk(this.l1,H_(t))))),this.hasL2&&(e=G_(e,Yk(Xk(this.l2,j$(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}TF.className="L1L2",O_(TF);const NF={l1l2:"L1L2"};function $F(t){return qN(t)}function AF(t,e={}){return XN(t,D_.getMap().classNameMap,e,"regularizer")}function RF(t){return null==t?null:"string"==typeof t?AF({className:t in NF?NF[t]:t,config:{}}):t instanceof EF?t:AF(t)}class FF extends DA{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=kA(t);let n=TC(t);return null!=this.maxValue&&(n=gk(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}FF.className="ReLU",O_(FF);class DF extends DA{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=kA(t);return Hk(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}DF.className="LeakyReLU",O_(DF);class OF extends DA{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=gA(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=RF(t.alphaRegularizer),this.alphaConstraint=p$(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new LN(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=CA(t)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)e[s-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let s=1;s<t.length;++s)n[s]=t[s];this.inputSpec=[new NA({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=kA(t),_C(t,this.alpha.read())}getConfig(){const t={alphaInitializer:mA(this.alphaInitializer),alphaRegularizer:$F(this.alphaRegularizer),alphaConstraint:h$(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}OF.className="PReLU",O_(OF);class LF extends DA{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new MN(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=kA(t);return Rk(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}LF.className="ELU",O_(LF);class MF extends DA{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=kA(t);return n.mul(F$(n.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}MF.className="ThresholdedReLU",O_(MF);class PF extends DA{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new wF).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=kA(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function zF(t,e,n){if("number"==typeof t)return zN(t,e);if(t.length!==e)throw new LN(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let r=0;r<e;++r){const i=t[r];if((s=i)!==parseInt(s.toString(),10))throw new LN(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`)}return t;var s}function BF(t,e,n,s,r=1){if(null==t)return t;let i;return i="same"===n?t:t-(e+(e-1)*(r-1))+1,Math.floor((i+s-1)/s)}function VF(t,e,n,s){if(null==t)return null;if("valid"===s)t=t*e+A$([n-e,0]);else{if("same"!==s)throw new LN(`Unsupport padding mode: ${s}.`);t*=e}return t}function WF(t,e){return P_(()=>(w$(e),"channelsFirst"===e?YC(t,[0,2,3,1]):t))}function UF(t,e){return P_(()=>(w$(e),"channelsFirst"===e?YC(t,[0,2,3,4,1]):t))}function jF(t,e,n,s=[1,1],r="valid",i,o,a=null){return P_(()=>{if(null==i&&(i="channelsLast"),w$(i),3!==t.rank&&4!==t.rank)throw new LN(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new LN(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=WF(t,i);if("causal"===r)throw new MN("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=dI({x:l,filter:e,strides:s,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),"channelsFirst"===i&&(l=YC(l,[0,3,1,2])),l})}PF.className="Softmax",O_(PF);class HF extends DA{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",HF.verifyArgs(e),this.rank=t,e$(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new MN(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=zF(e.kernelSize,t,"kernelSize"),this.strides=zF(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,x$(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,w$(this.dataFormat),this.activation=SF(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=gA(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=p$(e.biasConstraint),this.biasRegularizer=RF(e.biasRegularizer),this.activityRegularizer=RF(e.activityRegularizer),this.dilationRate=zF(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new LN(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new LN(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new LN(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(BN("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!t$(t.kernelSize,"number",1,3))throw new LN(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:CF(this.activation),useBias:this.useBias,biasInitializer:mA(this.biasInitializer),biasRegularizer:$F(this.biasRegularizer),activityRegularizer:$F(this.activityRegularizer),biasConstraint:h$(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class GF extends HF{constructor(t,e){super(t,e),this.kernel=null,GF.verifyArgs(e),this.filters=e.filters,e$(this.filters,"filters"),this.kernelInitializer=gA(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=p$(e.kernelConstraint),this.kernelRegularizer=RF(e.kernelRegularizer)}build(t){t=CA(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new LN(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],s=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return P_(()=>{let e;t=kA(t);const n=null==this.bias?null:this.bias.read(),s=s$(this.activation.getClassName());if(null!=s&&2===this.rank)e=jF(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)e=function(t,e,n,s=1,r="valid",i,o=1){return P_(()=>{if(null==i&&(i="channelsLast"),w$(i),3!==t.shape.length)throw new LN(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new LN(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new LN(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===i&&(t=YC(t,[0,2,1])),"causal"===r)throw new MN("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=kk(t,e,s,"same"===r?"same":"valid","NWC",o);return null!=n&&(a=G$(a,n)),a})}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=jF(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new MN("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,s=[1,1,1],r="valid",i,o){return P_(()=>{if(null==i&&(i="channelsLast"),w$(i),4!==t.rank&&5!==t.rank)throw new LN(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new LN(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=UF(t,i);if("causal"===r)throw new MN("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Sk(a,e,s,"same"===r?"same":"valid","NDHWC",o),null!=n&&(a=G$(a,n)),"channelsFirst"===i&&(a=YC(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(t){t=CA(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let r=0;r<n.length;++r){const t=BF(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);e.push(t)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:mA(this.kernelInitializer),kernelRegularizer:$F(this.kernelRegularizer),kernelConstraint:h$(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new LN(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class qF extends GF{constructor(t){super(2,t),qF.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!t$(t.kernelSize,"number",1,2))throw new LN(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}qF.className="Conv2D",O_(qF);class KF extends GF{constructor(t){super(3,t),KF.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new LN(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}KF.className="Conv3D",O_(KF);class XF extends qF{constructor(t){if(super(t),this.inputSpec=[new NA({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new LN(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=CA(t)).length)throw new LN("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new LN("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new NA({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return P_(()=>{let e=kA(t);if(4!==e.shape.length)throw new LN(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let s,r;"channelsFirst"===this.dataFormat?(s=2,r=3):(s=1,r=2);const i=n[r],o=this.kernelSize[1],a=this.strides[1],l=[n[0],VF(n[s],this.strides[0],this.kernelSize[0],this.padding),VF(i,a,o,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=YC(e,[0,2,3,1]));let u=Ik(e,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(u=YC(u,[0,3,1,2])),null!=this.bias&&(u=G$(u,this.bias.read(),this.dataFormat)),null!=this.activation&&(u=this.activation.apply(u)),u})}computeOutputShape(t){const e=(t=CA(t)).slice();let n,s,r;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3):(n=3,s=1,r=2);const i=this.kernelSize[0],o=this.kernelSize[1],a=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[s]=VF(e[s],a,i,this.padding),e[r]=VF(e[r],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}XF.className="Conv2DTranspose",O_(XF);class ZF extends KF{constructor(t){if(super(t),this.inputSpec=[new NA({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new LN(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=CA(t)).length)throw new LN("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new LN("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new NA({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return P_(()=>{let e=kA(t);if(5!==e.shape.length)throw new LN(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let s,r,i;"channelsFirst"===this.dataFormat?(i=2,s=3,r=4):(i=1,s=2,r=3);const o=n[s],a=n[r],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[1],h=this.strides[2],d=[n[0],VF(n[i],this.strides[0],this.kernelSize[0],this.padding),VF(o,c,l,this.padding),VF(a,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=YC(e,[0,2,3,4,1]));let p=Tk(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=YC(p,[0,4,1,2,3])),null!==this.bias&&(p=G$(p,this.bias.read(),this.dataFormat)),null!==this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(t){const e=(t=CA(t)).slice();let n,s,r,i;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3,i=4):(n=4,s=1,r=2,i=3);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[s]=VF(e[s],u,o,this.padding),e[r]=VF(e[r],c,a,this.padding),e[i]=VF(e[i],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}ZF.className="Conv3DTranspose",O_(ZF);class YF extends GF{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new LN("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new LN("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new LN(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=gA(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=RF(e.depthwiseRegularizer),this.depthwiseConstraint=p$(e.depthwiseConstraint),this.pointwiseInitializer=gA(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=RF(e.pointwiseRegularizer),this.pointwiseConstraint=p$(e.pointwiseConstraint)}build(t){if((t=CA(t)).length<this.rank+2)throw new LN(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new LN(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],s=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let o=0;o<this.rank;++o)r.push(1);r.push(n*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):null,this.inputSpec=[new NA({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return P_(()=>{let e;if(t=kA(t),1===this.rank)throw new MN("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=YC(t,[0,2,3,1])),e=AC(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=G$(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=YC(e,[0,3,1,2])),e})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=mA(this.depthwiseInitializer),t.pointwiseInitializer=mA(this.pointwiseInitializer),t.depthwiseRegularizer=$F(this.depthwiseRegularizer),t.pointwiseRegularizer=$F(this.pointwiseRegularizer),t.depthwiseConstraint=h$(this.depthwiseConstraint),t.pointwiseConstraint=h$(this.pointwiseConstraint),t}}YF.className="SeparableConv";class QF extends YF{constructor(t){super(2,t)}}QF.className="SeparableConv2D",O_(QF);class JF extends GF{constructor(t){super(1,t),JF.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!t$(t.kernelSize,"number",1,1))throw new LN(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}JF.className="Conv1D",O_(JF);class tD extends DA{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return P_(()=>{if(t=kA(t),"channelsLast"===this.dataFormat){const e=M$(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return M$(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=M$(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return M$(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}tD.className="Cropping2D",O_(tD);class eD extends DA{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,w$(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,JN(m$,"InterpolationFormat",this.interpolation)}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,e){return P_(()=>{let e=kA(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=YC(e,[0,2,3,1]);const t=this.size[0]*n[2],s=this.size[1]*n[3],r="nearest"===this.interpolation?e.resizeNearestNeighbor([t,s]):e.resizeBilinear([t,s]);return YC(r,[0,3,1,2])}{const t=this.size[0]*n[1],s=this.size[1]*n[2];return"nearest"===this.interpolation?e.resizeNearestNeighbor([t,s]):e.resizeBilinear([t,s])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}eD.className="UpSampling2D",O_(eD);class nD extends HF{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=gA(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=p$(t.depthwiseConstraint),this.depthwiseRegularizer=RF(t.depthwiseRegularizer)}build(t){if((t=CA(t)).length<4)throw new LN(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new LN(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return P_(()=>{let e=function(t,e,n=[1,1],s="valid",r,i){return P_(()=>{null==r&&(r="channelsLast"),w$(r);let o=WF(t,r);if(4!==t.rank)throw new LN(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new LN(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=Nk(o,e,n,"same"===s?"same":"valid","NHWC",i),"channelsFirst"===r&&(o=YC(o,[0,3,1,2])),o})}(t=kA(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=G$(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(t){t=CA(t);const e="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=BF("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),r=BF(e,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,s,r]:[t[0],s,r,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=mA(this.depthwiseInitializer),t.depthwiseRegularizer=$F(this.depthwiseRegularizer),t.depthwiseConstraint=h$(this.depthwiseRegularizer),t}}function sD(t,e,n,s){if(Array.isArray(t)){if(null!=e||null!=n)throw new LN("When inputs is an array, neither initialState or constants should be provided");null!=s&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=r(e),constants:n=r(n)}}function rD(t,e,n,s=!1,r,i,o=!1,a=!1){return P_(()=>{const l=e.shape.length;if(l<3)throw new LN(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(R$(2,l));if(e=YC(e,u),null!=i)throw new MN("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=r.asType("bool").asType("float32")).rank===l-1&&(r=Mk(r,-1)),r=YC(r,u)),s&&(e=NC(e,0),null!=r&&(r=NC(r,0)));const c=[];let h,d=n;const p=e.shape[0],f=qC(e);let m,g;null!=r&&(m=qC(r));for(let e=0;e<p;++e){const n=f[e],s=P_(()=>t(n,d));if(null==r)h=s[0],d=s[1];else{const t=P_(()=>{const t=m[e],n=wC(t).sub(t);return{output:s[0].mul(t).add(d[0].mul(n)),newStates:d.map((e,r)=>s[1][r].mul(t).add(e.mul(n)))}});h=t.output,d=t.newStates}a&&c.push(h)}return a&&(g=UC(c,1)),[h,g,d]})}nD.className="DepthwiseConv2D",O_(nD);class iD extends DA{constructor(t){let e;if(super(t),null==t.cell)throw new LN("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new pD({cells:t.cell}):t.cell,null==e.stateSize)throw new LN("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new NA({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?R$(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){xA(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let s;if(s=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const s of e)n.push([t[0],s]);return[s].concat(n)}return s}computeMask(t,e){return P_(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new MN("Constants support is not implemented in RNN yet.");xA(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new NA({shape:[e,null,...n]});const s=[t[0]].concat(t.slice(2));let r;if(this.cell.build(s),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!xg(this.stateSpec.map(t=>t.shape[t.shape.length-1]),r))throw new LN(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(t=>new NA({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){P_(()=>{if(!this.stateful)throw new DN("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new LN("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>bC([n,t])):[bC([n,this.cell.stateSize])];else if(null==t)z_(this.states_),null!=this.keptStates&&(z_(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>bC([n,t])):this.states_[0]=bC([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new LN(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):z_(this.states_);for(let e=0;e<this.states_.length;++e){const s=t[e],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,i=[n,r];if(!xg(s.shape,i))throw new LN(`State ${e} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[e]=s}}this.states_=this.states_.map(t=>B_(t.clone()))})}apply(t,e){let n=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=sD(t,n,s,this.numConstants);t=r.inputs,n=r.initialState,s=r.constants;let i=[],o=[];if(null!=n){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new NA({shape:t.shape}));o=o.concat(this.stateSpec)}if(null!=s&&(e.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof $A){const n=[t].concat(i),s=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=s;const a=super.apply(n,e);return this.inputSpec=r,a}return super.apply(t,e)}call(t,e){return P_(()=>{const n=null==e?null:e.mask,s=null==e?null:e.training;let r=null==e?null:e.initialState;t=kA(t),null==r&&(r=this.stateful?this.states_:this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==i)throw new LN(`RNN Layer has ${i} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:s},a=rD((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]},t,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=a[0],u=a[1],c=a[2];this.stateful&&this.resetStates(c,s);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h})}getInitialState(t){return P_(()=>{let e=bC(t.shape);return e=Yk(e,[1,2]),e=D$(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?B$(e,[1,t]):e):this.cell.stateSize>1?[B$(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===iD.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){const s=XA(e.cell,n);return new t(Object.assign(e,{cell:s}))}}iD.className="RNN",O_(iD);class oD extends DA{}class aD extends oD{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,e$(this.units,"units"),this.activation=SF(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=gA(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gA(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gA(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=RF(t.kernelRegularizer),this.recurrentRegularizer=RF(t.recurrentRegularizer),this.biasRegularizer=RF(t.biasRegularizer),this.kernelConstraint=p$(t.kernelConstraint),this.recurrentConstraint=p$(t.recurrentConstraint),this.biasConstraint=p$(t.biasConstraint),this.dropout=$$([1,A$([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=$$([1,A$([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=CA(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return P_(()=>{if(2!==(t=t).length)throw new LN(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const s=null!=e.training&&e.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=fD({ones:()=>wC(t),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=fD({ones:()=>wC(n),rate:this.recurrentDropout,training:s}));const i=this.dropoutMask,o=this.recurrentDropoutMask;r=W$(null!=i?Xk(t,i):t,this.kernel.read()),null!=this.bias&&(r=G$(r,this.bias.read())),null!=o&&(n=Xk(n,o));let a=G_(r,W$(n,this.recurrentKernel.read()));return null!=this.activation&&(a=this.activation.apply(a)),[a,a]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:CF(this.activation),useBias:this.useBias,kernelInitializer:mA(this.kernelInitializer),recurrentInitializer:mA(this.recurrentInitializer),biasInitializer:mA(this.biasInitializer),kernelRegularizer:$F(this.kernelRegularizer),recurrentRegularizer:$F(this.recurrentRegularizer),biasRegularizer:$F(this.biasRegularizer),activityRegularizer:$F(this.activityRegularizer),kernelConstraint:h$(this.kernelConstraint),recurrentConstraint:h$(this.recurrentConstraint),biasConstraint:h$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}aD.className="SimpleRNNCell",O_(aD);class lD extends iD{constructor(t){t.cell=new aD(t),super(t)}call(t,e){return P_(()=>(null!=this.cell.dropoutMask&&(z_(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(z_(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return new t(e)}}lD.className="SimpleRNN",O_(lD);class uD extends oD{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new LN("GRUCell does not support reset_after parameter set to true.");this.units=t.units,e$(this.units,"units"),this.activation=SF(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=SF(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=gA(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gA(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gA(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=RF(t.kernelRegularizer),this.recurrentRegularizer=RF(t.recurrentRegularizer),this.biasRegularizer=RF(t.biasRegularizer),this.kernelConstraint=p$(t.kernelConstraint),this.recurrentConstraint=p$(t.recurrentConstraint),this.biasConstraint=p$(t.biasConstraint),this.dropout=$$([1,A$([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=$$([1,A$([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=CA(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return P_(()=>{if(2!==(t=t).length)throw new LN(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=fD({ones:()=>wC(t),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=fD({ones:()=>wC(s),rate:this.recurrentDropout,training:n,count:3}));const r=this.recurrentDropoutMask;let i,o,a;0<this.dropout&&this.dropout<1&&(t=Xk(t,this.dropoutMask[0]));let l=W$(t,this.kernel.read());this.useBias&&(l=G$(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Xk(s,r[0]));const u=this.recurrentKernel.read(),[c,h]=BC(u,[2*this.units,this.units],u.rank-1),d=W$(s,c),[p,f,m]=BC(l,3,l.rank-1),[g,y]=BC(d,2,d.rank-1);i=this.recurrentActivation.apply(G_(p,g)),o=this.recurrentActivation.apply(G_(f,y));const b=W$(Xk(o,s),h);a=this.activation.apply(G_(m,b));const v=G_(Xk(i,s),Xk(G_(1,mC(i)),a));return[v,v]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:CF(this.activation),recurrentActivation:CF(this.recurrentActivation),useBias:this.useBias,kernelInitializer:mA(this.kernelInitializer),recurrentInitializer:mA(this.recurrentInitializer),biasInitializer:mA(this.biasInitializer),kernelRegularizer:$F(this.kernelRegularizer),recurrentRegularizer:$F(this.recurrentRegularizer),biasRegularizer:$F(this.biasRegularizer),activityRegularizer:$F(this.activityRegularizer),kernelConstraint:h$(this.kernelConstraint),recurrentConstraint:h$(this.recurrentConstraint),biasConstraint:h$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}uD.className="GRUCell",O_(uD);class cD extends iD{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new uD(t),super(t)}call(t,e){return P_(()=>(null!=this.cell.dropoutMask&&(z_(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(z_(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}cD.className="GRU",O_(cD);class hD extends oD{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,e$(this.units,"units"),this.activation=SF(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=SF(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=gA(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gA(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gA(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=RF(t.kernelRegularizer),this.recurrentRegularizer=RF(t.recurrentRegularizer),this.biasRegularizer=RF(t.biasRegularizer),this.kernelConstraint=p$(t.kernelConstraint),this.recurrentConstraint=p$(t.recurrentConstraint),this.biasConstraint=p$(t.biasConstraint),this.dropout=$$([1,A$([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=$$([1,A$([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;let n;if(t=CA(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,s=this.units;n=new((e=class extends Y${apply(e,n){const r=t.apply([s]),i=(new J$).apply([s]),o=t.apply([2*s]);return z$(z$(r,i),o)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return P_(()=>{const n=null!=e.training&&e.training;if(3!==(t=t).length)throw new LN(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=fD({ones:()=>wC(t),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=fD({ones:()=>wC(s),rate:this.recurrentDropout,training:n,count:4}));const i=this.recurrentDropoutMask;let o,a,l,u;0<this.dropout&&this.dropout<1&&(t=Xk(t,this.dropoutMask[0]));let c=W$(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Xk(s,i[0])),c=G_(c,W$(s,this.recurrentKernel.read())),this.useBias&&(c=G$(c,this.bias.read()));const[h,d,p,f]=BC(c,4,c.rank-1);o=this.recurrentActivation.apply(h),a=this.recurrentActivation.apply(d),l=G_(Xk(a,r),Xk(o,this.activation.apply(p))),u=this.recurrentActivation.apply(f);const m=Xk(u,this.activation.apply(l));return[m,m,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:CF(this.activation),recurrentActivation:CF(this.recurrentActivation),useBias:this.useBias,kernelInitializer:mA(this.kernelInitializer),recurrentInitializer:mA(this.recurrentInitializer),biasInitializer:mA(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:$F(this.kernelRegularizer),recurrentRegularizer:$F(this.recurrentRegularizer),biasRegularizer:$F(this.biasRegularizer),activityRegularizer:$F(this.activityRegularizer),kernelConstraint:h$(this.kernelConstraint),recurrentConstraint:h$(this.recurrentConstraint),biasConstraint:h$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}hD.className="LSTMCell",O_(hD);class dD extends iD{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new hD(t),super(t)}call(t,e){return P_(()=>(null!=this.cell.dropoutMask&&(z_(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(z_(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}dD.className="LSTM",O_(dD);class pD extends oD{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return P_(()=>{let n=(t=t).slice(1);const s=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?s.push(n.splice(0,t.stateSize.length)):s.push(n.splice(0,1));s.reverse();const r=[];let i;for(let o=0;o<this.cells.length;++o){const a=this.cells[o];n=s[o],i=0===o?[t[0]].concat(n):[i[0]].concat(n),i=a.call(i,e),r.push(i.slice(1))}n=[];for(const t of r.slice().reverse())n.push(...t);return[i[0]].concat(n)})}build(t){let e;xA(t)&&(t=t[0]),t=t,this.cells.forEach((n,s)=>{C$(`RNNCell_${s}`,()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=this.cells.map(t=>({className:t.getClassName(),config:t.getConfig()}));return Object.assign({},t,{cells:e})}static fromConfig(t,e,n={}){const s=[];for(const r of e.cells)s.push(XA(r,n));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return EA(t)}setWeights(t){const e=[];for(const n of this.cells){const s=t.splice(n.weights.length);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],s[t]])}TA(e)}}function fD(t){const{ones:e,rate:n,training:s=!1,count:r=1}=t,i=()=>q$(e(),n),o=()=>K$(i,e,s);return!r||r<=1?B_(o().clone()):Array(r).fill(void 0).map(o).map(t=>B_(t.clone()))}var mD,gD,yD,bD;pD.className="StackedRNNCells",O_(pD);class vD extends iD{constructor(t){if(t.unroll)throw new MN("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new MN("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new NA({ndim:5})]}call(t,e){return P_(()=>{if(null!=this.cell.dropoutMask&&(z_(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(z_(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new LN("ConvRNN2D cell does not support constants");return super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return P_(()=>{const{stateSize:e}=this.cell,n=this.computeSingleOutputShape(t.shape),s=bC([n[0],...n.slice(2)]);return Array.isArray(e)?Array(e.length).fill(s):[s]})}resetStates(t,e=!1){P_(()=>{if(!this.stateful)throw new DN("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,s=this.computeSingleOutputShape(n),r=[s[0],...s.slice(2)];if(null==n[0])throw new LN("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>bC(r)):[bC(r)];else if(null==t)z_(this.states_),null!=this.keptStates&&(z_(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>bC(r)):this.states_[0]=bC(r);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new LN(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):z_(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],s=r;if(!xg(n.shape,s))throw new LN(`State ${e} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${n.shape}`);this.states_[e]=n}}this.states_=this.states_.map(t=>B_(t.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:s,padding:r,strides:i,dilationRate:o}=this.cell,a="channelsFirst"===e,l=t[a?4:3],u=BF(t[a?3:2],s[0],r,i[0],o[0]),c=BF(l,s[1],r,i[1],o[1]);return[...t.slice(0,2),...a?[n,u,c]:[u,c,n]]}}vD.className="ConvRNN2D";class wD extends hD{constructor(t){const{filters:e,kernelSize:n,strides:s,padding:r,dataFormat:i,dilationRate:o}=t;super(Object.assign({},t,{units:e})),this.filters=e,e$(this.filters,"filters"),this.kernelSize=zF(n,2,"kernelSize"),this.kernelSize.forEach(t=>e$(t,"kernelSize")),this.strides=zF(s||1,2,"strides"),this.strides.forEach(t=>e$(t,"strides")),this.padding=r||"valid",x$(this.padding),this.dataFormat=i||"channelsLast",w$(this.dataFormat),this.dilationRate=zF(o||1,2,"dilationRate"),this.dilationRate.forEach(t=>e$(t,"dilationRate"))}build(t){var e;t=CA(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new LN(`The channel dimension of the input should be defined. Found ${t[n]}`);const s=this.kernelSize.concat([t[n],4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,s=this.filters;t=new((e=class extends Y${apply(t,e){return P$([n.apply([s]),vC([s]),n.apply([2*s])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return P_(()=>{if(3!==t.length)throw new LN(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,s=t[0],r=t[1],i=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=fD({ones:()=>wC(s),rate:this.dropout,training:n,count:4}));const o=this.dropoutMask,a=(t,e,n)=>e&&e[n]?Xk(e[n],t):t;let l=a(s,o,0),u=a(s,o,1),c=a(s,o,2),h=a(s,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=fD({ones:()=>wC(r),rate:this.recurrentDropout,training:n,count:4}));const d=this.recurrentDropoutMask;let p=a(r,d,0),f=a(r,d,1),m=a(r,d,2),g=a(r,d,3);const[y,b,v,w]=BC(this.kernel.read(),4,3),[x,_,k,C]=this.useBias?BC(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,x,this.padding),u=this.inputConv(u,b,_,this.padding),c=this.inputConv(c,v,k,this.padding),h=this.inputConv(h,w,C,this.padding);const[I,S,E,T]=BC(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,I),f=this.recurrentConv(f,S),m=this.recurrentConv(m,E),g=this.recurrentConv(g,T);const N=this.recurrentActivation.apply(G_(l,p)),$=this.recurrentActivation.apply(G_(u,f)),A=G_(Xk($,i),Xk(N,this.activation.apply(G_(c,m)))),R=Xk(this.recurrentActivation.apply(G_(h,g)),this.activation.apply(A));return[R,R,A]})}getConfig(){const t=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]])}return n}(super.getConfig(),["units"]);return Object.assign({},t,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(t,e,n,s){const r=_k(t,e,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?G$(r,n,this.dataFormat):r}recurrentConv(t,e){return _k(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}wD.className="ConvLSTM2DCell",O_(wD);class xD extends vD{constructor(t){const e=new wD(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}xD.className="ConvLSTM2D",O_(xD);class _D extends DA{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(null==this.noiseShape[s]?e[s]:this.noiseShape[s]);return n}call(t,e){return P_(()=>{this.invokeCallHook(t,e);const n=kA(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,s=this.getNoiseShape(n);return K$(()=>q$(n,this.rate,s,this.seed),()=>n,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}_D.className="Dropout",O_(_D);class kD extends _D{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}kD.className="SpatialDropout1D",O_(kD);class CD extends DA{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,e$(this.units,"units"),this.activation=SF(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=gA(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=gA(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=p$(t.kernelConstraint),this.biasConstraint=p$(t.biasConstraint),this.kernelRegularizer=RF(t.kernelRegularizer),this.biasRegularizer=RF(t.biasRegularizer),this.activityRegularizer=RF(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=CA(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=CA(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return P_(()=>{this.invokeCallHook(t,e);const n=kA(t),s=s$(this.activation.getClassName());let r;return null!=s?r=W$(n,this.kernel.read(),s,this.bias?this.bias.read():null):(r=W$(n,this.kernel.read()),null!=this.bias&&(r=G$(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){const t={units:this.units,activation:CF(this.activation),useBias:this.useBias,kernelInitializer:mA(this.kernelInitializer),biasInitializer:mA(this.biasInitializer),kernelRegularizer:$F(this.kernelRegularizer),biasRegularizer:$F(this.biasRegularizer),activityRegularizer:$F(this.activityRegularizer),kernelConstraint:h$(this.kernelConstraint),biasConstraint:h$(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}CD.className="Dense",O_(CD);class ID extends DA{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=CA(t);for(const e of t.slice(1))if(null==e)throw new LN(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],N$(t,1)]}call(t,e){return P_(()=>{this.invokeCallHook(t,e);let n=kA(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=n.transpose(t)}return function(t){if(t.rank<=1)throw new LN(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],N$(t.shape,1)];return t.reshape(e)}(n)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}ID.className="Flatten",O_(ID);class SD extends DA{constructor(t){super(t),this.supportsMasking=!0,this.activation=SF(t.activation)}call(t,e){return P_(()=>{this.invokeCallHook(t,e);const n=kA(t);return this.activation.apply(n)})}getConfig(){const t={activation:CF(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}SD.className="Activation",O_(SD);class ED extends DA{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return P_(()=>{return t=kA(t),e=t,n=this.n,P_(()=>{if(2!==e.shape.length)throw new LN(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return B$(D$(e,1),[1,n,1])});var e,n})}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}ED.className="RepeatVector",O_(ED);class TD extends DA{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",s=e.slice();let r=1,i=null;for(let a=0;a<s.length;++a){const t=s[a];if(this.isUnknown(t)){if(null!==i)throw new LN("Can only specifiy one unknown dimension.");i=a}else r*=t}const o=N$(t);if(null!==i){if(0===r||o%r!=0)throw new LN(n);s[i]=o/r}else if(o!==r)throw new LN(n);return s}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return P_(()=>{this.invokeCallHook(t,e);const n=kA(t),s=n.shape,r=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return n.reshape(r)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}TD.className="Reshape",O_(TD);class ND extends DA{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=R$(1,t.dims.length+1);if(!xg(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new NA({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=CA(t)).slice();return this.dims.forEach((n,s)=>{e[s+1]=t[n]}),e}call(t,e){return YC(kA(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}ND.className="Permute",O_(ND);class $D extends DA{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=kA(t);return K_(gC(n,this.maskValue),-1)}call(t,e){return P_(()=>{this.invokeCallHook(t,e);const n=kA(t),s=K_(gC(n,this.maskValue),-1,!0);return n.mul(s.asType(n.dtype))})}}$D.className="Masking",O_($D);class AD extends DA{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=null==t.inputLength?[e,null]:[e].concat(UN(t.inputLength))}this.inputDim=t.inputDim,e$(this.inputDim,"inputDim"),this.outputDim=t.outputDim,e$(this.outputDim,"outputDim"),this.embeddingsInitializer=gA(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=RF(t.embeddingsRegularizer),this.activityRegularizer=RF(t.activityRegularizer),this.embeddingsConstraint=p$(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return P_(()=>this.maskZero?(t=kA(t),gC(t,ZC(t))):null)}computeOutputShape(t){if(t=CA(t),null==this.inputLength)return[...t,this.outputDim];const e=UN(this.inputLength);if(e.length!==t.length-1)throw new LN(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let s=0;s<e.length;++s){const r=e[s],i=t[s+1];if(null!=r&&null!=i&&r!==i)throw new LN(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==r&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return P_(()=>{this.invokeCallHook(t,e);let n=kA(t);return"int32"!==n.dtype&&(n=F$(n,"int32")),U$(this.embeddings.read(),n.as1D()).reshape(CA(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:mA(this.embeddingsInitializer),embeddingsRegularizer:$F(this.embeddingsRegularizer),activityRegularizer:$F(this.activityRegularizer),embeddingsConstraint:h$(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}AD.className="Embedding",O_(AD);class RD extends DA{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new MN}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const r=t[t.length-e.length+s],i=e[s];if(null==r||null==i||r<0||i<0)n.push(null);else if(1===r)n.push(i);else if(1===i)n.push(r);else{if(r!==i)throw new LN("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(r)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[CA(t)]),(t=t).length<2)throw new LN(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const r of t)null!=r&&null!==r[0]&&e.push(r[0]);if(e=YN(e),e.length>1)throw new LN(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const e=null==t[r]?null:t[r].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const s=t.map(t=>t.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==YN(s).length}call(t,e){return P_(()=>{if(t=t,this.reshapeRequired){const e=[],n=t.map(t=>t.rank);if(-1===n.indexOf(null)){const s=A$(n);for(let n of t){const t=n.rank;for(let e=0;e<s-t;++e)n=D$(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const i of t){const t=i.rank;if(null==t){const t=i.shape,s=t[0],r=t.slice(1).concat([s]);let o=i.reshape([s].concat(N$(t.slice(1))));o=YC(o,[1,0]),o=o.reshape(r),e.push(o),n=!0}else if(t>1){const s=R$(1,t).concat([0]);e.push(YC(i,s)),n=!0}else e.push(i)}let s=this.mergeFunction(e);const r=s.rank;if(n)if(null==r){const t=s.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));s=YC(s.reshape([-1,e]),[1,0]).reshape(n)}else if(r>1){const t=[r-1].concat(R$(0,r-1));s=YC(s,t)}return s}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const n=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const s of t)null!=s&&null!==s[0]&&n.push(s[0]);return n=YN(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return P_(()=>{if(null==e)return null;if(!Array.isArray(e))throw new LN("`mask` should be an Array");if(!Array.isArray(t))throw new LN("`inputs` should be an Array");if(e.length!==t.length)throw new LN(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(t=>null==t))return null;let n=(e=e.map(t=>null==t?t:Mk(t,0)))[0];for(let t=1;t<e.length-1;++t)n=Jk(n,e[t]);return n})}}class FD extends RD{constructor(t){super(t)}mergeFunction(t){return P_(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=G_(e,t[n]);return e})}}FD.className="Add",O_(FD);class DD extends RD{constructor(t){super(t)}mergeFunction(t){return P_(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Xk(e,t[n]);return e})}}DD.className="Multiply",O_(DD);class OD extends RD{constructor(t){super(t)}mergeFunction(t){return P_(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=G_(e,t[n]);return Xk(1/t.length,e)})}}OD.className="Average",O_(OD);class LD extends RD{constructor(t){super(t)}mergeFunction(t){return P_(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=nC(e,t[n]);return e})}}LD.className="Maximum",O_(LD);class MD extends RD{constructor(t){super(t)}mergeFunction(t){return P_(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=rC(e,t[n]);return e})}}MD.className="Minimum",O_(MD);class PD extends RD{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new LN("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const s of t)if(null!=s){e=!1;break}if(e)return;const n=[];for(let s=0;s<t.length;++s){const e=t[s].slice();e.splice(this.axis,1);let r=!1;for(const t of n)if(xg(t,e)){r=!0;break}r||n.push(e)}if(n.length>1)throw new LN("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return P_(()=>P$(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new LN("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(const r of e.slice(1)){if(null==n[s]||null==r[s]){n[s]=null;break}n[s]+=r[s]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new LN("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new LN("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new LN(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return P_(()=>{let n=!0;if(e.forEach(t=>{null==t||(n=!1)}),n)return null;const s=[];for(let i=0;i<t.length;++i)s.push(null==e[i]?wC(t[i]).asType("bool"):e[i].rank<t[i].rank?Mk(e[i],-1):e[i]);const r=yk(s,this.axis);return q_(r,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function zD(t,e){for(;t<0;)t+=e;return t}PD.className="Concatenate",O_(PD);class BD extends RD{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){gg(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new MN("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,n);if(e[s[0]]!==n[s[1]])throw new LN(`Dimension incompatibility: ${e[s[0]]} !== ${n[s[1]]}`)}mergeFunction(t){if(2!==t.length)throw new LN(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],s=t[1];return e=Array.isArray(this.axes)?this.axes.map((e,n)=>zD(e,t[n].shape.length)):[zD(this.axes,n.shape.length),zD(this.axes,s.shape.length)],this.normalize&&(n=ZA(n,e[0]),s=ZA(s,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new MN("batchDot is not implemented for tensors of 4D or higher rank yet");if(gg(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),gg(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new MN("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;null==n&&(n=[s-1,r-2]);const i=n;return P_(()=>{let n,o;if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else n=0;if(o=2===t.shape.length&&2===e.shape.length?i[0]===i[1]?t.mul(e).sum(i[0]):t.transpose([1,0]).mul(e).sum(i[1]):t.matMul(e,i[0]!==t.shape.length-1,i[1]===e.shape.length-1),n>0){let t;t=s>r?s+r-3:s-1;const e=[];for(let s=t;s<t+n;++s)e.push(s);o=o.squeeze(e)}return 1===o.shape.length&&(o=o.expandDims(1)),o})}(n,s,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[zD(this.axes,t.length),zD(this.axes,e.length)],n}computeOutputShape(t){gg(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new MN("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,n);e.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);const r=e.concat(n);return 1===r.length&&r.push(1),r}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}BD.className="Dot",O_(BD);class VD extends DA{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return P_(()=>{this.invokeCallHook(t,e);const n=kA(t);return K$(()=>V$(n.shape,0,this.stddev).add(n),()=>n,e.training||!1)})}}VD.className="GaussianNoise",O_(VD);class WD extends DA{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return P_(()=>{this.invokeCallHook(t,e);const n=kA(t);return this.rate>0&&this.rate<1?K$(()=>{const t=Math.sqrt(this.rate/(1-this.rate));return n.mul(V$(n.shape,1,t))},()=>n,e.training||!1):n})}}WD.className="GaussianDropout",O_(WD);class UD extends DA{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||kA(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return P_(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return K$(()=>{const e=kA(t),s=-1.7580993408473766;let r=jk(EC(n),this.rate);r=F$(r,"float32");const i=((1-this.rate)*(1+this.rate*s**2))**-.5,o=-i*s*this.rate;return e.mul(r).add(r.add(-1).mul(s)).mul(i).add(o)},()=>kA(t),e.training||!1)}return t})}}function jD(t,e,n,s,r,i=.001){let o;if(2===t.rank)o=pk(t,e,n,s,r,i);else if(3===t.rank)o=fk(t,e,n,s,r,i);else{if(4!==t.rank)throw new MN(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=mk(t,e,n,s,r,i)}return o}UD.className="AlphaDropout",O_(UD);class HD extends DA{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=gA(t.betaInitializer||"zeros"),this.gammaInitializer=gA(t.gammaInitializer||"ones"),this.movingMeanInitializer=gA(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=gA(t.movingVarianceInitializer||"ones"),this.betaConstraint=p$(t.betaConstraint),this.gammaConstraint=p$(t.gammaConstraint),this.betaRegularizer=RF(t.betaRegularizer),this.gammaRegularizer=RF(t.gammaRegularizer)}build(t){t=CA(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new LN(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new NA({ndim:t.length,axes:{[e]:n}})];const s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return P_(()=>{const n=null!=e.training&&e.training,s=kA(t),r=s.shape,i=r.length,o=R$(0,i),a=this.axis>=0?this.axis:this.axis+i;o.splice(a,1);const l=zN(1,i);l[a]=r[a];const u=o.slice();u.sort();const c=!xg(u,R$(0,i).slice(0,i-1));if(!n)return(()=>{if(c){const t=this.movingMean.read().reshape(l),e=this.movingVariance.read().reshape(l),n=this.center?this.beta.read().reshape(l):null,r=this.scale?this.gamma.read().reshape(l):null;return jD(s,t,e,n,r,this.epsilon)}return jD(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(t,e,n,s,r=.001){return xg(s.slice().sort(),R$(0,t.rank-1))?function(t,e,n,s,r=.001){return P_(()=>{const i=fC(t,s),o=i.mean,a=i.variance;return[jD(t,o,a,n,e,r),o,a]})}(t,e,n,s,r):function(t,e,n,s,r=.001){return P_(()=>{const i=fC(t,s),o=i.mean,a=i.variance,l=[];for(const e of R$(0,t.rank))-1!==s.indexOf(e)?l.push(1):l.push(t.shape[e]);const u=o.reshape(l),c=a.reshape(l),h=null==e?null:e.reshape(l),d=null==n?null:n.reshape(l);return[jD(t,u,c,d,h,r),o,a]})}(t,e,n,s,r)}(s,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(t,e,n)=>{P_(()=>{const s=1-n,r=t.read(),i=r.sub(e).mul(s);t.write(r.sub(i))})};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:mA(this.betaInitializer),gammaInitializer:mA(this.gammaInitializer),movingMeanInitializer:mA(this.movingMeanInitializer),movingVarianceInitializer:mA(this.movingVarianceInitializer),betaRegularizer:$F(this.betaRegularizer),gammaRegularizer:$F(this.gammaRegularizer),betaConstraint:h$(this.betaConstraint),gammaConstraint:h$(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}HD.className="BatchNormalization",O_(HD);class GD extends DA{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=gA(t.betaInitializer||"zeros"),this.gammaInitializer=gA(t.gammaInitializer||"ones"),this.betaRegularizer=RF(t.betaRegularizer),this.gammaRegularizer=RF(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=CA(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(const s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==YN(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(e=>t[e]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,e){const n=kA(t),s=n.shape,r=s.length;return P_(()=>{let{mean:t,variance:e}=fC(n,this.axis,!0);const i=zN(1,r);for(const n of this.axis)i[n]=s[n];const o=t=>null!=t&&t.shape.length!==r&&this.axis!==[r-1]?t.reshape(i):t;let a=o(this.gamma.read()),l=o(this.beta.read());const u=[],c=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(u.push(s[n]),c.push(1)):(u.push(1),c.push(s[n]));return t=t.tile(u),e=e.tile(u),a=a.tile(c),l=l.tile(c),jD(n,t,e,l,a,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:mA(this.betaInitializer),gammaInitializer:mA(this.gammaInitializer),betaRegularizer:$F(this.betaRegularizer),gammaRegularizer:$F(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}GD.className="LayerNormalization",O_(GD);class qD extends DA{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new LN(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new LN(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new LN(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new NA({ndim:4})]}computeOutputShape(t){let e,n;return t=CA(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return P_(()=>{return e=kA(t),n=this.padding,s=this.dataFormat,P_(()=>{if(4!==e.rank)throw new LN(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new LN("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==s&&(s="channelsLast"),"channelsLast"!==s&&"channelsFirst"!==s)throw new LN(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===s?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],xC(e,t)});var e,n,s})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function KD(t,e,n,s,r,i){return P_(()=>{let o;w$(r),_$(i),x$(s),null==n&&(n=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),t=WF(t,r);const a="same"===s?"same":"valid";return o="max"===i?tC(t,e,n,a):ck(t,e,n,a),"channelsFirst"===r&&(o=YC(o,[0,3,1,2])),o})}function XD(t,e,n,s,r,i){return P_(()=>{let o;w$(r),_$(i),x$(s),null==n&&(n=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),t=UF(t,r);const a="same"===s?"same":"valid";return o="max"===i?eC(t,e,n,a):hk(t,e,n,a),"channelsFirst"===r&&(o=YC(o,[0,4,1,2,3])),o})}qD.className="ZeroPadding2D",O_(qD);class ZD extends DA{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new LN(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(e$(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new LN(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}e$(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,x$(this.padding),this.inputSpec=[new NA({ndim:3})]}computeOutputShape(t){const e=BF((t=CA(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return P_(()=>{this.invokeCallHook(t,e),t=D$(kA(t),2);const n=this.poolingFunction(kA(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return WC(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class YD extends ZD{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return w$(r),x$(s),KD(t,e,n,s,r,"max")}}YD.className="MaxPooling1D",O_(YD);class QD extends ZD{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return w$(r),x$(s),KD(t,e,n,s,r,"avg")}}QD.className="AveragePooling1D",O_(QD);class JD extends DA{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new LN(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];e$(this.poolSize,"poolSize"),e$(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,w$(this.dataFormat),x$(this.padding),this.inputSpec=[new NA({ndim:4})]}computeOutputShape(t){t=CA(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=BF(e,this.poolSize[0],this.padding,this.strides[0]),n=BF(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return P_(()=>(this.invokeCallHook(t,e),this.poolingFunction(kA(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class tO extends JD{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return w$(r),x$(s),KD(t,e,n,s,r,"max")}}tO.className="MaxPooling2D",O_(tO);class eO extends JD{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return w$(r),x$(s),KD(t,e,n,s,r,"avg")}}eO.className="AveragePooling2D",O_(eO);class nO extends DA{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new LN(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];e$(this.poolSize,"poolSize"),e$(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,w$(this.dataFormat),x$(this.padding),this.inputSpec=[new NA({ndim:5})]}computeOutputShape(t){t=CA(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=BF(e,this.poolSize[0],this.padding,this.strides[0]),n=BF(n,this.poolSize[1],this.padding,this.strides[1]),s=BF(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,s]:[t[0],e,n,s,t[4]]}call(t,e){return P_(()=>(this.invokeCallHook(t,e),this.poolingFunction(kA(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class sO extends nO{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return w$(r),x$(s),XD(t,e,n,s,r,"max")}}sO.className="MaxPooling3D",O_(sO);class rO extends nO{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return w$(r),x$(s),XD(t,e,n,s,r,"avg")}}rO.className="AveragePooling3D",O_(rO);class iO extends DA{constructor(t){super(t),this.inputSpec=[new NA({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new MN}}class oO extends iO{constructor(t){super(t||{})}call(t,e){return P_(()=>{const e=kA(t);return sC(e,1)})}}oO.className="GlobalAveragePooling1D",O_(oO);class aO extends iO{constructor(t){super(t||{})}call(t,e){return P_(()=>{const e=kA(t);return Kk(e,1)})}}aO.className="GlobalMaxPooling1D",O_(aO);class lO extends DA{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,w$(this.dataFormat),this.inputSpec=[new NA({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new MN}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class uO extends lO{call(t,e){return P_(()=>{const e=kA(t);return sC(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}uO.className="GlobalAveragePooling2D",O_(uO);class cO extends lO{call(t,e){return P_(()=>{const e=kA(t);return Kk(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}cO.className="GlobalMaxPooling2D",O_(cO);class hO extends DA{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const s=XA(e.layer,n);delete e.layer;const r={layer:s};return Object.assign(r,e),new t(r)}}class dO extends hO{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=CA(t)).length<3)throw new LN(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=CA(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e);return[n[0],t[1]].concat(n.slice(1))}call(t,e){return P_(()=>rD((t,n)=>[kA(this.layer.call(t,e)),[]],t=kA(t),[],!1,null,null,!1,!0)[1])}}dO.className="TimeDistributed",O_(dO);class pO extends hO{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=XA(n),e.goBackwards=!0!==e.goBackwards;const s={};if(s.className=t.layer.getClassName(),s.config=e,this.backwardLayer=XA(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,JN(b$,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new MN("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,e)),this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let e,n,s,r=this.forwardLayer.computeOutputShape(t);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState?(s=r.slice(1),e=r[0]):e=r[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(s).concat(s.slice()):[e].concat(s).concat(s.slice()):WN(n)}apply(t,e){let n=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=sD(t,n,s,this.numConstants);if(t=r.inputs,n=r.initialState,s=r.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==s)return super.apply(t,e);const i=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new LN("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);const s=n.map(t=>new NA({shape:t.shape}));this.forwardLayer.stateSpec=s.slice(0,t/2),this.backwardLayer.stateSpec=s.slice(t/2),o.push(...s)}if(null!=s)throw new MN("Support for constants in Bidirectional layers is not implemented yet.");const a=i[0]instanceof $A;for(const l of i)if(l instanceof $A!==a)throw new LN("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(a){const n=[t].concat(i),s=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=s;const a=super.apply(n,e);return this.inputSpec=r,a}return super.apply(t,e)}call(t,e){return P_(()=>{const n=e.initialState;let s,r,i,o;if(null==n)s=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const i=n.slice(0,n.length/2),o=n.slice(n.length/2);s=this.forwardLayer.call(t,Object.assign(e,{initialState:i})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(r.slice(1))),s=s[0],r=r[0]),this.returnSequences&&(r=NC(r,1)),"concat"===this.mergeMode?o=P$([s,r]):"sum"===this.mergeMode?o=G_(s,r):"ave"===this.mergeMode?o=Xk(.5,G_(s,r)):"mul"===this.mergeMode?o=Xk(s,r):null==this.mergeMode&&(o=[s,r]),this.returnState?null==this.mergeMode?o.concat(i):[o].concat(i):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){C$(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),C$(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map(t=>null);return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=XA(e.layer);if(delete e.layer,null!=e.numConstants)throw new MN("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=e;return s.layer=n,new t(s)}}function fO(t,e,n=new Map,s=new Set){if(null==t)return null;if(s.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(bO(t)){const r=Array.isArray(t)?[]:{};s.add(t);for(const i in t){const o=fO(t[i],e,n,s);r[i]=o}return s.delete(t),r}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,r.value),r.value}function mO(t,e=yO){return gO(t,e)}function gO(t,e,n=new Set){const s=t[0];if(n.has(s))throw new Error("Circular references are not supported.");const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(bO(s)){const r=Array.isArray(s)?[]:{};n.add(s);for(const i in s){const s=gO(t.map(t=>t[i]),e,n);r[i]=s}return n.delete(s),r}throw new Error(`Can't recurse into non-iterable type: ${s}`)}return r.value}function yO(t){return null===t?null:bO(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function bO(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof Ww))}function vO(t){return fO(t,wO)}function wO(t){return t instanceof Ww?{value:t.clone(),recurse:!1}:bO(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}pO.className="Bidirectional",O_(pO),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(mD||(mD={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(gD||(gD={}));class xO{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class _O extends xO{constructor(){super(_O.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let s=0;s<n;s++)e[s]=this.get(this.wrap(this.begin+s));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}_O.INITIAL_CAPACITY=32;class kO{toArray(){var t=this;return lg(function*(){const e=[];let n=yield t.next();for(;!n.done;)e.push(n.value),n=yield t.next();return e})()}toArrayForTest(){var t=this;return lg(function*(){const e=t.prefetch(100),n=[];let s=yield e.next();for(;!s.done;)n.push(s.value),s=yield e.next();return n})()}resolveFully(){var t=this;return lg(function*(){let e=yield t.next();for(;!e.done;)e=yield t.next()})()}resolveWhile(t){var e=this;return lg(function*(){let n=yield e.next(),s=t(n.value);for(;!n.done&&s;)n=yield e.next(),s=t(n.value)})()}handleErrors(t){return new RO(this,t)}filter(t){return new $O(this,t)}map(t){return new AO(this,t)}mapAsync(t){return new FO(this,t)}serialMapAsync(t){return new FO(this,t).serial()}flatmap(t){return new OO(this,t)}forEachAsync(t){var e=this;return lg(function*(){return e.map(t).resolveFully()})()}serialForEach(t){var e=this;return lg(function*(){return e.serialMapAsync(t).resolveWhile(t=>!0===t)})()}rowMajorBatch(t,e=!0){return new NO(this,t,e)}columnMajorBatch(t,e=!0,n=yO){return this.rowMajorBatch(t,e).map(t=>mO(t,n))}concatenate(t,e){return new LO(new CO([this,t]),e)}take(t){return t<0||null==t?this:new TO(this,t)}skip(t){return t<0||null==t?this:new EO(this,t)}prefetch(t){return new MO(this,t)}shuffle(t,e){return new PO(this,t,e)}serial(){return new SO(this)}}class CO extends kO{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var t=this;return lg(function*(){if(t.trav>=t.items.length)return{value:null,done:!0};const e=t.items[t.trav];return t.trav++,{value:vO(e),done:!1}})()}}class IO extends kO{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}next(){var t=this;return lg(function*(){try{return t.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}})()}}class SO extends kO{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var t=this;return lg(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return lg(function*(){return t.upstream.next()})()}}class EO extends kO{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var t=this;return lg(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return lg(function*(){for(;t.count++<t.maxCount;){const e=yield t.upstream.next();if(e.done)return e;z_(e.value)}return t.upstream.next()})()}}class TO extends kO{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var t=this;return lg(function*(){return t.count++>=t.maxCount?{value:null,done:!0}:t.upstream.next()})()}}class NO extends kO{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var t=this;return lg(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return lg(function*(){const e=[];for(;e.length<t.batchSize;){const n=yield t.upstream.next();if(n.done)return t.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(n.value)}return{value:e,done:!1}})()}}class $O extends kO{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var t=this;return lg(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return lg(function*(){for(;;){const e=yield t.upstream.next();if(e.done||t.predicate(e.value))return e;z_(e.value)}})()}}class AO extends kO{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}next(){var t=this;return lg(function*(){const e=yield t.upstream.next();if(e.done)return{value:null,done:!0};const n=ex(e.value),s=t.transform(e.value),r=ex(s);for(const t of n)tx(t,r)||t.dispose();return{value:s,done:!1}})()}}class RO extends kO{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var t=this;return lg(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return lg(function*(){for(;;)try{return yield t.upstream.next()}catch(e){if(!t.handler(e))return{value:null,done:!0}}})()}}class FO extends kO{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var t=this;return lg(function*(){const e=yield t.upstream.next();if(e.done)return{value:null,done:!0};const n=ex(e.value),s=yield t.transform(e.value),r=ex(s);for(const t of n)tx(t,r)||t.dispose();return{value:s,done:!1}})()}}class DO extends kO{constructor(){super(),this.outputQueue=new _O,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var t=this;return lg(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return lg(function*(){for(;0===t.outputQueue.length();)if(!(yield t.pump()))return{value:null,done:!0};return{value:t.outputQueue.shift(),done:!1}})()}}class OO extends DO{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var t=this;return lg(function*(){const e=yield t.upstream.next();if(e.done)return!1;const n=ex(e.value),s=t.transform(e.value),r=ex(s);t.outputQueue.pushAll(s);for(const t of n)tx(t,r)||t.dispose();return!0})()}}class LO extends kO{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var t=this;return lg(function*(){return t.lastRead=t.readFromChain(t.lastRead),t.lastRead})()}readFromChain(t){var e=this;return lg(function*(){if(yield t,null==e.iterator){const t=yield e.moreIterators.next();if(t.done)return{value:null,done:!0};e.iterator=t.value,null!=e.baseErrorHandler&&(e.iterator=e.iterator.handleErrors(e.baseErrorHandler))}const n=yield e.iterator.next();return n.done?(e.iterator=null,e.readFromChain(t)):n})()}}(bD=yD||(yD={}))[bD.FAIL=0]="FAIL",bD[bD.SHORTEST=1]="SHORTEST",bD[bD.LONGEST=2]="LONGEST";class MO extends kO{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new xO(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class PO extends MO{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=kC.alea(n||Ew().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var t=this;return lg(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var t=this;return lg(function*(){for(t.upstreamExhausted||t.refill();!t.buffer.isEmpty();){const e=t.chooseIndex(),n=yield t.buffer.shuffleExcise(e);if(!n.done)return t.refill(),n;t.upstreamExhausted=!0}return{value:null,done:!0}})()}}class zO{constructor(){this.size=null}batch(t,e=!0){const n=this;let s;return gg(t>0,()=>`batchSize needs to be positive, but it is\n      ${t}`),s=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),BO(lg(function*(){return(yield n.iterator()).columnMajorBatch(t,e,VO)}),s)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,BO(lg(function*(){return(yield e.iterator()).concatenate(yield t.iterator())}),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,BO(lg(function*(){return(yield e.iterator()).filter(e=>P_(()=>t(e)))}),n)}forEachAsync(t){var e=this;return lg(function*(){return(yield e.iterator()).forEachAsync(t)})()}map(t){const e=this;return BO(lg(function*(){return(yield e.iterator()).map(e=>P_(()=>t(e)))}),this.size)}mapAsync(t){const e=this;return BO(lg(function*(){return(yield e.iterator()).mapAsync(t)}),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return BO(lg(function*(){return(yield e.iterator()).prefetch(t)}),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,BO(lg(function*(){return n=(s=lg(function*(){return{value:yield e.iterator(),done:!1}}),new IO(s)).take(t),new LO(n,undefined);var n,s}),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,BO(lg(function*(){return(yield e.iterator()).skip(t)}),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,r=kC.alea(e||Ew().toString());return BO(lg(function*(){let e=r.int32();return n&&(e+=r.int32()),(yield s.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,BO(lg(function*(){return(yield e.iterator()).take(t)}),n)}toArray(){var t=this;return lg(function*(){if(t.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield t.iterator()).toArray()})()}toArrayForTest(){var t=this;return lg(function*(){if(t.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield t.iterator()).toArrayForTest()})()}}function BO(t,e=null){return new class extends zO{constructor(){super(...arguments),this.size=e}iterator(){return lg(function*(){return t()})()}}}function VO(t){return null===t?null:null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof Ww||Rg(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Ww?UC(t):wx(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function WO(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&gg("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the CPU backend.`)})}zO.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const UO=JS;class jO extends hg{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new cg(this,L_())}nextDataId(){return jO.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,Yg().get("IS_NODE")&&$S("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:n,refCount:1}),s}makeTensorInfo(t,e,n){let s;if("string"===e&&null!=n&&n.length>0&&Dg(n[0])){const r=n.map(t=>Tw(t));s=this.write(r,t,e)}else s=this.write(n,t,e);return{dataId:s,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,e,n,s,r){this.data.set(t,{values:e,dtype:s,refCount:r})}numDataIds(){return this.data.numDataIds()}read(t){var e=this;return lg(function*(){return e.readSync(t)})()}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);return"complex64"===e?RS(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>Nw(t))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return e_(t.shape,t.dtype,n)}makeOutput(t,e,n){const s=this.write(t,e,n);return L_().makeTensorFromDataId(s,e,n,this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}time(t){return lg(function*(){const e=Ew();return t(),{kernelMs:Ew()-e}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){WO([t],"where");const e=this.readSync(t.dataId);return UO(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function HO(t,e,n){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;if(WO(o,t),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,u=wg(o.shape),c=n||o.dtype,h=$g(c,u);for(let t=0;t<u;++t)h[t]=e(l[t],r);return a.makeTensorInfo(o.shape,c,h)}}function GO(t,e,n){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;if(WO(o,t),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,u=n||o.dtype,c=e(l,u,r);return a.makeTensorInfo(o.shape,u,c)}}jO.nextDataId=0,V_("cpu",()=>new jO,1);const qO=HO(Zy,t=>t>=0?t:Math.exp(t)-1),KO={kernelName:Zy,backendName:"cpu",kernelFunc:qO};function XO(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const ZO={kernelName:pb,backendName:"cpu",kernelFunc:XO};function YO(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:i}=s;WO([r],"leakyRelu");const o=wg(r.shape),a=n.data.get(r.dataId).values,l=Ng("float32",o);for(let u=0;u<a.length;u++)l[u]=a[u]<0?i*a[u]:a[u];return n.makeTensorInfo(r.shape,"float32",l)}const QO={kernelName:vb,backendName:"cpu",kernelFunc:YO};function JO(t){return(e,n,s,r,i)=>{const o=Ok(e,n),a=o.length,l=zg(o),u=Ng(i,wg(o)),c=e.length,h=n.length,d=zg(e),p=zg(n),f=Fk(e,o),m=Fk(n,o);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=t(s[g%s.length],r[g%r.length]);else for(let g=0;g<u.length;++g){const e=qg(g,a,l),n=e.slice(-c);f.forEach(t=>n[t]=0);const i=Gg(n,c,d),o=e.slice(-h);m.forEach(t=>o[t]=0);const y=Gg(o,h,p);u[g]=t(s[i],r[y])}return[u,o]}}const tL=JO((t,e)=>t<0?e*t:t);function eL(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;WO([s,r],"prelu");const i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,[a,l]=tL(s.shape,r.shape,i,o,s.dtype);return n.makeTensorInfo(l,s.dtype,a)}const nL={kernelName:tv,backendName:"cpu",kernelFunc:eL},sL=HO(iv,t=>Math.max(0,t)),rL={kernelName:iv,backendName:"cpu",kernelFunc:sL},iL=HO(hv,t=>Math.min(Math.max(0,t),6)),oL={kernelName:hv,backendName:"cpu",kernelFunc:iL},aL=HO(_v,t=>1/(1+Math.exp(-t))),lL={kernelName:_v,backendName:"cpu",kernelFunc:aL};function uL(t,e,n,s,r){if("linear"===n)return XO({inputs:{x:e},backend:t});if("relu"===n)return sL({inputs:{x:e},backend:t});if("elu"===n)return qO({inputs:{x:e},backend:t});if("relu6"===n)return iL({inputs:{x:e},backend:t});if("prelu"===n)return eL({inputs:{x:e,alpha:s},backend:t});if("leakyrelu"===n)return YO({inputs:{x:e},backend:t,attrs:{alpha:r}});if("sigmoid"===n)return aL({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function cL(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,a=n.makeTensorInfo(s.shape,"complex64");return n.data.get(a.dataId).complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",i),imag:n.makeTensorInfo(r.shape,"float32",o)},a}const hL={kernelName:Sy,backendName:"cpu",kernelFunc:cL};function dL(t,e,n="float32"){if("complex64"===n)return cL({inputs:{real:dL(t,e,"float32"),imag:dL(t,e,"float32")},backend:t});const s=Ug(wg(e),n);return t.makeTensorInfo(e,n,s)}function pL(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const fL={kernelName:sv,backendName:"cpu",kernelFunc:pL};function mL(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return XO({inputs:{x:r},backend:n});const t=dL(n,r.shape,r.dtype),e=mL({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),s=cL({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),s}if("complex64"===r.dtype){const t=pL({inputs:{input:r},backend:n}),e=mL({inputs:{x:t},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(t),e}if(!Ag(r.dtype,i)){const t=XO({inputs:{x:r},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:i}}if("int32"===i){const t=n.data.get(r.dataId).values,e=Int32Array.from(t);return n.makeTensorInfo(r.shape,"int32",e)}if("bool"===i){const t=n.data.get(r.dataId).values,e=Sw([0],r.dtype),[s,i]=JO((t,e)=>t!==e?1:0)(r.shape,[],t,e,"bool");return n.makeTensorInfo(i,"bool",s)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const gL={kernelName:ky,backendName:"cpu",kernelFunc:mL};function yL(t,e,n,s){return null==n?({inputs:n,backend:r})=>{const{a:i,b:o}=n,a=r;WO([i,o],t);const l=a.data.get(i.dataId).values,u=a.data.get(o.dataId).values,c="string"===i.dtype?YS(l):l,h="string"===i.dtype?YS(u):u,d=s||i.dtype,[p,f]=e(i.shape,o.shape,c,h,d);return a.makeTensorInfo(f,d,p)}:({inputs:t,backend:r})=>{const{a:i,b:o}=t,a=r;if("complex64"===i.dtype||"complex64"===o.dtype){const t=mL({inputs:{x:i},backend:a,attrs:{dtype:"complex64"}}),e=a.data.get(t.dataId),s=e.complexTensorInfos.imag,r=a.data.get(e.complexTensorInfos.real.dataId).values,l=a.data.get(s.dataId).values,u=mL({inputs:{x:o},backend:a,attrs:{dtype:"complex64"}}),c=a.data.get(u.dataId),h=c.complexTensorInfos.imag,d=a.data.get(c.complexTensorInfos.real.dataId).values,p=a.data.get(h.dataId).values,[f,m,g]=n(i.shape,o.shape,r,l,d,p),y=a.makeTensorInfo(g,"float32",f),b=a.makeTensorInfo(g,"float32",m),v=cL({inputs:{real:y,imag:b},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(u),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(b),v}{const t=a.data.get(i.dataId).values,n=a.data.get(o.dataId).values,r=s||i.dtype,[l,u]=e(i.shape,o.shape,t,n,r);return a.makeTensorInfo(u,r,l)}}}function bL(t){return(e,n,s,r,i,o)=>{const a=Ok(e,n),l=wg(a),u=a.length,c=zg(a),h=Ng("float32",l),d=Ng("float32",l),p=Fk(e,a),f=Fk(n,a),m=RS(s,r),g=RS(i,o),y=e.length,b=zg(e),v=n.length,w=zg(n);if(p.length+f.length===0)for(let x=0;x<h.length;x++){const e=x%m.length,n=x%g.length,s=t(m[2*e],m[2*e+1],g[2*n],g[2*n+1]);h[x]=s.real,d[x]=s.imag}else for(let x=0;x<h.length;x++){const e=qg(x,u,c),n=e.slice(-y);p.forEach(t=>n[t]=0);const s=Gg(n,y,b),r=e.slice(-v);f.forEach(t=>r[t]=0);const i=Gg(r,v,w),o=t(m[2*s],m[2*s+1],g[2*i],g[2*i+1]);h[x]=o.real,d[x]=o.imag}return[h,d,a]}}const vL=JO((t,e)=>t+e),wL=bL((t,e,n,s)=>({real:t+n,imag:e+s})),xL=yL(iy,vL,wL),_L={kernelName:iy,backendName:"cpu",kernelFunc:xL};function kL(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:i}=s,o=wg(r.shape),a=Sg(i,o),l=wg(a);gg(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(null!=u.complexTensorInfos){const t=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,t.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const CL={kernelName:ov,backendName:"cpu",kernelFunc:kL};function IL(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;WO([r,i],"matMul");const l=r.shape.length,u=i.shape.length,c=o?r.shape[l-2]:r.shape[l-1],h=a?i.shape[u-1]:i.shape[u-2],d=o?r.shape[l-1]:r.shape[l-2],p=a?i.shape[u-2]:i.shape[u-1],f=r.shape.slice(0,-2),m=i.shape.slice(0,-2),g=wg(f),y=wg(m);gg(l>=2&&u>=2&&(g===y||1===g||1===y),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`);const b=(g>y?r.shape.slice(0,-2):i.shape.slice(0,-2)).concat([d,p]);gg(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const v=a?[y,p,h]:[y,h,p],w=kL({inputs:{x:r},backend:n,attrs:{shape:o?[g,c,d]:[g,d,c]}}),x=kL({inputs:{x:i},backend:n,attrs:{shape:v}}),_=o?w.shape[1]:w.shape[2],k=o?w.shape[2]:w.shape[1],C=a?x.shape[1]:x.shape[2],I=Math.max(g,y),S=n.data.get(w.dataId).values,E=n.data.get(x.dataId).values,T=zg(w.shape),N=zg(x.shape),[$,A,R]=o?[T[0],1,T[1]]:[T[0],T[1],1],[F,D,O]=a?[1,N[1],N[0]]:[N[1],1,N[0]],L=k*C,M=e_([I,k,C],w.dtype),P=M.values,z=n.blockSize;for(let B=0;B<I;B++)for(let t=0;t<k;t+=z)for(let e=0;e<C;e+=z)for(let n=0;n<_;n+=z){const s=Math.min(t+z,k),r=Math.min(e+z,C),i=Math.min(n+z,_);for(let o=t;o<s;o++)for(let t=e;t<r;t++){let e=0;for(let s=n;s<i;s++){const n=Math.min(B,g-1)*$,r=Math.min(B,y-1)*O;e+=S[n+o*A+s*R]*E[s*F+t*D+r]}P[B*L+(o*C+t)]+=e}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(x),n.makeTensorInfo(b,M.dtype,M.values)}const SL={kernelName:wy,backendName:"cpu",kernelFunc:IL},EL={kernelName:tw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,p,f;const m=[];d=IL({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),o&&(p=xL({inputs:{a:d,b:o},backend:n}),m.push(d),d=p),c&&(f=uL(n,d,c,a,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function TL(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const NL={kernelName:ny,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;WO(e,"abs");let s=new Float32Array(wg(e.shape));return s=TL(n.data.get(e.dataId).values),n.makeOutput(s,e.shape,"float32")}},$L=HO(sy,t=>Math.acos(t)),AL={kernelName:sy,backendName:"cpu",kernelFunc:$L},RL=HO(ry,t=>Math.acosh(t)),FL={kernelName:ry,backendName:"cpu",kernelFunc:RL},DL={kernelName:oy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,s=e;WO(e,"addN");const r=s.map(t=>n.data.get(t.dataId).values),i=e_(s[0].shape,s[0].dtype),o=i.values;for(let a=0;a<s.length;a++){const t=r[a];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function OL(t,e,n,s,r){const i=e.length,o=wg(e),a=zg(e),l=zg(r),u=Ng(n,wg(r));for(let c=0;c<o;++c){const e=qg(c,i,a),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[s[t]];u[Gg(n,i,l)]=t[c]}return u}function LL(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:i}=n;WO(r,"transpose");const o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[i[l]];const a=OL(s.data.get(r.dataId).values,r.shape,r.dtype,i,o);return{dataId:s.write(a,o,r.dtype),shape:o,dtype:r.dtype}}const ML={kernelName:Gv,backendName:"cpu",kernelFunc:LL},PL={kernelName:ay,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;WO(r,"all");const a=Eg(i,r.shape);let l=a;const u=cC(l,r.shape.length);let c=r;null!=u&&(c=LL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=dC(l.length,r.shape.length)),uC("all",l,c.shape.length);const[h,d]=aC(c.shape,l),p=wg(d),f=Ug(wg(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const t=y*p;let e=m[t];for(let n=0;n<p;++n){const s=m[t+n];e=e&&s}f[y]=e}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(o){const t=kL({inputs:{x:g},backend:n,attrs:{shape:lC(h,a)}});return n.disposeIntermediateTensorInfo(g),t}return g}},zL={kernelName:ly,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;WO(r,"any");const a=Eg(i,r.shape);let l=a;const u=cC(l,r.shape.length);let c=r;null!=u&&(c=LL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=dC(l.length,r.shape.length)),uC("any",l,c.shape.length);const[h,d]=aC(c.shape,l),p=wg(d),f=Ug(wg(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const t=y*p;let e=m[t];for(let n=0;n<p;++n){const s=m[t+n];e=e||s}f[y]=e}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(o){const t=kL({inputs:{x:g},backend:n,attrs:{shape:lC(h,a)}});return n.disposeIntermediateTensorInfo(g),t}return g}},BL={kernelName:uy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;WO(r,"argMax");let o=Eg(i,r.shape);const a=cC(o,r.shape.length);let l=r;const u=[];null!=a&&(l=LL({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=dC(o.length,l.shape.length)),o=[o[0]],uC("argMax",o,l.shape.length);const[c,h]=aC(l.shape,o),d=Ug(wg(c),"int32"),p=wg(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const t=m*p;let e=f[t],n=0;for(let s=0;s<p;++s){const r=f[t+s];r>e&&(e=r,n=s)}d[m]=n}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(c,"int32",d)}},VL={kernelName:cy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;WO(r,"argMin");let o=Eg(i,r.shape);const a=cC(o,r.shape.length);let l=r;const u=[];null!=a&&(l=LL({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=dC(o.length,l.shape.length)),o=[o[0]],uC("argMin",o,l.shape.length);const[c,h]=aC(l.shape,o),d=Ug(wg(c),"int32"),p=wg(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const t=m*p;let e=f[t],n=0;for(let s=0;s<p;++s){const r=f[t+s];r<e&&(e=r,n=s)}d[m]=n}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(c,"int32",d)}},WL=HO(hy,t=>Math.asin(t)),UL={kernelName:hy,backendName:"cpu",kernelFunc:WL},jL=HO(dy,t=>Math.asinh(t)),HL={kernelName:dy,backendName:"cpu",kernelFunc:jL},GL=HO(py,t=>Math.atan(t)),qL={kernelName:py,backendName:"cpu",kernelFunc:GL},KL=JO((t,e)=>Math.atan2(t,e)),XL=yL(my,KL),ZL={kernelName:my,backendName:"cpu",kernelFunc:XL},YL=HO(fy,t=>Math.atanh(t)),QL={kernelName:fy,backendName:"cpu",kernelFunc:YL};function JL(t,e,n,s,r,i){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=e_(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let w=0;w<r.batchSize;++w){const e=w*y,n=w*s[0];for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outHeight;++y){const w=y*o-d,x=Math.max(0,w),_=Math.min(r.inHeight,c+w),k=e+y*b;for(let e=0;e<r.outWidth;++e){const o=e*a-p,c=Math.max(0,o),d=Math.min(r.inWidth,h+o);let y=f,b=0,w=0;for(let e=x;e<_;e+=l){const r=n+e*s[1];for(let e=c;e<d;e+=u){const n=t[r+e*s[2]+m];"max"===i&&n>y?y=n:"avg"===i&&(b+=n,w++)}if(isNaN(y))break}g[k+e*v+m]="avg"===i?b/w:y}}}return m}function tM(t,e,n,s,r=!1,i=!1){const o=e_(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=e_(e,n,t);for(let g=0;g<s.batchSize;++g)for(let t=0;t<s.inChannels;++t)for(let e=0;e<s.outHeight;++e){const n=e*a-p;let y=n;for(;y<0;)y+=u;const b=Math.min(s.inHeight,h+n);for(let a=0;a<s.outWidth;++a){const h=a*l-f;let p=h;for(;p<0;)p+=c;const v=Math.min(s.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,x=-1;for(let e=y;e<b;e+=u){const o=e-n;for(let n=p;n<v;n+=c){const a=n-h,l=m.get(g,e,n,t);l>w&&(w=l,x=r?i?((g*s.inHeight+e)*s.inWidth+n)*s.inChannels+t:(e*s.inWidth+n)*s.inChannels+t:o*d+a)}}o.set(x,g,e,a,t)}}return o}function eM(t,e,n,s,r,i){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=e_(r.outShape,n),w=v.values,x=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[3]*r.outShape[4],C=r.outShape[4];for(let I=0;I<r.batchSize;++I){const e=I*x,n=I*s[0];for(let v=0;v<r.inChannels;++v)for(let x=0;x<r.outDepth;++x){const I=x*o-m;let S=I;for(;S<0;)S+=u;const E=Math.min(r.inDepth,d+I),T=e+x*_;for(let e=0;e<r.outHeight;++e){const o=e*a-g;let d=o;for(;d<0;)d+=c;const m=Math.min(r.inHeight,p+o),x=T+e*k;for(let e=0;e<r.outWidth;++e){const o=e*l-y;let a=o;for(;a<0;)a+=h;const p=Math.min(r.inWidth,f+o),g=x+e*C;let _=b,k=0,I=0;for(let e=S;e<E;e+=u){const r=n+e*s[1];for(let e=d;e<m;e+=c){const n=r+e*s[2];for(let e=a;e<p;e+=h){const r=t[n+e*s[3]+v];if("max"===i&&r>_?_=r:"avg"===i&&(k+=r,I++),isNaN(_))break}if(isNaN(_))break}if(isNaN(_))break}w[g+v]="avg"===i?k/I:_}}}}return v}const nM={kernelName:gy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;WO(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s;gg(ak(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Y_(r.shape,i,o,1,a,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&xg(u.inShape,u.outShape))c=XO({inputs:{x:r},backend:n});else{const t=n.data.get(r.dataId).values,e=zg(r.shape),s=JL(t,0,r.dtype,e,u,"avg");c=n.makeTensorInfo(u.outShape,r.dtype,s.values)}return c}},sM={kernelName:by,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s;WO(r,"avgPool3d");const c=Q_(r.shape,i,o,1,a,l,u),h=eM(n.data.get(r.dataId).values,0,r.dtype,zg(r.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},rM={kernelName:vy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s;WO([r,i],"avgPool3DGrad");const c=Q_(i.shape,o,a,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,x=c.effectiveFilterHeight,_=c.effectiveFilterWidth,k=w-1-c.padInfo.front,C=_-1-c.padInfo.left,I=x-1-c.padInfo.top,S=e_(i.shape,"float32"),E=1/(f*m*g),T=n.bufferSync(r);for(let N=0;N<c.batchSize;++N)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inDepth;++e)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=e-k,i=n-I,o=s-C;let a=0;for(let e=0;e<w;e+=y){const n=(r+e)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let e=0;e<x;e+=b){const s=(i+e)/d;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let e=0;e<_;e+=v){const r=(o+e)/p;r<0||r>=c.outWidth||Math.floor(r)!==r||(a+=T.get(N,n,s,r,t))}}}S.set(a*E,N,e,n,s,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},iM={kernelName:yy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i;WO([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=Y_(o.shape,a,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,w=y-1-c.padInfo.top,x=e_(o.shape,"float32"),_=1/(p*f),k=n.data.get(r.dataId).values,C=e_(r.shape,"float32",k);for(let I=0;I<c.batchSize;++I)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inHeight;++e)for(let n=0;n<c.inWidth;++n){const s=e-w,r=n-v;let i=0;for(let e=0;e<y;e+=m){const n=(s+e)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let e=0;e<b;e+=g){const s=(r+e)/d;s<0||s>=c.outWidth||Math.floor(s)!==s||(i+=C.get(I,n,s,t))}}x.set(i*_,I,e,n,t)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},oM={kernelName:lb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,scale:i,offset:o,mean:a,variance:l}=e;gg(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),gg(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),gg(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),WO([r,a,l,i,o],"batchNorm");let{varianceEpsilon:u}=s;null==u&&(u=.001);const c=n.data.get(r.dataId).values,h=n.data.get(a.dataId).values,d=n.data.get(l.dataId).values,p=i?n.data.get(i.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=d.length,v=h.length;let w=0,x=0,_=0,k=0;for(let C=0;C<c.length;++C)m[C]=f[w++]+(c[C]-h[x++])*p[_++]/Math.sqrt(d[k++]+u),w>=g&&(w=0),x>=v&&(x=0),_>=y&&(_=0),k>=b&&(k=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function aM(t,e,n,s,r){const i=N_(s,e,n),o=wg(n),a=zg(s);if(i){const n=$_(e,a);return"string"===r?t.slice(n,n+o):t.subarray(n,n+o)}const l=e_(s,r,"string"===r?YS(t):t),u=e_(n,r);for(let c=0;c<u.size;++c){const t=u.indexToLoc(c),n=t.map((t,n)=>t+e[n]);u.set(l.get(...n),...t)}return"string"===r?QS(u.values):u.values}function lM(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:o}=s;WO(r,"slice");const[a,l]=A_(r,i,o);y_(r,a,l);const u=aM(n.data.get(r.dataId).values,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,u)}const uM={kernelName:bv,backendName:"cpu",kernelFunc:lM},cM={kernelName:xy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:o}=s;WO([r],"batchToSpaceND");const a=i.reduce((t,e)=>t*e),l=pS(r.shape,i,a),u=fS(l.length,i.length),c=mS(r.shape,i,a),h=gS(o,i.length),d=yS(c,o,i.length),p=kL({inputs:{x:r},backend:n,attrs:{shape:l}}),f=LL({inputs:{x:p},backend:n,attrs:{perm:u}}),m=kL({inputs:{x:f},backend:n,attrs:{shape:c}}),g=lM({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function hM(t,e,n,s,r){const i=wg(s),o=Ug(r,n);for(let a=0;a<t.length;a++){const n=t[a];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(o[n]+=i>0?e[a]:1)}return o}function dM(t,e,n,s=!1){const r=t.shape[0],i=t.shape[1],o=e_([r,n],e.dtype);for(let a=0;a<r;a++)for(let r=0;r<i;r++){const i=t.get(a,r);if(i<0)throw new Error("Input x must be non-negative!");i>=n||o.set(s?1:e.size>0?o.get(a,i)+e.get(a,r):o.get(a,i)+1,a,i)}return o}const pM={kernelName:_y,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o}=s,a=hM(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,a)}};function fM(t){return(e,n,s)=>{const r=Ng(n,e.length);for(let i=0;i<e.length;++i)r[i]=t(e[i],s);return r}}const mM=fM(t=>Math.ceil(t)),gM=GO(Cy,mM),yM={kernelName:Cy,backendName:"cpu",kernelFunc:gM},bM=HO(Iy,(t,e)=>t>e.clipValueMax?e.clipValueMax:t<e.clipValueMin?e.clipValueMin:t),vM={kernelName:Iy,backendName:"cpu",kernelFunc:bM},wM={kernelName:Ey,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,s=new Float32Array(wg(e.shape)),r=n.data.get(e.dataId),i=r.complexTensorInfos.imag,o=n.data.get(r.complexTensorInfos.real.dataId).values,a=n.data.get(i.dataId).values;for(let l=0;l<o.length;l++)s[l]=Math.hypot(o[l],a[l]);return n.makeOutput(s,e.shape,"float32")}};function xM(t,e,n,s){const r=$g(n,wg(e));if(s&&"string"!==n){let e=0;t.forEach(t=>{const n=wg(t.shape);r.set(t.vals,e),e+=n})}else{let s=0;t.forEach(t=>{const i="string"===n?YS(t.vals):t.vals;let o=0;for(let n=0;n<t.shape[0];++n){const a=n*e[1]+s;for(let e=0;e<t.shape[1];++e)r[a+e]=i[o++]}s+=t.shape[1]})}return r}function _M(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const kM={kernelName:mb,backendName:"cpu",kernelFunc:_M};function CM(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,i=Eg(r,e[0].shape)[0];let o=uS(e.map(t=>t.shape),i);if(0===wg(o))return n.makeTensorInfo(o,e[0].dtype,[]);const a=e.filter(t=>wg(t.shape)>0);if(1===a.length)return XO({inputs:{x:a[0]},backend:n});if(lS(a.map(t=>t.shape),i),"complex64"===a[0].dtype){const t=a.map(t=>pL({inputs:{input:t},backend:n})),e=a.map(t=>_M({inputs:{input:t},backend:n})),s=CM({inputs:t,backend:n,attrs:{axis:i}}),r=CM({inputs:e,backend:n,attrs:{axis:i}}),o=cL({inputs:{real:s,imag:r},backend:n});return t.forEach(t=>n.disposeIntermediateTensorInfo(t)),e.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),o}const l=a.map(t=>{const e=wg(t.shape.slice(i));return kL({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})}),u=l.map(t=>({vals:n.data.get(t.dataId).values,shape:t.shape}));o=uS(l.map(t=>t.shape),1);const c=xM(u,o,e[0].dtype,1===l[0].shape[0]),h=uS(a.map(t=>t.shape),i),d=n.makeTensorInfo(h,e[0].dtype,c);return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),d}const IM={kernelName:Ty,backendName:"cpu",kernelFunc:CM};function SM(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s;WO([r,i],"conv2d");const h=lk(l),d=J_(r.shape,i.shape,o,u,a,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v="channelsLast"===d.dataFormat,w=new Pw(d.outShape,r.dtype),x=zg(r.shape),_=zg(i.shape),k=x[0],C=v?x[1]:x[2],I=v?x[2]:1,S=v?1:x[1],E=w.strides[0],T=v?w.strides[1]:w.strides[2],N=v?w.strides[2]:1,$=v?1:w.strides[1],A=n.data.get(r.dataId).values,R=n.data.get(i.dataId).values,F=w.values;for(let D=0;D<d.batchSize;++D){const t=D*k,e=D*E;for(let n=0;n<d.outHeight;++n){const s=e+n*T,r=n*d.strideHeight-b;for(let e=0;e<p;++e){const n=r+e*m;if(n<0||n>=d.inHeight)continue;const i=e*_[0],o=t+n*C;for(let t=0;t<d.outWidth;++t){const e=s+t*N,n=t*d.strideWidth-y;for(let t=0;t<f;++t){const s=n+t*g;if(s<0||s>=d.inWidth)continue;const r=o+s*I;let a=i+t*_[1];for(let t=0;t<d.inChannels;++t){const n=A[r+t*S];for(let t=0;t<d.outChannels;++t)F[e+t*$]+=n*R[a+t];a+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,F)}const EM={kernelName:Ny,backendName:"cpu",kernelFunc:SM},TM={kernelName:$y,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;WO([r,i],"conv2dBackpropFilter");const h=lk(l),d=J_(r.shape,c,o,1,a,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new Pw(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,x=n.data.get(r.dataId).values,_=n.data.get(i.dataId).values,k=new Pw(r.shape,r.dtype,x),C=new Pw(i.shape,i.dtype,_);for(let I=0;I<m;++I){const t=Math.max(0,Math.ceil((w-I)/p)),e=Math.min(d.outHeight,(d.inHeight+w-I)/p);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let i=0;i<d.inChannels;++i)for(let o=0;o<d.outChannels;++o){let a=0;for(let l=0;l<d.batchSize;++l)for(let u=t;u<e;++u){const t=I+u*p-w;for(let e=s;e<r;++e){const s=n+e*f-v;a+=y?k.get(l,t,s,i)*C.get(l,u,e,o):k.get(l,i,t,s)*C.get(l,o,u,e)}}b.set(a,I,n,i,o)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},NM={kernelName:Ay,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s;WO([r,i],"conv2dBackpropInput");const h=zg(i.shape),d=zg(r.shape);let p=lk(u);const f=J_(o,i.shape,a,1,l,c,!1,p),m=new Pw(f.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,b=n.data.get(i.dataId).values,[v,w,x]=h,{batchSize:_,filterHeight:k,filterWidth:C,inChannels:I,inHeight:S,inWidth:E,outChannels:T,outHeight:N,outWidth:$,strideHeight:A,strideWidth:R}=f;p=f.dataFormat;const F=k-1-f.padInfo.top,D=C-1-f.padInfo.left,O="channelsLast"===p,L=m.strides[0],M=O?m.strides[1]:m.strides[2],P=O?m.strides[2]:1,z=O?1:m.strides[1],B=d[0],V=O?d[1]:d[2],W=O?d[2]:1,U=O?1:d[1];for(let j=0;j<_;++j)for(let t=0;t<I;++t)for(let e=0;e<S;++e){const n=e-F,s=Math.max(0,Math.ceil(n/A)),r=Math.min(N,(k+n)/A);for(let i=0;i<E;++i){const o=i-D,a=Math.max(0,Math.ceil(o/R)),l=Math.min($,(C+o)/R);let u=0;for(let e=s;e<r;++e){const s=e*A-n;for(let n=a;n<l;++n){const r=B*j+V*e+W*n,i=v*(k-1-s)+w*(C-1-(n*R-o))+x*t;for(let t=0;t<T;++t)u+=y[r+U*t]*b[i+t]}}g[L*j+M*e+P*i+z*t]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},$M={kernelName:Ry,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s;WO([r,i],"conv3d");const u=tk(r.shape,i.shape,o,l,a),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,w=new Pw(u.outShape,r.dtype),x=n.data.get(r.dataId).values,_=n.data.get(i.dataId).values,k=w.values,C=zg(r.shape),I=zg(i.shape);for(let S=0;S<u.batchSize;++S){const t=S*C[0],e=S*w.strides[0];for(let n=0;n<u.outDepth;++n){const s=e+n*w.strides[1],r=n*u.strideDepth-y;for(let e=0;e<c;++e){const n=r+e*p;if(n<0||n>=u.inDepth)continue;const i=e*I[0],o=t+n*C[1];for(let t=0;t<u.outHeight;++t){const e=s+t*w.strides[2],n=t*u.strideHeight-v;for(let t=0;t<h;++t){const s=n+t*f;if(s<0||s>=u.inHeight)continue;const r=i+t*I[1],a=o+s*C[2];for(let t=0;t<u.outWidth;++t){const n=e+t*u.outChannels,s=t*u.strideWidth-b;for(let t=0;t<d;++t){const e=s+t*m;if(e<0||e>=u.inWidth)continue;const i=a+e*u.inChannels;let o=r+t*I[2];for(let t=0;t<u.inChannels;++t){const e=x[i+t];for(let t=0;t<u.outChannels;++t)k[n+t]+=e*_[o+t];o+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},AM={kernelName:Fy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s;WO([r,i],"conv3dBackpropFilterV2");const u=zg(r.shape),c=zg(i.shape),h=tk(r.shape,l,o,1,a),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new Pw(h.filterShape,"float32"),v=b.values,[w,x,_,k]=b.strides,C=n.data.get(i.dataId).values,[I,S,E,T]=c,N=n.data.get(r.dataId).values,[$,A,R,F]=u,D=h.padInfo.front,O=h.padInfo.left,L=h.padInfo.top;for(let M=0;M<m;++M){const t=Math.max(0,Math.ceil((D-M)/d)),e=Math.min(h.outDepth,(h.inDepth+D-M)/d),n=M*w;for(let s=0;s<g;++s){const r=Math.max(0,Math.ceil((L-s)/p)),i=Math.min(h.outHeight,(h.inHeight+L-s)/p),o=s*x+n;for(let n=0;n<y;++n){const a=Math.max(0,Math.ceil((O-n)/f)),l=Math.min(h.outWidth,(h.inWidth+O-n)/f),u=n*_+o;for(let o=0;o<h.inChannels;++o){const c=o*k+u;for(let u=0;u<h.outChannels;++u){let m=0;for(let c=0;c<h.batchSize;++c){const h=c*$,g=c*I;for(let c=t;c<e;++c){const t=(M+c*d-D)*A+h,e=c*S+g;for(let c=r;c<i;++c){const r=(s+c*p-L)*R+t,i=c*E+e;for(let t=a;t<l;++t)m+=N[(n+t*f-O)*F+r+o]*C[t*T+i+u]}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},RM={kernelName:Dy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s;WO([r],"conv3dBackpropInputV2");const u=zg(r.shape),c=zg(i.shape),h=tk(l,i.shape,a,1,o),d=new Pw(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(r.dataId).values,[v,w,x,_]=u,k=n.data.get(i.dataId).values,[C,I,S,E]=c,{batchSize:T,filterDepth:N,filterHeight:$,filterWidth:A,inChannels:R,inDepth:F,inHeight:D,inWidth:O,outChannels:L,outDepth:M,outHeight:P,outWidth:z,strideDepth:B,strideHeight:V,strideWidth:W}=h,U=N-1-h.padInfo.front,j=$-1-h.padInfo.top,H=A-1-h.padInfo.left;for(let G=0;G<T;++G)for(let t=0;t<R;++t)for(let e=0;e<F;++e){const n=e-U,s=Math.max(0,Math.ceil(n/B)),r=Math.min(M,(N+n)/B);for(let i=0;i<D;++i){const o=i-j,a=Math.max(0,Math.ceil(o/V)),l=Math.min(P,($+o)/V);for(let u=0;u<O;++u){const c=u-H,h=Math.max(0,Math.ceil(c/W)),d=Math.min(z,(A+c)/W);let T=0;for(let e=s;e<r;++e){const s=e*B-n;for(let n=a;n<l;++n){const r=n*V-o;for(let i=h;i<d;++i){const o=v*G+w*e+x*n+_*i,a=C*(N-1-s)+I*($-1-r)+S*(A-1-(i*W-c))+E*t;for(let t=0;t<L;++t)T+=b[o+t]*k[a+t]}}}p[f*G+m*e+g*i+y*u+t]=T}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},FM=HO(Oy,t=>Math.cos(t)),DM={kernelName:Oy,backendName:"cpu",kernelFunc:FM},OM=HO(Ly,t=>Math.cosh(t)),LM={kernelName:Ly,backendName:"cpu",kernelFunc:OM},MM={kernelName:Py,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=s,[c,h,d,p]=r.shape,f=i.shape[0],[m,g]=a,y=e_([f,m,g,p],"float32"),b=n.data.get(i.dataId).values,v=n.data.get(o.dataId).values,w=n.data.get(r.dataId).values,x=zg(r.shape),_=zg(y.shape);for(let k=0;k<f;k++){const t=4*k,e=b[t],n=b[t+1],s=b[t+2],r=b[t+3],i=v[k];if(i>=c)continue;const o=m>1?(s-e)*(h-1)/(m-1):0,a=g>1?(r-n)*(d-1)/(g-1):0;for(let c=0;c<m;c++){const t=m>1?e*(h-1)+c*o:.5*(e+s)*(h-1);if(t<0||t>h-1)for(let e=0;e<g;e++)for(let t=0;t<p;t++)y.values[t+e*_[2]+c*_[1]+k*_[0]]=u;else if("bilinear"===l){const e=Math.floor(t),s=Math.ceil(t),o=t-e;for(let t=0;t<g;t++){const l=g>1?n*(d-1)+t*a:.5*(n+r)*(d-1);if(l<0||l>d-1){for(let e=0;e<p;e++)y.values[e+t*_[2]+c*_[1]+k*_[0]]=u;continue}const h=Math.floor(l),f=Math.ceil(l),m=l-h;for(let n=0;n<p;n++){let r=n+h*x[2]+e*x[1]+i*x[0];const a=w[r];r=n+f*x[2]+e*x[1]+i*x[0];const l=w[r];r=n+h*x[2]+s*x[1]+i*x[0];const u=w[r];r=n+f*x[2]+s*x[1]+i*x[0];const d=w[r],p=a+(l-a)*m;r=n+t*_[2]+c*_[1]+k*_[0],y.values[r]=p+(u+(d-u)*m-p)*o}}}else for(let e=0;e<g;++e){const s=g>1?n*(d-1)+e*a:.5*(n+r)*(d-1);if(s<0||s>d-1){for(let t=0;t<p;t++)y.values[t+e*_[2]+c*_[1]+k*_[0]]=u;continue}const o=Math.round(s),l=Math.round(t);for(let t=0;t<p;t++)y.values[t+e*_[2]+c*_[1]+k*_[0]]=w[t+o*x[2]+l*x[1]+i*x[0]]}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},PM={kernelName:My,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;WO(r,"cumsum");const l=cC([i],r.shape.length);let u=r;null!=l&&(u=LL({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=dC(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Yw(u.dtype,"int32"),d=Ug(wg(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=a?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let y=0;y<p.length;y+=f)for(let t=0;t<f;t++){const e=m(y,t);if(0===t)d[e]=o?0:p[e];else{const n=m(y,t-1);d[e]=o?p[n]+d[n]:p[e]+d[n]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const t=LL({inputs:{x:g},backend:n,attrs:{perm:hC(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}},zM={kernelName:zy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(1===r.shape.length){const t=hM(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,t)}if(2===r.shape.length){const t=dM(n.bufferSync(r),n.bufferSync(i),o,a);return n.makeTensorInfo(t.shape,i.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},BM={kernelName:By,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:i,dataFormat:o}=s;gg("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`),gg(i>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${i}`);const a=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*i,d=u*i,p=c/(i*i),f=n.data.get(r.dataId).values,m=new Float32Array(a*h*d*p);let g=0;for(let y=0;y<a;++y)for(let t=0;t<h;++t){const e=Math.floor(t/i),n=t%i;for(let t=0;t<d;++t){const s=Math.floor(t/i),r=(n*i+t%i)*p;for(let t=0;t<p;++t)m[g++]=f[t+r+c*(s+u*(e+l*y))]}}return n.makeTensorInfo([a,h,d,p],r.dtype,m)}};function VM(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=s;WO([r,i],"depthwiseConv2DNative");const c=zg(r.shape),h=zg(i.shape);let d=l;null==d&&(d=[1,1]),gg(ak(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=J_(r.shape,i.shape,o,d,a,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,w=b.top,x=p.outChannels/p.inChannels,_=new Pw(p.outShape,r.dtype),k=n.data.get(r.dataId).values,C=n.data.get(i.dataId).values,I=_.values;for(let S=0;S<p.batchSize;++S){const t=S*c[0],e=S*_.strides[0];for(let n=0;n<p.outHeight;++n){const s=e+n*_.strides[1],r=n*p.strideHeight-w;for(let e=0;e<f;++e){const n=r+e*g;if(n<0||n>=p.inHeight)continue;const i=e*h[0],o=t+n*c[1];for(let t=0;t<p.outWidth;++t){const e=s+t*_.strides[2],n=t*p.strideWidth-v;for(let t=0;t<m;++t){const s=n+t*y;if(s<0||s>=p.inWidth)continue;const r=o+s*p.inChannels;let a=e,l=i+t*h[1];for(let t=0;t<p.inChannels;++t){const e=k[r+t];for(let t=0;t<x;++t)I[a+t]+=e*C[l+t];a+=x,l+=x}}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}const WM={kernelName:Vy,backendName:"cpu",kernelFunc:VM},UM={kernelName:Wy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s;WO([r,i],"depthwiseConv2dNativeBackpropFilter");const h=J_(r.shape,c,o,a,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new Pw(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(r.dataId).values,x=new Pw(r.shape,r.dtype,w),_=n.data.get(i.dataId).values,k=new Pw(i.shape,i.dtype,_);for(let C=0;C<f;++C){const t=Math.max(0,Math.ceil((b-C)/d)),e=Math.min(h.outHeight,(h.inHeight+b-C)/d);for(let n=0;n<m;++n){const s=Math.max(0,Math.ceil((y-n)/p)),r=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let i=0;i<h.outChannels;++i){const o=Math.trunc(i/v),a=i%v;let l=0;for(let u=0;u<h.batchSize;++u)for(let a=t;a<e;++a){const t=C+a*d-b;for(let e=s;e<r;++e)l+=x.get(u,t,n+e*p-y,o)*k.get(u,a,e,i)}g.set(l,C,n,o,a)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},jM={kernelName:Uy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s;WO([r,i],"depthwiseConv2DNativeBackpropInput");const h=zg(r.shape),d=zg(i.shape),p=J_(c,i.shape,o,a,l,u,!0),f=new Pw(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(r.dataId).values,[w,x,_]=h,k=n.data.get(i.dataId).values,[C,I,S]=d,{batchSize:E,filterHeight:T,filterWidth:N,inChannels:$,inHeight:A,inWidth:R,outChannels:F,outHeight:D,outWidth:O,strideHeight:L,strideWidth:M}=p,P=T-1-p.padInfo.top,z=N-1-p.padInfo.left,B=F/$;for(let V=0;V<E;++V)for(let t=0;t<$;++t)for(let e=0;e<A;++e){const n=e-P,s=Math.max(0,Math.ceil(n/L)),r=Math.min(D,(T+n)/L);for(let i=0;i<R;++i){const o=i-z,a=Math.max(0,Math.ceil(o/M)),l=Math.min(O,(N+o)/M);let u=0;for(let e=s;e<r;++e){const s=e*L-n;for(let n=a;n<l;++n){const r=w*V+x*e+_*n,i=C*(T-1-s)+I*(N-1-(n*M-o))+S*t;for(let e=0;e<B;++e)u+=v[r+(t*B+e)]*k[i+e]}}m[g*V+y*e+b*i+t]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},HM={kernelName:jy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,r=wg(s.shape),i=n.data.get(s.dataId).values,o=e_([r,r],s.dtype),a=o.values;for(let u=0;u<i.length;u++)a[u*r+u]=i[u];const l=[...s.shape,...s.shape];return n.makeTensorInfo(l,o.dtype,o.values)}},GM={kernelName:Hy,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r}=t,{strides:i,pad:o,dilations:a}=n,l=e,u=l.data.get(s.dataId).values,c=s.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:_,filterWidth:k,dilationHeight:C,dilationWidth:I,outShape:S}=Z_(s.shape,r.shape,i,o,"NHWC",a),E=wg(S),T=S.length,N=$g(s.dtype,E);for(let $=0;$<p;++$)for(let t=0;t<y;++t){const e=t*w-v.top;for(let n=0;n<b;++n){const i=n*x-v.left;for(let o=0;o<g;++o){let a=Number.MIN_SAFE_INTEGER;for(let t=0;t<_;++t){const n=e+t*C;if(n>=0&&n<f)for(let e=0;e<k;++e){const l=i+e*I;if(l>=0&&l<m){const i=Gg([$,n,l,o],c,zg(s.shape)),p=Gg([t,e,o],d,zg(r.shape)),f=u[i]+h[p];f>a&&(a=f)}}}N[Gg([$,t,n,o],T,zg(S))]=a}}}return{dataId:l.write(Sw(N,s.dtype),S,s.dtype),shape:S,dtype:s.dtype}}},qM={kernelName:qy,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:i}=t,{strides:o,pad:a,dilations:l}=n,u=e,c=Vg(s.shape,u.data.get(s.dataId).values),h=Vg(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:w,filterHeight:x,filterWidth:_,dilationHeight:k,dilationWidth:C,outShape:I}=Z_(s.shape,r.shape,o,a,"NHWC",l);gg(i.rank===I.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${I.length}, but got ${i.rank}`);const S=Vg(I,u.data.get(i.dataId).values),E=jg(r.shape,r.dtype);for(let T=0;T<d;++T)for(let t=0;t<g;++t){const e=t*v-b.top;for(let n=0;n<y;++n){const s=n*w-b.left;for(let r=0;r<m;++r){let i=Number.MIN_SAFE_INTEGER,o=0,a=0;for(let t=0;t<x;++t){const n=e+t*k;if(n>=0&&n<p)for(let e=0;e<_;++e){const l=s+e*C;if(l>=0&&l<f){const s=c[T][n][l][r]+h[t][e][r];s>i&&(i=s,o=t,a=e)}}}E[o][a][r]+=S[T][t][n][r]}}}return{dataId:u.write(Sw(E,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},KM={kernelName:Gy,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:i}=t,{strides:o,pad:a,dilations:l}=n,u=e,c=Vg(s.shape,u.data.get(s.dataId).values),h=Vg(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:w,filterHeight:x,filterWidth:_,dilationHeight:k,dilationWidth:C,outShape:I}=Z_(s.shape,r.shape,o,a,"NHWC",l);gg(i.rank===I.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${I.length}, but got ${i.rank}`);const S=Vg(I,u.data.get(i.dataId).values),E=jg(s.shape,s.dtype);for(let T=0;T<d;++T)for(let t=0;t<g;++t){const e=t*v-b.top;for(let n=0;n<y;++n){const s=n*w-b.left;for(let r=0;r<m;++r){let i=Number.MIN_SAFE_INTEGER,o=e<0?0:e,a=s<0?0:s;for(let t=0;t<x;++t){const n=e+t*k;if(n>=0&&n<p)for(let e=0;e<_;++e){const l=s+e*C;if(l>=0&&l<f){const s=c[T][n][l][r]+h[t][e][r];s>i&&(i=s,o=n,a=l)}}}E[T][o][a][r]+=S[T][t][n][r]}}}return{dataId:u.write(Sw(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},XM=JO((t,e)=>t*e),ZM=bL((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),YM=yL(Ub,XM,ZM),QM={kernelName:Ub,backendName:"cpu",kernelFunc:YM};function JM(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;let a;WO(r,"sum"),a="bool"===r.dtype?mL({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):XO({inputs:{x:r},backend:n});const l=a.shape.length,u=Eg(i,a.shape),c=cC(u,l);let h=u,d=a;null!=c&&(d=LL({inputs:{x:a},backend:n,attrs:{perm:c}}),h=dC(h.length,l)),uC("sum",h,d.shape.length);const[p,f]=aC(d.shape,h);let m=dL(n,p,Yw(d.dtype,"int32"));const g=wg(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let v=0;v<y.length;++v){const t=v*g;let e=0;for(let n=0;n<g;++n)e+=b[t+n];y[v]=e}if(o){const t=m;m=kL({inputs:{x:m},backend:n,attrs:{shape:lC(m.shape,u)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(a),null!=c&&n.disposeIntermediateTensorInfo(d),m}const tP={kernelName:Iv,backendName:"cpu",kernelFunc:JM},eP={kernelName:Xy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=VS(r,i.length);US(o.length,l,i);const{path:u,steps:c}=jS(a,l),h=c.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const t of c[m]){const{permutationIndices:e,expandDims:s}=WS(p,l[t]);let r;HS(e)?r=i[t]:(r=LL({inputs:{x:i[t]},backend:n,attrs:{perm:e}}),f.push(r));const o=r.shape.slice();for(let t=0;t<s.length;++t)o.splice(s[t],0,1);xg(r.shape,o)||(r=kL({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=YM({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=JM({inputs:{x:d},backend:n,attrs:{axis:u[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},nP={kernelName:Yy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:s,y:r}=e;WO([s,r],"eluGrad");const i=new Float32Array(wg(r.shape)),o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const t=o[l];i[l]=t>=1?a[l]:a[l]*(t+1)}return n.makeTensorInfo(r.shape,"float32",i)}},sP=JO((t,e)=>t===e?1:0),rP=yL(Jy,sP,null,"bool"),iP={kernelName:Jy,backendName:"cpu",kernelFunc:rP},oP=CS,aP=IS,lP=SS,uP=ES,cP=TS,hP=NS,dP=HO(Qy,t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+oP*n);return e*(1-((((hP*s+cP)*s+uP)*s+lP)*s+aP)*s*Math.exp(-n*n))}),pP={kernelName:Qy,backendName:"cpu",kernelFunc:dP},fP=fM(t=>Math.exp(t)),mP=GO(tb,fP),gP={kernelName:tb,backendName:"cpu",kernelFunc:mP};function yP(t){const{inputs:e,backend:n,attrs:s}=t,{input:r}=e,{dim:i}=s,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(gg(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),kL({inputs:{x:r},backend:n,attrs:{shape:a}})}const bP={kernelName:eb,backendName:"cpu",kernelFunc:yP},vP=fM(t=>Math.expm1(t)),wP=GO(nb,vP),xP={kernelName:nb,backendName:"cpu",kernelFunc:wP},_P=JO((t,e)=>t/e),kP=yL(Ky,_P),CP={kernelName:Ky,backendName:"cpu",kernelFunc:kP},IP=JO((t,e)=>t-e),SP=bL((t,e,n,s)=>({real:t-n,imag:e-s})),EP=yL(Bv,IP,SP),TP={kernelName:Bv,backendName:"cpu",kernelFunc:EP};function NP(t,e,n){const s=t.shape,r=s[0],i=s[1],o=n.data.get(t.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[r,i],c=wg(u),h=Ng("float32",c),d=Ng("float32",c);for(let g=0;g<r;g++){const t=lM({inputs:{x:a},backend:n,attrs:{begin:[g,0],size:[1,i]}}),s=lM({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,i]}}),r=cL({inputs:{real:t,imag:s},backend:n}),{real:o,imag:u}=$P(r,e,n),c=RS(o,u);for(let e=0;e<i;e++){const t=LS(c,e);h[g*i+e]=t.real,d[g*i+e]=t.imag}n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=cL({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function $P(t,e,n){const s=wg(t.shape),r=n.data.get(t.dataId),i=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0==((a=s)&a-1)){const r=AP(i,o,s,e,n),a=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(a,"float32",r.real),e=n.makeTensorInfo(a,"float32",r.imag),i=n.makeTensorInfo([],"float32",Iw(s,"float32")),o=XO({inputs:{x:i},backend:n}),l=CP.kernelFunc({inputs:{a:t,b:i},backend:n}),u=CP.kernelFunc({inputs:{a:e,b:o},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return r}return FS(function(t,e,n){const s=new Float32Array(2*e);for(let r=0;r<e;r++){let i=0,o=0;for(let s=0;s<e;s++){const a=zS(r*s,e,n),l=LS(t,s);i+=l.real*a.real-l.imag*a.imag,o+=l.real*a.imag+l.imag*a.real}n&&(i/=e,o/=e),MS(s,i,o,r)}return s}(RS(i,o),s,e));var a}function AP(t,e,n,s,r){if(1===n)return{real:t,imag:e};const i=RS(t,e),o=n/2,a=DS(i),l=a.real,u=a.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),d=r.makeTensorInfo(c,"float32",u),p=cL({inputs:{real:h,imag:d},backend:r}),f=OS(i),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),v=r.makeTensorInfo(y,"float32",g),w=cL({inputs:{real:b,imag:v},backend:r}),x=AP(l,u,o,s,r),_=x.real,k=x.imag,C=[_.length],I=r.makeTensorInfo(C,"float32",_),S=r.makeTensorInfo(C,"float32",k),E=cL({inputs:{real:I,imag:S},backend:r}),T=AP(m,g,o,s,r),N=T.real,$=T.imag,A=[N.length],R=r.makeTensorInfo(A,"float32",N),F=r.makeTensorInfo(A,"float32",$),D=cL({inputs:{real:R,imag:F},backend:r}),O=PS(n,s),L=[O.real.length],M=r.makeTensorInfo(L,"float32",O.real),P=r.makeTensorInfo(L,"float32",O.imag),z=cL({inputs:{real:M,imag:P},backend:r}),B=YM({inputs:{a:z,b:D},backend:r}),V=xL({inputs:{a:E,b:B},backend:r}),W=EP({inputs:{a:E,b:B},backend:r}),U=pL({inputs:{input:V},backend:r}),j=pL({inputs:{input:W},backend:r}),H=_M({inputs:{input:V},backend:r}),G=_M({inputs:{input:W},backend:r}),q=CM({inputs:[U,j],backend:r,attrs:{axis:0}}),K=CM({inputs:[H,G],backend:r,attrs:{axis:0}}),X=r.data.get(q.dataId).values,Z=r.data.get(K.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(K),{real:X,imag:Z}}const RP={kernelName:sb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e,r=wg(s.shape),i=s.shape[s.shape.length-1],o=kL({inputs:{x:s},backend:n,attrs:{shape:[r/i,i]}}),a=NP(o,!1,n),l=kL({inputs:{x:a},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}};function FP(t){const{backend:e,attrs:n}=t,{shape:s,value:r,dtype:i}=n,o=i||Lg(r),a=$g(o,wg(s));return function(t,e,n){t.fill(e)}(a,r),e.makeTensorInfo(s,o,a)}const DP={kernelName:rb,backendName:"cpu",kernelFunc:FP},OP={kernelName:ib,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=Ng(n.dtype,wg(n.shape)),[i,o,a,l]=n.shape,u=s.data.get(n.dataId).values;for(let c=0;c<i;c++){const t=c*a*o*l;for(let e=0;e<o;e++){const n=e*(a*l);for(let s=0;s<a;s++){const o=s*l;for(let c=0;c<l;c++){const h=Math.round(a-[i,e,s,c][2]),d=t+n+o+c;let p=u[d];h>=0&&h<a&&(p=u[t+n+h*l+c]),r[d]=p}}}}return{dataId:s.write(r,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},LP=fM(t=>Math.floor(t)),MP=GO(ob,LP),PP={kernelName:ob,backendName:"cpu",kernelFunc:MP},zP=JO((t,e)=>Math.floor(t/e)),BP=yL(ab,zP,null,"int32"),VP={kernelName:ab,backendName:"cpu",kernelFunc:BP},WP={kernelName:ew,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=SM({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(o){const t=m;m=xL({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=uL(n,m,p,a,f),n.disposeIntermediateTensorInfo(t)}return m}},UP={kernelName:nw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=VM({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(o){const t=m;m=xL({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=uL(n,m,p,a,f),n.disposeIntermediateTensorInfo(t)}return m}};function jP(t,e,n,s,r,i,o,a,l){const u=e_([s,i],n);for(let c=0;c<s;c++){const n=[];let s=0;for(let e=0;e<r;e++){const i=t[c*r+e];s+=i*o[e],n.push(i)}if(s<0||s>=l/i)throw new Error(`Invalid indices: ${n} does not index into ${a}`);for(let t=0;t<i;t++)u.values[c*i+t]=e.get(...e.indexToLoc(s*i+t))}return u}const HP={kernelName:cb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,i=wg(s.shape),o=r.shape,a=o[o.length-1],[l,u,c,h]=bS(s,r);if(0===u)return n.makeTensorInfo(l,s.dtype,[]);const d=jP(n.data.get(r.dataId).values,n.bufferSync(s),s.dtype,u,a,c,h,s.shape,i);return n.makeTensorInfo(l,s.dtype,d.values)}};function GP(t,e,n){const s=e_(n,t.dtype);for(let r=0;r<s.size;++r){const n=s.indexToLoc(r).slice(),i=e.locToIndex([n[0],n[2]]);n[2]=e.values[i];const o=t.locToIndex(n);s.values[r]=t.values[o]}return s}const qP={kernelName:ub,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:i}=e,{axis:o,batchDims:a}=s;WO([r,i],"gatherV2");let l=a;null==a&&(l=0);const u=wg(i.shape),c=ZS(r,i,Eg(o,r.shape)[0],l),h=kL({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=kL({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}}),p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize],f=n.bufferSync(d),m=GP(n.bufferSync(h),f,p);return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.makeTensorInfo(c.outputShape,m.dtype,m.values)}},KP=JO((t,e)=>t>e?1:0),XP=yL(hb,KP,null,"bool"),ZP={kernelName:hb,backendName:"cpu",kernelFunc:XP},YP=JO((t,e)=>t>=e?1:0),QP=yL(db,YP,null,"bool"),JP={kernelName:db,backendName:"cpu",kernelFunc:QP},tz={kernelName:fb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e,r=wg(s.shape),i=s.shape[s.shape.length-1],o=kL({inputs:{x:s},backend:n,attrs:{shape:[r/i,i]}}),a=NP(o,!0,n),l=kL({inputs:{x:a},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}},ez=HO(gb,t=>Number.isFinite(t)?1:0,"bool"),nz={kernelName:gb,backendName:"cpu",kernelFunc:ez},sz=HO(yb,t=>Math.abs(t)===1/0?1:0,"bool"),rz={kernelName:yb,backendName:"cpu",kernelFunc:sz},iz=HO(bb,t=>Number.isNaN(t)?1:0,"bool"),oz={kernelName:bb,backendName:"cpu",kernelFunc:iz},az=JO((t,e)=>t<e?1:0),lz=yL(wb,az,null,"bool"),uz={kernelName:wb,backendName:"cpu",kernelFunc:lz},cz=JO((t,e)=>t<=e?1:0),hz=yL(xb,cz,null,"bool"),dz={kernelName:xb,backendName:"cpu",kernelFunc:hz};function pz(t,e,n){const s=(e-t)/(n-1),r=Ug(n,"float32");r[0]=t;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const fz={kernelName:_b,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,o=pz(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}},mz=fM(t=>Math.log(t)),gz=GO(kb,mz),yz={kernelName:kb,backendName:"cpu",kernelFunc:gz},bz=HO(Cb,t=>Math.log1p(t)),vz={kernelName:Cb,backendName:"cpu",kernelFunc:bz},wz=JO((t,e)=>t&&e),xz=yL(Ib,wz,null,"bool"),_z={kernelName:Ib,backendName:"cpu",kernelFunc:xz},kz=HO(Sb,t=>t?0:1,"bool"),Cz={kernelName:Sb,backendName:"cpu",kernelFunc:kz},Iz=JO((t,e)=>t||e),Sz=yL(Eb,Iz,null,"bool"),Ez={kernelName:Eb,backendName:"cpu",kernelFunc:Sz},Tz={kernelName:Tb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s;WO(r,"LRN");const u=r.shape[3],c=u-1,h=n.data.get(r.dataId).values,d=wg(r.shape),p=new Float32Array(d);function f(t){const e=t%u;let n=t-e+Math.max(0,e-i);const s=t-e+Math.min(e+i,c);let r=0;for(;n<=s;n++){const t=h[n];r+=t*t}return r}for(let m=0;m<d;m++){const t=f(m),e=h[m]*Math.pow(o+a*t,-l);p[m]=e}return n.makeTensorInfo(r.shape,r.dtype,p)}},Nz={kernelName:Nb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s;WO(o,"LRNGrad");const h=wg(o.shape),d=o.shape[3],p=n.data.get(o.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(i.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const t=b%d,e=b-t+Math.max(0,t-a),n=b-t+Math.min(d,t+a+1);let s=0;for(let r=e;r<n;r++)s+=Math.pow(f[r],2);s=u*s+l;for(let r=e;r<n;r++){let t=-2*u*c*f[r]*m[b]/s;b===r&&(t+=Math.pow(s,-c)),t*=p[b],g[r]+=t}}return n.makeTensorInfo(o.shape,r.dtype,g)}};function $z(t,e,n,s){const r=Ng(s,wg(n));for(let i=0;i<r.length;++i){const n=i*e;let s=t[n];for(let r=0;r<e;++r){const e=t[n+r];(Number.isNaN(e)||e>s)&&(s=e)}r[i]=s}return r}function Az(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=n;let l=r.shape;const u=l.length,c=Eg(i,l);let h=c;const d=cC(h,u);let p=a.data.get(r.dataId).values;if(null!=d){const t=new Array(u);for(let e=0;e<t.length;e++)t[e]=l[d[e]];p=OL(p,l,r.dtype,d,t),h=dC(h.length,u),l=t}WO(r,"max"),uC("max",h,u);const[f,m]=aC(l,h),g=$z(p,wg(m),f,r.dtype),y=a.write(g,f,r.dtype);let b=f;return o&&(b=lC(f,c)),{dataId:y,shape:b,dtype:r.dtype}}const Rz={kernelName:$b,backendName:"cpu",kernelFunc:Az},Fz=JO((t,e)=>Math.max(t,e)),Dz=yL(Ab,Fz),Oz={kernelName:Ab,backendName:"cpu",kernelFunc:Dz},Lz={kernelName:Rb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;WO(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s;gg(ak(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Y_(r.shape,i,o,1,a,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&xg(u.inShape,u.outShape))c=XO({inputs:{x:r},backend:n});else{const t=n.data.get(r.dataId).values,e=zg(r.shape),s=JL(t,0,r.dtype,e,u,"max");c=n.makeTensorInfo(u.outShape,r.dtype,s.values)}return c}},Mz={kernelName:Db,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s;WO(r,"maxPool3d");const c=Q_(r.shape,i,o,1,a,l,u),h=eM(n.data.get(r.dataId).values,0,r.dtype,zg(r.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},Pz={kernelName:Ob,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s;WO([r,i],"maxPool3DGrad");const c=Q_(i.shape,o,a,1,l,u),h=function(t,e){const n=e_(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*s-d;let v=b;for(;v<0;)v+=o;const w=Math.min(e.inDepth,u+b);for(let s=0;s<e.outHeight;++s){const u=s*r-p;let d=u;for(;d<0;)d+=a;const x=Math.min(e.inHeight,c+u);for(let r=0;r<e.outWidth;++r){const p=r*i-f;let _=p;for(;_<0;)_+=l;const k=Math.min(e.inWidth,h+p);let C=Number.NEGATIVE_INFINITY,I=-1;for(let e=v;e<w;e+=o){const n=e-b;for(let s=d;s<x;s+=a){const r=s-u;for(let i=_;i<k;i+=l){const o=i-p,a=t.get(m,e,s,i,g);a>=C&&(C=a,I=n*c*h+r*c+o)}}}n.set(I,m,y,s,r,g)}}}return n}(n.bufferSync(i),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,x=b-1-c.padInfo.front,_=w-1-c.padInfo.left,k=v-1-c.padInfo.top,C=e_(i.shape,"float32"),I=n.bufferSync(r);for(let S=0;S<c.batchSize;++S)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inDepth;++e)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=e-x,i=n-k,o=s-_;let a=0;for(let e=0;e<b;e+=m){const n=(r+e)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let s=0;s<v;s+=g){const r=(i+s)/p;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let i=0;i<w;i+=y){const l=(o+i)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*v*w-1-h.get(S,n,r,l,t)===e*v*w+s*w+i?1:0;0!==u&&(a+=I.get(S,n,r,l,t)*u)}}}C.set(a,S,e,n,s,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},zz={kernelName:Fb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:o}=e,a=i;WO([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=Y_(a.shape,l,u,1,c,h),p=n.data.get(a.dataId).values,f=e_(d.outShape,a.dtype,tM(p,a.shape,a.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,x=w-1-d.padInfo.left,_=v-1-d.padInfo.top,k=e_(a.shape,"float32"),C=n.data.get(r.dataId).values,I=e_(r.shape,"float32",C);for(let S=0;S<d.batchSize;++S)for(let t=0;t<d.inChannels;++t)for(let e=0;e<d.inHeight;++e)for(let n=0;n<d.inWidth;++n){const s=e-_,r=n-x;let i=0;for(let e=0;e<v;e+=y){const n=(s+e)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let s=0;s<w;s+=b){const o=(r+s)/g;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const a=v*w-1-f.get(S,n,o,t)===e*w+s?1:0;0!==a&&(i+=I.get(S,n,o,t)*a)}}k.set(i,S,e,n,t)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},Bz={kernelName:Lb,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=n;WO(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=Y_(s.shape,r,i,[1,1],o),[h,d]=function(t,e,n,s,r){const i=JL(t,0,n,zg(e),r,"max"),o=tM(t,e,n,r,!0,s);return[i.values,o.values]}(u,s.shape,s.dtype,a,c),p=l.write(h,c.outShape,s.dtype),f=l.write(d,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},Vz={kernelName:Mb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=Eg(i,r.shape),l=wg(aC(r.shape,a)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=mL({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=kP({inputs:{a:h,b:c},backend:n});u.push(d);const p=JM({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:o}});return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),p}},Wz={kernelName:Pb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;WO(r,"min");const a=Eg(i,r.shape);let l=a;const u=cC(l,r.shape.length);let c=r;null!=u&&(c=LL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=dC(l.length,r.shape.length)),uC("min",l,c.shape.length);const[h,d]=aC(c.shape,l),p=wg(d),f=Ug(wg(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const t=y*p;let e=m[t];for(let n=0;n<p;++n){const s=m[t+n];(Number.isNaN(s)||s<e)&&(e=s)}f[y]=e}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(o){const t=kL({inputs:{x:g},backend:n,attrs:{shape:lC(h,a)}});return n.disposeIntermediateTensorInfo(g),t}return g}},Uz=JO((t,e)=>Math.min(t,e)),jz=yL(zb,Uz),Hz={kernelName:zb,backendName:"cpu",kernelFunc:jz},Gz={kernelName:Bb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,mode:o}=s;WO(r,"mirrorPad");const a=i.map((t,e)=>t[0]+r.shape[e]+t[1]),l=i.map(t=>t[0]),u=i.map((t,e)=>t[0]+r.shape[e]),c="reflect"===o?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,p=zg(r.shape),f=wg(a),m=a.length,g=zg(a),y=Ng(r.dtype,f);for(let b=0;b<f;b++){let t=qg(b,m,g);for(let n=0;n<m;n++)t[n]<l[n]?t[n]=2*l[n]-t[n]-c:t[n]>=u[n]&&(t[n]=2*(u[n]-1)-t[n]+c);t=t.map((t,e)=>t-l[e]);const e=Gg(t,d,p);y[b]=h[e]}return{dataId:n.write(y,a,r.dtype),shape:a,dtype:r.dtype}}},qz=JO((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),Kz=yL(Vb,qz),Xz={kernelName:Vb,backendName:"cpu",kernelFunc:Kz};function Zz(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:i}=s,o=r.shape.length;let a=i;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=Eg([a],r.shape),u=Az({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=lC(u.shape,l),h=kL({inputs:{x:u},backend:n,attrs:{shape:c}}),d=EP({inputs:{a:r,b:h},backend:n}),p=mP({inputs:{x:d},backend:n}),f=JM({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=kL({inputs:{x:f},backend:n,attrs:{shape:c}}),g=kP({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const Yz={kernelName:Tv,backendName:"cpu",kernelFunc:Zz},Qz={kernelName:Wb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s;WO(r,"multinomial");const l=a?r:Zz({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,i],p=Ug(wg(d),"int32");for(let f=0;f<u;++f){const t=f*c,e=new Float32Array(c-1);e[0]=h[t];for(let r=1;r<e.length;++r)e[r]=e[r-1]+h[t+r];const n=kC.alea(o.toString()),s=f*i;for(let r=0;r<i;++r){const t=n();p[s+r]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){p[s+r]=n;break}}}return a||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function Jz(t,e,n){const s=Iw(-1,n);return XM([],e,s,t,n)}const tB={kernelName:jb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;WO(s,"neg");const r=n.data.get(s.dataId).values,[i,o]=Jz(r,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,i)}},eB=CI,nB={kernelName:Gb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;WO(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=eB(u,c,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},sB=II,rB={kernelName:qb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s;WO(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=sB(c,h,o,a,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},iB=SI,oB={kernelName:Kb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s;WO(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=o,p=a,f=l,m=u,{selectedIndices:g,selectedScores:y}=iB(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},aB=JO((t,e)=>t!==e?1:0),lB=yL(Hb,aB,null,"bool"),uB={kernelName:Hb,backendName:"cpu",kernelFunc:lB},cB={kernelName:Zb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{depth:i,onValue:o,offValue:a}=s;WO(r,"oneHot");const l=wg(r.shape),u=new Float32Array(l*i);u.fill(a);const c=n.data.get(r.dataId).values;for(let h=0;h<l;++h)c[h]>=0&&c[h]<i&&(u[h*i+c[h]]=o);return n.makeTensorInfo([...r.shape,i],"int32",u)}};function hB(t){const{inputs:e,backend:n}=t,{x:s}=e;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const t=pL({inputs:{input:s},backend:n}),e=hB({inputs:{x:t},backend:n}),r=_M({inputs:{input:s},backend:n}),i=hB({inputs:{x:r},backend:n}),o=cL({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),o}return FP({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const dB={kernelName:Zv,backendName:"cpu",kernelFunc:hB},pB={kernelName:Xb,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:s}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const e=pL({inputs:{input:r},backend:s}),n=t({inputs:{x:e},backend:s}),i=_M({inputs:{input:r},backend:s}),o=hB({inputs:{x:i},backend:s}),a=cL({inputs:{real:n,imag:o},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(o),a}return FP({backend:s,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function fB(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(1===e.length)return yP({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(t=>{yg(i,t.shape,"All tensors passed to stack must have matching shapes"),gg(o===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=CM({inputs:e.map(t=>{const e=yP({inputs:{input:t},backend:n,attrs:{dim:r}});return a.push(e),e}),backend:n,attrs:{axis:r}});return a.forEach(t=>n.disposeIntermediateTensorInfo(t)),l}const mB={kernelName:Yb,backendName:"cpu",kernelFunc:fB},gB={kernelName:Qb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:o}=s;WO(r,"pad");const a=i.map((t,e)=>t[0]+r.shape[e]+t[1]),l=i.map(t=>t[0]),u=n.data.get(r.dataId).values,c=wg(r.shape),h=r.shape.length,d=zg(r.shape),p=wg(a),f=a.length,m=zg(a),g=Ng(r.dtype,p);0!==o&&g.fill(o);for(let y=0;y<c;y++)g[Gg(qg(y,h,d).map((t,e)=>t+l[e]),f,m)]=u[y];return{dataId:n.write(g,a,r.dtype),shape:a,dtype:r.dtype}}},yB=JO((t,e)=>Math.pow(t,e)),bB=yL(Jb,yB),vB={kernelName:Jb,backendName:"cpu",kernelFunc:bB};function wB(t,e,n,s){const[r,i]=aC(t,s),o=Yw(e,"int32"),a=Ug(wg(r),o),l=wg(i);for(let u=0;u<a.length;++u){const t=u*l;let e=1;for(let s=0;s<l;++s)e*=n[t+s];a[u]=e}return{outVals:a,outShape:r,outDtype:o}}const xB={kernelName:ev,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;WO(r,"prod");const a=r.shape.length,l=Eg(i,r.shape),u=cC(l,a);let c=l,h=r;const d=[];null!=u&&(h=LL({inputs:{x:r},backend:n,attrs:{perm:u}}),d.push(h),c=dC(c.length,a));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=wB(h.shape,h.dtype,p,c);let y=m;return o&&(y=lC(m,l)),d.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(y,g,f)}};function _B(t,e,n,s){if(t===e||t<e&&n<0||e<t&&n>1)return Ug(0,s);const r=Ug(Math.abs(Math.ceil((e-t)/n)),s);e<t&&1===n&&(n=-1),r[0]=t;for(let i=1;i<r.length;i++)r[i]=r[i-1]+n;return r}const kB={kernelName:nv,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:i,step:o}=n,a=_B(s,r,o,i);return e.makeTensorInfo([a.length],i,a)}},CB=HO(rv,t=>1/t),IB={kernelName:rv,backendName:"cpu",kernelFunc:CB},SB={kernelName:uv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;WO(r,"resizeBilinear");const l=zg(r.shape),[u,c]=a,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(wg([h,u,c,f])),y=[i&&u>1?d-1:d,i&&c>1?p-1:p],b=[i&&u>1?u-1:u,i&&c>1?c-1:c];let v=0;const w=y[0]/b[0],x=y[1]/b[1];for(let _=0;_<h;_++)for(let t=0;t<u;t++){let e;e=o?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),s=e-n,r=Math.min(d-1,Math.ceil(e)),i=_*l[0]+n*l[1],a=_*l[0]+r*l[1];for(let t=0;t<c;t++){let e;e=o?x*(t+.5)-.5:x*t;const n=Math.max(0,Math.floor(e)),r=e-n,u=Math.min(p-1,Math.ceil(e)),c=i+n*l[2],h=a+n*l[2],d=i+u*l[2],y=a+u*l[2];for(let t=0;t<f;t++){const e=m[c+t],n=m[h+t],i=e+(m[d+t]-e)*r;g[v++]=i+(n+(m[y+t]-n)*r-i)*s}}}return n.makeTensorInfo([h,u,c,f],"float32",g)}},EB={kernelName:cv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s;WO([i,r],"resizeBilinearGrad");const a=zg(r.shape),[l,u,c,h]=r.shape,[,d,p]=i.shape,f=new Float32Array(l*u*c*h),m=[o&&d>1?u-1:u,o&&p>1?c-1:c],g=[o&&d>1?d-1:d,o&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(i.dataId).values;let w=0;for(let x=0;x<l;x++){const t=x*a[0];for(let e=0;e<d;e++){const n=e*y,s=Math.floor(n),r=Math.min(Math.ceil(n),u-1),i=t+s*a[1],o=t+r*a[1],l=n-s,d=1-l;for(let t=0;t<p;t++){const e=t*b,n=Math.floor(e),s=Math.min(Math.ceil(e),c-1),r=e-n,u=1-r,p=i+n*a[2],m=i+s*a[2],g=o+n*a[2],y=o+s*a[2],x=d*u,_=d*r,k=l*u,C=l*r;for(let t=0;t<h;t++){const e=v[w++];f[p+t]+=e*x,f[m+t]+=e*_,f[g+t]+=e*k,f[y+t]+=e*C}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}},TB={kernelName:av,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;WO(r,"resizeNearestNeighbor");const l=zg(r.shape),[u,c]=a,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(h*u*c*f),y=[i&&u>1?d-1:d,i&&c>1?p-1:p],b=[i&&u>1?u-1:u,i&&c>1?c-1:c],v=y[0]/b[0],w=y[1]/b[1];let x=0;for(let _=0;_<h;_++){const t=_*l[0];for(let e=0;e<u;e++){const n=o?v*(e+.5):v*e;let s=Math.min(d-1,i?Math.round(n):Math.floor(n));o&&(s=Math.max(0,s));const r=t+s*l[1];for(let t=0;t<c;t++){const e=o?w*(t+.5):w*t;let n=Math.min(p-1,i?Math.round(e):Math.floor(e));o&&(n=Math.max(0,n));const s=r+n*l[2];for(let t=0;t<f;t++)g[x++]=m[s+t]}}}return n.makeTensorInfo([h,u,c,f],r.dtype,g)}},NB={kernelName:lv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s;WO([i,r],"resizeNearestNeighborGrad");const a=zg(r.shape),l=zg(i.shape),[u,c,h,d]=r.shape,[,p,f]=i.shape,m=new Float32Array(u*c*h*d),g=n.data.get(i.dataId).values,y=[o&&p>1?c-1:c,o&&f>1?h-1:h],b=[o&&p>1?p-1:p,o&&f>1?f-1:f],v=y[0]/b[0],w=y[1]/b[1],x=1/v,_=1/w,k=2*Math.ceil(x)+2,C=2*Math.ceil(_)+2;for(let I=0;I<u;I++){const t=I*a[0];for(let e=0;e<c;e++){const n=t+e*a[1],s=Math.floor(e*x),r=Math.floor(s-k/2);for(let i=0;i<h;i++){const s=n+i*a[2],u=Math.floor(i*_),y=Math.floor(u-C/2);for(let n=0;n<d;n++){let a=0;for(let s=0;s<k;s++){const u=s+r;if(u<0||u>=p)continue;const d=t+u*l[1],m=u*v;if(e===Math.min(c-1,o?Math.round(m):Math.floor(m)))for(let t=0;t<C;t++){const e=t+y;if(e<0||e>=f)continue;const s=d+e*l[2],r=e*w;i===Math.min(h-1,o?Math.round(r):Math.floor(r))&&(a+=g[s+n])}}m[s+n]=a}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}},$B={kernelName:dv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:i}=s;WO(r,"reverse");const o=r.shape.length,a=Eg(i,r.shape);if(0===o)return XO({inputs:{x:r},backend:n});const l=new Pw(r.shape,r.dtype),u=n.bufferSync(r);for(let c=0;c<l.size;c++){const t=l.indexToLoc(c),e=t.slice();a.forEach(t=>e[t]=r.shape[t]-1-e[t]),l.set(u.get(...e),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},AB={kernelName:Jv,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:o}=e,a=n,l=Ng(s.dtype,wg(s.shape)),[u,c,h,d]=s.shape,[p,f]=dS(o,c,h),m=Math.sin(r),g=Math.cos(r),y=a.data.get(s.dataId).values;for(let b=0;b<u;b++){const t=b*h*c*d;for(let e=0;e<c;e++){const n=e*(h*d);for(let s=0;s<h;s++){const r=s*d;for(let o=0;o<d;o++){const a=[u,e,s,o],b=a[2],v=a[1];let w=(b-p)*g-(v-f)*m,x=(b-p)*m+(v-f)*g;w=Math.round(w+p),x=Math.round(x+f);let _=i;"number"!=typeof i&&(_=3===o?255:i[o]),w>=0&&w<h&&x>=0&&x<c&&(_=y[t+x*(h*d)+w*d+o]),l[t+n+r+o]=_}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},RB=HO(pv,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1}),FB={kernelName:pv,backendName:"cpu",kernelFunc:RB},DB=fM(t=>1/Math.sqrt(t)),OB=GO(fv,DB),LB={kernelName:fv,backendName:"cpu",kernelFunc:OB};function MB(t,e,n,s,r,i,o,a,l,u){const c=[s/r,r],h=t.values,d=e.values;if(0===s)return e_(n,e.dtype);const p=e_(c,e.dtype);p.values.fill(l);for(let f=0;f<i;f++){const t=[];let i=0;for(let e=0;e<o;e++){const n=h[f*o+e];t.push(n),i+=n*a[e]}if(i<0||i>=s/r)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<r;n++)u?p.values[i*r+n]+=d[f*r+n]:p.values[i*r+n]=0===e.rank?d[0]:d[f*r+n]}return p}const PB={kernelName:mv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=xS(0,r,o),d=MB(n.bufferSync(r),n.bufferSync(i),o,h,u,l,a,c,0,!0);return n.makeTensorInfo(o,d.dtype,d.values)}},zB={kernelName:gv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e;WO([s,r,i],"select");const o=s.shape.length,a=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=Yw(r.dtype,i.dtype),h=Ug(wg(r.shape),c);let d=0;const p=0===o||o>1||1===r.shape.length?1:wg(r.shape.slice(1));for(let f=0;f<a.length;f++)for(let t=0;t<p;t++)h[d++]=1===a[f]?l[f]:u[f];return n.makeTensorInfo(r.shape,c,h)}},BB=_S,VB=kS,WB=HO(yv,t=>t>=0?VB*t:BB*(Math.exp(t)-1)),UB={kernelName:yv,backendName:"cpu",kernelFunc:WB},jB=HO(xv,t=>t<0?-1:t>0?1:0),HB={kernelName:xv,backendName:"cpu",kernelFunc:jB},GB=HO(vv,t=>Math.sin(t)),qB={kernelName:vv,backendName:"cpu",kernelFunc:GB},KB=HO(wv,t=>Math.sinh(t)),XB={kernelName:wv,backendName:"cpu",kernelFunc:KB},ZB=Math.log(1.1920928955078125e-7)+2,YB=HO(kv,t=>{const e=t>-ZB,n=t<ZB,s=Math.exp(t);let r;return r=n?s:e?t:Math.log(1+s),r}),QB={kernelName:kv,backendName:"cpu",kernelFunc:YB},JB={kernelName:Sv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,paddings:o}=s;WO([r],"spaceToBatchND");const a=wg(i),l=[[0,0]];l.push(...o);for(let g=1+i.length;g<r.shape.length;++g)l.push([0,0]);const u=gB.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=pS(u.shape,i,a,!1),h=fS(c.length,i.length,!1),d=mS(u.shape,i,a,!1),p=kL({inputs:{x:u},backend:n,attrs:{shape:c}}),f=LL({inputs:{x:p},backend:n,attrs:{perm:h}}),m=kL({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function tV(t,e,n,s,r,i,o){const a=e[0],l=i[0],u=new Array(l),c=new Array(a),h=e[1];if(0===l){if(0!==a)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${a}`);return[$g(n,0),[0,h],$g(r,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<a;++g){const e=t[g*h];if(e<0)throw new Error(`indices(${g}, 0) is invalid: ${e} < 0`);if(e>=l)throw new Error(`indices(${g}, 0) is invalid: ${e} >= ${l}`);++f[e],d=d&&e>=p,p=e}let m=!0;for(let g=0;g<l;++g){const t=0===f[g];u[g]=t,m=m&&!t,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const e=t,n=s;for(let t=0;t<a;++t)c[t]=t;return[e,[a,h],n,u,c]}{const e=f[l-1],i=$g(n,e*h),d=$g(r,e),p=new Array(l).fill(0);for(let n=0;n<a;++n){const e=t[n*h],r=(0===e?0:f[e-1])+p[e];p[e]++;for(let s=0;s<h;++s)i[r*h+s]=t[n*h+s];d[r]=s[n],c[n]=r}for(let t=0;t<l;++t)if(0===p[t]){const e=0===t?0:f[t-1];i[e*h+0]=t;for(let t=1;t<h;++t)i[e*h+t]=0;d[e]=o}return[i,[e,h],d,u,c]}}const eV={kernelName:Nv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(o.dataId).values[0],[h,d,p,f,m]=tV(a,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(t=>Number(t)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}};function nV(t,e,n,s,r){const i=wg(s),o=e[0],a=r.length,l=[];let u=1,c=-1;for(let g=0;g<a;++g){const t=r[g];if(-1===t){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,l.push(1)}else{if(t<0)throw new Error(`size ${g} must be non-negative, not ${t}`);u*=t,l.push(t)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(i/u);if(u*t!==i)throw new Error(`Input to reshape is a SparseTensor with ${i}\n          dense values, but the requested shape requires a multiple of ${u}. inputShape=${s} outputShape= ${l}`);l[c]=t}const h=wg(l);if(h!==i)throw new Error(`Input to reshape is a tensor with ${i} dense values, but the requested shape has ${h}. inputShape=${s} outputShape=${l}`);const d=s.length,p=[];if(d>0){p[d-1]=1;for(let t=d-2;t>=0;--t)p[t]=p[t+1]*s[t+1]}const f=[];if(a>0){f[a-1]=1;for(let t=a-2;t>=0;--t)f[t]=f[t+1]*l[t+1]}const m=$g(n,o*a);for(let g=0;g<o;++g){let e=0;for(let n=0;n<d;++n)e+=t[g*d+n]*p[n];for(let t=0;t<a;++t)m[g*a+t]=Math.trunc(e/f[t]),e%=f[t]}return[m,[o,a],l]}const sV={kernelName:$v,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:i}=e;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(n.data.get(r.dataId).values),a=n.data.get(s.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,c,h]=nV(a,s.shape,s.dtype,o,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}};function rV(t,e,n,s,r,i=!1,o=0){const a=s.length;if(a!==r.length)throw new Error("segmentIds and indices should have same size.");const l=[e[0],t.length/e[0]],u=l[1],c=a>0?r[a-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=e.slice();h[0]=c;const d=$g(n,h.reduce((t,e)=>t*e,1));if(0===a)return c>0&&d.fill(o),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let e=0;if(f<a){if(e=r[f],g===e){++f;continue}if(g>=e)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(`Segment id ${g} out of range [0, ${c}), possibly because segmentIds input is not sorted.`);g>m&&d.fill(o,m*u,g*u);for(let n=p;n<f;++n){const e=s[n];if(e<0||e>=l[0])throw new Error(`Bad: indices[${n}] == ${s[n]} out of range [0, ${l[0]})`);for(let n=0;n<u;n++)d[g*u+n]+=t[e*u+n]}if(i)for(let t=0;t<u;t++)d[g*u+t]/=f-p;if(p=f,++f,m=g+1,g=e,f>a)break}return m<c&&d.fill(o,m*u,c*u),[d,h]}const iV={kernelName:Av,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);const o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=rV(o,s.shape,s.dtype,a,l,!0);return n.makeTensorInfo(c,s.dtype,u)}},oV={kernelName:Rv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);const o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=rV(o,s.shape,s.dtype,a,l);return n.makeTensorInfo(c,s.dtype,u)}},aV={kernelName:Fv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=xS(0,r,a),p=MB(n.bufferSync(r),n.bufferSync(i),a,d,c,u,l,h,n.data.get(o.dataId).values[0],!1);return n.makeTensorInfo(a,p.dtype,p.values)}},lV={kernelName:Ev,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=Eg(o,r.shape)[0],l=qS(r,i,a),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(t=>{const e=[...c];e[a]=t;const s=lM({inputs:{x:r},backend:n,attrs:{begin:u,size:e}});return u[a]+=t,s})}},uV=HO(Cv,t=>Math.sqrt(t)),cV={kernelName:Cv,backendName:"cpu",kernelFunc:uV},hV={kernelName:Ov,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;WO(n,"square");const r=s.data.get(n.dataId).values,i=new Float32Array(r.length);for(let o=0;o<r.length;++o){const t=r[o];i[o]=t*t}return{dataId:s.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},dV=JO((t,e)=>{const n=t-e;return n*n}),pV=yL(Dv,dV),fV={kernelName:Dv,backendName:"cpu",kernelFunc:pV},mV=HO(Yv,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),gV={kernelName:Yv,backendName:"cpu",kernelFunc:mV};function yV(t,e,n,s){const r=e_(t,e.dtype);for(let i=0;i<r.size;i++){const t=r.indexToLoc(i),o=new Array(t.length);for(let e=0;e<o.length;e++)o[e]=t[e]*n[e]+s[e];r.set(e.get(...o),...t)}return r}const bV={kernelName:Lv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;WO(r,"stridedSlice");const{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=R_(r.shape,i,o,a,l,u,c,h,d),v=kL({inputs:{x:r},backend:n,attrs:{shape:y}});let w;if(p){const t=lM({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});w=kL({inputs:{x:t},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(t)}else if(b.some(t=>0===t))w=n.makeTensorInfo(b,r.dtype,[]);else{const t=yV(b,n.bufferSync(v),m,f);w=n.makeTensorInfo(t.shape,t.dtype,t.values)}const x=kL({inputs:{x:w},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),x}};class vV{constructor(t,e,n,s,r,i){this.separator=Tw(t),this.nGramWidths=e,this.leftPad=Tw(n),this.rightPad=Tw(s),this.padWidth=r,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,s,r,i){for(let o=0;o<r;++o){const a=this.getPadWidth(i),l=Math.max(0,a-o),u=Math.max(0,a-(r-(o+1))),c=i-(l+u),h=e+(l>0?0:o-a);let d=0;d+=l*this.leftPad.length;for(let e=0;e<c;++e)d+=t[h+e].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[s+o]=new Uint8Array(d);const p=n[s+o];let f=0;const m=t=>t.forEach(t=>p[f++]=t);for(let t=0;t<l;++t)m(this.leftPad),m(this.separator);for(let e=0;e<c-1;++e)m(t[h+e]),m(this.separator);if(c>0){m(t[h+c-1]);for(let t=0;t<u;++t)m(this.separator),m(this.rightPad)}else{for(let t=0;t<u-1;++t)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(t,e){const n=t.length,s=e.length;if(s>0){let t=e[0];if(0!==t)throw new Error(`First split value must be 0, got ${t}`);for(let r=1;r<s;++r){let s=e[r]>=t;if(s=s&&e[r]<=n,!s)throw new Error(`Invalid split value ${e[r]}, must be in [${t}, ${n}]`);t=e[r]}if(t!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${t}`)}const r=s-1,i=$g("int32",s);if(0===n||0===s){const t=new Array(n);for(let e=0;e<=r;++e)i[e]=0;return[t,i]}i[0]=0;for(let a=1;a<=r;++a){const t=e[a]-e[a-1];let n=0;this.nGramWidths.forEach(e=>{n+=this.getNumNGrams(t,e)}),this.preserveShort&&t>0&&0===n&&(n=1),i[a]=i[a-1]+n}const o=new Array(i[r]);for(let a=0;a<r;++a){const n=e[a];let s=i[a];if(this.nGramWidths.forEach(r=>{const i=this.getNumNGrams(e[a+1]-e[a],r);this.createNGrams(t,n,o,s,i,r),s+=i}),this.preserveShort&&s===i[a]){const r=e[a+1]-e[a];if(0===r)continue;this.createNGrams(t,n,o,s,1,r+2*this.padWidth)}}return[o,i]}}function wV(t,e,n,s,r,i,o,a){return new vV(n,s,r,i,o,a).compute(t,e)}const xV={kernelName:Mv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=wV(d,p,r,i,o,a,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function _V(t,e,n){if(!t.length)return[];if(0===e.length){const e=new Array(t.length);for(let n=0;n<t.length;++n)e[n]=t.subarray(n,n+1);return e}if(1===e.length){const s=e[0],r=[];let i=t.indexOf(s);for(;-1!==i;){const e=t.subarray(0,i);n&&0===e.length||r.push(e),i=(t=t.subarray(i+1)).indexOf(s)}return n&&0===t.length||r.push(t),r}const s=[];let r=0;for(let i=0;i<t.length+1;i++)if(i===t.length||-1!==e.indexOf(t[i])){const e=t.subarray(r,i);n&&0===e.length||s.push(e),r=i+1}return s}function kV(t,e,n){const s=t.length,r=[];let i=0,o=0;const a=new Array(s);for(let d=0;d<s;++d){const s=_V(t[d],e,n),l=s.length;a[d]=l,i+=l,o=Math.max(o,l),r.push(...s)}const l=$g("int32",2*i),u=new Array(i),c=[s,o];let h=0;for(let d=0;d<s;++d)for(let t=0;t<a[d];++t)l[2*h]=d,l[2*h+1]=t,u[h]=r[h],++h;return[l,u,c]}const CV={kernelName:Pv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values[0],[u,c,h]=kV(a,l,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function IV(t,e){const n=$g("int32",t.length);for(let s=0;s<t.length;++s)n[s]=Cw(t[s]).modulo(e).getLowBitsUnsigned();return n}const SV={kernelName:zv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:i}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=IV(n.data.get(i.dataId).values,r);return n.makeTensorInfo(i.shape,"int32",o)}},EV=HO(Vv,t=>Math.tan(t)),TV={kernelName:Vv,backendName:"cpu",kernelFunc:EV},NV=HO(Wv,t=>Math.tanh(t));function $V(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=e_(n,t.dtype);for(let r=0;r<s.values.length;++r){const e=s.indexToLoc(r),n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=e[s]%t.shape[s];const i=t.locToIndex(n);s.values[r]=t.values[i]}return s}function AV(t,e,n,s,r){const i=e[e.length-1],[o,a]=[t.length/i,i],l=Ng(n,o*s),u=Ng("int32",o*s);for(let h=0;h<o;h++){const e=h*a,n=t.subarray(e,e+a),r=[];for(let t=0;t<n.length;t++)r.push({value:n[t],index:t});r.sort((t,e)=>e.value-t.value);const i=h*s,o=l.subarray(i,i+s),c=u.subarray(i,i+s);for(let t=0;t<s;t++)o[t]=r[t].value,c[t]=r[t].index}const c=e.slice();return c[c.length-1]=s,[e_(c,n,l),e_(c,"int32",u)]}function RV(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return fg(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;return n<0?e<=1?n=0:n+=e*(Math.trunc(-n/(e-1))+1):n>e-1&&(e<=1?n=0:n-=e*Math.trunc(n/(e-1))),fg(0,n,e-1)}(t,e);case"nearest":return function(t,e){return fg(0,t,e-1)}(t,e);case"constant":default:return function(t,e){return t}(t)}}function FV(t,e,n,s,r,i,o,a,l,u,c){return 0<=a&&a<e&&0<=l&&l<n?t[o*s+a*r+l*i+u]:c}function DV(t,e,n,s,r,i,o,a,l,u,c){return FV(t,e,n,s,r,i,o,Math.round(a),Math.round(l),u,c)}function OV(t,e,n,s,r,i,o,a,l,u,c){const h=Math.floor(a),d=Math.floor(l),p=h+1,f=d+1;return(p-a)*((f-l)*FV(t,e,n,s,r,i,o,h,d,u,c)+(l-d)*FV(t,e,n,s,r,i,o,h,f,u,c))+(a-h)*((f-l)*FV(t,e,n,s,r,i,o,p,d,u,c)+(l-d)*FV(t,e,n,s,r,i,o,p,f,u,c))}function LV(t,e,n,s){const r=Eg(e,n)[0],i=[1,n[0],1];for(let f=0;f<r;f++)i[0]*=n[f];i[1]=n[r];for(let f=r+1;f<n.length;f++)i[2]*=n[f];const o={},a=new Int32Array(n[r]),l=new Pw(i,s,t),u=[],c=1===i[0]&&1===i[2];for(let f=0;f<n[r];f++){let e;if(c)e=t[f].toString();else{const t=[];for(let e=0;e<i[0];e++)for(let n=0;n<i[2];n++)t.push(l.get(e,f,n));e=t.join(",")}if(void 0!==o[e])a[f]=o[e];else{const t=Object.keys(o).length;o[e]=t,a[f]=t,u.push(f)}}const h=i.slice();h[1]=Object.keys(o).length;const d=new Pw(h,s);u.forEach((t,e)=>{for(let n=0;n<i[0];n++)for(let s=0;s<i[2];s++)d.set(l.get(n,t,s),n,e,s)});const p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:a}}const MV=[EL,NL,AL,FL,_L,DL,PL,zL,BL,VL,UL,HL,qL,ZL,QL,nM,sM,rM,iM,SL,oM,cM,pM,gL,yM,vM,hL,wM,IM,TM,NM,EM,AM,RM,$M,DM,LM,MM,PM,zM,BM,WM,UM,jM,HM,GM,KM,qM,CP,eP,KO,nP,iP,pP,gP,bP,xP,RP,DP,OP,PP,VP,WP,UP,HP,qP,ZP,JP,ZO,tz,kM,nz,rz,oz,QO,uz,dz,fz,yz,vz,_z,Cz,Ez,Tz,Nz,Oz,Lz,Mz,Pz,zz,Bz,Rz,Vz,Wz,Hz,Gz,Xz,Qz,QM,tB,nB,rB,oB,uB,cB,pB,mB,gB,vB,nL,xB,kB,fL,IB,rL,oL,CL,SB,EB,TB,NB,$B,AB,FB,LB,PB,zB,UB,lL,HB,qB,XB,uM,Yz,QB,JB,eV,sV,iV,oV,aV,lV,cV,hV,fV,gV,bV,xV,CV,SV,TP,tP,TV,{kernelName:Wv,backendName:"cpu",kernelFunc:NV},{kernelName:Uv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;WO(r,"tile");const o=$V(n.bufferSync(r),i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:jv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i}=s;WO(r,"topk");const o=n.data.get(r.dataId).values,[a,l]=AV(o,r.shape,r.dtype,i);return[n.makeTensorInfo(a.shape,a.dtype,a.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},ML,{kernelName:Hv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=n,[c,h,d,p]=r.shape,[f,m]=null!=u?u:[h,d],g=[c,f,m,p],y=zg(r.shape),b=y[0],v=y[1],w=y[2],x=Ng(r.dtype,wg(g));x.fill(l);const _=s.data.get(r.dataId).values,k=s.data.get(i.dataId).values;for(let C=0;C<c;++C){const t=1===i.shape[0]?k:k.subarray(8*C,8*C+8);for(let e=0;e<f;++e)for(let n=0;n<m;++n)for(let s=0;s<p;++s){let r;const i=t[6]*n+t[7]*e+1;if(0===i)continue;const u=(t[3]*n+t[4]*e+t[5])/i,c=RV((t[0]*n+t[1]*e+t[2])/i,d,a),p=RV(u,h,a);switch(o){case"nearest":r=DV(_,h,d,b,v,w,C,p,c,s,l);break;case"bilinear":r=OV(_,h,d,b,v,w,C,p,c,s,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}x[C*b+e*v+n*w+s]=r}return s.makeTensorInfo(g,r.dtype,x)}return{dataId:s.write(x,g,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:qv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;WO(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:u}=LV(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}},{kernelName:Kv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],l=new Array(o-1);let u=0;for(let p=0;p<o;p++)p!==i&&(l[u++]=r.shape[p]);const c=new Array(o).fill(0),h=r.shape.slice();h[i]=1;const d=new Array(a);for(let p=0;p<d.length;p++){c[i]=p;const t=lM({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});d[p]=kL({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}},{kernelName:Xv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:i}=e,{numSegments:o}=s;WO(r,"unsortedSegmentSum");const a=[],l=[],u=r.shape.length-i.shape.length;let c=i;for(let d=0;d<u;++d){const t=yP({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=t,l.push(t)}for(let d=0;d<o;++d){const t=Iw(d,"int32"),e=n.makeTensorInfo([],"int32",t),s=rP({inputs:{a:e,b:c},backend:n}),i=mL({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),o=YM({inputs:{a:i,b:r},backend:n}),u=JM({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});a.push(u),l.push(e),l.push(s),l.push(i),l.push(o),l.push(u)}const h=fB({inputs:a,backend:n,attrs:{axis:0}});return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),h}},dB];for(const Y3 of MV)lw(Y3);const PV={},zV={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function BV(t){if(!(t in PV)){const e=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete PV[t]},!1),1===t?e.getContext("webgl",zV)||e.getContext("experimental-webgl",zV):e.getContext("webgl2",zV)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;PV[t]=e}const e=PV[t];return e.isContextLost()?(delete PV[t],BV(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),PV[t])}var VV,WV,UV;function jV(t,e){return[e,t]}function HV(t){const e=wg(t);return kg(Math.ceil(e/4))}function GV(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function qV(t,e){const n=t;let s,r,i,o,a,l,u,c,h,d;return 2===Yg().getNumber("WEBGL_VERSION")?(s=n.R32F,r=n.R16F,i=n.RGBA16F,o=n.RGBA32F,a=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(s=t.RGBA,r=t.RGBA,i=t.RGBA,o=n.RGBA,a=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function KV(t,e){const n=e();return Yg().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}function XV(t){return!!(Yg().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function ZV(t,e){return sW(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(VV||(VV={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(WV||(WV={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(UV||(UV={}));const YV=/ERROR: [0-9]+:([0-9]+):/g;function QV(t,e){if(KV(t,()=>t.validateProgram(e)),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function JV(t,e,n,s,r,i,o){const a=t.getAttribLocation(e,n);return-1!==a&&(KV(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),KV(t,()=>t.vertexAttribPointer(a,r,t.FLOAT,!1,i,o)),KV(t,()=>t.enableVertexAttribArray(a)),!0)}function tW(t,e,n){KV(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),KV(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function eW(t,e){KV(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),KV(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function nW(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function sW(t,e,n){const s=KV(t,()=>e());if(null==s)throw new Error(n);return s}function rW(t,e=2){return wg(t.slice(0,t.length-e))}function iW(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function oW(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[rW(t),...iW(t)]),e}function aW(t){return t%2==0}function lW(t,e){if(xg(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],s=e.slice(-1)[0];if(n===s)return!0;if(aW(n)&&aW(s)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&aW(t[0])&&aW(e[0])}let uW,cW;function hW(t,e){return null!=t.getExtension(e)}function dW(t){try{if(null!=BV(t))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function pW(t){const e=qV(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const r=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(s),r}function fW(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&gg("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const mW=Yg();function gW(){let t,e,n,s,r,i,o,a,l,u;return 2===Yg().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function yW(t,e,n="index"){const s=zg(e);return s.map((e,r)=>`int ${t[r]} = ${n} / ${e}; ${r===s.length-1?`int ${t[r+1]} = ${n} - ${t[r]} * ${e}`:`index -= ${t[r]} * ${e}`};`).join("")}function bW(t){const e=zg(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}mW.registerFlag("HAS_WEBGL",()=>mW.getNumber("WEBGL_VERSION")>0),mW.registerFlag("WEBGL_VERSION",()=>dW(2)?2:dW(1)?1:0),mW.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),mW.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===mW.get("WEBGL_VERSION")),mW.registerFlag("WEBGL_CPU_FORWARD",()=>!0),mW.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),mW.registerFlag("WEBGL_PACK",()=>mW.getBool("HAS_WEBGL")),mW.registerFlag("WEBGL_PACK_NORMALIZATION",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_PACK_CLIP",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_PACK_REDUCE",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_LAZILY_UNPACK",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_CONV_IM2COL",()=>mW.getBool("WEBGL_PACK")),mW.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==uW){const e=BV(t);uW=e.getParameter(e.MAX_TEXTURE_SIZE)}return uW}(mW.getNumber("WEBGL_VERSION"))),mW.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==cW){const e=BV(t);cW=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,cW)}(mW.getNumber("WEBGL_VERSION"))),mW.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=mW.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=BV(t);return e=hW(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:hW(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),mW.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>mW.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ux()),mW.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=BV(t);if(1===t){if(!hW(e,"OES_texture_float"))return!1}else if(!hW(e,"EXT_color_buffer_float"))return!1;return pW(e)}(mW.getNumber("WEBGL_VERSION"))),mW.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!mW.getBool("WEBGL_FORCE_F16_TEXTURES")&&mW.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),mW.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(t){if(0===t)return!1;const e=BV(t);if(1!==t){if(hW(e,"EXT_color_buffer_float"))return pW(e);const t="EXT_color_buffer_half_float";if(hW(e,t)){const n=e.getExtension(t);return function(t,e){const n=qV(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(r),i}(e,n)}return!1}return!!hW(e,"OES_texture_float")&&!!hW(e,"WEBGL_color_buffer_float")&&pW(e)}(mW.getNumber("WEBGL_VERSION"))),mW.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=mW.getNumber("WEBGL_VERSION"))&&null!=BV(t).fenceSync;var t}),mW.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>mW.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),mW.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),mW.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ux()&&mW.getBool("IS_CHROME")?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}),mW.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);const vW="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class wW{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=VV.DENSE;const e=HV(t),n=gW();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${yW(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class xW{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=VV.DENSE;const e=HV(t),n=gW();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${yW(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class _W{constructor(t){this.variableNames=["A"],this.outTexUsage=WV.DOWNLOAD;const e=gW();this.outputShape=t,this.userCode=`\n      ${vW}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class kW{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=WV.DOWNLOAD;const e=gW();this.outputShape=t,this.userCode=`\n      ${vW}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class CW{constructor(t,e,n=!1){this.variableNames=["A"];const s=gW(),[r,i]=e;this.outputShape=t;let o="result";n&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${bW(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${r}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class IW{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const s=gW(),[r,i]=e;this.outputShape=t;let o="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let e=0;e<=1;e++){const n=2*l+e;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${l} < ${t[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${r}.0);\n              values = ${s.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${bW(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${o}\n\n        ${s.output} = ${a};\n      }\n    `}}function SW(t,e,n,s,r,i){!function(t,e){const n=Yg().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const o=function(t){return sW(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return KV(t,()=>t.bindTexture(a,o)),KV(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),KV(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),KV(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),KV(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),KV(t,()=>t.texImage2D(a,0,s,e,n,0,r,i,null)),KV(t,()=>t.bindTexture(t.TEXTURE_2D,null)),o}function EW(t){return t.internalFormatFloat}function TW(t){return t.internalFormatHalfFloat}function NW(t){return t.downloadTextureFormat}function $W(t){return t.internalFormatPackedFloat}function AW(t){return t.internalFormatPackedHalfFloat}class RW{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Yg().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){PV[t]=e}(e,t)):this.gl=BV(e);let n="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(1===Yg().getNumber("WEBGL_VERSION")){const t="OES_texture_half_float";if(this.textureFloatExtension=ZV(this.gl,"OES_texture_float"),hW(this.gl,t))this.textureHalfFloatExtension=ZV(this.gl,t);else if(Yg().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),hW(this.gl,s))this.colorBufferHalfFloatExtension=ZV(this.gl,s);else if(Yg().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",hW(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!hW(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function(t){return function(t,e){const n=sW(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return KV(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),KV(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=sW(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return KV(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),KV(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return sW(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=qV(this.gl,this.textureHalfFloatExtension)}get debug(){return Yg().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;KV(t,()=>t.finish()),KV(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),KV(t,()=>t.deleteFramebuffer(this.framebuffer)),KV(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),KV(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),KV(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=jV(e,n);return SW(t,r,i,EW(s),s.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=jV(e,n);return SW(t,r,i,TW(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=jV(e,n);return SW(t,r,i,NW(s),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){KV(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?KV(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):KV(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),KV(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,s){this.throwIfDisposed(),function(t,e,n,s,r,i){let o,a,l;KV(t,()=>t.bindTexture(t.TEXTURE_2D,e)),r instanceof Uint8Array?(o=new Uint8Array(n*s*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*s*4),a=t.FLOAT,l=i.internalFormatPackedFloat),o.set(r),KV(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,s,0,t.RGBA,a,o)),KV(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=GV(e,n);return SW(t,r,i,AW(s),t.RGBA,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=GV(e,n);return SW(t,r,i,$W(s),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(eW(this.gl,this.framebuffer),this.outputTexture=null),KV(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,s){const[r,i]=jV(e,n),o=new Uint8Array(e*n*4);return KV(t,()=>t.readPixels(0,0,r,i,s.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,s,r,i){return function(t,e,n,s,r,i,o,a){const l=t,u=new Float32Array(function(t,e){const[n,s]=GV(t,e);return n*s*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,r,i)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const s=function(t,e,n,s){const r=t.createBuffer();KV(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const i=16*e*n;return KV(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)),KV(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),KV(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,n);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Yg().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,r=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=s.clientWaitSync(r,0,0);return t===s.ALREADY_SIGNALED||t===s.CONDITION_SATISFIED},e=r}else Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n){const s=new Float32Array(e*n*4);return KV(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e){const n=sW(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(KV(t,()=>t.shaderSource(n,e)),KV(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=YV.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const s=+n[1],r=t.split("\n"),i=r.length.toString().length+2,o=r.map((t,e)=>Cg((e+1).toString(),i)+t);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,s-1),u=o.slice(s-1,s),c=o.slice(s);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${Cg(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e,t);null==this.vertexShader&&(this.vertexShader=function(t){const e=gW();return function(t,e){const n=sW(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(KV(t,()=>t.shaderSource(n,e)),KV(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const s=function(t){return sW(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return KV(e,()=>e.attachShader(s,this.vertexShader)),KV(e,()=>e.attachShader(s,n)),function(t,e){if(KV(t,()=>t.linkProgram(e)),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,s),this.debug&&QV(e,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(t,e,n){return KV(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),JV(t,e,"clipSpacePos",n,3,20,0)&&JV(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&KV(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&QV(this.gl,this.program),KV(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return sW(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),KV(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,s){KV(t,()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),KV(t,()=>t.activeTexture(t.TEXTURE0+n)),KV(t,()=>t.bindTexture(t.TEXTURE_2D,e))}(t,e,s)),KV(t,()=>t.uniform1i(n,s))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[s,r]=GV(e,n);this.setOutputMatrixTextureDriver(t,s,r)}setOutputMatrixWriteRegion(t,e,n,s){this.setOutputMatrixWriteRegionDriver(n,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&QV(this.gl,this.program),nW(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),KV(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),KV(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=ZV(this.gl,2===Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return lg(function*(){return yield Ig(()=>e.disposed||e.isQueryAvailable(t,Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||Ig(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),tW(this.gl,t,this.framebuffer),this.debug&&nW(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(tW(this.gl,this.outputTexture,this.framebuffer),this.debug&&nW(this.gl)):eW(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const s=this.gl;tW(s,t,this.framebuffer),this.debug&&nW(s),this.outputTexture=t,KV(s,()=>s.viewport(0,0,e,n)),KV(s,()=>s.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,s){this.throwIfDisposed(),KV(this.gl,()=>this.gl.scissor(t,e,n,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:FW}=i;function DW(t,e,n,s){const r=[];t.forEach(t=>{const e=wg(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?r.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(r.push(`uniform sampler2D ${t.name};`),r.push(`uniform int offset${t.name};`))});const i=r.join("\n"),o=t.map(t=>function(t,e,n=!1){let s="";return s+=n?LW(t):OW(t),t.shapeInfo.logicalShape.length<=e.logicalShape.length&&(s+=n?function(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=FW(t.shapeInfo.logicalShape,e.logicalShape),l=UW(o),u=o-i;let c;const h=["x","y","z","w","u","v"];c=0===i?"":o<2&&a.length>=1?"coords = 0;":a.map(t=>`coords.${h[t+u]} = 0;`).join("\n");let d="";d=o<2&&i>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${h[e+u]}`).join(", ");let p="return outputValue;";const f=1===wg(t.shapeInfo.logicalShape),m=1===wg(e.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const t=i-2,e=i-1;a.indexOf(t)>-1&&a.indexOf(e)>-1?p="return vec4(outputValue.x);":a.indexOf(t)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(e)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${s}(${d});\n      ${p}\n    }\n  `}(t,e):function(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=t.shapeInfo.logicalShape.length,o=e.logicalShape.length;if(!t.shapeInfo.isUniform&&i===o&&null==t.shapeInfo.flatOffset&&xg(t.shapeInfo.texShape,e.texShape))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const a=UW(o),l=FW(t.shapeInfo.logicalShape,e.logicalShape),u=o-i;let c;const h=["x","y","z","w","u","v"];c=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map(t=>`coords.${h[t+u]} = 0;`).join("\n");let d="";return d=o<2&&i>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${h[e+u]}`).join(", "),`\n    float ${r}() {\n      ${a} coords = getOutputCoords();\n      ${c}\n      return get${s}(${d});\n    }\n  `}(t,e)),s}(t,e,s)).join("\n"),a=e.texShape,l=gW(),u=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let c,h,d=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${MW}\n    ${PW}\n    ${zW}\n  `}(l);return e.isPacked?(c=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(xg(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),r=s*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),r=s*Math.ceil(t[t.length-2]/2);let i=r,o="",a="b, r, c";for(let l=2;l<t.length-1;l++)i*=t[t.length-l-1],o=`\n      int b${l} = index / ${i};\n      index -= b${l} * ${i};\n    `+o,a=`b${l}, `+a;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${t.length}(${a});\n    }\n  `}(t,e)}}(e.logicalShape,a),h=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(l)):(c=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=e)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(t,e){return xg(t,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=yW(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=yW(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=yW(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=yW(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}var n}(e.logicalShape,a),h=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),s&&(d+=BW),[d,u,h,i,c,o,n].join("\n")}function OW(t){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[s,r]=t.shapeInfo.texShape;if(1===s&&1===r)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[i,o]=t.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${i}, ${o}, ${VW(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${WW(t)}\n      }\n    `;const s=t.shapeInfo.texShape,r=s[0],i=s[1];if(1===i&&1===r)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=VW(e);return 1===i?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${r}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===r?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${i}, index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape;if(null!=r&&xg(e,r))return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:i,keptDims:o}=Tg(e);if(i.length<e.length){const e=["row","col"];return`\n      ${OW(jW(t,i))}\n      float ${s}(int row, int col) {\n        return ${s}(${HW(e,o)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${WW(t)}\n      }\n    `;const a=r[0],l=r[1],u=VW(n);return 1===l?`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${a}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===a?`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${u};\n    vec2 uv = uvFromFlat(${a}, ${l}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[1]*e[2],i=e[2],{newShape:o,keptDims:a}=Tg(e);if(o.length<e.length){const e=["row","col","depth"];return`\n        ${OW(jW(t,o))}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${HW(e,a)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${i}, 1)));\n        ${WW(t)}\n      }\n    `;const l=t.shapeInfo.texShape,u=l[0],c=l[1],h=t.shapeInfo.flatOffset;return c===r&&null==h?`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${u}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:c===i&&null==h?`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${u}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${i} + depth + ${VW(n)};\n        vec2 uv = uvFromFlat(${u}, ${c}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(t);case 4:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[3],i=e[2]*r,o=e[1]*i,{newShape:a,keptDims:l}=Tg(e);if(a.length<e.length){const e=["row","col","depth","depth2"];return`\n      ${OW(jW(t,a))}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${HW(e,l)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${r}, 1)));\n        ${WW(t)}\n      }\n    `;const u=t.shapeInfo.flatOffset,c=t.shapeInfo.texShape,h=c[0],d=c[1];return d===o&&null==u?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:d===r&&null==u?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${VW(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[4],i=e[3]*r,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:u}=Tg(e);if(l.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${OW(jW(t,l))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${HW(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${i}, ${r})) +\n          depth3;\n        ${WW(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];return p===a&&null==c?`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===r&&null==c?`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${i} +\n          depth2 * ${r} + depth3 + ${VW(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:i}=Tg(e);if(r.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${OW(jW(t,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${HW(e,i)});\n      }\n    `}const o=e[5],a=e[4]*o,l=e[3]*a,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${WW(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];return f===c&&null==h?`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===o&&null==h?`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${VW(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function LW(t){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${gW().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,r=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],i=gW();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,i=r[0],o=r[1],a=gW();if(null!=r&&xg(e,r))return`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${a.texture2D}(${n}, uv);\n      }\n    `;const l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${l[0]}, ${l[1]}, row, col);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===e[0]){const n=[1,2],r=["b","row","col"];return`\n        ${LW(jW(t,e.slice(1)))}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${HW(r,n)});\n        }\n      `}const o=i[0],a=i[1],l=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${o}, ${a}, ${l*Math.ceil(e[1]/2)}, ${l}, b, row, col);\n      return ${gW().texture2D}(${n}, uv);\n    }\n  `}(t);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],a=o[0],l=o[1],u=Math.ceil(e[n-1]/2);let c=u*Math.ceil(e[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=e[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${r}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${a});\n      return ${gW().texture2D}(${s}, uv);\n    }\n  `}(t)}}const MW="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",PW="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",zW="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",BW="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function VW(t){return`offset${t}`}function WW(t){const e=t.name,n=wg(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function UW(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function jW(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function HW(t,e){return e.map(e=>t[e]).join(", ")}function GW(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const s=t.logicalShape,r=e[n],i=r.shape;if(!xg(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(t.isUniform&&r.isUniform)return;const o=t.texShape,a=r.isUniform?null:r.texData.texShape;if(!xg(o,a))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${a} must match`)})}const{addImpl:qW,bincountImpl:KW,bincountReduceImpl:XW,ceilImpl:ZW,concatImpl:YW,equalImpl:QW,expImpl:JW,expm1Impl:tU,floorImpl:eU,gatherNdImpl:nU,gatherV2Impl:sU,greaterImpl:rU,greaterEqualImpl:iU,lessImpl:oU,lessEqualImpl:aU,linSpaceImpl:lU,logImpl:uU,maxImpl:cU,maximumImpl:hU,minimumImpl:dU,multiplyImpl:pU,negImpl:fU,notEqualImpl:mU,prodImpl:gU,rangeImpl:yU,rsqrtImpl:bU,simpleAbsImpl:vU,sliceImpl:wU,sparseFillEmptyRowsImpl:xU,sparseReshapeImpl:_U,sparseSegmentReductionImpl:kU,stridedSliceImpl:CU,stringNGramsImpl:IU,stringSplitImpl:SU,stringToHashBucketFastImpl:EU,subImpl:TU,tileImpl:NU,topKImpl:$U,transposeImpl:AU,uniqueImpl:RU}=o;function FU(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function DU(t,e){return 1===e?[t]:FU(t,e)}class OU{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=DU("rc",e),s=UW(e),r=function(t,e,n){if(1===t)return`rc > ${e[0]}`;let s="";for(let r=t-2;r<t;r++)s+=`${n[r]} >= ${e[r]}`,r<t-1&&(s+="||");return s}(e,t,n),i=function(t,e,n,s){if(1===t)return"";const r=s.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),o=function(t,e){const n=t.length,s=function(t,e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<t;n++)i=`${e[e.length-1-n]},`+i;n.push(i)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${s[0]}),\n          cEdge ? 0. : getA(${s[1]}),\n          rEdge ? 0. : getA(${s[2]}),\n          rEdge || cEdge ? 0. : getA(${s[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}class LU{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let r=0;r<4;r++){let t="thisRC = rc;";r%2==1&&(t+="thisRC.z += 1;"),r>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}var s;this.userCode=`\n      ${s=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${yW(["r","c","d"],s)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${bW(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class MU{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const s=zU(e,n),r=BU(t,s,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const i=PU(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const t=this.freeTextures[r].shift();return this.usedTextures[r].push(t),t}let o;return s===UV.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===UV.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===UV.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===UV.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===UV.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(t,e,n,s){if(null==this.freeTextures)return;const r=zU(n,s),i=BU(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]);const o=PU(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s),a=Yg().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==a&&this._numBytesAllocated>a?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=o):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[i],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function PU(t,e,n,s,r){const i=function(t,e){switch(t){case UV.PACKED_2X2_FLOAT32:return $W(e);case UV.PACKED_2X2_FLOAT16:return AW(e);case UV.UNPACKED_FLOAT32:return EW(e);case UV.UNPACKED_FLOAT16:return TW(e);case UV.PACKED_4X1_UNSIGNED_BYTE:return NW(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,s);let o;if(r){const[e,n]=GV(t[0],t[1]);o=e*n}else{const[e,n]=jV(t[0],t[1]);o=e*n}return o*function(t,e){if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}(n,i)}function zU(t,e){if(t===WV.UPLOAD)return UV.PACKED_2X2_FLOAT32;if(t===WV.RENDER||null==t)return function(t){return Yg().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?UV.PACKED_2X2_FLOAT32:UV.UNPACKED_FLOAT32:t?UV.PACKED_2X2_FLOAT16:UV.UNPACKED_FLOAT16}(e);if(t===WV.DOWNLOAD||t===WV.PIXELS)return UV.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function BU(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class VU{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const WU="return abs(x);",UU="return x;";class jU{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class HU{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=DU("rc",e),s=UW(e),r=function(t,e){if(1===t)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}(e,n),i=n.slice(-2),o=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const GU=JS,qU={},KU=Yg().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class XU extends hg{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Yg().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=BV(Yg().getNumber("WEBGL_VERSION"));this.binaryCache=((e=Yg().getNumber("WEBGL_VERSION"))in qU||(qU[e]={}),qU[e]),this.gpgpu=new RW(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new MU(this.gpgpu),this.numMBBeforeWarning=null==Yg().global.screen?1024:Yg().global.screen.height*Yg().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new cg(this,L_())}nextDataId(){return XU.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((Yg().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Yg().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:e,dtype:n,values:t,usage:WV.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,e,n,s,r){if(Yg().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:s,values:e,usage:WV.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:s,complexTensorInfos:r,slice:i,shape:o,isPacked:a}=e;if(null!=i){let e;e=a?new jU(o,UU):new VU(o,UU);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:s}],s),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===s)return n;const l=null!=this.activeTimers;let u,c;return l&&(u=Ew()),c="complex64"===s?RS(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):this.getValuesFromTexture(t),l&&(this.downloadWaitMs+=Ew()-u),this.convertAndCacheOnCPU(t,c)}read(t){var e=this;return lg(function*(){if(e.pendingRead.has(t)){const n=e.pendingRead.get(t);return new Promise(t=>n.push(t))}const n=e.texData.get(t),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=n;if(null!=i){let n;n=l?new jU(r,UU):new VU(r,UU);const s=e.runWebGLProgram(n,[{dataId:t,shape:r,dtype:o}],o),i=e.read(s.dataId);return e.disposeIntermediateTensorInfo(s),i}if(null!=s)return e.convertAndCacheOnCPU(t);if(!Yg().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Yg().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,h=null;if("complex64"!==o&&Yg().get("WEBGL_BUFFER_SUPPORTED")){u=e.decode(t);const n=e.texData.get(u.dataId);h=e.gpgpu.createBufferFromTexture(n.texture,...HV(r))}if(e.pendingRead.set(t,[]),"complex64"!==o&&(yield e.gpgpu.createAndWaitForFence()),"complex64"===o){const t=yield Promise.all([e.read(a.real.dataId),e.read(a.imag.dataId)]);c=RS(t[0],t[1])}else if(null==h)c=e.getValuesFromTexture(t);else{const t=wg(r);c=e.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}null!=u&&e.disposeIntermediateTensorInfo(u);const d=e.convertAndCacheOnCPU(t,c),p=e.pendingRead.get(t);return e.pendingRead.delete(t),p.forEach(t=>t(d)),e.pendingDisposal.has(t)&&(e.pendingDisposal.delete(t),e.disposeData(t)&&L_().removeDataId(t,e),e.pendingDeletes--),d})()}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>Nw(t))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return e_(t.shape,t.dtype,n)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!XV(n)){if(Yg().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:s}=this.texData.get(t),r=wg(e);if(Yg().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),s=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(s.texture,...HV(e)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),i}const i=Yg().getBool("WEBGL_PACK")&&!0===s,o=i?oW(e):e,a=i?new kW(o):new _W(o),l=this.runWebGLProgram(a,[{shape:o,dtype:n,dataId:t}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){var e=this;return lg(function*(){const n=e.activeTimers,s=[];let r=!1;null==e.programTimersStack?(e.programTimersStack=s,r=!0):e.activeTimers.push(s),e.activeTimers=s,t();const i=vg(e.activeTimers.map(t=>t.query)).filter(t=>null!=t),o=vg(e.activeTimers.map(t=>t.name)).filter(t=>null!=t);e.activeTimers=n,r&&(e.programTimersStack=null);const a={uploadWaitMs:e.uploadWaitMs,downloadWaitMs:e.downloadWaitMs,kernelMs:null,wallMs:null};if(Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=yield Promise.all(i);a.kernelMs=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}(t),a.getExtraProfileInfo=()=>t.map((t,e)=>({name:o[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return e.uploadWaitMs=0,e.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ew(),endMs:null}}endTimer(t){return Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Ew(),t)}getQueryTime(t){var e=this;return lg(function*(){return Yg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?e.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs})()}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:s,usage:r,isPacked:i,slice:o}=this.texData.get(t),a=o&&o.origDataId||t,l=this.dataRefCount.get(a);l>1?this.dataRefCount.set(a,l-1):(this.dataRefCount.delete(a),null!=e&&(this.numBytesInGPU-=this.computeBytes(s,n),this.textureManager.releaseTexture(e,s,r,i)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=KU){return Yg().getBool("WEBGL_CPU_FORWARD")&&t.every(t=>null==this.texData.get(t.dataId).texture&&wg(t.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){$S("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return GU(t.shape,e)}packedUnaryOp(t,e,n){const s=new jU(t.shape,e),r=this.compileAndRun(s,[t],n);return L_().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=vU(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Yg().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,WU,t.dtype);const e=new VU(t.shape,WU),n=this.compileAndRun(e,[t]);return L_().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(t,e,n){let s;if("string"===e&&null!=n&&n.length>0&&Dg(n[0])){const r=n.map(t=>Tw(t));s=this.write(r,t,e)}else s=this.write(n,t,e);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:e}}makeOutput(t,e,n){const{dataId:s}=this.makeTensorInfo(t,e,n);return L_().makeTensorFromDataId(s,t,e,this)}unpackTensor(t){const e=new HU(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new OU(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[rW(t.shape),...iW(t.shape)],s={dtype:t.dtype,shape:n,dataId:t.dataId},r=[rW(e),...iW(e)],i=new LU(r,n),o=this.runWebGLProgram(i,[s],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:s,dtype:r}=e,i=oW(s);let o;return o=n?new xW(i):new wW(i),{dtype:r,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:r,dataId:t}],r,null,!0).dataId}}runWebGLProgram(t,e,n,s,r=!1){const i=this.makeTensorInfo(t.outputShape,n),o=this.texData.get(i.dataId);if(t.packedOutput&&(o.isPacked=!0),t.outPackingScheme===VV.DENSE){const e=HV(t.outputShape);o.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(o.usage=t.outTexUsage),0===wg(i.shape))return o.values=Ng(i.dtype,0),i;const a=[],l=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&wg(e.shape)<=Yg().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),a.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!lW(n.shape,e.shape)){const t=e,s=e.shape;e.shape=n.shape,e=this.packedReshape(e,s),a.push(e),n=this.texData.get(e.dataId),t.shape=s}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(i.dataId);const u={shape:i.shape,texData:o,isUniform:!1},c=function(t,e,n){let s="";e.concat(n).forEach(t=>{s+=`${t.shape}_${t.isUniform?"uniform":t.texData.texShape}_${null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0}`});let r=t.constructor.name;return r+="_"+s+"_"+t.userCode,r}(t,l,u),h=this.getAndSaveBinary(c,()=>function(t,e,n,s){const r=e.userCode,i=n.map((t,n)=>{const s={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(s.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:s}}),o=i.map(t=>t.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=DW(i,a,r,e.packedInputs),u=t.createProgram(l);let c=null;const h=t.getUniformLocation(u,"NAN",!1);1===Yg().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(u,"INFINITY",!1));const d={};for(let p=0;p<e.variableNames.length;p++){const n=e.variableNames[p],s=!1;d[n]=t.getUniformLocation(u,n,s),d[`offset${n}`]=t.getUniformLocation(u,`offset${n}`,s)}return{program:e,source:l,webGLProgram:u,uniformLocations:d,inShapeInfos:o,outShapeInfo:a,infLoc:c,nanLoc:h}}(this.gpgpu,t,l,u)),d=null!=this.activeTimers;let p;d&&(p=this.startTimer()),function(t,e,n,s,r){GW(e.inShapeInfos,n),GW([e.outShapeInfo],[s]);const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(i,o[0],o[1]):t.setOutputMatrixTexture(i,o[0],o[1]),t.setProgram(e.webGLProgram),1===Yg().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,s)=>{const r=e.program.variableNames[s],i=e.uniformLocations[r],o=e.uniformLocations[`offset${r}`];if(null!=i)if(n.isUniform)if(wg(n.shape)<2)t.gl.uniform1f(i,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(i,e)}else null!=n.texData.slice&&null!=o&&t.gl.uniform1i(o,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,i,s)}),null!=r&&r(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,h,l,u,s),a.forEach(t=>this.disposeIntermediateTensorInfo(t)),d&&(p=this.endTimer(p),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(p)}));const f=Yg().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const t=Ew();t-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Yg().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===r){const t=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),t}return i}compileAndRun(t,e,n,s,r=!1){return this.runWebGLProgram(t,e,n=n||e[0].dtype,s,r)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Yg().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=P_(()=>{if(!Yg().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Yg().getBool("DEBUG");Yg().set("DEBUG",!1);const e=this.abs(U_(1e-8)).dataSync()[0];if(Yg().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:s,values:r,texture:i,usage:o,isPacked:a}=e;if(null!=i)return;const l=null!=this.activeTimers;let u;l&&(u=Ew());let c=e.texShape;if(null==c&&(c=function(t,e=!1){let n=Yg().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?mg(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=Tg(t);t=e.newShape}let s=wg(t);if(t.length<=1&&s<=n)return[1,s];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=rW(t);let n=2,r=2;return t.length&&([n,r]=iW(t)),s=e*(n/2)*(r/2),kg(s).map(t=>2*t)}return kg(s)}(n,a),e.texShape=c),null!=r){const t=oW(n);let i,o=c[1],h=c[0];const d=r instanceof Uint8Array;a?([o,h]=GV(c[0],c[1]),i=new IW(t,[h,o],d)):i=new CW(t,[h,o],d);const p=this.makeTensorInfo([h,o],s);this.texData.get(p.dataId).usage=d?WV.PIXELS:WV.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),o,h,r);const f=this.runWebGLProgram(i,[p],s,null,!0),m=this.texData.get(f.dataId);e.texture=m.texture,e.texShape=m.texShape,e.isPacked=m.isPacked,e.usage=m.usage,this.disposeIntermediateTensorInfo(p),this.texData.delete(f.dataId),e.values=null,l&&(this.uploadWaitMs+=Ew()-u)}else{const t=this.acquireTexture(c,o,s,a);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:s}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,s)),n.values}acquireTexture(t,e,n,s){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,s)}computeBytes(t,e){return t[0]*t[1]*Fg(e)}}XU.nextDataId=0,cx()&&V_("webgl",()=>new XU,2);class ZU{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=Ok(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class YU{constructor(t,e,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ok(e,n);const r=this.outputShape.length;let i="";if(s)if(0===r||1===wg(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${UW(r)} coords = getOutputCoords();\n        `,1===r)i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=DU("coords",r);i+=`\n            bool nextRowOutOfBounds =\n              (${t[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${t[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function QU(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const JU={kernelName:pb,backendName:"webgl",kernelFunc:QU};function tj(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.makeTensorInfo(s.shape,"complex64"),o=n.texData.get(i.dataId),a=QU({inputs:{x:s},backend:n}),l=QU({inputs:{x:r},backend:n});return o.complexTensorInfos={real:a,imag:l},i}const ej={kernelName:Sy,backendName:"webgl",kernelFunc:tj},nj="return (a < 0.) ? b * a : a;",sj="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",rj={kernelName:vb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:i}=s,o=n.makeTensorInfo([],"float32",Iw(i,"float32")),a=Yg().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new YU(sj,r.shape,o.shape):new ZU(nj,r.shape,o.shape),l=n.runWebGLProgram(a,[r,o],r.dtype);return n.disposeIntermediateTensorInfo(o),l}},ij="return (a < 0.) ? b * a : a;",oj="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",aj={kernelName:tv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,i=Yg().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new YU(oj,s.shape,r.shape):new ZU(ij,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}};function lj({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=n){const t=a.texData.get(o.dataId),e=n(t.values,l);return a.makeTensorInfo(o.shape,l,e)}let u;return u=Yg().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=e?new jU(o.shape,e):new VU(o.shape,t),a.runWebGLProgram(u,[o],l)}}function uj({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:u}=o,c=a;if(s&&"complex64"===l.dtype){const e=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[s,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,s]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},i={dataId:s.dataId,dtype:s.dtype,shape:u.shape},o=new ZU(t,l.shape,u.shape);return c.runWebGLProgram(o,[r,i],Yw(n.dtype,s.dtype))}),i=tj({inputs:{real:s,imag:r},backend:c});return c.disposeIntermediateTensorInfo(s),c.disposeIntermediateTensorInfo(r),i}const h=i||Yw(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=r){const t=c.texData.get(l.dataId).values,e=c.texData.get(u.dataId).values,n="string"===l.dtype?YS(t):t,s="string"===l.dtype?YS(e):e,[i,o]=r(l.shape,u.shape,n,s,h),a=c.makeTensorInfo(o,h);return c.texData.get(a.dataId).values=i,a}let d;return d=Yg().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new YU(e,l.shape,u.shape,n):new ZU(t,l.shape,u.shape),c.runWebGLProgram(d,[l,u],h)}}function cj(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===t)return e?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return e?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===t)return e?oj:ij;if("leakyrelu"===t)return e?sj:nj;if("sigmoid"===t)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class hj{constructor(t,e,n,s=!1,r=!1,i=!1,o=null,a=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const u=Math.ceil((s?t[1]:t[2])/2),c=s?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",d=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";o&&(f=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,m="result = activation(result);");const g=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",b="rc.x";t[0]<e[0]?y=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(b=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          int batchA = ${y};\n          int batchB = ${b};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class dj{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ok(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const pj="return a * b;";function fj(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,i=Yw(s.dtype,r.dtype);if("complex64"===s.dtype){const t=n.texData.get(s.dataId),e=n.texData.get(r.dataId),i=new dj("return areal * breal - aimag * bimag;",s.shape,r.shape),o=new dj("return areal * bimag + aimag * breal;",s.shape,r.shape),a=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(i,a,"float32"),u=n.runWebGLProgram(o,a,"float32"),c=tj({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([s,r])){const t=n.texData.get(s.dataId),e=n.texData.get(r.dataId),[o,a]=pU(s.shape,r.shape,t.values,e.values,i),l=n.makeTensorInfo(a,i);return n.texData.get(l.dataId).values=o,l}let o;return o=Yg().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new YU(pj,s.shape,r.shape):new ZU(pj,s.shape,r.shape),n.runWebGLProgram(o,[s,r],i)}const mj={kernelName:Ub,backendName:"webgl",kernelFunc:fj};function gj(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:i}=s,o=n,a=wg(r.shape),l=Sg(i,a),u=wg(l);gg(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(r.dataId);return!c.isPacked||lW(r.shape,l)||null!==c.texture&&lW(c.shape,l)?(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function(t,e,n){const s=[rW(t.shape),...iW(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[rW(e),...iW(e)],o=new LU(i,s),a=n.runWebGLProgram(o,[r],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}(r,l,o)}const yj={kernelName:ov,backendName:"webgl",kernelFunc:gj};class bj{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:i}=t;this.outputShape=[s,i];const o=4*Math.floor(n/4),a=n%4;let l="sumValue += dot(values, ones);";if(null!=e){const t=1/e;l=`sumValue += dot(values * ${_g(t)?t.toPrecision(2):t}, ones);`}let u="";r%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===a}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class vj{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:i}=t;this.outputShape=[s,i];let o="0.0",a="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",a="min"):"max"===e&&(o="-1.0 / 1e-20",a="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${a}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${a}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function wj(t,e,n,s){const r=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],s=hS(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}(t.shape);let i=t;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:u}=r[o];let c,h;c="mean"===n?0===o?new bj({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},a):new bj({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u}):new vj({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},n),h=i,i=s.runWebGLProgram(c,[i],e),h.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(h)}return i}class xj{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;const s=UW(this.rank),r=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class _j{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let u=0;u<n.length;u++)n[u]=t[e[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=UW(this.rank),r=FU("rc",this.rank),i=new Array(this.rank);for(let u=0;u<e.length;u++)i[e[u]]=r[u];const o=`vec2(${i.slice(-2).join()})`,a=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${a}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${a}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function kj(t,e,n){const s=Yg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _j(t.shape,e):new xj(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}function Cj(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s;return function(t,e,n,s){const r=t.shape.length,i=Eg(e,t.shape);let o=i;const a=cC(o,r),l=null!=a;let u=t;l&&(u=kj(t,a,s),o=dC(o.length,r)),uC("sum",o,r);const[c,h]=aC(u.shape,o);let d=c;n&&(d=lC(c,i));const p=wg(h),f=gj({inputs:{x:u},attrs:{shape:[wg(t.shape)/p,p]},backend:s}),m=wj(f,Qw(t.dtype),"sum",s),g=gj({inputs:{x:m},attrs:{shape:d},backend:s});return s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(m),l&&s.disposeIntermediateTensorInfo(u),g}(r,i,o,n)}const Ij={kernelName:Iv,backendName:"webgl",kernelFunc:Cj};function Sj(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:i}=s,o=n,a=new Array(r.shape.length);for(let u=0;u<a.length;u++)a[u]=r.shape[i[u]];let l;if(o.shouldExecuteOnCPU([r])){const t=o.texData.get(r.dataId),e=AU(t.values,r.shape,r.dtype,i,a);l=o.makeTensorInfo(a,r.dtype),o.texData.get(l.dataId).values=e}else l=kj(r,i,o);return l}const Ej={kernelName:Gv,backendName:"webgl",kernelFunc:Sj};function Tj({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,h=n?t.shape[u-2]:t.shape[u-1],d=s?e.shape[c-1]:e.shape[c-2],p=n?t.shape[u-1]:t.shape[u-2],f=s?e.shape[c-2]:e.shape[c-1],m=t.shape.slice(0,-2),g=e.shape.slice(0,-2),y=wg(m),b=wg(g);gg(u>=2&&c>=2&&(y===b||1===y||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const v=(y>b?t.shape.slice(0,-2):e.shape.slice(0,-2)).concat([p,f]);gg(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const w=n?[y,h,p]:[y,p,h],x=s?[b,f,d]:[b,d,f],_=gj({inputs:{x:t},backend:r,attrs:{shape:w}}),k=gj({inputs:{x:e},backend:r,attrs:{shape:x}}),C=[_,k],I=Math.max(y,b),S=n?_.shape[1]:_.shape[2],E=null!=i,T=null!=o,N="leakyrelu"===l,$=null!=l?cj(l,!0):null;let A;if((1===p||1===f)&&S>1e3&&!1===(E||T||N||null!=$)){let t=_,e=k;n&&(t=Sj({inputs:{x:_},backend:r,attrs:{perm:[0,2,1]}}),C.push(t)),s&&(e=Sj({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),C.push(e));const i=1===f;let o=t;1!==f&&(o=gj({inputs:{x:t},backend:r,attrs:{shape:[I,S,1]}}),C.push(o));const a=1===f?2:1;let l=e;i&&(l=gj({inputs:{x:e},backend:r,attrs:{shape:[I,1,S]}}),C.push(l));const u=fj({inputs:{a:o,b:l},backend:r});A=Cj({inputs:{x:u},backend:r,attrs:{axis:a,keepDims:!0}}),C.push(u)}else{const l=Yw(t.dtype,e.dtype),u=new hj(w,x,[I,p,f],n,s,E,$,T,N),c=[_,k];if(null!=i&&c.push(i),T&&c.push(o),N){const t=r.makeTensorInfo([],"float32",Iw(a,"float32"));c.push(t),C.push(t)}A=r.runWebGLProgram(u,c,l)}const R=gj({inputs:{x:A},backend:r,attrs:{shape:v}});C.push(A);for(const F of C)r.disposeIntermediateTensorInfo(F);return R}const Nj={kernelName:tw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return Tj({a:r,b:i,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}},$j="return abs(x);",Aj={kernelName:ny,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const t=n.texData.get(s.dataId),e=vU(t.values);return n.makeTensorInfo(s.shape,s.dtype,e)}let r;return r=Yg().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new jU(s.shape,$j):new VU(s.shape,$j),n.runWebGLProgram(r,[s],s.dtype)}},Rj=lj({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Fj={kernelName:sy,backendName:"webgl",kernelFunc:Rj},Dj=lj({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Oj={kernelName:ry,backendName:"webgl",kernelFunc:Dj},Lj="return a + b;",Mj=uj({opSnippet:Lj,packedOpSnippet:Lj,supportsComplex:!0,cpuKernelImpl:qW}),Pj={kernelName:iy,backendName:"webgl",kernelFunc:Mj};class zj{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const s=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class Bj{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const s=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const Vj={kernelName:oy,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s}=e,r=n;if(1===r.length)return QU({inputs:{x:r[0]},backend:s});if(r.length>Yg().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(r.length/2),n=t({inputs:r.slice(0,e),backend:s}),i=t({inputs:r.slice(e),backend:s});return t({inputs:[n,i],backend:s})}const i=r.map(t=>t.dtype).reduce((t,e)=>Yw(t,e)),o=r.map(t=>t.shape),a=Yg().getBool("WEBGL_PACK")?new Bj(r[0].shape,o):new zj(r[0].shape,o);return s.runWebGLProgram(a,r,i)}},Wj={kernelName:ay,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=Eg(i,r.shape);let u=l;const c=cC(u,a);let h=r;null!=c&&(h=Sj({inputs:{x:r},backend:n,attrs:{perm:c}}),u=dC(u.length,a)),uC("all",u,a);const[d,p]=aC(h.shape,u),f=gj({inputs:{x:h},backend:n,attrs:{shape:[-1,wg(p)]}}),m=wj(f,f.dtype,"all",n);let g;return g=gj(o?{inputs:{x:m},backend:n,attrs:{shape:lC(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},Uj={kernelName:ly,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=Eg(i,r.shape);let u=l;const c=cC(u,a);let h=r;null!=c&&(h=Sj({inputs:{x:r},backend:n,attrs:{perm:c}}),u=dC(u.length,a)),uC("any",u,a);const[d,p]=aC(h.shape,u),f=gj({inputs:{x:h},backend:n,attrs:{shape:[-1,wg(p)]}}),m=wj(f,f.dtype,"any",n);let g;return g=gj(o?{inputs:{x:m},backend:n,attrs:{shape:lC(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class jj{constructor(t,e,n){this.variableNames=["A"];const{windowSize:s,batchSize:r,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Hj{constructor(t,e,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,gg(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const r=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),r>1&&this.outputShape.push(r),s||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,a=UW(o),l=DU("coords",o);let u,c;if(1===r){c=o+1;const t=UW(c);u=`\n        ${t} sourceLocR = ${t}(${l.join()}, 0);\n        ++${l[o-1]};\n        ${t} sourceLocG = ${t}(${l.join()}, 0);\n        ++${l[o-2]};\n        ${t} sourceLocA = ${t}(${l.join()}, 0);\n        --${l[o-1]};\n        ${t} sourceLocB = ${t}(${l.join()}, 0);\n        --${l[o-2]};`}else c=o,u=`\n        ${a} sourceLocR = coords;\n        ++${l[o-1]};\n        ${a} sourceLocG = coords;\n        ++${l[o-2]};\n        ${a} sourceLocA = coords;\n        --${l[o-1]};\n        ${a} sourceLocB = coords;\n        --${l[o-2]};`;const h=["x","y","z","w","u","v"].slice(0,c),d="."+h[c-1],p=h.map(t=>"int "+t),f=DU("sourceLocR",c-1).concat("inIdx.r"),m=DU("sourceLocG",c-1).concat("inIdx.g"),g=DU("sourceLocB",c-1).concat("inIdx.b"),y=DU("sourceLocA",c-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",v=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,x=s?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${x}\n      void main() {\n        ${a} coords = getOutputCoords();\n        bool hasNextCol = ${l[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${l[o-2]} < ${i[o-2]-1};\n        ${u}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Gj(t,e,n,s=null){let r=e.shape[0],i=e.shape[1];null!=s&&(r=s.shape[0],i=s.shape[1]);const o=hS(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new jj(a,n,null==s),u=[e];null!=s&&u.push(s);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=Gj(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function qj(t,e,n,s=null){const r=null!=s?s.shape:e.shape,i=hS(r[r.length-1]),o=new Hj(r,i,n,null==s),a=t.runWebGLProgram(o,null==s?[e]:[e,s],"int32");if(a.shape.length===e.shape.length){const s=qj(t,e,n,a);return t.disposeIntermediateTensorInfo(a),s}return a}function Kj(t,e,n,s){const r=[n];if(uC("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!Yg().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],[i,o]=aC(e.shape,r),a=wg(o),l=gj({inputs:{x:e},backend:t,attrs:{shape:[-1,a]}});n.push(l);const u=Gj(t,l,s);n.push(u);const c=gj({inputs:{x:u},backend:t,attrs:{shape:i}});return n.forEach(e=>t.disposeIntermediateTensorInfo(e)),c}return qj(t,e,s)}const Xj={kernelName:uy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;let o=Eg(i,r.shape);const a=cC(o,r.shape.length);let l=r;const u=[];null!=a&&(l=Sj({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=dC(o.length,l.shape.length)),uC("argMax",[o[0]],l.shape.length);const c=Kj(n,l,o[0],"max");return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),c}},Zj={kernelName:cy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;let o=Eg(i,r.shape);const a=cC(o,r.shape.length);let l=r;const u=[];null!=a&&(l=Sj({inputs:{x:r},backend:n,attrs:{perm:a}}),u.push(l),o=dC(o.length,l.shape.length)),uC("argMin",[o[0]],l.shape.length);const c=Kj(n,l,o[0],"min");return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),c}},Yj=lj({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Qj={kernelName:hy,backendName:"webgl",kernelFunc:Yj},Jj=lj({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),tH={kernelName:dy,backendName:"webgl",kernelFunc:Jj},eH=lj({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),nH={kernelName:py,backendName:"webgl",kernelFunc:eH},sH=uj({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),rH={kernelName:my,backendName:"webgl",kernelFunc:sH},iH=lj({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),oH={kernelName:fy,backendName:"webgl",kernelFunc:iH};class aH{constructor(t,e,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${a});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?r?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(g="avgValue / count");const y=4*Math.floor(i/4),b=i%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class lH{constructor(t,e,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const b="avg"===e;let v="0.0";if(b||(v="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${a}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?r?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(w="avgValue / count");const x=4*Math.floor(i/4),_=i%4,k=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${a}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${x};\n            if (${1===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n          setOutput(${w});\n        }\n      }\n    `}}const uH={kernelName:gy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;fW(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s;gg(ak(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Y_(r.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&xg(u.inShape,u.outShape))return QU({inputs:{x:r},backend:n});const c=new aH(u,"avg",!1);return n.runWebGLProgram(c,[r],"float32")}},cH={kernelName:by,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s,c=Q_(r.shape,i,o,[1,1,1],a,l,u),h=new lH(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class hH{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class dH{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const pH={kernelName:vy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=Q_(o.shape,a,l,[1,1,1],u,c),d=new dH(h);return n.runWebGLProgram(d,[r],o.dtype)}},fH={kernelName:yy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i;fW([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=Y_(o.shape,a,l,1,u),h=new hH(c);return n.runWebGLProgram(h,[r],o.dtype)}},mH={kernelName:wy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;return Tj({a:r,b:i,transposeA:o,transposeB:a,backend:n})}};class gH{constructor(t,e,n,s,r,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Ok(t,e),Ok(t,n);let o="0.0";null!=s&&(Ok(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="1.0";null!=r&&(Ok(t,r),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class yH{constructor(t,e,n,s,r,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ok(t,e),Ok(t,n);let o="vec4(0.0)";null!=s&&(Ok(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=r&&(Ok(t,r),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const bH={kernelName:lb,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=t;gg(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),gg(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),gg(null==a||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[s,r,i];let c=null;null!=o&&(c=o.shape,u.push(o));let h=null;null!=a&&(h=a.shape,u.push(a));const d=Yg().getBool("WEBGL_PACK_NORMALIZATION")?new yH(s.shape,r.shape,i.shape,c,h,l):new gH(s.shape,r.shape,i.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)}};class vH{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=UW(this.rank),n=`uniform int start[${this.rank}];`,s=function(t){if(1===t)return"sourceLoc";if(t<=6)return wH.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${wH[e]} = start[${e}] + coords.${wH[e]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const wH=["x","y","z","w","u","v"];class xH{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=UW(this.rank),n=DU("coords",this.rank),s=DU("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${r})`,o=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,a=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${s[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${a}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}function _H(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:o}=s,[a,l]=A_(r,i,o);if(y_(r,a,l),0===wg(l))return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const t=n.texData.get(r.dataId),e=wU(t.values,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,e)}const{isPacked:u}=n.texData.get(r.dataId),c=N_(r.shape,a,l);if(u||!c){const t=Yg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xH(l):new vH(l),e=t.getCustomSetupFunc(a);return n.runWebGLProgram(t,[r],r.dtype,e)}return n.uploadToGPU(r.dataId),function(t,e,n,s){const r=s.texData.get(t.dataId),i=s.makeTensorInfo(n,t.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=t.dtype;let a=$_(e,zg(t.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),i}(r,a,l,n)}const kH={kernelName:bv,backendName:"webgl",kernelFunc:_H},CH={kernelName:xy,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:o}=s;gg(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((t,e)=>t*e),l=pS(r.shape,i,a),u=fS(l.length,i.length),c=mS(r.shape,i,a),h=gS(o,i.length),d=yS(c,o,i.length),p=[],f=gj({inputs:{x:r},backend:n,attrs:{shape:l}}),m=Sj({inputs:{x:f},backend:n,attrs:{perm:u}}),g=gj({inputs:{x:m},backend:n,attrs:{shape:c}}),y=_H({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(t=>n.disposeIntermediateTensorInfo(t)),y}},IH={kernelName:_y,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o}=s,a=n.readSync(r.dataId),l=n.readSync(i.dataId),u=KW(a,l,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,u)}},SH=uj({opSnippet:"return float(a != b);",cpuKernelImpl:mU,dtype:"bool"}),EH={kernelName:Hb,backendName:"webgl",kernelFunc:SH};function TH(t){const{inputs:e,backend:n}=t,{input:s}=e;return QU({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.real},backend:n})}const NH={kernelName:sv,backendName:"webgl",kernelFunc:TH},$H={kernelName:ky,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s,attrs:r}=e,{x:i}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===i.dtype)return QU({inputs:{x:i},backend:s});const e=bC(i.shape),n=t({inputs:{x:i},backend:s,attrs:{dtype:"float32"}}),r=tj({inputs:{real:n,imag:e},backend:s});return e.dispose(),s.disposeIntermediateTensorInfo(n),r}if("complex64"===i.dtype){const e=TH({inputs:{input:i},backend:s}),n=t({inputs:{x:e},backend:s,attrs:{dtype:o}});return s.disposeIntermediateTensorInfo(e),n}if(!Ag(i.dtype,o)){const t=QU({inputs:{x:i},backend:s});return{dataId:t.dataId,shape:t.shape,dtype:o}}if("int32"===o)return function(t,e){const n=new VU(t.shape,"return float(int(x));"),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(i,s);if("bool"===o){const t=s.makeTensorInfo([],"bool",Ng("bool",1)),e=SH({inputs:{a:i,b:t},backend:s});return s.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${o}`)}},AH="return ceil(x);",RH=lj({opSnippet:AH,packedOpSnippet:AH,cpuKernelImpl:ZW}),FH={kernelName:Cy,backendName:"webgl",kernelFunc:RH};class DH{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class OH{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}const LH={kernelName:Iy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let a;a=Yg().getBool("WEBGL_PACK_CLIP")?new OH(r.shape):new DH(r.shape);const l=a.getCustomSetupFunc(i,o);return n.runWebGLProgram(a,[r],r.dtype,l)}};class MH{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function PH(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const zH={kernelName:Ey,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),i=new MH(s.shape),o=[PH(s,r.complexTensorInfos.real),PH(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(i,o,o[0].dtype)}};class BH{constructor(t){this.outputShape=[],this.outputShape=uS(t,1),this.variableNames=t.map((t,e)=>`T${e}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<e.length;s++)n.push(`else if (yC < ${e[s]}) setOutput(getT${s}(yR, yC-${e[s-1]}));`);n.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class VH{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=uS(t,e);const n=this.outputShape,s=n.length,r=UW(s),i=DU("coords",s),o=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((t,e)=>`T${e}`);const a=new Array(t.length-1);a[0]=t[0][e];for(let p=1;p<a.length;p++)a[p]=a[p-1]+t[p][e];const l=o[e],u=o.slice(-2),c=o.join();let h=`if (${l} < ${a[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let p=1;p<a.length;p++){const t=a[p-1];h+=`\n        if (${l} < ${a[p]}  && ${l} >= ${a[p-1]}) {\n          return getChannel(\n            getT${p}(${WH(o,l,t)}),\n            vec2(${WH(u,l,t)}));\n        }`}const d=a[a.length-1];h+=`\n        return getChannel(\n          getT${a.length}(${WH(o,l,d)}),\n          vec2(${WH(u,l,d)}));`,this.userCode=`\n      float getValue(${o.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${n[s-2]} &&\n            ${i[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function WH(t,e,n){const s=t.indexOf(e);return t.map((t,e)=>e===s?`${t} - ${n}`:t).join()}function UH(t){const{inputs:e,backend:n}=t,{input:s}=e;return QU({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.imag},backend:n})}const jH={kernelName:mb,backendName:"webgl",kernelFunc:UH};function HH(t,e,n){const s=t[0].dtype;if("complex64"===s){const s=t.map(t=>TH({inputs:{input:t},backend:n})),r=t.map(t=>UH({inputs:{input:t},backend:n})),i=HH(s,e,n),o=HH(r,e,n),a=tj({inputs:{real:i,imag:o},backend:n});return s.forEach(t=>n.disposeIntermediateTensorInfo(t)),r.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),a}let r=n.shouldExecuteOnCPU(t);if("string"===s&&(r=!0),r){const r=t.map(t=>{const s=wg(t.shape.slice(e));return gj({inputs:{x:t},backend:n,attrs:{shape:[-1,s]}})}),i=r.map(t=>({vals:n.readSync(t.dataId),shape:t.shape})),o=uS(r.map(t=>t.shape),1),a=YW(i,o,s,1===r[0].shape[0]),l=uS(t.map(t=>t.shape),e),u=n.makeTensorInfo(l,s,a);return r.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}if(t.length>Yg().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const s=Math.floor(t.length/2),r=HH(t.slice(0,s),e,n),i=HH(t.slice(s),e,n),o=HH([r,i],e,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),o}if(Yg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const r=new VH(t.map(t=>t.shape),e);return n.runWebGLProgram(r,t,s)}const{tensors2D:i,outShape:o}=function(t,e,n){const s=uS(t.map(t=>t.shape),e);return{tensors2D:t.map(t=>gj({inputs:{x:t},attrs:{shape:[-1,wg(t.shape.slice(e))]},backend:n})),outShape:s}}(t,e,n),a=new BH(i.map(t=>t.shape)),l=n.runWebGLProgram(a,i,s);i.forEach(t=>n.disposeIntermediateTensorInfo(t));const u=gj({inputs:{x:l},attrs:{shape:o},backend:n});return n.disposeIntermediateTensorInfo(l),u}function GH(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,i=Eg(r,e[0].shape)[0],o=uS(e.map(t=>t.shape),i);if(0===wg(o))return n.makeTensorInfo(o,e[0].dtype,[]);const a=e.filter(t=>wg(t.shape)>0);return 1===a.length?QU({inputs:{x:a[0]},backend:n}):(lS(a.map(t=>t.shape),i),HH(a,i,n))}const qH={kernelName:Ty,backendName:"webgl",kernelFunc:GH};class KH{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,m="channelsLast"===t.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",w="";n&&(v=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${w}\n        setOutput(result);\n      }\n    `}}class XH{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,s=t.padInfo.left,r=t.strideDepth,i=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${i}, ${o});\n      const ivec3 pads = ivec3(${e}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ZH{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:s,inChannels:r,strideWidth:i,strideHeight:o,padInfo:a,outWidth:l,dilationWidth:u,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=a,f=r*s,m=gW(),g="channelsLast"===h,y=g?0:1,b=g?1:2;let v="";for(let w=0;w<=1;w++)for(let n=0;n<=1;n++)v+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${w};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${o} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${i}. - ${d}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${r}.));\n\n              if(d1 < ${e[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*w+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*w+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${m.output} = result;\n      }\n    `}}function YH({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.shape,u=s.texData.get(t.dataId),c="channelsLast"===n.dataFormat;let h;const d=[],p=l[2]%2!=0&&!!u.isPacked;if((1!=l[0]*l[1]*l[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&Yg().getBool("WEBGL_LAZILY_UNPACK")&&Yg().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&p){const p={dataId:t.dataId,shape:[1,c?l[0]*l[1]*(l[2]+1):l[0]*l[2]*(l[3]+1),n.inChannels],dtype:t.dtype},f=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,gg(lW(u.shape,p.shape),()=>`packed reshape ${u.shape} to ${p.shape} isn't free`);const m=gj({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});d.push(m);const g=Tj({a:p,b:m,backend:s,transposeA:!1,transposeB:!1,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),y=s.texData.get(g.dataId);gg(y.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=f,y.shape=n.outShape,h=QU({inputs:{x:g},backend:s}),h.shape=n.outShape,d.push(g)}else{const u=gj({inputs:{x:t},backend:s,attrs:{shape:[1,c?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],n.inChannels]}}),p=gj({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=Tj({a:u,b:p,transposeA:!1,transposeB:!1,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});h=gj({inputs:{x:f},backend:s,attrs:{shape:n.outShape}}),d.push(u),d.push(p),d.push(f)}for(const f of d)s.disposeIntermediateTensorInfo(f);return h}function QH({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,g=d*h,y=[m,g],b=[],v=gj({inputs:{x:t},backend:s,attrs:{shape:t.shape.slice(1)}}),w=gj({inputs:{x:e},backend:s,attrs:{shape:[1,m,wg(e.shape)/m]}});b.push(v),b.push(w);const x=new ZH(y,v.shape,n),_=s.runWebGLProgram(x,[v],"float32"),k=gj({inputs:{x:_},backend:s,attrs:{shape:[1,y[0],y[1]]}});b.push(_),b.push(k);const C=null!=r,I=null!=i,S="leakyrelu"===a,E=a?cj(a,!0):null,T=new hj(k.shape,w.shape,[1,g,n.outChannels],!0,!1,C,E,I,S),N=[k,w];if(r&&N.push(r),I&&N.push(i),S){const t=s.makeTensorInfo([],"float32",Iw(o,"float32"));N.push(t),b.push(t)}const $=s.runWebGLProgram(T,N,"float32"),A=gj({inputs:{x:$},backend:s,attrs:{shape:f?[1,d,h,n.outChannels]:[1,n.outChannels,d,h]}});b.push($);for(const R of b)s.disposeIntermediateTensorInfo(R);return A}const JH={kernelName:Ny,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=lk(l),d=J_(r.shape,i.shape,o,u,a,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(Yg().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])p=QH({x:r,filter:i,convInfo:d,backend:n});else{const t=new KH(d);p=n.runWebGLProgram(t,[r,i],"float32")}else p=YH({x:r,filter:i,convInfo:d,backend:n});const f=gj({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class tG{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class eG{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,s="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${s?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class nG{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class sG{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const rG={kernelName:$y,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=lk(l),d=J_(r.shape,c,o,1,a,u,!1,h),p=new tG(d);return n.runWebGLProgram(p,[r,i],"float32")}},iG={kernelName:Ay,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=lk(u),d=J_(o,i.shape,a,1,l,c,!1,h),p=new eG(d);return n.runWebGLProgram(p,[r,i],"float32")}},oG={kernelName:Ry,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,u=tk(r.shape,i.shape,o,l,a),c=new XH(u);return n.runWebGLProgram(c,[r,i],"float32")}},aG={kernelName:Fy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s,u=tk(r.shape,l,o,1,a),c=new nG(u);return n.runWebGLProgram(c,[r,i],"float32")}},lG={kernelName:Dy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s,u=tk(l,i.shape,a,1,o),c=new sG(u);return n.runWebGLProgram(c,[r,i],"float32")}},uG=lj({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),cG={kernelName:Oy,backendName:"webgl",kernelFunc:uG},hG=lj({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),dG={kernelName:Ly,backendName:"webgl",kernelFunc:hG};class pG{constructor(t,e,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,a,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===s?1:0,[p,f]=[o-1+".0",a-1+".0"],[m,g,y]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,w]=h>1?[""+(a-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const fG={kernelName:Py,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=s,c=new pG(r.shape,i.shape,a,l,u);return n.runWebGLProgram(c,[r,i,o],"float32")}};class mG{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const s=t.length,r=e?"0.0":`getX(${gG(s,"coords")})`,i=t[t.length-1];let o="",a="";e?(o=n?"end != "+(i-1):"end != 0",a=n?"end + 1":"end - 1"):(o=n?`end + pow2 < ${i}`:"end >= pow2",a=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${UW(s)} coords = getOutputCoords();\n        int end = ${yG(s,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${a};\n          ${yG(s,"coords")} = idx;\n          val += getX(${gG(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function gG(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function yG(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}const bG={kernelName:My,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s,l=r.shape.length,u=cC([i],l);let c=r;null!=u&&(c=Sj({inputs:{x:r},backend:n,attrs:{perm:u}}));const h=dC(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${i}`);const d=c.shape[h];let p=QU({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){const t=new mG(c.shape,!1,a),e=t.getCustomSetupFunc(f),s=p;p=n.runWebGLProgram(t,[p],p.dtype,e),n.disposeIntermediateTensorInfo(s)}if(o){const t=new mG(c.shape,o,a),e=p;p=n.runWebGLProgram(t,[p],p.dtype),n.disposeIntermediateTensorInfo(e)}if(null!=u){const t=Sj({inputs:{x:p},backend:n,attrs:{perm:hC(u)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),t}return p}},vG={kernelName:zy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(1===r.shape.length){const t=n.readSync(r.dataId),e=n.readSync(i.dataId),s=KW(t,e,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,s)}if(2===r.shape.length){const t=n.bufferSync(r),e=n.bufferSync(i),s=XW(t,e,o,a);return n.makeTensorInfo(s.shape,i.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class wG{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const xG={kernelName:By,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:i,dataFormat:o}=s;gg(i>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${i}`);const a=r.shape[0],l=("NHWC"===o?r.shape[1]:r.shape[2])*i,u=("NHWC"===o?r.shape[2]:r.shape[3])*i,c=("NHWC"===o?r.shape[3]:r.shape[1])/(i*i),h=new wG("NHWC"===o?[a,l,u,c]:[a,c,l,u],i,o);return n.runWebGLProgram(h,[r],r.dtype)}};class _G{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.inHeight,o=t.inWidth,a=t.padInfo.top,l=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=t.outChannels/t.inChannels;let g="",y="";n&&(g=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${a}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${o}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${y}\n        setOutput(result);\n      }\n    `}}class kG{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const i=t.outChannels/t.inChannels,o=t.inHeight,a=t.inWidth,l=t.padInfo.top,u=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,f=t.filterHeight,m=t.filterWidth,g=m;let y="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let x=0;x<m;x++)y+=`\n          vec4 xTexelC${2*x};\n          int xTexelC${2*x}Ready;\n          vec4 xC${x};`;for(let x=0;x<f;x++){for(let t=0;t<m;t++)y+=`\n          xTexelC${2*t} = vec4(0.0);\n          xTexelC${2*t}Ready = 0;\n          xC${t} = vec4(0.0);`;y+=`\n        xR = xRCorner + ${x*d};\n        if (xR >=0 && xR < ${o}) {\n      `;for(let t=0;t<(g+1)/2;t++){const e=2*t,n=e*p;if(y+=`\n          xC = xCCorner + ${n};\n          `,1===h){if(e<m&&(u%2==1?(y+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,y+=1===p&&n>0?`\n                xC${e} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${a}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${a}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):y+=`\n                if (xC >= 0 && xC < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${e} = xTexelC${n};\n                `,n+1<m)){const t=u%2==0?mg(p):p;p%2==0&&u%2==1||p%2!=0&&u%2!=1?(y+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${a}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,p>1&&(y+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),y+=`\n                  xC${e+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):y+=1===t?`\n                    xC${e+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${a}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${n+2};\n                    `}}else n<m&&(u%2==1?(y+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${a}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<m&&(y+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<m&&(y+=`\n                  xC${e+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));e<m&&(y+=`\n            wTexel = getW(${x}, ${n}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<m&&(y+=`\n              wTexel = getW(${x}, ${n+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}y+="\n        }\n      "}let b="",v="";n&&(b=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,v="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${y}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}const CG={kernelName:Vy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=s;let c=l;null==c&&(c=[1,1]),gg(ak(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=J_(r.shape,i.shape,o,c,a,u,!0);let d;return d=Yg().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new kG(h):new _G(h),n.runWebGLProgram(d,[r,i],"float32")}};class IG{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SG{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,s=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const EG={kernelName:Wy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s,h=J_(r.shape,c,o,a,l,u,!0),d=new IG(h);return n.runWebGLProgram(d,[r,i],"float32")}},TG={kernelName:Uy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s,h=J_(c,i.shape,o,a,l,u,!0),d=new SG(h);return n.runWebGLProgram(d,[r,i],"float32")}};class NG{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const $G={kernelName:jy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],i=wg(s.shape),o=gj({inputs:{x:s},backend:n,attrs:{shape:[i]}}),a=new NG(i),l=n.runWebGLProgram(a,[o],o.dtype),u=gj({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}};class AG{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:s,strideHeight:r,strideWidth:i,filterHeight:o,filterWidth:a,dilationHeight:l,dilationWidth:u}=t,{top:c,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${i});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${a}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const RG={kernelName:Hy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,u=Z_(r.shape,i.shape,o,a,"NHWC",l);let c;const h=new AG(u);c=n.runWebGLProgram(h,[r,i],"float32");const d=gj({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}},FG={kernelName:Xy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=VS(r,i.length);US(o.length,l,i);const{path:u,steps:c}=jS(a,l),h=c.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const t of c[m]){const{permutationIndices:e,expandDims:s}=WS(p,l[t]);let r;HS(e)?r=i[t]:(r=Sj({inputs:{x:i[t]},backend:n,attrs:{perm:e}}),f.push(r));const o=r.shape.slice();for(let t=0;t<s.length;++t)o.splice(s[t],0,1);xg(r.shape,o)||(r=gj({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=fj({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=Cj({inputs:{x:d},backend:n,attrs:{axis:u[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},DG=lj({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),OG={kernelName:Zy,backendName:"webgl",kernelFunc:DG},LG={kernelName:Yy,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,i=Yg().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new YU("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new ZU("return (b >= 1.0) ? a : a * (b + 1.0);",s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}},MG=uj({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:QW}),PG={kernelName:Jy,backendName:"webgl",kernelFunc:MG},zG=lj({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${CS};\n  float a1 = ${IS};\n  float a2 = ${SS};\n  float a3 = ${ES};\n  float a4 = ${TS};\n  float a5 = ${NS};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),BG={kernelName:Qy,backendName:"webgl",kernelFunc:zG},VG="return exp(x);",WG=lj({opSnippet:VG,packedOpSnippet:VG,cpuKernelImpl:JW}),UG={kernelName:tb,backendName:"webgl",kernelFunc:WG};function jG(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(gg(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),gj({inputs:{x:i},backend:s,attrs:{shape:a}})}const HG={kernelName:eb,backendName:"webgl",kernelFunc:jG},GG="return exp(x) - 1.0;",qG=lj({opSnippet:GG,packedOpSnippet:GG,cpuKernelImpl:tU}),KG={kernelName:nb,backendName:"webgl",kernelFunc:qG};class XG{constructor(t,e,n){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${s}.0`:"1.0";let o;if("real"===t)o="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function ZG(t,e,n){const s=n.texData.get(t.dataId),r=wg(t.shape),i=t.shape[t.shape.length-1],o=gj({inputs:{x:t},backend:n,attrs:{shape:[r/i,i]}}),a=o.shape,l=new XG("real",a,e),u=new XG("imag",a,e),c=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:a},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:a}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=tj({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=gj({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),f}const YG={kernelName:sb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e;return ZG(s,!1,n)}};class QG{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}function JG(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:i}=n;if(i=i||Lg(r),"string"===i){const t=$g(i,wg(s));return t.fill(r),e.makeTensorInfo(s,i,t)}{const t=new QG(s,r),n=t.getCustomSetupFunc(r);return e.runWebGLProgram(t,[],i,n)}}const tq={kernelName:rb,backendName:"webgl",kernelFunc:JG};class eq{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const nq={kernelName:ib,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new eq(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}},sq="return floor(x);",rq=lj({opSnippet:sq,packedOpSnippet:sq,cpuKernelImpl:eU}),iq={kernelName:ob,backendName:"webgl",kernelFunc:rq},oq=uj({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),aq={kernelName:ab,backendName:"webgl",kernelFunc:oq};class lq{constructor(t){this.variableNames=["A"];const e=gW(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class uq{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=gW(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const cq={kernelName:Qv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:i}=s,o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,u]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,i];(a||o)&&(null==hq&&(hq=document.createElement("canvas").getContext("2d")),hq.canvas.width=l,hq.canvas.height=u,hq.drawImage(r,0,0,l,u),r=hq.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=WV.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=Yg().getBool("WEBGL_PACK")?new uq(h):new lq(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let hq;const dq={kernelName:ew,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=lk(c),g=J_(r.shape,i.shape,l,h,u,d,!1,m);let y;const b=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(Yg().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])y=QH({x:r,filter:i,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const t=null!=o,e=null!=a,s="leakyrelu"===p,l=p?cj(p,!1):null,u=new KH(g,t,l,e,s),c=[r,i];if(o&&c.push(o),a&&c.push(a),s){const t=n.makeTensorInfo([],"float32",Iw(f,"float32"));c.push(t),b.push(t)}y=n.runWebGLProgram(u,c,"float32")}else y=YH({x:r,filter:i,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});const v=gj({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(t=>n.disposeIntermediateTensorInfo(t)),v}},pq={kernelName:nw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let m=c;null==m&&(m=[1,1]),gg(ak(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=J_(r.shape,i.shape,l,m,u,h,!0),y=Yg().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=d?cj(d,y):null,v=[r,i],w=null!=o,x=null!=a,_="leakyrelu"===d;if(w&&v.push(o),x&&v.push(a),_){const t=n.makeTensorInfo([],"float32",Iw(p,"float32"));v.push(t),f.push(t)}let k;k=y?new kG(g,w,b,x,_):new _G(g,w,b,x,_);const C=n.runWebGLProgram(k,v,"float32");return f.forEach(t=>n.disposeIntermediateTensorInfo(t)),C}};class fq{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const s=UW(e.length),r=UW(n.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const mq={kernelName:cb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],a=wg(s.shape),[l,u,c,h]=bS(s,r),d=gj({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),p=gj({inputs:{x:s},backend:n,attrs:{shape:[wg(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||"string"===s.dtype){const t=n.readSync(r.dataId),e=n.bufferSync(s),i=nU(t,e,s.dtype,u,o,c,h,s.shape,a);return n.makeTensorInfo(l,s.dtype,i.values)}const f=new fq(o,h,[u,c]),m=n.runWebGLProgram(f,[p,d],p.dtype),g=gj({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class gq{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=UW(this.rank),s=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)s.push(2===r?"int(getIndices(resRC.x, resRC.z))":`${n[r]}`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}const yq={kernelName:ub,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:i}=e,{axis:o,batchDims:a}=s,l=ZS(r,i,Eg(o,r.shape)[0],a),u=wg(i.shape),c=[],h=gj({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=gj({inputs:{x:i},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});c.push(h),c.push(d);const p=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const t=n.bufferSync(d),e=n.bufferSync(h),s=sU(e,t,p);return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(l.outputShape,s.dtype,s.values)}const f=new gq(h.shape,p),m=n.runWebGLProgram(f,[h,d],h.dtype);c.push(m);const g=gj({inputs:{x:m},backend:n,attrs:{shape:l.outputShape}});return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),g}},bq=uj({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:rU,dtype:"bool"}),vq={kernelName:hb,backendName:"webgl",kernelFunc:bq},wq=uj({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:iU}),xq={kernelName:db,backendName:"webgl",kernelFunc:wq},_q={kernelName:fb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e;return ZG(s,!0,n)}},kq=lj({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Cq={kernelName:gb,backendName:"webgl",kernelFunc:kq},Iq=lj({opSnippet:"return float(isinf(x));",dtype:"bool"}),Sq={kernelName:yb,backendName:"webgl",kernelFunc:Iq},Eq=lj({opSnippet:"return float(isnan(x));",dtype:"bool"}),Tq={kernelName:bb,backendName:"webgl",kernelFunc:Eq},Nq=uj({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:oU,dtype:"bool"}),$q={kernelName:wb,backendName:"webgl",kernelFunc:Nq},Aq=uj({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:aU,dtype:"bool"}),Rq={kernelName:xb,backendName:"webgl",kernelFunc:Aq},Fq={kernelName:_b,backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,o=lU(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}},Dq=lj({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:uU}),Oq={kernelName:kb,backendName:"webgl",kernelFunc:Dq},Lq=lj({opSnippet:"return log(1.0 + x);"}),Mq={kernelName:Cb,backendName:"webgl",kernelFunc:Lq},Pq=uj({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),zq={kernelName:Ib,backendName:"webgl",kernelFunc:Pq},Bq=lj({opSnippet:"return float(!(x >= 1.0));"}),Vq={kernelName:Sb,backendName:"webgl",kernelFunc:Bq},Wq=uj({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Uq={kernelName:Eb,backendName:"webgl",kernelFunc:Wq};class jq{constructor(t,e,n,s,r){this.variableNames=["x"],this.outputShape=[];const i=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${s}) * sum`;a=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}class Hq{constructor(t,e,n,s,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${s}) * sum`;a=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${a};\n        setOutput(result);\n      }\n    `}}const Gq={kernelName:Tb,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s,u=Yg().getBool("WEBGL_PACK_NORMALIZATION")?new Hq(r.shape,i,o,a,l):new jq(r.shape,i,o,a,l);return n.runWebGLProgram(u,[r],r.dtype)}};class qq{constructor(t,e,n,s,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=s,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Kq={kernelName:Nb,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s,h=new qq(r.shape,a,l,u,c);return n.runWebGLProgram(h,[r,i,o],r.dtype)}};function Xq(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,l=Eg(i,r.shape);let u=l;const c=cC(u,a),h=null!=c,d=n.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const t=n.texData.get(p.dataId).values,e=new Array(a);for(let n=0;n<e.length;n++)e[n]=r.shape[c[n]];const s=AU(t,r.shape,r.dtype,c,e);p=n.makeTensorInfo(e,r.dtype),n.texData.get(p.dataId).values=s}else p=kj(r,c,n);u=dC(u.length,a)}uC("max",u,a);const[f,m]=aC(p.shape,u);let g,y=f;if(o&&(y=lC(f,l)),d){const t=n.texData.get(p.dataId),e=cU(t.values,wg(m),y,r.dtype);g=n.makeTensorInfo(y,r.dtype),n.texData.get(g.dataId).values=e}else g=function(t,e,n,s){const r=wg(e),i=gj({inputs:{x:t},attrs:{shape:[wg(t.shape)/r,r]},backend:s}),o=wj(i,t.dtype,"max",s),a=gj({inputs:{x:o},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(o),a}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const Zq={kernelName:$b,backendName:"webgl",kernelFunc:Xq},Yq=uj({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:hU}),Qq={kernelName:Ab,backendName:"webgl",kernelFunc:Yq},Jq={kernelName:Rb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;fW(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s;gg(ak(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Y_(r.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&xg(u.inShape,u.outShape))return QU({inputs:{x:r},backend:n});const c=new aH(u,"max",!1);return n.runWebGLProgram(c,[r],r.dtype)}},tK={kernelName:Db,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=Q_(r.shape,i,o,[1,1,1],a,u,l),h=new lH(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class eK{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${e*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class nK{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${e*n*s-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${s} +\n                  wR * ${s} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const sK={kernelName:Ob,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=Q_(o.shape,a,l,[1,1,1],u,c),d=new lH(h,"max",!0),p=n.runWebGLProgram(d,[o],o.dtype),f=new nK(h),m=n.runWebGLProgram(f,[r,p],o.dtype);return n.disposeIntermediateTensorInfo(p),m}},rK={kernelName:Fb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:o}=e,a=i;fW([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=Y_(a.shape,l,u,1,c,h),p=new aH(d,"max",!0),f=n.runWebGLProgram(p,[a],a.dtype),m=new eK(d),g=n.runWebGLProgram(m,[r,f],a.dtype);return n.disposeIntermediateTensorInfo(f),g}},iK={kernelName:Lb,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=n;gg(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];gg(ak(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Y_(s.shape,r,i,u,o),[h,d]=function(t,e,n,s){let r=new aH(n,"max",!1);const i=s.runWebGLProgram(r,[t],"float32");return r=new aH(n,"max",!0,!0,e),[i,s.runWebGLProgram(r,[t],"float32")]}(s,a,c,l);return[h,d]}},oK={kernelName:Mb,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{keepDims:r,axis:i}=e,o=n,a=s.shape.length,l=Eg(i,s.shape);let u=l;const c=cC(u,a),h=null!=c,d=o.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const t=o.texData.get(f.dataId).values,e=new Array(a);for(let r=0;r<e.length;r++)e[r]=s.shape[c[r]];const n=AU(t,s.shape,s.dtype,c,e);f=o.makeTensorInfo(e,s.dtype),o.texData.get(f.dataId).values=n}else f=kj(s,c,o);p.push(f),u=dC(u.length,a)}uC("sum",u,a);const[m,g]=aC(f.shape,u);let y=m;r&&(y=lC(m,l));const b=function(t,e,n,s){const r=wg(e),i=gj({inputs:{x:t},attrs:{shape:[wg(t.shape)/r,r]},backend:s}),o=wj(i,"float32","mean",s),a=gj({inputs:{x:o},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(o),a}(f,g,y,o);for(const v of p)o.disposeIntermediateTensorInfo(v);return b}},aK={kernelName:Pb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=Eg(i,r.shape);let u=l;const c=cC(u,a);let h=r;null!=c&&(h=Sj({inputs:{x:r},backend:n,attrs:{perm:c}}),u=dC(u.length,r.shape.length)),uC("min",u,a);const[d,p]=aC(h.shape,u),f=gj({inputs:{x:h},backend:n,attrs:{shape:[-1,wg(p)]}}),m=wj(f,f.dtype,"min",n);let g;return g=gj(o?{inputs:{x:m},backend:n,attrs:{shape:lC(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},lK=uj({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:dU}),uK={kernelName:zb,backendName:"webgl",kernelFunc:lK};class cK{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=UW(s),i=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l="reflect"===n?0:1;this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${a}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class hK{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=UW(s),i=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=DU("rc",s),l=DU("source",s),u=`${a[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===s){const t=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${a[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const t=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${a[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${a[s-2]} += 1;\n        if(${a[s-2]} < ${this.outputShape[s-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${a[s-1]} += 1;\n          if(${u}) {\n            ${t}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const dK={kernelName:Bb,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:i}=n,o=Yg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hK(s.shape,r,i):new cK(s.shape,r,i);return e.runWebGLProgram(o,[s],s.dtype)}},pK=uj({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),fK={kernelName:Vb,backendName:"webgl",kernelFunc:pK};class mK{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}const gK=uj({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),yK={kernelName:Ky,backendName:"webgl",kernelFunc:gK},bK="return a - b;",vK=uj({opSnippet:bK,packedOpSnippet:bK,supportsComplex:!0,cpuKernelImpl:TU}),wK={kernelName:Bv,backendName:"webgl",kernelFunc:vK};function xK(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:i}=s,o=Eg([i],r.shape),a=Xq({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=lC(a.shape,o),u=gj({inputs:{x:a},backend:n,attrs:{shape:l}}),c=vK({inputs:{a:r,b:u},backend:n}),h=WG({inputs:{x:c},backend:n}),d=Cj({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),p=gj({inputs:{x:d},backend:n,attrs:{shape:l}}),f=gK({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const _K={kernelName:Tv,backendName:"webgl",kernelFunc:xK},kK={kernelName:Wb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s,l=a?r:xK({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=new mK(l.shape[0],l.shape[1],i),c=u.getCustomSetupFunc(o),h=n.runWebGLProgram(u,[l],"int32",c);return a||n.disposeIntermediateTensorInfo(l),h}},CK="return -x;",IK={kernelName:jb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const t=n.texData.get(s.dataId),[e,r]=fU(t.values,s.shape,s.dtype);return n.makeTensorInfo(r,s.dtype,e)}let r;return r=Yg().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new jU(s.shape,CK):new VU(s.shape,CK),n.runWebGLProgram(r,[s],s.dtype)}},SK=CI,EK={kernelName:Gb,backendName:"webgl",kernelFunc:function(t){$S("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=SK(u,c,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},TK=II,NK={kernelName:qb,backendName:"webgl",kernelFunc:function(t){$S("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=TK(c,h,o,a,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},$K=SI,AK={kernelName:Kb,backendName:"webgl",kernelFunc:function(t){$S("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),d=o,p=a,f=l,m=u,{selectedIndices:g,selectedScores:y}=$K(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class RK{constructor(t,e,n,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const FK={kernelName:Zb,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{depth:i,onValue:o,offValue:a}=s,l=wg(r.shape),u=new RK(l,i,o,a),c=gj({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[c],r.dtype);n.disposeIntermediateTensorInfo(c);const d=gj({inputs:{x:h},backend:n,attrs:{shape:[...r.shape,i]}});return n.disposeIntermediateTensorInfo(h),d}};function DK(t){const{inputs:e,backend:n}=t,{x:s}=e;if("complex64"===s.dtype){const t=TH({inputs:{input:s},backend:n}),e=DK({inputs:{x:t},backend:n}),r=UH({inputs:{input:s},backend:n}),i=DK({inputs:{x:r},backend:n}),o=tj({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),o}return JG({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:n})}const OK={kernelName:Zv,backendName:"webgl",kernelFunc:DK},LK={kernelName:Xb,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=TH({inputs:{input:r},backend:s}),n=t({inputs:{x:e},backend:s}),i=UH({inputs:{input:r},backend:s}),o=DK({inputs:{x:i},backend:s}),a=tj({inputs:{real:n,imag:o},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(o),a}return JG({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:s})}},MK={kernelName:Yb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(1===e.length)return jG({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(t=>{yg(i,t.shape,"All tensors passed to stack must have matching shapes"),gg(o===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=GH({inputs:e.map(t=>{const e=jG({inputs:{input:t},backend:n,attrs:{dim:r}});return a.push(e),e}),backend:n,attrs:{axis:r}});return a.forEach(t=>n.disposeIntermediateTensorInfo(t)),l}};class PK{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=UW(s),i=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${o});\n      uniform float value;\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${a}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${o};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class zK{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=UW(s),i=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=DU("rc",s),l=DU("source",s),u=`${a[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${a[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${a[s-2]} += 1;\n       if(${a[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${a[s-1]} += 1;\n         if(${u}) {`],d=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===s?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${o});\n      uniform float value;\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}const BK=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:o}=s,a=Yg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zK(r.shape,i,o):new PK(r.shape,i,o),l=a.getCustomSetupFunc(o);return n.runWebGLProgram(a,[r],r.dtype,l)},VK={kernelName:Qb,backendName:"webgl",kernelFunc:BK},WK=uj({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),UK={kernelName:Jb,backendName:"webgl",kernelFunc:WK},jK={kernelName:ev,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=[],u=Eg(i,r.shape);let c=u;const h=cC(c,a);let d,p=r;if(null!=h&&(p=Sj({inputs:{x:r},backend:n,attrs:{perm:h}}),c=dC(c.length,a),l.push(p)),uC("prod",c,a),n.shouldExecuteOnCPU([p])){const t=n.texData.get(p.dataId).values,{outVals:e,outShape:s,outDtype:r}=gU(p.shape,p.dtype,t,c);d=n.makeTensorInfo(s,r,e)}else{const[t,e]=aC(p.shape,c),s=wg(e),i=gj({inputs:{x:p},backend:n,attrs:{shape:[-1,s]}}),o=wj(i,Qw(r.dtype),"prod",n);d=gj({inputs:{x:o},backend:n,attrs:{shape:t}}),l.push(i),l.push(o)}if(o){l.push(d);const t=lC(d.shape,u);d=gj({inputs:{x:d},backend:n,attrs:{shape:t}})}return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),d}},HK=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:i,dtype:o}=n,a=yU(s,r,i,o);return e.makeTensorInfo([a.length],o,a)},GK={kernelName:nv,backendName:"webgl",kernelFunc:HK},qK=lj({opSnippet:"return 1.0 / x;"}),KK={kernelName:rv,backendName:"webgl",kernelFunc:qK},XK=lj({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),ZK={kernelName:iv,backendName:"webgl",kernelFunc:XK},YK=lj({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),QK={kernelName:hv,backendName:"webgl",kernelFunc:YK};class JK{constructor(t,e,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,o,a,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?o-1:o,s&&n>1?a-1:a],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class tX{constructor(t,e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,a,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?o-1:o,s&&n>1?a-1:a],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const eX={kernelName:uv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=Yg().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tX(r.shape,l,u,i,o):new JK(r.shape,l,u,i,o);return n.runWebGLProgram(c,[r],"float32")}};class nX{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,r]=e,[,i,o]=t,a=[n&&i>1?s-1:s,n&&o>1?r-1:r],l=[n&&i>1?i-1:i,n&&o>1?o-1:o],u=a[0]/l[0],c=a[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const sX={kernelName:cv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s,a=new nX(i.shape,r.shape,o);return n.runWebGLProgram(a,[i],i.dtype)}};class rX{constructor(t,e,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,o,a,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?o-1:o,s&&n>1?a-1:a],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class iX{constructor(t,e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,a,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?o-1:o,s&&n>1?a-1:a],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const oX={kernelName:av,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=Yg().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new iX(r.shape,l,u,i,o):new rX(r.shape,l,u,i,o);return n.runWebGLProgram(c,[r],r.dtype)}};class aX{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,r]=e,[,i,o]=t,a=[n&&i>1?s-1:s,n&&o>1?r-1:r],l=[n&&i>1?i-1:i,n&&o>1?o-1:o],u=a[0]/l[0],c=a[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${a[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${a[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const lX={kernelName:lv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:o}=s,a=new aX(i.shape,r.shape,o);return n.runWebGLProgram(a,[i],i.dtype)}};class uX{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const s=t.map((n,s)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(s)).join(","),r=UW(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class cX{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const s=DU("rc",n),r=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,o=UW(n);function a(n){const s=t.map((s,r)=>function(n,s){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${s[n]} - 1`:`${s[n]}`}(r,n));return`getChannel(getX(${s.join(",")}), vec2(${s.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return a(t)}(s.slice())};\n          if(${r}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",a(t)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",a(t)}(s.slice())};\n            if(${r}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",a(t)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const hX={kernelName:dv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:i}=s,o=r.shape.length,a=Eg(i,r.shape);if(0===o)return QU({inputs:{x:r},backend:n});const l=Yg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cX(r.shape,a):new uX(r.shape,a);return n.runWebGLProgram(l,[r],r.dtype)}};class dX{constructor(t,e){this.variableNames=["Image"],this.outputShape=[];const n=t[1],s=t[2];this.outputShape=t;let r="";r="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(t,e,n,s){return(r,i)=>{null==this.paramsLoc&&(this.paramsLoc=r.getUniformLocationNoThrow(i,"params")),r.gl.uniform4f(this.paramsLoc,t,e,n,s)}}}const pX={kernelName:Jv,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:o}=e,a=n,l=new dX(s.shape,i),[u,c]=dS(o,s.shape[1],s.shape[2]),h=l.getCustomSetupFunc(u,c,Math.sin(r),Math.cos(r));return a.runWebGLProgram(l,[s],s.dtype,h)}},fX=lj({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),mX={kernelName:pv,backendName:"webgl",kernelFunc:fX},gX=lj({opSnippet:"return inversesqrt(x);",cpuKernelImpl:bU}),yX={kernelName:fv,backendName:"webgl",kernelFunc:gX};class bX{constructor(t,e,n,s,r,i,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const a=UW(r.length),l=UW(i.length);let u="";1===n?u="i":2===n&&(u="i, j");let c="";1===s?c="i":2===s&&(c="i, coords[1]"),this.userCode=`\n        ${a} strides = ${a}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const vX={kernelName:mv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=xS(0,r,o),d=[h/u,u];if(0===h)return n.makeTensorInfo(o,r.dtype);const p=gj({inputs:{x:r},backend:n,attrs:{shape:[l,a]}}),f=gj({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new bX(l,a,p.shape.length,f.shape.length,c,d),y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=gj({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class wX{constructor(t,e,n){let s,r;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",s="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let s=0;s<e.length;s++)o.push(`${n[s]}`),s<t&&i.push(`${n[s]}`);s=i.join(),r=o.join()}const i=UW(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const xX={kernelName:gv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e,o=new wX(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[s,r,i],Yw(r.dtype,i.dtype))}},_X=lj({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${_S};\n  float scale = ${kS};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),kX={kernelName:yv,backendName:"webgl",kernelFunc:_X},CX=lj({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),IX={kernelName:_v,backendName:"webgl",kernelFunc:CX},SX=lj({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),EX={kernelName:xv,backendName:"webgl",kernelFunc:SX},TX=lj({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),NX={kernelName:vv,backendName:"webgl",kernelFunc:TX},$X=lj({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),AX={kernelName:wv,backendName:"webgl",kernelFunc:$X},RX=lj({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),FX={kernelName:kv,backendName:"webgl",kernelFunc:RX},DX={kernelName:Sv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,paddings:o}=s;gg(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((t,e)=>t*e),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<r.shape.length;++y)l.push([0,0]);const u=[],c=BK({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=pS(c.shape,i,a,!1),d=fS(h.length,i.length,!1),p=mS(c.shape,i,a,!1),f=gj({inputs:{x:c},backend:n,attrs:{shape:h}}),m=Sj({inputs:{x:f},backend:n,attrs:{perm:d}}),g=gj({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(t=>n.disposeIntermediateTensorInfo(t)),g}},OX={kernelName:Nv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=n.readSync(s.dataId),l=n.readSync(r.dataId),u=n.readSync(i.dataId),c=n.readSync(o.dataId)[0],[h,d,p,f,m]=xU(a,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(t=>Number(t)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}},LX={kernelName:$v,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:i}=e;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(n.readSync(r.dataId)),a=n.readSync(s.dataId),l=Array.from(n.readSync(i.dataId)),[u,c,h]=_U(a,s.shape,s.dtype,o,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}},MX={kernelName:Av,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const o=n.readSync(s.dataId),a=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=kU(o,s.shape,s.dtype,a,l,!0);return n.makeTensorInfo(c,s.dtype,u)}},PX={kernelName:Rv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const o=n.readSync(s.dataId),a=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=kU(o,s.shape,s.dtype,a,l);return n.makeTensorInfo(c,s.dtype,u)}},zX={kernelName:Fv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,strides:c,outputSize:h}=xS(0,r,a),d=new bX(u,l,r.shape.length,i.shape.length,c,[h,1],!1),p=n.runWebGLProgram(d,[i,r,o],i.dtype),f=gj({inputs:{x:p},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),f}},BX={kernelName:Ev,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=Eg(o,r.shape)[0],l=qS(r,i,a),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(t=>{const e=[...c];e[a]=t;const s=_H({inputs:{x:r},backend:n,attrs:{begin:u,size:e}});return u[a]+=t,s})}},VX=lj({opSnippet:"return sqrt(x);"}),WX={kernelName:Cv,backendName:"webgl",kernelFunc:VX},UX={kernelName:Ov,backendName:"webgl",kernelFunc:lj({opSnippet:"return x * x;"})},jX="return (a - b) * (a - b);",HX=uj({opSnippet:jX,packedOpSnippet:jX}),GX={kernelName:Dv,backendName:"webgl",kernelFunc:HX},qX={kernelName:Yv,backendName:"webgl",kernelFunc:function({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=new VU(s.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${e.alpha});\n  `);return n.runWebGLProgram(r,[s],s.dtype)}};class KX{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const s=n.length,r=UW(n.length),i=UW(n.length);let o="";if(1===s)o="coords * strides + begin";else{let t=0;o=n.map((e,s)=>(t++,1===n.length?`coords * strides[${s}] + begin[${s}]`:`coords[${t-1}] * strides[${s}] + begin[${s}]`)).join(",")}this.userCode=`\n      ${r} begin = ${r}(${t});\n      ${r} strides = ${r}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}const XX={kernelName:Lv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=R_(r.shape,i,o,a,l,u,c,h,d),v=gj({inputs:{x:r},backend:n,attrs:{shape:y}});let w;if(p){const t=_H({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});w=gj({inputs:{x:t},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(t)}else if(b.some(t=>0===t))w=n.makeTensorInfo(b,r.dtype,[]);else if(n.shouldExecuteOnCPU([v])){const t=n.texData.get(v.dataId),e=e_(v.shape,v.dtype,t.values),s=CU(b,e,m,f);w=n.makeTensorInfo(b,v.dtype,s.values)}else{const t=new KX(f,m,b);w=n.runWebGLProgram(t,[v],v.dtype)}const x=gj({inputs:{x:w},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),x}},ZX={kernelName:Mv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=IU(d,p,r,i,o,a,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},YX={kernelName:Pv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.readSync(i.dataId),l=n.readSync(o.dataId)[0],[u,c,h]=SU(a,l,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},QX={kernelName:zv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:i}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(i.dataId),a=EU(o,r);return n.makeTensorInfo(i.shape,"int32",a)}},JX=lj({opSnippet:"return tan(x);"}),tZ={kernelName:Vv,backendName:"webgl",kernelFunc:JX},eZ=lj({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),nZ={kernelName:Wv,backendName:"webgl",kernelFunc:eZ};class sZ{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;const s=UW(this.rank),r=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function rZ(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;if("string"===r.dtype||r.shape.length>5){const t=n.readSync(r.dataId),e="string"===r.dtype?t.map(t=>Nw(t)):t,s=e_(r.shape,r.dtype,e),o=NU(s,i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new sZ(r.shape,i);return n.runWebGLProgram(o,[r],r.dtype)}const iZ={kernelName:Uv,backendName:"webgl",kernelFunc:rZ},oZ={kernelName:jv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i,sorted:o}=s,a=n.readSync(r.dataId),[l,u]=$U(a,r.shape,r.dtype,i,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};class aZ{constructor(t,e,n,s,r,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o="nearest"===n?1:2;let a;switch(s){case"constant":a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4;break;default:a=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const lZ={kernelName:Hv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=s,[c,h,d,p]=r.shape,[f,m]=null!=u?u:[h,d],g=new aZ(h,d,o,a,l,[c,f,m,p]);return n.runWebGLProgram(g,[r,i],"float32")}},uZ={kernelName:qv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;fW(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:l,indices:u}=RU(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}},cZ={kernelName:Kv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],u=new Array(a-1);let c=0;for(let m=0;m<a;m++)m!==i&&(u[c++]=o.shape[m]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[i]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[i]=m;const t=_H({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),e=gj({inputs:{x:t},backend:n,attrs:{shape:u}});f[m]=e,h.push(t)}return h.forEach(t=>n.disposeIntermediateTensorInfo(t)),f}};class hZ{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,s=t.batchSize,r=t.inSize,i=t.numSegments,o=i*Math.ceil(r/n);this.outputShape=[s,o];const a=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const dZ=[Gq,Kq,Nj,Aj,Fj,Oj,Pj,Vj,Wj,Uj,Xj,Zj,Qj,tH,rH,nH,oH,cH,uH,pH,fH,mH,bH,CH,IH,$H,FH,LH,zH,ej,qH,rG,iG,JH,aG,lG,oG,cG,dG,fG,bG,vG,xG,EG,TG,CG,$G,RG,FG,OG,LG,PG,BG,UG,HG,KG,YG,tq,nq,iq,aq,cq,dq,pq,mq,yq,vq,xq,JU,_q,jH,Cq,Sq,Tq,rj,$q,Rq,Fq,Mq,Oq,zq,Vq,Uq,Zq,tK,Jq,sK,rK,iK,Qq,oK,aK,uK,dK,fK,kK,mj,IK,EK,NK,AK,EH,FK,LK,MK,VK,UK,aj,jK,GK,NH,yK,KK,QK,ZK,yj,eX,sX,oX,lX,hX,pX,mX,yX,vX,xX,kX,IX,EX,NX,AX,kH,_K,FX,DX,OX,LX,MX,PX,zX,BX,WX,UX,GX,qX,XX,ZX,YX,QX,wK,Ij,tZ,nZ,iZ,oZ,lZ,Ej,uZ,cZ,{kernelName:Xv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:i}=e,{numSegments:o}=s,a=r.shape.length,l=[];let u=0;const c=cC([u],a);let h=r;null!=c&&(h=Sj({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(h),u=dC(1,a)[0]);const d=XS(h.shape,u,o),p=wg([h.shape[u]]),f=gj({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=Qw(r.dtype),g=(t,e,s,r,i)=>{const o=t.shape[0],a=t.shape[1],u=KS(a,i),c=new hZ({windowSize:u,inSize:a,batchSize:o,numSegments:i},e),h=n.compileAndRun(c,[t,s],r);if(l.push(h),h.shape[1]===i)return h;const d=HK({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),p=rZ({inputs:{x:d},backend:n,attrs:{reps:[a/u]}});return l.push(d),l.push(p),g(h,e,p,r,i)},y=gj({inputs:{x:g(f,"unsortedSegmentSum",i,m,o)},backend:n,attrs:{shape:d}});let b=y;if(null!=c){l.push(y);const t=hC(c);b=Sj({inputs:{x:b},backend:n,attrs:{perm:t}})}return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),b}},OK];for(const Y3 of dZ)lw(Y3);let pZ=(()=>{class t{constructor(){this.settings={},this._modelLoaded=new md(!1),this.modelLoaded=this._modelLoaded.asObservable(),fetch(ug+"/settings").then(t=>{t.json().then(t=>{this.settings=t,this.loadModel().then(()=>{this._modelLoaded.next(!0)}).catch(t=>{this._modelLoaded.next(!1)})}).catch(t=>{console.log(t)})}).catch(t=>{})}loadModel(){var t=this;return lg(function*(){var e,n;t.model=yield(e=ug+"/models/"+t.settings.MODEL_NAME+"/model.json",null==n&&(n={}),function(t,e){return rF.apply(this,arguments)}(e,n)),console.log("model loaded")})()}bufftoarr(t){return function(t,e){return m_.apply(this,arguments)}(t)}predict(t){return this.model.predict(t.expandDims(),{batchSize:1})}loadImage(t){let e=g_(t);return e.pad(this.getPadding(e.shape)).resizeBilinear(this.settings.IMG_SIZE)}getPadding(t){let e=[[0,0],[0,0],[0,0]],n=t[0]-t[1];return n>0?e[1]=[Math.abs(n/2),Math.abs(n/2)]:e[0]=[Math.abs(n/2),Math.abs(n/2)],e}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();class fZ extends m{constructor(t,e){super()}schedule(t,e=0){return this}}class mZ extends fZ{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const n=this.id,s=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(s,n,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(s,this.id,e),this}requestAsyncId(t,e,n=0){return setInterval(t.flush.bind(t,this),n)}recycleAsyncId(t,e,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(t,e);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let n,s=!1;try{this.work(t)}catch(r){s=!0,n=!!r&&r||new Error(r)}if(s)return this.unsubscribe(),n}_unsubscribe(){const t=this.id,e=this.scheduler,n=e.actions,s=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==s&&n.splice(s,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}let gZ=(()=>{class t{constructor(e,n=t.now){this.SchedulerAction=e,this.now=n}schedule(t,e=0,n){return new this.SchedulerAction(this,t).schedule(n,e)}}return t.now=()=>Date.now(),t})();class yZ extends gZ{constructor(t,e=gZ.now){super(t,()=>yZ.delegate&&yZ.delegate!==this?yZ.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,n){return yZ.delegate&&yZ.delegate!==this?yZ.delegate.schedule(t,e,n):super.schedule(t,e,n)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let n;this.active=!0;do{if(n=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}}const bZ=new yZ(mZ);function vZ(t){return null!=t&&"false"!=`${t}`}function wZ(t,e=0){return function(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}(t)?Number(t):e}function xZ(t){return Array.isArray(t)?t:[t]}function _Z(t){return null==t?"":"string"==typeof t?t:`${t}px`}function kZ(t){return t instanceof Ta?t.nativeElement:t}let CZ;try{CZ="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(Z3){CZ=!1}let IZ,SZ,EZ,TZ=(()=>{class t{constructor(t){this._platformId=t,this.isBrowser=this._platformId?"browser"===this._platformId:"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!CZ)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return t.\u0275fac=function(e){return new(e||t)(fs(tu))},t.\u0275prov=gt({factory:function(){return new t(fs(tu))},token:t,providedIn:"root"}),t})(),NZ=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})();function $Z(t){return function(){if(null==IZ&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>IZ=!0}))}finally{IZ=IZ||!1}return IZ}()?t:!!t.capture}function AZ(){if(null==SZ){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return SZ=!1,SZ;if("scrollBehavior"in document.documentElement.style)SZ=!0;else{const t=Element.prototype.scrollTo;SZ=!!t&&!/\{\s*\[native code\]\s*\}/.test(t.toString())}}return SZ}function RZ(t){if(function(){if(null==EZ){const t="undefined"!=typeof document?document.head:null;EZ=!(!t||!t.createShadowRoot&&!t.attachShadow)}return EZ}()){const e=t.getRootNode?t.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}function FZ(){let t="undefined"!=typeof document&&document?document.activeElement:null;for(;t&&t.shadowRoot;){const e=t.shadowRoot.activeElement;if(e===t)break;t=e}return t}let DZ=(()=>{class t{create(t){return"undefined"==typeof MutationObserver?null:new MutationObserver(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),OZ=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[DZ]}),t})(),LZ=(()=>{class t{constructor(t){this._platform=t}isDisabled(t){return t.hasAttribute("disabled")}isVisible(t){return function(t){return!!(t.offsetWidth||t.offsetHeight||"function"==typeof t.getClientRects&&t.getClientRects().length)}(t)&&"visible"===getComputedStyle(t).visibility}isTabbable(t){if(!this._platform.isBrowser)return!1;const e=function(t){try{return t.frameElement}catch(Z3){return null}}((n=t).ownerDocument&&n.ownerDocument.defaultView||window);var n;if(e){if(-1===PZ(e))return!1;if(!this.isVisible(e))return!1}let s=t.nodeName.toLowerCase(),r=PZ(t);return t.hasAttribute("contenteditable")?-1!==r:"iframe"!==s&&"object"!==s&&!(this._platform.WEBKIT&&this._platform.IOS&&!function(t){let e=t.nodeName.toLowerCase(),n="input"===e&&t.type;return"text"===n||"password"===n||"select"===e||"textarea"===e}(t))&&("audio"===s?!!t.hasAttribute("controls")&&-1!==r:"video"===s?-1!==r&&(null!==r||this._platform.FIREFOX||t.hasAttribute("controls")):t.tabIndex>=0)}isFocusable(t,e){return function(t){return!function(t){return function(t){return"input"==t.nodeName.toLowerCase()}(t)&&"hidden"==t.type}(t)&&(function(t){let e=t.nodeName.toLowerCase();return"input"===e||"select"===e||"button"===e||"textarea"===e}(t)||function(t){return function(t){return"a"==t.nodeName.toLowerCase()}(t)&&t.hasAttribute("href")}(t)||t.hasAttribute("contenteditable")||MZ(t))}(t)&&!this.isDisabled(t)&&((null==e?void 0:e.ignoreVisibility)||this.isVisible(t))}}return t.\u0275fac=function(e){return new(e||t)(fs(TZ))},t.\u0275prov=gt({factory:function(){return new t(fs(TZ))},token:t,providedIn:"root"}),t})();function MZ(t){if(!t.hasAttribute("tabindex")||void 0===t.tabIndex)return!1;let e=t.getAttribute("tabindex");return"-32768"!=e&&!(!e||isNaN(parseInt(e,10)))}function PZ(t){if(!MZ(t))return null;const e=parseInt(t.getAttribute("tabindex")||"",10);return isNaN(e)?-1:e}class zZ{constructor(t,e,n,s,r=!1){this._element=t,this._checker=e,this._ngZone=n,this._document=s,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,r||this.attachAnchors()}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.parentNode&&t.parentNode.removeChild(t)),e&&(e.removeEventListener("focus",this.endAnchorListener),e.parentNode&&e.parentNode.removeChild(e)),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusInitialElement(t)))})}focusFirstTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusFirstTabbableElement(t)))})}focusLastTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusLastTabbableElement(t)))})}_getRegionBoundary(t){let e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);for(let n=0;n<e.length;n++)e[n].hasAttribute(`cdk-focus-${t}`)?console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]):e[n].hasAttribute(`cdk-focus-region-${t}`)&&console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(t){const e=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(e){if(e.hasAttribute("cdk-focus-initial")&&console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0",e),!this._checker.isFocusable(e)){const n=this._getFirstTabbableElement(e);return null==n||n.focus(t),!!n}return e.focus(t),!0}return this.focusFirstTabbableElement(t)}focusFirstTabbableElement(t){const e=this._getRegionBoundary("start");return e&&e.focus(t),!!e}focusLastTabbableElement(t){const e=this._getRegionBoundary("end");return e&&e.focus(t),!!e}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=0;n<e.length;n++){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[n]):null;if(t)return t}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=e.length-1;n>=0;n--){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[n]):null;if(t)return t}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(Ad(1)).subscribe(t)}}let BZ=(()=>{class t{constructor(t,e,n){this._checker=t,this._ngZone=e,this._document=n}create(t,e=!1){return new zZ(t,this._checker,this._ngZone,this._document,e)}}return t.\u0275fac=function(e){return new(e||t)(fs(LZ),fs(mu),fs(Ku))},t.\u0275prov=gt({factory:function(){return new t(fs(LZ),fs(mu),fs(Ku))},token:t,providedIn:"root"}),t})();function VZ(t){return 0===t.buttons}function WZ(t){const e=t.touches&&t.touches[0]||t.changedTouches&&t.changedTouches[0];return!(!e||-1!==e.identifier||null!=e.radiusX&&1!==e.radiusX||null!=e.radiusY&&1!==e.radiusY)}"undefined"!=typeof Element&&Element;const UZ=new Zn("cdk-focus-monitor-default-options"),jZ=$Z({passive:!0,capture:!0});let HZ=(()=>{class t{constructor(t,e,n,s){this._ngZone=t,this._platform=e,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue("keyboard")},this._documentMousedownListener=t=>{if(!this._lastTouchTarget){const e=VZ(t)?"keyboard":"mouse";this._setOriginForCurrentEventQueue(e)}},this._documentTouchstartListener=t=>{WZ(t)?this._lastTouchTarget||this._setOriginForCurrentEventQueue("keyboard"):(null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=GZ(t),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650))},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=t=>{const e=GZ(t),n="focus"===t.type?this._onFocus:this._onBlur;for(let s=e;s;s=s.parentElement)n.call(this,t,s)},this._document=n,this._detectionMode=(null==s?void 0:s.detectionMode)||0}monitor(t,e=!1){const n=kZ(t);if(!this._platform.isBrowser||1!==n.nodeType)return fd(null);const s=RZ(n)||this._getDocument(),r=this._elementInfo.get(n);if(r)return e&&(r.checkChildren=!0),r.subject;const i={checkChildren:e,subject:new E,rootNode:s};return this._elementInfo.set(n,i),this._registerGlobalListeners(i),i.subject}stopMonitoring(t){const e=kZ(t),n=this._elementInfo.get(e);n&&(n.subject.complete(),this._setClasses(e),this._elementInfo.delete(e),this._removeGlobalListeners(n))}focusVia(t,e,n){const s=kZ(t);s===this._getDocument().activeElement?this._getClosestElementsInfo(s).forEach(([t,n])=>this._originChanged(t,e,n)):(this._setOriginForCurrentEventQueue(e),"function"==typeof s.focus&&s.focus(n))}ngOnDestroy(){this._elementInfo.forEach((t,e)=>this.stopMonitoring(e))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(t,e,n){n?t.classList.add(e):t.classList.remove(e)}_getFocusOrigin(t){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(t)?"touch":"program"}_setClasses(t,e){this._toggleClass(t,"cdk-focused",!!e),this._toggleClass(t,"cdk-touch-focused","touch"===e),this._toggleClass(t,"cdk-keyboard-focused","keyboard"===e),this._toggleClass(t,"cdk-mouse-focused","mouse"===e),this._toggleClass(t,"cdk-program-focused","program"===e)}_setOriginForCurrentEventQueue(t){this._ngZone.runOutsideAngular(()=>{this._origin=t,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(t){const e=GZ(t);return this._lastTouchTarget instanceof Node&&e instanceof Node&&(e===this._lastTouchTarget||e.contains(this._lastTouchTarget))}_onFocus(t,e){const n=this._elementInfo.get(e);n&&(n.checkChildren||e===GZ(t))&&this._originChanged(e,this._getFocusOrigin(t),n)}_onBlur(t,e){const n=this._elementInfo.get(e);!n||n.checkChildren&&t.relatedTarget instanceof Node&&e.contains(t.relatedTarget)||(this._setClasses(e),this._emitOrigin(n.subject,null))}_emitOrigin(t,e){this._ngZone.run(()=>t.next(e))}_registerGlobalListeners(t){if(!this._platform.isBrowser)return;const e=t.rootNode,n=this._rootNodeFocusListenerCount.get(e)||0;n||this._ngZone.runOutsideAngular(()=>{e.addEventListener("focus",this._rootNodeFocusAndBlurListener,jZ),e.addEventListener("blur",this._rootNodeFocusAndBlurListener,jZ)}),this._rootNodeFocusListenerCount.set(e,n+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const t=this._getDocument(),e=this._getWindow();t.addEventListener("keydown",this._documentKeydownListener,jZ),t.addEventListener("mousedown",this._documentMousedownListener,jZ),t.addEventListener("touchstart",this._documentTouchstartListener,jZ),e.addEventListener("focus",this._windowFocusListener)})}_removeGlobalListeners(t){const e=t.rootNode;if(this._rootNodeFocusListenerCount.has(e)){const t=this._rootNodeFocusListenerCount.get(e);t>1?this._rootNodeFocusListenerCount.set(e,t-1):(e.removeEventListener("focus",this._rootNodeFocusAndBlurListener,jZ),e.removeEventListener("blur",this._rootNodeFocusAndBlurListener,jZ),this._rootNodeFocusListenerCount.delete(e))}if(!--this._monitoredElementCount){const t=this._getDocument(),e=this._getWindow();t.removeEventListener("keydown",this._documentKeydownListener,jZ),t.removeEventListener("mousedown",this._documentMousedownListener,jZ),t.removeEventListener("touchstart",this._documentTouchstartListener,jZ),e.removeEventListener("focus",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}_originChanged(t,e,n){this._setClasses(t,e),this._emitOrigin(n.subject,e),this._lastFocusOrigin=e}_getClosestElementsInfo(t){const e=[];return this._elementInfo.forEach((n,s)=>{(s===t||n.checkChildren&&s.contains(t))&&e.push([s,n])}),e}}return t.\u0275fac=function(e){return new(e||t)(fs(mu),fs(TZ),fs(Ku,8),fs(UZ,8))},t.\u0275prov=gt({factory:function(){return new t(fs(mu),fs(TZ),fs(Ku,8),fs(UZ,8))},token:t,providedIn:"root"}),t})();function GZ(t){return t.composedPath?t.composedPath()[0]:t.target}const qZ="cdk-high-contrast-black-on-white",KZ="cdk-high-contrast-white-on-black",XZ="cdk-high-contrast-active";let ZZ=(()=>{class t{constructor(t,e){this._platform=t,this._document=e}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const t=this._document.createElement("div");t.style.backgroundColor="rgb(1,2,3)",t.style.position="absolute",this._document.body.appendChild(t);const e=this._document.defaultView||window,n=e&&e.getComputedStyle?e.getComputedStyle(t):null,s=(n&&n.backgroundColor||"").replace(/ /g,"");switch(this._document.body.removeChild(t),s){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const t=this._document.body.classList;t.remove(XZ),t.remove(qZ),t.remove(KZ),this._hasCheckedHighContrastMode=!0;const e=this.getHighContrastMode();1===e?(t.add(XZ),t.add(qZ)):2===e&&(t.add(XZ),t.add(KZ))}}}return t.\u0275fac=function(e){return new(e||t)(fs(TZ),fs(Ku))},t.\u0275prov=gt({factory:function(){return new t(fs(TZ),fs(Ku))},token:t,providedIn:"root"}),t})(),YZ=(()=>{class t{constructor(t){t._applyBodyHighContrastModeCssClasses()}}return t.\u0275fac=function(e){return new(e||t)(fs(ZZ))},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[NZ,OZ]]}),t})();const QZ=new Zn("cdk-dir-doc",{providedIn:"root",factory:function(){return ms(Ku)}});let JZ=(()=>{class t{constructor(t){if(this.value="ltr",this.change=new Nl,t){const e=t.documentElement?t.documentElement.dir:null,n=(t.body?t.body.dir:null)||e;this.value="ltr"===n||"rtl"===n?n:"ltr"}}ngOnDestroy(){this.change.complete()}}return t.\u0275fac=function(e){return new(e||t)(fs(QZ,8))},t.\u0275prov=gt({factory:function(){return new t(fs(QZ,8))},token:t,providedIn:"root"}),t})(),tY=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})();const eY=new Da("12.0.4");class nY{}const sY="*";function rY(t,e){return{type:7,name:t,definitions:e,options:{}}}function iY(t,e=null){return{type:4,styles:e,timings:t}}function oY(t,e=null){return{type:2,steps:t,options:e}}function aY(t){return{type:6,styles:t,offset:null}}function lY(t,e,n){return{type:0,name:t,styles:e,options:n}}function uY(t,e,n=null){return{type:1,expr:t,animation:e,options:n}}function cY(t){Promise.resolve(null).then(t)}class hY{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){cY(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class dY{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,n=0,s=0;const r=this.players.length;0==r?cY(()=>this._onFinish()):this.players.forEach(t=>{t.onDone(()=>{++e==r&&this._onFinish()}),t.onDestroy(()=>{++n==r&&this._onDestroy()}),t.onStart(()=>{++s==r&&this._onStart()})}),this.totalTime=this.players.reduce((t,e)=>Math.max(t,e.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(t=>{const n=t.totalTime?Math.min(1,e/t.totalTime):1;t.setPosition(n)})}getPosition(){const t=this.players.reduce((t,e)=>null===t||e.totalTime>t.totalTime?e:t,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}function pY(){return"undefined"!=typeof window&&void 0!==window.document}function fY(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function mY(t){switch(t.length){case 0:return new hY;case 1:return t[0];default:return new dY(t)}}function gY(t,e,n,s,r={},i={}){const o=[],a=[];let l=-1,u=null;if(s.forEach(t=>{const n=t.offset,s=n==l,c=s&&u||{};Object.keys(t).forEach(n=>{let s=n,a=t[n];if("offset"!==n)switch(s=e.normalizePropertyName(s,o),a){case"!":a=r[n];break;case sY:a=i[n];break;default:a=e.normalizeStyleValue(n,s,a,o)}c[s]=a}),s||a.push(c),u=c,l=n}),o.length){const t="\n - ";throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`)}return a}function yY(t,e,n,s){switch(e){case"start":t.onStart(()=>s(n&&bY(n,"start",t)));break;case"done":t.onDone(()=>s(n&&bY(n,"done",t)));break;case"destroy":t.onDestroy(()=>s(n&&bY(n,"destroy",t)))}}function bY(t,e,n){const s=n.totalTime,r=vY(t.element,t.triggerName,t.fromState,t.toState,e||t.phaseName,null==s?t.totalTime:s,!!n.disabled),i=t._data;return null!=i&&(r._data=i),r}function vY(t,e,n,s,r="",i=0,o){return{element:t,triggerName:e,fromState:n,toState:s,phaseName:r,totalTime:i,disabled:!!o}}function wY(t,e,n){let s;return t instanceof Map?(s=t.get(e),s||t.set(e,s=n)):(s=t[e],s||(s=t[e]=n)),s}function xY(t){const e=t.indexOf(":");return[t.substring(1,e),t.substr(e+1)]}let _Y=(t,e)=>!1,kY=(t,e)=>!1,CY=(t,e,n)=>[];const IY=fY();(IY||"undefined"!=typeof Element)&&(_Y=pY()?(t,e)=>{for(;e&&e!==document.documentElement;){if(e===t)return!0;e=e.parentNode||e.host}return!1}:(t,e)=>t.contains(e),kY=(()=>{if(IY||Element.prototype.matches)return(t,e)=>t.matches(e);{const t=Element.prototype,e=t.matchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;return e?(t,n)=>e.apply(t,[n]):kY}})(),CY=(t,e,n)=>{let s=[];if(n){const n=t.querySelectorAll(e);for(let t=0;t<n.length;t++)s.push(n[t])}else{const n=t.querySelector(e);n&&s.push(n)}return s});let SY=null,EY=!1;function TY(t){SY||(SY=("undefined"!=typeof document?document.body:null)||{},EY=!!SY.style&&"WebkitAppearance"in SY.style);let e=!0;return SY.style&&!function(t){return"ebkit"==t.substring(1,6)}(t)&&(e=t in SY.style,!e&&EY)&&(e="Webkit"+t.charAt(0).toUpperCase()+t.substr(1)in SY.style),e}const NY=kY,$Y=_Y,AY=CY;function RY(t){const e={};return Object.keys(t).forEach(n=>{const s=n.replace(/([a-z])([A-Z])/g,"$1-$2");e[s]=t[n]}),e}let FY=(()=>{class t{validateStyleProperty(t){return TY(t)}matchesElement(t,e){return NY(t,e)}containsElement(t,e){return $Y(t,e)}query(t,e,n){return AY(t,e,n)}computeStyle(t,e,n){return n||""}animate(t,e,n,s,r,i=[],o){return new hY(n,s)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),DY=(()=>{class t{}return t.NOOP=new FY,t})();const OY="ng-enter",LY="ng-leave",MY="ng-trigger",PY=".ng-trigger",zY="ng-animating",BY=".ng-animating";function VY(t){if("number"==typeof t)return t;const e=t.match(/^(-?[\.\d]+)(m?s)/);return!e||e.length<2?0:WY(parseFloat(e[1]),e[2])}function WY(t,e){switch(e){case"s":return 1e3*t;default:return t}}function UY(t,e,n){return t.hasOwnProperty("duration")?t:function(t,e,n){let s,r=0,i="";if("string"==typeof t){const n=t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===n)return e.push(`The provided timing value "${t}" is invalid.`),{duration:0,delay:0,easing:""};s=WY(parseFloat(n[1]),n[2]);const o=n[3];null!=o&&(r=WY(parseFloat(o),n[4]));const a=n[5];a&&(i=a)}else s=t;if(!n){let n=!1,i=e.length;s<0&&(e.push("Duration values below 0 are not allowed for this animation step."),n=!0),r<0&&(e.push("Delay values below 0 are not allowed for this animation step."),n=!0),n&&e.splice(i,0,`The provided timing value "${t}" is invalid.`)}return{duration:s,delay:r,easing:i}}(t,e,n)}function jY(t,e={}){return Object.keys(t).forEach(n=>{e[n]=t[n]}),e}function HY(t,e,n={}){if(e)for(let s in t)n[s]=t[s];else jY(t,n);return n}function GY(t,e,n){return n?e+":"+n+";":""}function qY(t){let e="";for(let n=0;n<t.style.length;n++){const s=t.style.item(n);e+=GY(0,s,t.style.getPropertyValue(s))}for(const n in t.style)t.style.hasOwnProperty(n)&&!n.startsWith("_")&&(e+=GY(0,n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),t.style[n]));t.setAttribute("style",e)}function KY(t,e,n){t.style&&(Object.keys(e).forEach(s=>{const r=nQ(s);n&&!n.hasOwnProperty(s)&&(n[s]=t.style[r]),t.style[r]=e[s]}),fY()&&qY(t))}function XY(t,e){t.style&&(Object.keys(e).forEach(e=>{const n=nQ(e);t.style[n]=""}),fY()&&qY(t))}function ZY(t){return Array.isArray(t)?1==t.length?t[0]:oY(t):t}const YY=new RegExp("{{\\s*(.+?)\\s*}}","g");function QY(t){let e=[];if("string"==typeof t){let n;for(;n=YY.exec(t);)e.push(n[1]);YY.lastIndex=0}return e}function JY(t,e,n){const s=t.toString(),r=s.replace(YY,(t,s)=>{let r=e[s];return e.hasOwnProperty(s)||(n.push(`Please provide a value for the animation param ${s}`),r=""),r.toString()});return r==s?t:r}function tQ(t){const e=[];let n=t.next();for(;!n.done;)e.push(n.value),n=t.next();return e}const eQ=/-+([a-z0-9])/g;function nQ(t){return t.replace(eQ,(...t)=>t[1].toUpperCase())}function sQ(t,e){return 0===t||0===e}function rQ(t,e,n){const s=Object.keys(n);if(s.length&&e.length){let i=e[0],o=[];if(s.forEach(t=>{i.hasOwnProperty(t)||o.push(t),i[t]=n[t]}),o.length)for(var r=1;r<e.length;r++){let n=e[r];o.forEach(function(e){n[e]=oQ(t,e)})}}return e}function iQ(t,e,n){switch(e.type){case 7:return t.visitTrigger(e,n);case 0:return t.visitState(e,n);case 1:return t.visitTransition(e,n);case 2:return t.visitSequence(e,n);case 3:return t.visitGroup(e,n);case 4:return t.visitAnimate(e,n);case 5:return t.visitKeyframes(e,n);case 6:return t.visitStyle(e,n);case 8:return t.visitReference(e,n);case 9:return t.visitAnimateChild(e,n);case 10:return t.visitAnimateRef(e,n);case 11:return t.visitQuery(e,n);case 12:return t.visitStagger(e,n);default:throw new Error(`Unable to resolve animation metadata node #${e.type}`)}}function oQ(t,e){return window.getComputedStyle(t)[e]}const aQ="*";function lQ(t,e){const n=[];return"string"==typeof t?t.split(/\s*,\s*/).forEach(t=>function(t,e,n){if(":"==t[0]){const s=function(t,e){switch(t){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(t,e)=>parseFloat(e)>parseFloat(t);case":decrement":return(t,e)=>parseFloat(e)<parseFloat(t);default:return e.push(`The transition alias value "${t}" is not supported`),"* => *"}}(t,n);if("function"==typeof s)return void e.push(s);t=s}const s=t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==s||s.length<4)return n.push(`The provided transition expression "${t}" is not supported`),e;const r=s[1],i=s[2],o=s[3];e.push(hQ(r,o)),"<"!=i[0]||r==aQ&&o==aQ||e.push(hQ(o,r))}(t,n,e)):n.push(t),n}const uQ=new Set(["true","1"]),cQ=new Set(["false","0"]);function hQ(t,e){const n=uQ.has(t)||cQ.has(t),s=uQ.has(e)||cQ.has(e);return(r,i)=>{let o=t==aQ||t==r,a=e==aQ||e==i;return!o&&n&&"boolean"==typeof r&&(o=r?uQ.has(t):cQ.has(t)),!a&&s&&"boolean"==typeof i&&(a=i?uQ.has(e):cQ.has(e)),o&&a}}const dQ=new RegExp("s*:selfs*,?","g");function pQ(t,e,n){return new fQ(t).build(e,n)}class fQ{constructor(t){this._driver=t}build(t,e){const n=new mQ(e);return this._resetContextStyleTimingState(n),iQ(this,ZY(t),n)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let n=e.queryCount=0,s=e.depCount=0;const r=[],i=[];return"@"==t.name.charAt(0)&&e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"),t.definitions.forEach(t=>{if(this._resetContextStyleTimingState(e),0==t.type){const n=t,s=n.name;s.toString().split(/\s*,\s*/).forEach(t=>{n.name=t,r.push(this.visitState(n,e))}),n.name=s}else if(1==t.type){const r=this.visitTransition(t,e);n+=r.queryCount,s+=r.depCount,i.push(r)}else e.errors.push("only state() and transition() definitions can sit inside of a trigger()")}),{type:7,name:t.name,states:r,transitions:i,queryCount:n,depCount:s,options:null}}visitState(t,e){const n=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(n.containsDynamicStyles){const r=new Set,i=s||{};if(n.styles.forEach(t=>{if(gQ(t)){const e=t;Object.keys(e).forEach(t=>{QY(e[t]).forEach(t=>{i.hasOwnProperty(t)||r.add(t)})})}}),r.size){const n=tQ(r.values());e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`)}}return{type:0,name:t.name,style:n,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const n=iQ(this,ZY(t.animation),e);return{type:1,matchers:lQ(t.expr,e.errors),animation:n,queryCount:e.queryCount,depCount:e.depCount,options:yQ(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(t=>iQ(this,t,e)),options:yQ(t.options)}}visitGroup(t,e){const n=e.currentTime;let s=0;const r=t.steps.map(t=>{e.currentTime=n;const r=iQ(this,t,e);return s=Math.max(s,e.currentTime),r});return e.currentTime=s,{type:3,steps:r,options:yQ(t.options)}}visitAnimate(t,e){const n=function(t,e){let n=null;if(t.hasOwnProperty("duration"))n=t;else if("number"==typeof t)return bQ(UY(t,e).duration,0,"");const s=t;if(s.split(/\s+/).some(t=>"{"==t.charAt(0)&&"{"==t.charAt(1))){const t=bQ(0,0,"");return t.dynamic=!0,t.strValue=s,t}return n=n||UY(s,e),bQ(n.duration,n.delay,n.easing)}(t.timings,e.errors);let s;e.currentAnimateTimings=n;let r=t.styles?t.styles:aY({});if(5==r.type)s=this.visitKeyframes(r,e);else{let r=t.styles,i=!1;if(!r){i=!0;const t={};n.easing&&(t.easing=n.easing),r=aY(t)}e.currentTime+=n.duration+n.delay;const o=this.visitStyle(r,e);o.isEmptyStep=i,s=o}return e.currentAnimateTimings=null,{type:4,timings:n,style:s,options:null}}visitStyle(t,e){const n=this._makeStyleAst(t,e);return this._validateStyleAst(n,e),n}_makeStyleAst(t,e){const n=[];Array.isArray(t.styles)?t.styles.forEach(t=>{"string"==typeof t?t==sY?n.push(t):e.errors.push(`The provided style string value ${t} is not allowed.`):n.push(t)}):n.push(t.styles);let s=!1,r=null;return n.forEach(t=>{if(gQ(t)){const e=t,n=e.easing;if(n&&(r=n,delete e.easing),!s)for(let t in e)if(e[t].toString().indexOf("{{")>=0){s=!0;break}}}),{type:6,styles:n,easing:r,offset:t.offset,containsDynamicStyles:s,options:null}}_validateStyleAst(t,e){const n=e.currentAnimateTimings;let s=e.currentTime,r=e.currentTime;n&&r>0&&(r-=n.duration+n.delay),t.styles.forEach(t=>{"string"!=typeof t&&Object.keys(t).forEach(n=>{if(!this._driver.validateStyleProperty(n))return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`);const i=e.collectedStyles[e.currentQuerySelector],o=i[n];let a=!0;o&&(r!=s&&r>=o.startTime&&s<=o.endTime&&(e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${s}ms"`),a=!1),r=o.startTime),a&&(i[n]={startTime:r,endTime:s}),e.options&&function(t,e,n){const s=e.params||{},r=QY(t);r.length&&r.forEach(t=>{s.hasOwnProperty(t)||n.push(`Unable to resolve the local animation param ${t} in the given list of values`)})}(t[n],e.options,e.errors)})})}visitKeyframes(t,e){const n={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push("keyframes() must be placed inside of a call to animate()"),n;let s=0;const r=[];let i=!1,o=!1,a=0;const l=t.steps.map(t=>{const n=this._makeStyleAst(t,e);let l=null!=n.offset?n.offset:function(t){if("string"==typeof t)return null;let e=null;if(Array.isArray(t))t.forEach(t=>{if(gQ(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}});else if(gQ(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}return e}(n.styles),u=0;return null!=l&&(s++,u=n.offset=l),o=o||u<0||u>1,i=i||u<a,a=u,r.push(u),n});o&&e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"),i&&e.errors.push("Please ensure that all keyframe offsets are in order");const u=t.steps.length;let c=0;s>0&&s<u?e.errors.push("Not all style() steps within the declared keyframes() contain offsets"):0==s&&(c=1/(u-1));const h=u-1,d=e.currentTime,p=e.currentAnimateTimings,f=p.duration;return l.forEach((t,s)=>{const i=c>0?s==h?1:c*s:r[s],o=i*f;e.currentTime=d+p.delay+o,p.duration=o,this._validateStyleAst(t,e),t.offset=i,n.styles.push(t)}),n}visitReference(t,e){return{type:8,animation:iQ(this,ZY(t.animation),e),options:yQ(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:yQ(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:yQ(t.options)}}visitQuery(t,e){const n=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[r,i]=function(t){const e=!!t.split(/\s*,\s*/).find(t=>":self"==t);return e&&(t=t.replace(dQ,"")),[t=t.replace(/@\*/g,PY).replace(/@\w+/g,t=>".ng-trigger-"+t.substr(1)).replace(/:animating/g,BY),e]}(t.selector);e.currentQuerySelector=n.length?n+" "+r:r,wY(e.collectedStyles,e.currentQuerySelector,{});const o=iQ(this,ZY(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=n,{type:11,selector:r,limit:s.limit||0,optional:!!s.optional,includeSelf:i,animation:o,originalSelector:t.selector,options:yQ(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push("stagger() can only be used inside of query()");const n="full"===t.timings?{duration:0,delay:0,easing:"full"}:UY(t.timings,e.errors,!0);return{type:12,animation:iQ(this,ZY(t.animation),e),timings:n,options:null}}}class mQ{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function gQ(t){return!Array.isArray(t)&&"object"==typeof t}function yQ(t){var e;return t?(t=jY(t)).params&&(t.params=(e=t.params)?jY(e):null):t={},t}function bQ(t,e,n){return{duration:t,delay:e,easing:n}}function vQ(t,e,n,s,r,i,o=null,a=!1){return{type:1,element:t,keyframes:e,preStyleProps:n,postStyleProps:s,duration:r,delay:i,totalTime:r+i,easing:o,subTimeline:a}}class wQ{constructor(){this._map=new Map}consume(t){let e=this._map.get(t);return e?this._map.delete(t):e=[],e}append(t,e){let n=this._map.get(t);n||this._map.set(t,n=[]),n.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const xQ=new RegExp(":enter","g"),_Q=new RegExp(":leave","g");function kQ(t,e,n,s,r,i={},o={},a,l,u=[]){return(new CQ).buildKeyframes(t,e,n,s,r,i,o,a,l,u)}class CQ{buildKeyframes(t,e,n,s,r,i,o,a,l,u=[]){l=l||new wQ;const c=new SQ(t,e,l,s,r,u,[]);c.options=a,c.currentTimeline.setStyles([i],null,c.errors,a),iQ(this,n,c);const h=c.timelines.filter(t=>t.containsAnimation());if(h.length&&Object.keys(o).length){const t=h[h.length-1];t.allowOnlyTimelineStyles()||t.setStyles([o],null,c.errors,a)}return h.length?h.map(t=>t.buildKeyframes()):[vQ(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const n=e.subInstructions.consume(e.element);if(n){const s=e.createSubContext(t.options),r=e.currentTimeline.currentTime,i=this._visitSubInstructions(n,s,s.options);r!=i&&e.transformIntoNewTimeline(i)}e.previousNode=t}visitAnimateRef(t,e){const n=e.createSubContext(t.options);n.transformIntoNewTimeline(),this.visitReference(t.animation,n),e.transformIntoNewTimeline(n.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,n){let s=e.currentTimeline.currentTime;const r=null!=n.duration?VY(n.duration):null,i=null!=n.delay?VY(n.delay):null;return 0!==r&&t.forEach(t=>{const n=e.appendInstructionToTimeline(t,r,i);s=Math.max(s,n.duration+n.delay)}),s}visitReference(t,e){e.updateOptions(t.options,!0),iQ(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const n=e.subContextCount;let s=e;const r=t.options;if(r&&(r.params||r.delay)&&(s=e.createSubContext(r),s.transformIntoNewTimeline(),null!=r.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=IQ);const t=VY(r.delay);s.delayNextStep(t)}t.steps.length&&(t.steps.forEach(t=>iQ(this,t,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>n&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const n=[];let s=e.currentTimeline.currentTime;const r=t.options&&t.options.delay?VY(t.options.delay):0;t.steps.forEach(i=>{const o=e.createSubContext(t.options);r&&o.delayNextStep(r),iQ(this,i,o),s=Math.max(s,o.currentTimeline.currentTime),n.push(o.currentTimeline)}),n.forEach(t=>e.currentTimeline.mergeTimelineCollectedStyles(t)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const n=t.strValue;return UY(e.params?JY(n,e.params,e.errors):n,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const n=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;n.delay&&(e.incrementTime(n.delay),s.snapshotCurrentStyles());const r=t.style;5==r.type?this.visitKeyframes(r,e):(e.incrementTime(n.duration),this.visitStyle(r,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const n=e.currentTimeline,s=e.currentAnimateTimings;!s&&n.getCurrentStyleProperties().length&&n.forwardFrame();const r=s&&s.easing||t.easing;t.isEmptyStep?n.applyEmptyStep(r):n.setStyles(t.styles,r,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const n=e.currentAnimateTimings,s=e.currentTimeline.duration,r=n.duration,i=e.createSubContext().currentTimeline;i.easing=n.easing,t.styles.forEach(t=>{i.forwardTime((t.offset||0)*r),i.setStyles(t.styles,t.easing,e.errors,e.options),i.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(i),e.transformIntoNewTimeline(s+r),e.previousNode=t}visitQuery(t,e){const n=e.currentTimeline.currentTime,s=t.options||{},r=s.delay?VY(s.delay):0;r&&(6===e.previousNode.type||0==n&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=IQ);let i=n;const o=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=o.length;let a=null;o.forEach((n,s)=>{e.currentQueryIndex=s;const o=e.createSubContext(t.options,n);r&&o.delayNextStep(r),n===e.element&&(a=o.currentTimeline),iQ(this,t.animation,o),o.currentTimeline.applyStylesToKeyframe(),i=Math.max(i,o.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(i),a&&(e.currentTimeline.mergeTimelineCollectedStyles(a),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const n=e.parentContext,s=e.currentTimeline,r=t.timings,i=Math.abs(r.duration),o=i*(e.currentQueryTotal-1);let a=i*e.currentQueryIndex;switch(r.duration<0?"reverse":r.easing){case"reverse":a=o-a;break;case"full":a=n.currentStaggerTime}const l=e.currentTimeline;a&&l.delayNextStep(a);const u=l.currentTime;iQ(this,t.animation,e),e.previousNode=t,n.currentStaggerTime=s.currentTime-u+(s.startTime-n.currentTimeline.startTime)}}const IQ={};class SQ{constructor(t,e,n,s,r,i,o,a){this._driver=t,this.element=e,this.subInstructions=n,this._enterClassName=s,this._leaveClassName=r,this.errors=i,this.timelines=o,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=IQ,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=a||new EQ(this._driver,e,0),o.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const n=t;let s=this.options;null!=n.duration&&(s.duration=VY(n.duration)),null!=n.delay&&(s.delay=VY(n.delay));const r=n.params;if(r){let t=s.params;t||(t=this.options.params={}),Object.keys(r).forEach(n=>{e&&t.hasOwnProperty(n)||(t[n]=JY(r[n],t,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const n=t.params={};Object.keys(e).forEach(t=>{n[t]=e[t]})}}return t}createSubContext(t=null,e,n){const s=e||this.element,r=new SQ(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,n||0));return r.previousNode=this.previousNode,r.currentAnimateTimings=this.currentAnimateTimings,r.options=this._copyOptions(),r.updateOptions(t),r.currentQueryIndex=this.currentQueryIndex,r.currentQueryTotal=this.currentQueryTotal,r.parentContext=this,this.subContextCount++,r}transformIntoNewTimeline(t){return this.previousNode=IQ,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,n){const s={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=n?n:0)+t.delay,easing:""},r=new TQ(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(r),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,n,s,r,i){let o=[];if(s&&o.push(this.element),t.length>0){t=(t=t.replace(xQ,"."+this._enterClassName)).replace(_Q,"."+this._leaveClassName);let e=this._driver.query(this.element,t,1!=n);0!==n&&(e=n<0?e.slice(e.length+n,e.length):e.slice(0,n)),o.push(...e)}return r||0!=o.length||i.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`),o}}class EQ{constructor(t,e,n,s){this._driver=t,this.element=e,this.startTime=n,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new EQ(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(t=>{this._backFill[t]=this._globalTimelineStyles[t]||sY,this._currentKeyframe[t]=sY}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,n,s){e&&(this._previousKeyframe.easing=e);const r=s&&s.params||{},i=function(t,e){const n={};let s;return t.forEach(t=>{"*"===t?(s=s||Object.keys(e),s.forEach(t=>{n[t]=sY})):HY(t,!1,n)}),n}(t,this._globalTimelineStyles);Object.keys(i).forEach(t=>{const e=JY(i[t],r,n);this._pendingStyles[t]=e,this._localTimelineStyles.hasOwnProperty(t)||(this._backFill[t]=this._globalTimelineStyles.hasOwnProperty(t)?this._globalTimelineStyles[t]:sY),this._updateStyle(t,e)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(e=>{this._currentKeyframe[e]=t[e]}),Object.keys(this._localTimelineStyles).forEach(t=>{this._currentKeyframe.hasOwnProperty(t)||(this._currentKeyframe[t]=this._localTimelineStyles[t])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const n=this._styleSummary[e],s=t._styleSummary[e];(!n||s.time>n.time)&&this._updateStyle(e,s.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,n=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((r,i)=>{const o=HY(r,!0);Object.keys(o).forEach(n=>{const s=o[n];"!"==s?t.add(n):s==sY&&e.add(n)}),n||(o.offset=i/this.duration),s.push(o)});const r=t.size?tQ(t.values()):[],i=e.size?tQ(e.values()):[];if(n){const t=s[0],e=jY(t);t.offset=0,e.offset=1,s=[t,e]}return vQ(this.element,s,r,i,this.duration,this.startTime,this.easing,!1)}}class TQ extends EQ{constructor(t,e,n,s,r,i,o=!1){super(t,e,i.delay),this.element=e,this.keyframes=n,this.preStyleProps=s,this.postStyleProps=r,this._stretchStartingKeyframe=o,this.timings={duration:i.duration,delay:i.delay,easing:i.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:n,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const r=[],i=n+e,o=e/i,a=HY(t[0],!1);a.offset=0,r.push(a);const l=HY(t[0],!1);l.offset=NQ(o),r.push(l);const u=t.length-1;for(let s=1;s<=u;s++){let o=HY(t[s],!1);o.offset=NQ((e+o.offset*n)/i),r.push(o)}n=i,e=0,s="",t=r}return vQ(this.element,t,this.preStyleProps,this.postStyleProps,n,e,s,!0)}}function NQ(t,e=3){const n=Math.pow(10,e-1);return Math.round(t*n)/n}class $Q{}class AQ extends $Q{normalizePropertyName(t,e){return nQ(t)}normalizeStyleValue(t,e,n,s){let r="";const i=n.toString().trim();if(RQ[e]&&0!==n&&"0"!==n)if("number"==typeof n)r="px";else{const e=n.match(/^[+-]?[\d\.]+([a-z]*)$/);e&&0==e[1].length&&s.push(`Please provide a CSS unit value for ${t}:${n}`)}return i+r}}const RQ=(()=>function(t){const e={};return t.forEach(t=>e[t]=!0),e}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function FQ(t,e,n,s,r,i,o,a,l,u,c,h,d){return{type:0,element:t,triggerName:e,isRemovalTransition:r,fromState:n,fromStyles:i,toState:s,toStyles:o,timelines:a,queriedElements:l,preStyleProps:u,postStyleProps:c,totalTime:h,errors:d}}const DQ={};class OQ{constructor(t,e,n){this._triggerName=t,this.ast=e,this._stateStyles=n}match(t,e,n,s){return function(t,e,n,s,r){return t.some(t=>t(e,n,s,r))}(this.ast.matchers,t,e,n,s)}buildStyles(t,e,n){const s=this._stateStyles["*"],r=this._stateStyles[t],i=s?s.buildStyles(e,n):{};return r?r.buildStyles(e,n):i}build(t,e,n,s,r,i,o,a,l,u){const c=[],h=this.ast.options&&this.ast.options.params||DQ,d=this.buildStyles(n,o&&o.params||DQ,c),p=a&&a.params||DQ,f=this.buildStyles(s,p,c),m=new Set,g=new Map,y=new Map,b="void"===s,v={params:Object.assign(Object.assign({},h),p)},w=u?[]:kQ(t,e,this.ast.animation,r,i,d,f,v,l,c);let x=0;if(w.forEach(t=>{x=Math.max(t.duration+t.delay,x)}),c.length)return FQ(e,this._triggerName,n,s,b,d,f,[],[],g,y,x,c);w.forEach(t=>{const n=t.element,s=wY(g,n,{});t.preStyleProps.forEach(t=>s[t]=!0);const r=wY(y,n,{});t.postStyleProps.forEach(t=>r[t]=!0),n!==e&&m.add(n)});const _=tQ(m.values());return FQ(e,this._triggerName,n,s,b,d,f,w,_,g,y,x)}}class LQ{constructor(t,e){this.styles=t,this.defaultParams=e}buildStyles(t,e){const n={},s=jY(this.defaultParams);return Object.keys(t).forEach(e=>{const n=t[e];null!=n&&(s[e]=n)}),this.styles.styles.forEach(t=>{if("string"!=typeof t){const r=t;Object.keys(r).forEach(t=>{let i=r[t];i.length>1&&(i=JY(i,s,e)),n[t]=i})}}),n}}class MQ{constructor(t,e){this.name=t,this.ast=e,this.transitionFactories=[],this.states={},e.states.forEach(t=>{this.states[t.name]=new LQ(t.style,t.options&&t.options.params||{})}),PQ(this.states,"true","1"),PQ(this.states,"false","0"),e.transitions.forEach(e=>{this.transitionFactories.push(new OQ(t,e,this.states))}),this.fallbackTransition=new OQ(t,{type:1,animation:{type:2,steps:[],options:null},matchers:[(t,e)=>!0],options:null,queryCount:0,depCount:0},this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,n,s){return this.transitionFactories.find(r=>r.match(t,e,n,s))||null}matchStyles(t,e,n){return this.fallbackTransition.buildStyles(t,e,n)}}function PQ(t,e,n){t.hasOwnProperty(e)?t.hasOwnProperty(n)||(t[n]=t[e]):t.hasOwnProperty(n)&&(t[e]=t[n])}const zQ=new wQ;class BQ{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._normalizer=n,this._animations={},this._playersById={},this.players=[]}register(t,e){const n=[],s=pQ(this._driver,e,n);if(n.length)throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`);this._animations[t]=s}_buildPlayer(t,e,n){const s=t.element,r=gY(0,this._normalizer,0,t.keyframes,e,n);return this._driver.animate(s,r,t.duration,t.delay,t.easing,[],!0)}create(t,e,n={}){const s=[],r=this._animations[t];let i;const o=new Map;if(r?(i=kQ(this._driver,e,r,OY,LY,{},{},n,zQ,s),i.forEach(t=>{const e=wY(o,t.element,{});t.postStyleProps.forEach(t=>e[t]=null)})):(s.push("The requested animation doesn't exist or has already been destroyed"),i=[]),s.length)throw new Error(`Unable to create the animation due to the following errors: ${s.join("\n")}`);o.forEach((t,e)=>{Object.keys(t).forEach(n=>{t[n]=this._driver.computeStyle(e,n,sY)})});const a=mY(i.map(t=>{const e=o.get(t.element);return this._buildPlayer(t,{},e)}));return this._playersById[t]=a,a.onDestroy(()=>this.destroy(t)),this.players.push(a),a}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const n=this.players.indexOf(e);n>=0&&this.players.splice(n,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw new Error(`Unable to find the timeline player referenced by ${t}`);return e}listen(t,e,n,s){const r=vY(e,"","","");return yY(this._getPlayer(t),n,r,s),()=>{}}command(t,e,n,s){if("register"==n)return void this.register(t,s[0]);if("create"==n)return void this.create(t,e,s[0]||{});const r=this._getPlayer(t);switch(n){case"play":r.play();break;case"pause":r.pause();break;case"reset":r.reset();break;case"restart":r.restart();break;case"finish":r.finish();break;case"init":r.init();break;case"setPosition":r.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const VQ="ng-animate-queued",WQ="ng-animate-disabled",UQ=".ng-animate-disabled",jQ=[],HQ={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},GQ={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class qQ{constructor(t,e=""){this.namespaceId=e;const n=t&&t.hasOwnProperty("value");if(this.value=null!=(s=n?t.value:t)?s:null,n){const e=jY(t);delete e.value,this.options=e}else this.options={};var s;this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const t=this.options.params;Object.keys(e).forEach(n=>{null==t[n]&&(t[n]=e[n])})}}}const KQ="void",XQ=new qQ(KQ);class ZQ{constructor(t,e,n){this.id=t,this.hostElement=e,this._engine=n,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,sJ(e,this._hostClassName)}listen(t,e,n,s){if(!this._triggers.hasOwnProperty(e))throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`);if(null==n||0==n.length)throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`);if("start"!=(r=n)&&"done"!=r)throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`);var r;const i=wY(this._elementListeners,t,[]),o={name:e,phase:n,callback:s};i.push(o);const a=wY(this._engine.statesByElement,t,{});return a.hasOwnProperty(e)||(sJ(t,MY),sJ(t,"ng-trigger-"+e),a[e]=XQ),()=>{this._engine.afterFlush(()=>{const t=i.indexOf(o);t>=0&&i.splice(t,1),this._triggers[e]||delete a[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw new Error(`The provided animation trigger "${t}" has not been registered!`);return e}trigger(t,e,n,s=!0){const r=this._getTrigger(e),i=new QQ(this.id,e,t);let o=this._engine.statesByElement.get(t);o||(sJ(t,MY),sJ(t,"ng-trigger-"+e),this._engine.statesByElement.set(t,o={}));let a=o[e];const l=new qQ(n,this.id);if(!(n&&n.hasOwnProperty("value"))&&a&&l.absorbOptions(a.options),o[e]=l,a||(a=XQ),l.value!==KQ&&a.value===l.value){if(!function(t,e){const n=Object.keys(t),s=Object.keys(e);if(n.length!=s.length)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(!e.hasOwnProperty(s)||t[s]!==e[s])return!1}return!0}(a.params,l.params)){const e=[],n=r.matchStyles(a.value,a.params,e),s=r.matchStyles(l.value,l.params,e);e.length?this._engine.reportError(e):this._engine.afterFlush(()=>{XY(t,n),KY(t,s)})}return}const u=wY(this._engine.playersByElement,t,[]);u.forEach(t=>{t.namespaceId==this.id&&t.triggerName==e&&t.queued&&t.destroy()});let c=r.matchTransition(a.value,l.value,t,l.params),h=!1;if(!c){if(!s)return;c=r.fallbackTransition,h=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:c,fromState:a,toState:l,player:i,isFallbackTransition:h}),h||(sJ(t,VQ),i.onStart(()=>{rJ(t,VQ)})),i.onDone(()=>{let e=this.players.indexOf(i);e>=0&&this.players.splice(e,1);const n=this._engine.playersByElement.get(t);if(n){let t=n.indexOf(i);t>=0&&n.splice(t,1)}}),this.players.push(i),u.push(i),i}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,n)=>{delete e[t]}),this._elementListeners.forEach((e,n)=>{this._elementListeners.set(n,e.filter(e=>e.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(t=>t.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const n=this._engine.driver.query(t,PY,!0);n.forEach(t=>{if(t.__ng_removed)return;const n=this._engine.fetchNamespacesByElement(t);n.size?n.forEach(n=>n.triggerLeaveAnimation(t,e,!1,!0)):this.clearElementCache(t)}),this._engine.afterFlushAnimationsDone(()=>n.forEach(t=>this.clearElementCache(t)))}triggerLeaveAnimation(t,e,n,s){const r=this._engine.statesByElement.get(t);if(r){const i=[];if(Object.keys(r).forEach(e=>{if(this._triggers[e]){const n=this.trigger(t,e,KQ,s);n&&i.push(n)}}),i.length)return this._engine.markElementAsRemoved(this.id,t,!0,e),n&&mY(i).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),n=this._engine.statesByElement.get(t);if(e&&n){const s=new Set;e.forEach(e=>{const r=e.name;if(s.has(r))return;s.add(r);const i=this._triggers[r].fallbackTransition,o=n[r]||XQ,a=new qQ(KQ),l=new QQ(this.id,r,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:r,transition:i,fromState:o,toState:a,player:l,isFallbackTransition:!0})})}}removeNode(t,e){const n=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(n.totalAnimations){const e=n.players.length?n.playersByQueriedElement.get(t):[];if(e&&e.length)s=!0;else{let e=t;for(;e=e.parentNode;)if(n.statesByElement.get(e)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)n.markElementAsRemoved(this.id,t,!1,e);else{const s=t.__ng_removed;s&&s!==HQ||(n.afterFlush(()=>this.clearElementCache(t)),n.destroyInnerAnimations(t),n._onRemovalComplete(t,e))}}insertNode(t,e){sJ(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(n=>{const s=n.player;if(s.destroyed)return;const r=n.element,i=this._elementListeners.get(r);i&&i.forEach(e=>{if(e.name==n.triggerName){const s=vY(r,n.triggerName,n.fromState.value,n.toState.value);s._data=t,yY(n.player,e.phase,s,e.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(n)}),this._queue=[],e.sort((t,e)=>{const n=t.transition.ast.depCount,s=e.transition.ast.depCount;return 0==n||0==s?n-s:this._engine.driver.containsElement(t.element,e.element)?1:-1})}destroy(t){this.players.forEach(t=>t.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(e=>e.element===t)||e,e}}class YQ{constructor(t,e,n){this.bodyNode=t,this.driver=e,this._normalizer=n,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(t,e)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(e=>{e.queued&&t.push(e)})}),t}createNamespace(t,e){const n=new ZQ(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(n,e):(this.newHostElements.set(e,n),this.collectEnterElement(e)),this._namespaceLookup[t]=n}_balanceNamespaceList(t,e){const n=this._namespaceList.length-1;if(n>=0){let s=!1;for(let r=n;r>=0;r--)if(this.driver.containsElement(this._namespaceList[r].hostElement,e)){this._namespaceList.splice(r+1,0,t),s=!0;break}s||this._namespaceList.splice(0,0,t)}else this._namespaceList.push(t);return this.namespacesByHostElement.set(e,t),t}register(t,e){let n=this._namespaceLookup[t];return n||(n=this.createNamespace(t,e)),n}registerTrigger(t,e,n){let s=this._namespaceLookup[t];s&&s.register(e,n)&&this.totalAnimations++}destroy(t,e){if(!t)return;const n=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(n.hostElement),delete this._namespaceLookup[t];const e=this._namespaceList.indexOf(n);e>=0&&this._namespaceList.splice(e,1)}),this.afterFlushAnimationsDone(()=>n.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,n=this.statesByElement.get(t);if(n){const t=Object.keys(n);for(let s=0;s<t.length;s++){const r=n[t[s]].namespaceId;if(r){const t=this._fetchNamespace(r);t&&e.add(t)}}}return e}trigger(t,e,n,s){if(JQ(e)){const r=this._fetchNamespace(t);if(r)return r.trigger(e,n,s),!0}return!1}insertNode(t,e,n,s){if(!JQ(e))return;const r=e.__ng_removed;if(r&&r.setForRemoval){r.setForRemoval=!1,r.setForMove=!0;const t=this.collectedLeaveElements.indexOf(e);t>=0&&this.collectedLeaveElements.splice(t,1)}if(t){const s=this._fetchNamespace(t);s&&s.insertNode(e,n)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),sJ(t,WQ)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),rJ(t,WQ))}removeNode(t,e,n,s){if(JQ(e)){const r=t?this._fetchNamespace(t):null;if(r?r.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),n){const n=this.namespacesByHostElement.get(e);n&&n.id!==t&&n.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,n,s){this.collectedLeaveElements.push(e),e.__ng_removed={namespaceId:t,setForRemoval:s,hasAnimation:n,removedBeforeQueried:!1}}listen(t,e,n,s,r){return JQ(e)?this._fetchNamespace(t).listen(e,n,s,r):()=>{}}_buildInstruction(t,e,n,s,r){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,n,s,t.fromState.options,t.toState.options,e,r)}destroyInnerAnimations(t){let e=this.driver.query(t,PY,!0);e.forEach(t=>this.destroyActiveAnimationsForElement(t)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,BY,!0),e.forEach(t=>this.finishActiveQueriedAnimationOnElement(t)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(t=>{t.queued?t.markedForDestroy=!0:t.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(t=>t.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return mY(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t.__ng_removed;if(e&&e.setForRemoval){if(t.__ng_removed=HQ,e.namespaceId){this.destroyInnerAnimations(t);const n=this._fetchNamespace(e.namespaceId);n&&n.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}this.driver.matchesElement(t,UQ)&&this.markElementAsDisabled(t,!1),this.driver.query(t,UQ,!0).forEach(t=>{this.markElementAsDisabled(t,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((t,e)=>this._balanceNamespaceList(t,e)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let n=0;n<this.collectedEnterElements.length;n++)sJ(this.collectedEnterElements[n],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const n=[];try{e=this._flushAnimations(n,t)}finally{for(let t=0;t<n.length;t++)n[t]()}}else for(let n=0;n<this.collectedLeaveElements.length;n++)this.processLeaveNode(this.collectedLeaveElements[n]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(t=>t()),this._flushFns=[],this._whenQuietFns.length){const t=this._whenQuietFns;this._whenQuietFns=[],e.length?mY(e).onDone(()=>{t.forEach(t=>t())}):t.forEach(t=>t())}}reportError(t){throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`)}_flushAnimations(t,e){const n=new wQ,s=[],r=new Map,i=[],o=new Map,a=new Map,l=new Map,u=new Set;this.disabledNodes.forEach(t=>{u.add(t);const e=this.driver.query(t,".ng-animate-queued",!0);for(let n=0;n<e.length;n++)u.add(e[n])});const c=this.bodyNode,h=Array.from(this.statesByElement.keys()),d=nJ(h,this.collectedEnterElements),p=new Map;let f=0;d.forEach((t,e)=>{const n=OY+f++;p.set(e,n),t.forEach(t=>sJ(t,n))});const m=[],g=new Set,y=new Set;for(let $=0;$<this.collectedLeaveElements.length;$++){const t=this.collectedLeaveElements[$],e=t.__ng_removed;e&&e.setForRemoval&&(m.push(t),g.add(t),e.hasAnimation?this.driver.query(t,".ng-star-inserted",!0).forEach(t=>g.add(t)):y.add(t))}const b=new Map,v=nJ(h,Array.from(g));v.forEach((t,e)=>{const n=LY+f++;b.set(e,n),t.forEach(t=>sJ(t,n))}),t.push(()=>{d.forEach((t,e)=>{const n=p.get(e);t.forEach(t=>rJ(t,n))}),v.forEach((t,e)=>{const n=b.get(e);t.forEach(t=>rJ(t,n))}),m.forEach(t=>{this.processLeaveNode(t)})});const w=[],x=[];for(let $=this._namespaceList.length-1;$>=0;$--)this._namespaceList[$].drainQueuedTransitions(e).forEach(t=>{const e=t.player,r=t.element;if(w.push(e),this.collectedEnterElements.length){const t=r.__ng_removed;if(t&&t.setForMove)return void e.destroy()}const u=!c||!this.driver.containsElement(c,r),h=b.get(r),d=p.get(r),f=this._buildInstruction(t,n,d,h,u);if(f.errors&&f.errors.length)x.push(f);else{if(u)return e.onStart(()=>XY(r,f.fromStyles)),e.onDestroy(()=>KY(r,f.toStyles)),void s.push(e);if(t.isFallbackTransition)return e.onStart(()=>XY(r,f.fromStyles)),e.onDestroy(()=>KY(r,f.toStyles)),void s.push(e);f.timelines.forEach(t=>t.stretchStartingKeyframe=!0),n.append(r,f.timelines),i.push({instruction:f,player:e,element:r}),f.queriedElements.forEach(t=>wY(o,t,[]).push(e)),f.preStyleProps.forEach((t,e)=>{const n=Object.keys(t);if(n.length){let t=a.get(e);t||a.set(e,t=new Set),n.forEach(e=>t.add(e))}}),f.postStyleProps.forEach((t,e)=>{const n=Object.keys(t);let s=l.get(e);s||l.set(e,s=new Set),n.forEach(t=>s.add(t))})}});if(x.length){const t=[];x.forEach(e=>{t.push(`@${e.triggerName} has failed due to:\n`),e.errors.forEach(e=>t.push(`- ${e}\n`))}),w.forEach(t=>t.destroy()),this.reportError(t)}const _=new Map,k=new Map;i.forEach(t=>{const e=t.element;n.has(e)&&(k.set(e,e),this._beforeAnimationBuild(t.player.namespaceId,t.instruction,_))}),s.forEach(t=>{const e=t.element;this._getPreviousPlayers(e,!1,t.namespaceId,t.triggerName,null).forEach(t=>{wY(_,e,[]).push(t),t.destroy()})});const C=m.filter(t=>aJ(t,a,l)),I=new Map;eJ(I,this.driver,y,l,sY).forEach(t=>{aJ(t,a,l)&&C.push(t)});const S=new Map;d.forEach((t,e)=>{eJ(S,this.driver,new Set(t),a,"!")}),C.forEach(t=>{const e=I.get(t),n=S.get(t);I.set(t,Object.assign(Object.assign({},e),n))});const E=[],T=[],N={};i.forEach(t=>{const{element:e,player:i,instruction:o}=t;if(n.has(e)){if(u.has(e))return i.onDestroy(()=>KY(e,o.toStyles)),i.disabled=!0,i.overrideTotalTime(o.totalTime),void s.push(i);let t=N;if(k.size>1){let n=e;const s=[];for(;n=n.parentNode;){const e=k.get(n);if(e){t=e;break}s.push(n)}s.forEach(e=>k.set(e,t))}const n=this._buildAnimation(i.namespaceId,o,_,r,S,I);if(i.setRealPlayer(n),t===N)E.push(i);else{const e=this.playersByElement.get(t);e&&e.length&&(i.parentPlayer=mY(e)),s.push(i)}}else XY(e,o.fromStyles),i.onDestroy(()=>KY(e,o.toStyles)),T.push(i),u.has(e)&&s.push(i)}),T.forEach(t=>{const e=r.get(t.element);if(e&&e.length){const n=mY(e);t.setRealPlayer(n)}}),s.forEach(t=>{t.parentPlayer?t.syncPlayerEvents(t.parentPlayer):t.destroy()});for(let $=0;$<m.length;$++){const t=m[$],e=t.__ng_removed;if(rJ(t,LY),e&&e.hasAnimation)continue;let n=[];if(o.size){let e=o.get(t);e&&e.length&&n.push(...e);let s=this.driver.query(t,BY,!0);for(let t=0;t<s.length;t++){let e=o.get(s[t]);e&&e.length&&n.push(...e)}}const s=n.filter(t=>!t.destroyed);s.length?iJ(this,t,s):this.processLeaveNode(t)}return m.length=0,E.forEach(t=>{this.players.push(t),t.onDone(()=>{t.destroy();const e=this.players.indexOf(t);this.players.splice(e,1)}),t.play()}),E}elementContainsData(t,e){let n=!1;const s=e.__ng_removed;return s&&s.setForRemoval&&(n=!0),this.playersByElement.has(e)&&(n=!0),this.playersByQueriedElement.has(e)&&(n=!0),this.statesByElement.has(e)&&(n=!0),this._fetchNamespace(t).elementContainsData(e)||n}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,n,s,r){let i=[];if(e){const e=this.playersByQueriedElement.get(t);e&&(i=e)}else{const e=this.playersByElement.get(t);if(e){const t=!r||r==KQ;e.forEach(e=>{e.queued||(t||e.triggerName==s)&&i.push(e)})}}return(n||s)&&(i=i.filter(t=>!(n&&n!=t.namespaceId||s&&s!=t.triggerName))),i}_beforeAnimationBuild(t,e,n){const s=e.element,r=e.isRemovalTransition?void 0:t,i=e.isRemovalTransition?void 0:e.triggerName;for(const o of e.timelines){const t=o.element,a=t!==s,l=wY(n,t,[]);this._getPreviousPlayers(t,a,r,i,e.toState).forEach(t=>{const e=t.getRealPlayer();e.beforeDestroy&&e.beforeDestroy(),t.destroy(),l.push(t)})}XY(s,e.fromStyles)}_buildAnimation(t,e,n,s,r,i){const o=e.triggerName,a=e.element,l=[],u=new Set,c=new Set,h=e.timelines.map(e=>{const h=e.element;u.add(h);const d=h.__ng_removed;if(d&&d.removedBeforeQueried)return new hY(e.duration,e.delay);const p=h!==a,f=function(t){const e=[];return oJ(t,e),e}((n.get(h)||jQ).map(t=>t.getRealPlayer())).filter(t=>!!t.element&&t.element===h),m=r.get(h),g=i.get(h),y=gY(0,this._normalizer,0,e.keyframes,m,g),b=this._buildPlayer(e,y,f);if(e.subTimeline&&s&&c.add(h),p){const e=new QQ(t,o,h);e.setRealPlayer(b),l.push(e)}return b});l.forEach(t=>{wY(this.playersByQueriedElement,t.element,[]).push(t),t.onDone(()=>function(t,e,n){let s;if(t instanceof Map){if(s=t.get(e),s){if(s.length){const t=s.indexOf(n);s.splice(t,1)}0==s.length&&t.delete(e)}}else if(s=t[e],s){if(s.length){const t=s.indexOf(n);s.splice(t,1)}0==s.length&&delete t[e]}return s}(this.playersByQueriedElement,t.element,t))}),u.forEach(t=>sJ(t,zY));const d=mY(h);return d.onDestroy(()=>{u.forEach(t=>rJ(t,zY)),KY(a,e.toStyles)}),c.forEach(t=>{wY(s,t,[]).push(d)}),d}_buildPlayer(t,e,n){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,n):new hY(t.duration,t.delay)}}class QQ{constructor(t,e,n){this.namespaceId=t,this.triggerName=e,this.element=n,this._player=new hY,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(n=>yY(t,e,void 0,n))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){wY(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function JQ(t){return t&&1===t.nodeType}function tJ(t,e){const n=t.style.display;return t.style.display=null!=e?e:"none",n}function eJ(t,e,n,s,r){const i=[];n.forEach(t=>i.push(tJ(t)));const o=[];s.forEach((n,s)=>{const i={};n.forEach(t=>{const n=i[t]=e.computeStyle(s,t,r);n&&0!=n.length||(s.__ng_removed=GQ,o.push(s))}),t.set(s,i)});let a=0;return n.forEach(t=>tJ(t,i[a++])),o}function nJ(t,e){const n=new Map;if(t.forEach(t=>n.set(t,[])),0==e.length)return n;const s=new Set(e),r=new Map;function i(t){if(!t)return 1;let e=r.get(t);if(e)return e;const o=t.parentNode;return e=n.has(o)?o:s.has(o)?1:i(o),r.set(t,e),e}return e.forEach(t=>{const e=i(t);1!==e&&n.get(e).push(t)}),n}function sJ(t,e){if(t.classList)t.classList.add(e);else{let n=t.$$classes;n||(n=t.$$classes={}),n[e]=!0}}function rJ(t,e){if(t.classList)t.classList.remove(e);else{let n=t.$$classes;n&&delete n[e]}}function iJ(t,e,n){mY(n).onDone(()=>t.processLeaveNode(e))}function oJ(t,e){for(let n=0;n<t.length;n++){const s=t[n];s instanceof dY?oJ(s.players,e):e.push(s)}}function aJ(t,e,n){const s=n.get(t);if(!s)return!1;let r=e.get(t);return r?s.forEach(t=>r.add(t)):e.set(t,s),n.delete(t),!0}class lJ{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._triggerCache={},this.onRemovalComplete=(t,e)=>{},this._transitionEngine=new YQ(t,e,n),this._timelineEngine=new BQ(t,e,n),this._transitionEngine.onRemovalComplete=(t,e)=>this.onRemovalComplete(t,e)}registerTrigger(t,e,n,s,r){const i=t+"-"+s;let o=this._triggerCache[i];if(!o){const t=[],e=pQ(this._driver,r,t);if(t.length)throw new Error(`The animation trigger "${s}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);o=function(t,e){return new MQ(t,e)}(s,e),this._triggerCache[i]=o}this._transitionEngine.registerTrigger(e,s,o)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,n,s){this._transitionEngine.insertNode(t,e,n,s)}onRemove(t,e,n,s){this._transitionEngine.removeNode(t,e,s||!1,n)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,n,s){if("@"==n.charAt(0)){const[t,r]=xY(n);this._timelineEngine.command(t,e,r,s)}else this._transitionEngine.trigger(t,e,n,s)}listen(t,e,n,s,r){if("@"==n.charAt(0)){const[t,s]=xY(n);return this._timelineEngine.listen(t,e,s,r)}return this._transitionEngine.listen(t,e,n,s,r)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function uJ(t,e){let n=null,s=null;return Array.isArray(e)&&e.length?(n=hJ(e[0]),e.length>1&&(s=hJ(e[e.length-1]))):e&&(n=hJ(e)),n||s?new cJ(t,n,s):null}let cJ=(()=>{class t{constructor(e,n,s){this._element=e,this._startStyles=n,this._endStyles=s,this._state=0;let r=t.initialStylesByElement.get(e);r||t.initialStylesByElement.set(e,r={}),this._initialStyles=r}start(){this._state<1&&(this._startStyles&&KY(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(KY(this._element,this._initialStyles),this._endStyles&&(KY(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(t.initialStylesByElement.delete(this._element),this._startStyles&&(XY(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(XY(this._element,this._endStyles),this._endStyles=null),KY(this._element,this._initialStyles),this._state=3)}}return t.initialStylesByElement=new WeakMap,t})();function hJ(t){let e=null;const n=Object.keys(t);for(let s=0;s<n.length;s++){const r=n[s];dJ(r)&&(e=e||{},e[r]=t[r])}return e}function dJ(t){return"display"===t||"position"===t}const pJ="animation",fJ="animationend";class mJ{constructor(t,e,n,s,r,i,o){this._element=t,this._name=e,this._duration=n,this._delay=s,this._easing=r,this._fillMode=i,this._onDoneFn=o,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=t=>this._handleCallback(t)}apply(){!function(t,e){const n=xJ(t,"").trim();n.length&&(function(t,e){let n=0;for(let s=0;s<t.length;s++)","===t.charAt(s)&&n++}(n),e=`${n}, ${e}`),wJ(t,"",e)}(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),vJ(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){gJ(this._element,this._name,"paused")}resume(){gJ(this._element,this._name,"running")}setPosition(t){const e=yJ(this._element,this._name);this._position=t*this._duration,wJ(this._element,"Delay",`-${this._position}ms`,e)}getPosition(){return this._position}_handleCallback(t){const e=t._ngTestManualTimestamp||Date.now(),n=1e3*parseFloat(t.elapsedTime.toFixed(3));t.animationName==this._name&&Math.max(e-this._startTime,0)>=this._delay&&n>=this._duration&&this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),vJ(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(t,e){const n=xJ(t,"").split(","),s=bJ(n,e);s>=0&&(n.splice(s,1),wJ(t,"",n.join(",")))}(this._element,this._name))}}function gJ(t,e,n){wJ(t,"PlayState",n,yJ(t,e))}function yJ(t,e){const n=xJ(t,"");return n.indexOf(",")>0?bJ(n.split(","),e):bJ([n],e)}function bJ(t,e){for(let n=0;n<t.length;n++)if(t[n].indexOf(e)>=0)return n;return-1}function vJ(t,e,n){n?t.removeEventListener(fJ,e):t.addEventListener(fJ,e)}function wJ(t,e,n,s){const r=pJ+e;if(null!=s){const e=t.style[r];if(e.length){const t=e.split(",");t[s]=n,n=t.join(",")}}t.style[r]=n}function xJ(t,e){return t.style[pJ+e]||""}class _J{constructor(t,e,n,s,r,i,o,a){this.element=t,this.keyframes=e,this.animationName=n,this._duration=s,this._delay=r,this._finalStyles=o,this._specialStyles=a,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this.currentSnapshot={},this._state=0,this.easing=i||"linear",this.totalTime=s+r,this._buildStyler()}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}destroy(){this.init(),this._state>=4||(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(t=>t()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}finish(){this.init(),this._state>=3||(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&&this._specialStyles.finish(),this._flushDoneFns())}setPosition(t){this._styler.setPosition(t)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state>=2}init(){this._state>=1||(this._state=1,this._styler.apply(),this._delay&&this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&&this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._state=0,this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new mJ(this.element,this.animationName,this._duration,this._delay,this.easing,"forwards",()=>this.finish())}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}beforeDestroy(){this.init();const t={};if(this.hasStarted()){const e=this._state>=3;Object.keys(this._finalStyles).forEach(n=>{"offset"!=n&&(t[n]=e?this._finalStyles[n]:oQ(this.element,n))})}this.currentSnapshot=t}}class kJ extends hY{constructor(t,e){super(),this.element=t,this._startingStyles={},this.__initialized=!1,this._styles=RY(e)}init(){!this.__initialized&&this._startingStyles&&(this.__initialized=!0,Object.keys(this._styles).forEach(t=>{this._startingStyles[t]=this.element.style[t]}),super.init())}play(){this._startingStyles&&(this.init(),Object.keys(this._styles).forEach(t=>this.element.style.setProperty(t,this._styles[t])),super.play())}destroy(){this._startingStyles&&(Object.keys(this._startingStyles).forEach(t=>{const e=this._startingStyles[t];e?this.element.style.setProperty(t,e):this.element.style.removeProperty(t)}),this._startingStyles=null,super.destroy())}}class CJ{constructor(){this._count=0}validateStyleProperty(t){return TY(t)}matchesElement(t,e){return NY(t,e)}containsElement(t,e){return $Y(t,e)}query(t,e,n){return AY(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}buildKeyframeElement(t,e,n){n=n.map(t=>RY(t));let s=`@keyframes ${e} {\n`,r="";n.forEach(t=>{r=" ";const e=parseFloat(t.offset);s+=`${r}${100*e}% {\n`,r+=" ",Object.keys(t).forEach(e=>{const n=t[e];switch(e){case"offset":return;case"easing":return void(n&&(s+=`${r}animation-timing-function: ${n};\n`));default:return void(s+=`${r}${e}: ${n};\n`)}}),s+=`${r}}\n`}),s+="}\n";const i=document.createElement("style");return i.textContent=s,i}animate(t,e,n,s,r,i=[],o){const a=i.filter(t=>t instanceof _J),l={};sQ(n,s)&&a.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const u=function(t){let e={};return t&&(Array.isArray(t)?t:[t]).forEach(t=>{Object.keys(t).forEach(n=>{"offset"!=n&&"easing"!=n&&(e[n]=t[n])})}),e}(e=rQ(t,e,l));if(0==n)return new kJ(t,u);const c="gen_css_kf_"+this._count++,h=this.buildKeyframeElement(t,c,e);(function(t){var e;const n=null===(e=t.getRootNode)||void 0===e?void 0:e.call(t);return"undefined"!=typeof ShadowRoot&&n instanceof ShadowRoot?n:document.head})(t).appendChild(h);const d=uJ(t,e),p=new _J(t,e,c,n,s,r,u,d);return p.onDestroy(()=>{var t;(t=h).parentNode.removeChild(t)}),p}}class IJ{constructor(t,e,n,s){this.element=t,this.keyframes=e,this.options=n,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=n.duration,this._delay=n.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,n){return t.animate(e,n)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};this.hasStarted()&&Object.keys(this._finalKeyframe).forEach(e=>{"offset"!=e&&(t[e]=this._finished?this._finalKeyframe[e]:oQ(this.element,e))}),this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class SJ{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(EJ().toString()),this._cssKeyframesDriver=new CJ}validateStyleProperty(t){return TY(t)}matchesElement(t,e){return NY(t,e)}containsElement(t,e){return $Y(t,e)}query(t,e,n){return AY(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}overrideWebAnimationsSupport(t){this._isNativeImpl=t}animate(t,e,n,s,r,i=[],o){if(!o&&!this._isNativeImpl)return this._cssKeyframesDriver.animate(t,e,n,s,r,i);const a={duration:n,delay:s,fill:0==s?"both":"forwards"};r&&(a.easing=r);const l={},u=i.filter(t=>t instanceof IJ);sQ(n,s)&&u.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const c=uJ(t,e=rQ(t,e=e.map(t=>HY(t,!1)),l));return new IJ(t,e,a,c)}}function EJ(){return pY()&&Element.prototype.animate||{}}let TJ=(()=>{class t extends nY{constructor(t,e){super(),this._nextAnimationId=0,this._renderer=t.createRenderer(e.body,{id:"0",encapsulation:At.None,styles:[],data:{animation:[]}})}build(t){const e=this._nextAnimationId.toString();this._nextAnimationId++;const n=Array.isArray(t)?oY(t):t;return AJ(this._renderer,null,e,"register",[n]),new NJ(e,this._renderer)}}return t.\u0275fac=function(e){return new(e||t)(fs($a),fs(Ku))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();class NJ extends class{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new $J(this._id,t,e||{},this._renderer)}}class $J{constructor(t,e,n,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",n)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return AJ(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function AJ(t,e,n,s,r){return t.setProperty(e,`@@${n}:${s}`,r)}const RJ="@",FJ="@.disabled";let DJ=(()=>{class t{constructor(t,e,n){this.delegate=t,this.engine=e,this._zone=n,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),e.onRemovalComplete=(t,e)=>{e&&e.parentNode(t)&&e.removeChild(t.parentNode,t)}}createRenderer(t,e){const n=this.delegate.createRenderer(t,e);if(!(t&&e&&e.data&&e.data.animation)){let t=this._rendererCache.get(n);return t||(t=new OJ("",n,this.engine),this._rendererCache.set(n,t)),t}const s=e.id,r=e.id+"-"+this._currentId;this._currentId++,this.engine.register(r,t);const i=e=>{Array.isArray(e)?e.forEach(i):this.engine.registerTrigger(s,r,t,e.name,e)};return e.data.animation.forEach(i),new LJ(this,r,n,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(t,e,n){t>=0&&t<this._microtaskId?this._zone.run(()=>e(n)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(t=>{const[e,n]=t;e(n)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([e,n]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return t.\u0275fac=function(e){return new(e||t)(fs($a),fs(lJ),fs(mu))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();class OJ{constructor(t,e,n){this.namespaceId=t,this.delegate=e,this.engine=n,this.destroyNode=this.delegate.destroyNode?t=>e.destroyNode(t):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,n,s=!0){this.delegate.insertBefore(t,e,n),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,n){this.engine.onRemove(this.namespaceId,e,this.delegate,n)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,n,s){this.delegate.setAttribute(t,e,n,s)}removeAttribute(t,e,n){this.delegate.removeAttribute(t,e,n)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,n,s){this.delegate.setStyle(t,e,n,s)}removeStyle(t,e,n){this.delegate.removeStyle(t,e,n)}setProperty(t,e,n){e.charAt(0)==RJ&&e==FJ?this.disableAnimations(t,!!n):this.delegate.setProperty(t,e,n)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,n){return this.delegate.listen(t,e,n)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class LJ extends OJ{constructor(t,e,n,s){super(e,n,s),this.factory=t,this.namespaceId=e}setProperty(t,e,n){e.charAt(0)==RJ?"."==e.charAt(1)&&e==FJ?this.disableAnimations(t,n=void 0===n||!!n):this.engine.process(this.namespaceId,t,e.substr(1),n):this.delegate.setProperty(t,e,n)}listen(t,e,n){if(e.charAt(0)==RJ){const s=function(t){switch(t){case"body":return document.body;case"document":return document;case"window":return window;default:return t}}(t);let r=e.substr(1),i="";return r.charAt(0)!=RJ&&([r,i]=function(t){const e=t.indexOf(".");return[t.substring(0,e),t.substr(e+1)]}(r)),this.engine.listen(this.namespaceId,s,r,i,t=>{this.factory.scheduleListenerCallback(t._data||-1,n,t)})}return this.delegate.listen(t,e,n)}}let MJ=(()=>{class t extends lJ{constructor(t,e,n){super(t.body,e,n)}ngOnDestroy(){this.flush()}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku),fs(DY),fs($Q))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const PJ=new Zn("AnimationModuleType"),zJ=[{provide:nY,useClass:TJ},{provide:$Q,useFactory:function(){return new AQ}},{provide:lJ,useClass:MJ},{provide:$a,useFactory:function(t,e,n){return new DJ(t,e,n)},deps:[Zc,lJ,mu]}],BJ=[{provide:DY,useFactory:function(){return"function"==typeof EJ()?new SJ:new CJ}},{provide:PJ,useValue:"BrowserAnimations"},...zJ],VJ=[{provide:DY,useClass:FY},{provide:PJ,useValue:"NoopAnimations"},...zJ];let WJ=(()=>{class t{static withConfig(e){return{ngModule:t,providers:e.disableAnimations?VJ:BJ}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:BJ,imports:[hh]}),t})();const UJ=new Da("12.0.4"),jJ=new Zn("mat-sanity-checks",{providedIn:"root",factory:function(){return!0}});let HJ,GJ=(()=>{class t{constructor(t,e,n){this._hasDoneGlobalChecks=!1,this._document=n,t._applyBodyHighContrastModeCssClasses(),this._sanityChecks=e,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getWindow(){const t=this._document.defaultView||window;return"object"==typeof t&&t?t:null}_checksAreEnabled(){return Nu()&&!this._isTestEnv()}_isTestEnv(){const t=this._getWindow();return t&&(t.__karma__||t.jasmine)}_checkDoctypeIsDefined(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype)&&!this._document.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){if(!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme||!this._document.body||"function"!=typeof getComputedStyle)return;const t=this._document.createElement("div");t.classList.add("mat-theme-loaded-marker"),this._document.body.appendChild(t);const e=getComputedStyle(t);e&&"none"!==e.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),this._document.body.removeChild(t)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&UJ.full!==eY.full&&console.warn("The Angular Material version ("+UJ.full+") does not match the Angular CDK version ("+eY.full+").\nPlease ensure the versions of these two packages exactly match.")}}return t.\u0275fac=function(e){return new(e||t)(fs(ZZ),fs(jJ,8),fs(Ku))},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[tY],tY]}),t})();function qJ(t){return class extends t{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=vZ(t)}}}function KJ(t,e){return class extends t{constructor(...t){super(...t),this.defaultColor=e,this.color=e}get color(){return this._color}set color(t){const e=t||this.defaultColor;e!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),e&&this._elementRef.nativeElement.classList.add(`mat-${e}`),this._color=e)}}}function XJ(t){return class extends t{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=vZ(t)}}}try{HJ="undefined"!=typeof Intl}catch(Z3){HJ=!1}let ZJ=(()=>{class t{isErrorState(t,e){return!!(t&&t.invalid&&(t.touched||e&&e.submitted))}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),YJ=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ],GJ]}),t})();class QJ{constructor(t,e,n){this._renderer=t,this.element=e,this.config=n,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const JJ={enterDuration:450,exitDuration:400},t0=$Z({passive:!0}),e0=["mousedown","touchstart"],n0=["mouseup","mouseleave","touchend","touchcancel"];class s0{constructor(t,e,n,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=kZ(n))}fadeInRipple(t,e,n={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),r=Object.assign(Object.assign({},JJ),n.animation);n.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const i=n.radius||function(t,e,n){const s=Math.max(Math.abs(t-n.left),Math.abs(t-n.right)),r=Math.max(Math.abs(e-n.top),Math.abs(e-n.bottom));return Math.sqrt(s*s+r*r)}(t,e,s),o=t-s.left,a=e-s.top,l=r.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=o-i+"px",u.style.top=a-i+"px",u.style.height=2*i+"px",u.style.width=2*i+"px",null!=n.color&&(u.style.backgroundColor=n.color),u.style.transitionDuration=`${l}ms`,this._containerElement.appendChild(u),window.getComputedStyle(u).getPropertyValue("opacity"),u.style.transform="scale(1)";const c=new QJ(this,u,n);return c.state=0,this._activeRipples.add(c),n.persistent||(this._mostRecentTransientRipple=c),this._runTimeoutOutsideZone(()=>{const t=c===this._mostRecentTransientRipple;c.state=1,n.persistent||t&&this._isPointerDown||c.fadeOut()},l),c}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const n=t.element,s=Object.assign(Object.assign({},JJ),t.config.animation);n.style.transitionDuration=`${s.exitDuration}ms`,n.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,n.parentNode.removeChild(n)},s.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._activeRipples.forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=kZ(t);e&&e!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(e0))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(n0),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=VZ(t),n=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||e||n||(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!WZ(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let t=0;t<e.length;t++)this.fadeInRipple(e[t].clientX,e[t].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(t=>{this._triggerElement.addEventListener(t,this,t0)})})}_removeTriggerEvents(){this._triggerElement&&(e0.forEach(t=>{this._triggerElement.removeEventListener(t,this,t0)}),this._pointerUpEventsRegistered&&n0.forEach(t=>{this._triggerElement.removeEventListener(t,this,t0)}))}}const r0=new Zn("mat-ripple-global-options");let i0=(()=>{class t{constructor(t,e,n,s,r){this._elementRef=t,this._animationMode=r,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=s||{},this._rippleRenderer=new s0(this,e,t,n)}get disabled(){return this._disabled}set disabled(t){t&&this.fadeOutAllNonPersistent(),this._disabled=t,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(t){this._trigger=t,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(t,e=0,n){return"number"==typeof t?this._rippleRenderer.fadeInRipple(t,e,Object.assign(Object.assign({},this.rippleConfig),n)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),t))}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(mu),To(TZ),To(r0,8),To(PJ,8))},t.\u0275dir=Jt({type:t,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(t,e){2&t&&Xo("mat-ripple-unbounded",e.unbounded)},inputs:{radius:["matRippleRadius","radius"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"],color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],animation:["matRippleAnimation","animation"]},exportAs:["matRipple"]}),t})(),o0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ,NZ],GJ]}),t})(),a0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ]]}),t})(),l0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[o0,Nc,GJ,a0]]}),t})();const u0=["*",[["mat-toolbar-row"]]],c0=["*","mat-toolbar-row"];class h0{constructor(t){this._elementRef=t}}const d0=KJ(h0);let p0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Jt({type:t,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),t})(),f0=(()=>{class t extends d0{constructor(t,e,n){super(t),this._platform=e,this._document=n}ngAfterViewInit(){this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(TZ),To(Ku))},t.\u0275cmp=qt({type:t,selectors:[["mat-toolbar"]],contentQueries:function(t,e,n){if(1&t&&Ul(n,p0,5),2&t){let t;Vl(t=jl())&&(e._toolbarRows=t)}},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(t,e){2&t&&Xo("mat-toolbar-multiple-rows",e._toolbarRows.length>0)("mat-toolbar-single-row",0===e._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[mo],ngContentSelectors:c0,decls:2,vars:0,template:function(t,e){1&t&&(jo(u0),Ho(0),Ho(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),t})(),m0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ],GJ]}),t})();const g0=["*"],y0=".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n";class b0{constructor(){this.columnIndex=0,this.rowIndex=0}get rowCount(){return this.rowIndex+1}get rowspan(){const t=Math.max(...this.tracker);return t>1?this.rowCount+t-1:this.rowCount}update(t,e){this.columnIndex=0,this.rowIndex=0,this.tracker=new Array(t),this.tracker.fill(0,0,this.tracker.length),this.positions=e.map(t=>this._trackTile(t))}_trackTile(t){const e=this._findMatchingGap(t.colspan);return this._markTilePosition(e,t),this.columnIndex=e+t.colspan,new v0(this.rowIndex,e)}_findMatchingGap(t){let e=-1,n=-1;do{this.columnIndex+t>this.tracker.length?(this._nextRow(),e=this.tracker.indexOf(0,this.columnIndex),n=this._findGapEndIndex(e)):(e=this.tracker.indexOf(0,this.columnIndex),-1!=e?(n=this._findGapEndIndex(e),this.columnIndex=e+1):(this._nextRow(),e=this.tracker.indexOf(0,this.columnIndex),n=this._findGapEndIndex(e)))}while(n-e<t||0==n);return Math.max(e,0)}_nextRow(){this.columnIndex=0,this.rowIndex++;for(let t=0;t<this.tracker.length;t++)this.tracker[t]=Math.max(0,this.tracker[t]-1)}_findGapEndIndex(t){for(let e=t+1;e<this.tracker.length;e++)if(0!=this.tracker[e])return e;return this.tracker.length}_markTilePosition(t,e){for(let n=0;n<e.colspan;n++)this.tracker[t+n]=e.rowspan}}class v0{constructor(t,e){this.row=t,this.col=e}}const w0=new Zn("MAT_GRID_LIST");let x0=(()=>{class t{constructor(t,e){this._element=t,this._gridList=e,this._rowspan=1,this._colspan=1}get rowspan(){return this._rowspan}set rowspan(t){this._rowspan=Math.round(wZ(t))}get colspan(){return this._colspan}set colspan(t){this._colspan=Math.round(wZ(t))}_setStyle(t,e){this._element.nativeElement.style[t]=e}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(w0,8))},t.\u0275cmp=qt({type:t,selectors:[["mat-grid-tile"]],hostAttrs:[1,"mat-grid-tile"],hostVars:2,hostBindings:function(t,e){2&t&&So("rowspan",e.rowspan)("colspan",e.colspan)},inputs:{rowspan:"rowspan",colspan:"colspan"},exportAs:["matGridTile"],ngContentSelectors:g0,decls:2,vars:0,consts:[[1,"mat-grid-tile-content"]],template:function(t,e){1&t&&(jo(),Ao(0,"div",0),Ho(1),Ro())},styles:[y0],encapsulation:2,changeDetection:0}),t})();const _0=/^-?\d+((\.\d+)?[A-Za-z%$]?)+$/;class k0{constructor(){this._rows=0,this._rowspan=0}init(t,e,n,s){this._gutterSize=T0(t),this._rows=e.rowCount,this._rowspan=e.rowspan,this._cols=n,this._direction=s}getBaseTileSize(t,e){return`(${t}% - (${this._gutterSize} * ${e}))`}getTilePosition(t,e){return 0===e?"0":E0(`(${t} + ${this._gutterSize}) * ${e}`)}getTileSize(t,e){return`(${t} * ${e}) + (${e-1} * ${this._gutterSize})`}setStyle(t,e,n){let s=100/this._cols,r=(this._cols-1)/this._cols;this.setColStyles(t,n,s,r),this.setRowStyles(t,e,s,r)}setColStyles(t,e,n,s){let r=this.getBaseTileSize(n,s);t._setStyle("rtl"===this._direction?"right":"left",this.getTilePosition(r,e)),t._setStyle("width",E0(this.getTileSize(r,t.colspan)))}getGutterSpan(){return`${this._gutterSize} * (${this._rowspan} - 1)`}getTileSpan(t){return`${this._rowspan} * ${this.getTileSize(t,1)}`}getComputedHeight(){return null}}class C0 extends k0{constructor(t){super(),this.fixedRowHeight=t}init(t,e,n,s){super.init(t,e,n,s),this.fixedRowHeight=T0(this.fixedRowHeight),_0.test(this.fixedRowHeight)}setRowStyles(t,e){t._setStyle("top",this.getTilePosition(this.fixedRowHeight,e)),t._setStyle("height",E0(this.getTileSize(this.fixedRowHeight,t.rowspan)))}getComputedHeight(){return["height",E0(`${this.getTileSpan(this.fixedRowHeight)} + ${this.getGutterSpan()}`)]}reset(t){t._setListStyle(["height",null]),t._tiles&&t._tiles.forEach(t=>{t._setStyle("top",null),t._setStyle("height",null)})}}class I0 extends k0{constructor(t){super(),this._parseRatio(t)}setRowStyles(t,e,n,s){this.baseTileHeight=this.getBaseTileSize(n/this.rowHeightRatio,s),t._setStyle("marginTop",this.getTilePosition(this.baseTileHeight,e)),t._setStyle("paddingTop",E0(this.getTileSize(this.baseTileHeight,t.rowspan)))}getComputedHeight(){return["paddingBottom",E0(`${this.getTileSpan(this.baseTileHeight)} + ${this.getGutterSpan()}`)]}reset(t){t._setListStyle(["paddingBottom",null]),t._tiles.forEach(t=>{t._setStyle("marginTop",null),t._setStyle("paddingTop",null)})}_parseRatio(t){const e=t.split(":");this.rowHeightRatio=parseFloat(e[0])/parseFloat(e[1])}}class S0 extends k0{setRowStyles(t,e){let n=this.getBaseTileSize(100/this._rowspan,(this._rows-1)/this._rows);t._setStyle("top",this.getTilePosition(n,e)),t._setStyle("height",E0(this.getTileSize(n,t.rowspan)))}reset(t){t._tiles&&t._tiles.forEach(t=>{t._setStyle("top",null),t._setStyle("height",null)})}}function E0(t){return`calc(${t})`}function T0(t){return t.match(/([A-Za-z%]+)$/)?t:`${t}px`}let N0=(()=>{class t{constructor(t,e){this._element=t,this._dir=e,this._gutter="1px"}get cols(){return this._cols}set cols(t){this._cols=Math.max(1,Math.round(wZ(t)))}get gutterSize(){return this._gutter}set gutterSize(t){this._gutter=`${null==t?"":t}`}get rowHeight(){return this._rowHeight}set rowHeight(t){const e=`${null==t?"":t}`;e!==this._rowHeight&&(this._rowHeight=e,this._setTileStyler(this._rowHeight))}ngOnInit(){this._checkCols(),this._checkRowHeight()}ngAfterContentChecked(){this._layoutTiles()}_checkCols(){}_checkRowHeight(){this._rowHeight||this._setTileStyler("1:1")}_setTileStyler(t){this._tileStyler&&this._tileStyler.reset(this),this._tileStyler="fit"===t?new S0:t&&t.indexOf(":")>-1?new I0(t):new C0(t)}_layoutTiles(){this._tileCoordinator||(this._tileCoordinator=new b0);const t=this._tileCoordinator,e=this._tiles.filter(t=>!t._gridList||t._gridList===this),n=this._dir?this._dir.value:"ltr";this._tileCoordinator.update(this.cols,e),this._tileStyler.init(this.gutterSize,t,this.cols,n),e.forEach((e,n)=>{const s=t.positions[n];this._tileStyler.setStyle(e,s.row,s.col)}),this._setListStyle(this._tileStyler.getComputedHeight())}_setListStyle(t){t&&(this._element.nativeElement.style[t[0]]=t[1])}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(JZ,8))},t.\u0275cmp=qt({type:t,selectors:[["mat-grid-list"]],contentQueries:function(t,e,n){if(1&t&&Ul(n,x0,5),2&t){let t;Vl(t=jl())&&(e._tiles=t)}},hostAttrs:[1,"mat-grid-list"],hostVars:1,hostBindings:function(t,e){2&t&&So("cols",e.cols)},inputs:{cols:"cols",gutterSize:"gutterSize",rowHeight:"rowHeight"},exportAs:["matGridList"],features:[xa([{provide:w0,useExisting:t}])],ngContentSelectors:g0,decls:2,vars:0,template:function(t,e){1&t&&(jo(),Ao(0,"div"),Ho(1),Ro())},styles:[y0],encapsulation:2,changeDetection:0}),t})(),$0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[YJ,GJ],YJ,GJ]}),t})();const A0=["mat-button",""],R0=["*"],F0=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"];class D0{constructor(t){this._elementRef=t}}const O0=KJ(qJ(XJ(D0)));let L0=(()=>{class t extends O0{constructor(t,e,n){super(t),this._focusMonitor=e,this._animationMode=n,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const s of F0)this._hasHostAttributes(s)&&this._getHostElement().classList.add(s);t.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(t,e){t?this._focusMonitor.focusVia(this._getHostElement(),t,e):this._getHostElement().focus(e)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...t){return t.some(t=>this._getHostElement().hasAttribute(t))}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(HZ),To(PJ,8))},t.\u0275cmp=qt({type:t,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(t,e){if(1&t&&Wl(i0,5),2&t){let t;Vl(t=jl())&&(e.ripple=t.first)}},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(t,e){2&t&&(So("disabled",e.disabled||null),Xo("_mat-animation-noopable","NoopAnimations"===e._animationMode)("mat-button-disabled",e.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[mo],attrs:A0,ngContentSelectors:R0,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(t,e){1&t&&(jo(),Ao(0,"span",0),Ho(1),Ro(),Fo(2,"span",1),Fo(3,"span",2)),2&t&&(ni(2),Xo("mat-button-ripple-round",e.isRoundButton||e.isIconButton),No("matRippleDisabled",e._isRippleDisabled())("matRippleCentered",e.isIconButton)("matRippleTrigger",e._getHostElement()))},directives:[i0],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"],encapsulation:2,changeDetection:0}),t})(),M0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[o0,GJ],GJ]}),t})();function P0(t,e){if(1&t&&(un(),Fo(0,"circle",3)),2&t){const t=Wo();Ko("animation-name","mat-progress-spinner-stroke-rotate-"+t._spinnerAnimationLabel)("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),So("r",t._getCircleRadius())}}function z0(t,e){if(1&t&&(un(),Fo(0,"circle",3)),2&t){const t=Wo();Ko("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),So("r",t._getCircleRadius())}}function B0(t,e){if(1&t&&(un(),Fo(0,"circle",3)),2&t){const t=Wo();Ko("animation-name","mat-progress-spinner-stroke-rotate-"+t._spinnerAnimationLabel)("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),So("r",t._getCircleRadius())}}function V0(t,e){if(1&t&&(un(),Fo(0,"circle",3)),2&t){const t=Wo();Ko("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),So("r",t._getCircleRadius())}}const W0=".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:currentColor;stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n";class U0{constructor(t){this._elementRef=t}}const j0=KJ(U0,"primary"),H0=new Zn("mat-progress-spinner-default-options",{providedIn:"root",factory:function(){return{diameter:100}}});let G0=(()=>{class t extends j0{constructor(e,n,s,r,i){super(e),this._elementRef=e,this._document=s,this._diameter=100,this._value=0,this._fallbackAnimation=!1,this.mode="determinate";const o=t._diameters;this._spinnerAnimationLabel=this._getSpinnerAnimationLabel(),o.has(s.head)||o.set(s.head,new Set([100])),this._fallbackAnimation=n.EDGE||n.TRIDENT,this._noopAnimations="NoopAnimations"===r&&!!i&&!i._forceAnimations,i&&(i.diameter&&(this.diameter=i.diameter),i.strokeWidth&&(this.strokeWidth=i.strokeWidth))}get diameter(){return this._diameter}set diameter(t){this._diameter=wZ(t),this._spinnerAnimationLabel=this._getSpinnerAnimationLabel(),!this._fallbackAnimation&&this._styleRoot&&this._attachStyleNode()}get strokeWidth(){return this._strokeWidth||this.diameter/10}set strokeWidth(t){this._strokeWidth=wZ(t)}get value(){return"determinate"===this.mode?this._value:0}set value(t){this._value=Math.max(0,Math.min(100,wZ(t)))}ngOnInit(){const t=this._elementRef.nativeElement;this._styleRoot=RZ(t)||this._document.head,this._attachStyleNode(),t.classList.add(`mat-progress-spinner-indeterminate${this._fallbackAnimation?"-fallback":""}-animation`)}_getCircleRadius(){return(this.diameter-10)/2}_getViewBox(){const t=2*this._getCircleRadius()+this.strokeWidth;return`0 0 ${t} ${t}`}_getStrokeCircumference(){return 2*Math.PI*this._getCircleRadius()}_getStrokeDashOffset(){return"determinate"===this.mode?this._getStrokeCircumference()*(100-this._value)/100:this._fallbackAnimation&&"indeterminate"===this.mode?.2*this._getStrokeCircumference():null}_getCircleStrokeWidth(){return this.strokeWidth/this.diameter*100}_attachStyleNode(){const e=this._styleRoot,n=this._diameter,s=t._diameters;let r=s.get(e);if(!r||!r.has(n)){const t=this._document.createElement("style");t.setAttribute("mat-spinner-animation",this._spinnerAnimationLabel),t.textContent=this._getAnimationText(),e.appendChild(t),r||(r=new Set,s.set(e,r)),r.add(n)}}_getAnimationText(){const t=this._getStrokeCircumference();return"\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g,""+.95*t).replace(/END_VALUE/g,""+.2*t).replace(/DIAMETER/g,`${this._spinnerAnimationLabel}`)}_getSpinnerAnimationLabel(){return this.diameter.toString().replace(".","_")}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(TZ),To(Ku,8),To(PJ,8),To(H0))},t.\u0275cmp=qt({type:t,selectors:[["mat-progress-spinner"]],hostAttrs:["role","progressbar","tabindex","-1",1,"mat-progress-spinner"],hostVars:10,hostBindings:function(t,e){2&t&&(So("aria-valuemin","determinate"===e.mode?0:null)("aria-valuemax","determinate"===e.mode?100:null)("aria-valuenow","determinate"===e.mode?e.value:null)("mode",e.mode),Ko("width",e.diameter,"px")("height",e.diameter,"px"),Xo("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color",mode:"mode",diameter:"diameter",strokeWidth:"strokeWidth",value:"value"},exportAs:["matProgressSpinner"],features:[mo],decls:3,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false","aria-hidden","true",3,"ngSwitch"],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(un(),Ao(0,"svg",0),Eo(1,P0,1,9,"circle",1),Eo(2,z0,1,7,"circle",2),Ro()),2&t&&(Ko("width",e.diameter,"px")("height",e.diameter,"px"),No("ngSwitch","indeterminate"===e.mode),So("viewBox",e._getViewBox()),ni(1),No("ngSwitchCase",!0),ni(1),No("ngSwitchCase",!1))},directives:[Sc,Ec],styles:[W0],encapsulation:2,changeDetection:0}),t._diameters=new WeakMap,t})(),q0=(()=>{class t extends G0{constructor(t,e,n,s,r){super(t,e,n,s,r),this.mode="indeterminate"}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(TZ),To(Ku,8),To(PJ,8),To(H0))},t.\u0275cmp=qt({type:t,selectors:[["mat-spinner"]],hostAttrs:["role","progressbar","mode","indeterminate",1,"mat-spinner","mat-progress-spinner"],hostVars:6,hostBindings:function(t,e){2&t&&(Ko("width",e.diameter,"px")("height",e.diameter,"px"),Xo("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color"},features:[mo],decls:3,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false","aria-hidden","true",3,"ngSwitch"],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(un(),Ao(0,"svg",0),Eo(1,B0,1,9,"circle",1),Eo(2,V0,1,7,"circle",2),Ro()),2&t&&(Ko("width",e.diameter,"px")("height",e.diameter,"px"),No("ngSwitch","indeterminate"===e.mode),So("viewBox",e._getViewBox()),ni(1),No("ngSwitchCase",!0),ni(1),No("ngSwitchCase",!1))},directives:[Sc,Ec],styles:[W0],encapsulation:2,changeDetection:0}),t})(),K0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ,Nc],GJ]}),t})();class X0{}class Z0{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(t=>{const e=t.indexOf(":");if(e>0){const n=t.slice(0,e),s=n.toLowerCase(),r=t.slice(e+1).trim();this.maybeSetNormalizedName(n,s),this.headers.has(s)?this.headers.get(s).push(r):this.headers.set(s,[r])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let n=t[e];const s=e.toLowerCase();"string"==typeof n&&(n=[n]),n.length>0&&(this.headers.set(s,n),this.maybeSetNormalizedName(e,s))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof Z0?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new Z0;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof Z0?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let n=t.value;if("string"==typeof n&&(n=[n]),0===n.length)return;this.maybeSetNormalizedName(t.name,e);const s=("a"===t.op?this.headers.get(e):void 0)||[];s.push(...n),this.headers.set(e,s);break;case"d":const r=t.value;if(r){let t=this.headers.get(e);if(!t)return;t=t.filter(t=>-1===r.indexOf(t)),0===t.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,t)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class Y0{encodeKey(t){return Q0(t)}encodeValue(t){return Q0(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}function Q0(t){return encodeURIComponent(t).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/gi,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%2B/gi,"+").replace(/%3D/gi,"=").replace(/%3F/gi,"?").replace(/%2F/gi,"/")}function J0(t){return`${t}`}class t1{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new Y0,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function(t,e){const n=new Map;return t.length>0&&t.replace(/^\?/,"").split("&").forEach(t=>{const s=t.indexOf("="),[r,i]=-1==s?[e.decodeKey(t),""]:[e.decodeKey(t.slice(0,s)),e.decodeValue(t.slice(s+1))],o=n.get(r)||[];o.push(i),n.set(r,o)}),n}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const n=t.fromObject[e];this.map.set(e,Array.isArray(n)?n:[n])})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(n=>{const s=t[n];Array.isArray(s)?s.forEach(t=>{e.push({param:n,value:t,op:"a"})}):e.push({param:n,value:s,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(t=>e+"="+this.encoder.encodeValue(t)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new t1({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(J0(t.value)),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let e=this.map.get(t.param)||[];const n=e.indexOf(J0(t.value));-1!==n&&e.splice(n,1),e.length>0?this.map.set(t.param,e):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class e1{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}keys(){return this.map.keys()}}function n1(t){return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer}function s1(t){return"undefined"!=typeof Blob&&t instanceof Blob}function r1(t){return"undefined"!=typeof FormData&&t instanceof FormData}class i1{constructor(t,e,n,s){let r;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function(t){switch(t){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==n?n:null,r=s):r=n,r&&(this.reportProgress=!!r.reportProgress,this.withCredentials=!!r.withCredentials,r.responseType&&(this.responseType=r.responseType),r.headers&&(this.headers=r.headers),r.context&&(this.context=r.context),r.params&&(this.params=r.params)),this.headers||(this.headers=new Z0),this.context||(this.context=new e1),this.params){const t=this.params.toString();if(0===t.length)this.urlWithParams=e;else{const n=e.indexOf("?");this.urlWithParams=e+(-1===n?"?":n<e.length-1?"&":"")+t}}else this.params=new t1,this.urlWithParams=e}serializeBody(){return null===this.body?null:n1(this.body)||s1(this.body)||r1(this.body)||"string"==typeof this.body?this.body:this.body instanceof t1?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||r1(this.body)?null:s1(this.body)?this.body.type||null:n1(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof t1?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){var e;const n=t.method||this.method,s=t.url||this.url,r=t.responseType||this.responseType,i=void 0!==t.body?t.body:this.body,o=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,a=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let l=t.headers||this.headers,u=t.params||this.params;const c=null!==(e=t.context)&&void 0!==e?e:this.context;return void 0!==t.setHeaders&&(l=Object.keys(t.setHeaders).reduce((e,n)=>e.set(n,t.setHeaders[n]),l)),t.setParams&&(u=Object.keys(t.setParams).reduce((e,n)=>e.set(n,t.setParams[n]),u)),new i1(n,s,i,{params:u,headers:l,context:c,reportProgress:a,responseType:r,withCredentials:o})}}var o1=function(t){return t[t.Sent=0]="Sent",t[t.UploadProgress=1]="UploadProgress",t[t.ResponseHeader=2]="ResponseHeader",t[t.DownloadProgress=3]="DownloadProgress",t[t.Response=4]="Response",t[t.User=5]="User",t}({});class a1 extends class{constructor(t,e=200,n="OK"){this.headers=t.headers||new Z0,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||n,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}{constructor(t={}){super(t),this.type=o1.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new a1({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}function l1(t,e){return{body:e,headers:t.headers,context:t.context,observe:t.observe,params:t.params,reportProgress:t.reportProgress,responseType:t.responseType,withCredentials:t.withCredentials}}let u1=(()=>{class t{constructor(t){this.handler=t}request(t,e,n={}){let s;if(t instanceof i1)s=t;else{let r,i;r=n.headers instanceof Z0?n.headers:new Z0(n.headers),n.params&&(i=n.params instanceof t1?n.params:new t1({fromObject:n.params})),s=new i1(t,e,void 0!==n.body?n.body:null,{headers:r,context:n.context,params:i,reportProgress:n.reportProgress,responseType:n.responseType||"json",withCredentials:n.withCredentials})}const r=fd(s).pipe(jd(t=>this.handler.handle(t)));if(t instanceof i1||"events"===n.observe)return r;const i=r.pipe(Pd(t=>t instanceof a1));switch(n.observe||"body"){case"body":switch(s.responseType){case"arraybuffer":return i.pipe($(t=>{if(null!==t.body&&!(t.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return t.body}));case"blob":return i.pipe($(t=>{if(null!==t.body&&!(t.body instanceof Blob))throw new Error("Response is not a Blob.");return t.body}));case"text":return i.pipe($(t=>{if(null!==t.body&&"string"!=typeof t.body)throw new Error("Response is not a string.");return t.body}));case"json":default:return i.pipe($(t=>t.body))}case"response":return i;default:throw new Error(`Unreachable: unhandled observe type ${n.observe}}`)}}delete(t,e={}){return this.request("DELETE",t,e)}get(t,e={}){return this.request("GET",t,e)}head(t,e={}){return this.request("HEAD",t,e)}jsonp(t,e){return this.request("JSONP",t,{params:(new t1).append(e,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(t,e={}){return this.request("OPTIONS",t,e)}patch(t,e,n={}){return this.request("PATCH",t,l1(n,e))}post(t,e,n={}){return this.request("POST",t,l1(n,e))}put(t,e,n={}){return this.request("PUT",t,l1(n,e))}}return t.\u0275fac=function(e){return new(e||t)(fs(X0))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const c1=["*"];function h1(t){return Error(`Unable to find icon with the name "${t}"`)}function d1(t){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`)}function p1(t){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`)}class f1{constructor(t,e,n){this.url=t,this.svgText=e,this.options=n}}let m1=(()=>{class t{constructor(t,e,n,s){this._httpClient=t,this._sanitizer=e,this._errorHandler=s,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass="material-icons",this._document=n}addSvgIcon(t,e,n){return this.addSvgIconInNamespace("",t,e,n)}addSvgIconLiteral(t,e,n){return this.addSvgIconLiteralInNamespace("",t,e,n)}addSvgIconInNamespace(t,e,n,s){return this._addSvgIconConfig(t,e,new f1(n,null,s))}addSvgIconResolver(t){return this._resolvers.push(t),this}addSvgIconLiteralInNamespace(t,e,n,s){const r=this._sanitizer.sanitize(sr.HTML,n);if(!r)throw p1(n);return this._addSvgIconConfig(t,e,new f1("",r,s))}addSvgIconSet(t,e){return this.addSvgIconSetInNamespace("",t,e)}addSvgIconSetLiteral(t,e){return this.addSvgIconSetLiteralInNamespace("",t,e)}addSvgIconSetInNamespace(t,e,n){return this._addSvgIconSetConfig(t,new f1(e,null,n))}addSvgIconSetLiteralInNamespace(t,e,n){const s=this._sanitizer.sanitize(sr.HTML,e);if(!s)throw p1(e);return this._addSvgIconSetConfig(t,new f1("",s,n))}registerFontClassAlias(t,e=t){return this._fontCssClassesByAlias.set(t,e),this}classNameForFontAlias(t){return this._fontCssClassesByAlias.get(t)||t}setDefaultFontSetClass(t){return this._defaultFontSetClass=t,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(t){const e=this._sanitizer.sanitize(sr.RESOURCE_URL,t);if(!e)throw d1(t);const n=this._cachedIconsByUrl.get(e);return n?fd(g1(n)):this._loadSvgIconFromConfig(new f1(t,null)).pipe(sp(t=>this._cachedIconsByUrl.set(e,t)),$(t=>g1(t)))}getNamedSvgIcon(t,e=""){const n=y1(e,t);let s=this._svgIconConfigs.get(n);if(s)return this._getSvgFromConfig(s);if(s=this._getIconConfigFromResolvers(e,t),s)return this._svgIconConfigs.set(n,s),this._getSvgFromConfig(s);const r=this._iconSetConfigs.get(e);return r?this._getSvgFromIconSetConfigs(t,r):(i=h1(n),new _(t=>t.error(i)));var i}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(t){return t.svgText?fd(g1(this._svgElementFromConfig(t))):this._loadSvgIconFromConfig(t).pipe($(t=>g1(t)))}_getSvgFromIconSetConfigs(t,e){const n=this._extractIconWithNameFromAnySet(t,e);return n?fd(n):dh(e.filter(t=>!t.svgText).map(t=>this._loadSvgIconSetFromConfig(t).pipe(Vd(e=>{const n=this._sanitizer.sanitize(sr.RESOURCE_URL,t.url);return this._errorHandler.handleError(new Error(`Loading icon set URL: ${n} failed: ${e.message}`)),fd(null)})))).pipe($(()=>{const n=this._extractIconWithNameFromAnySet(t,e);if(!n)throw h1(t);return n}))}_extractIconWithNameFromAnySet(t,e){for(let n=e.length-1;n>=0;n--){const s=e[n];if(s.svgText&&s.svgText.indexOf(t)>-1){const e=this._svgElementFromConfig(s),n=this._extractSvgIconFromSet(e,t,s.options);if(n)return n}}return null}_loadSvgIconFromConfig(t){return this._fetchIcon(t).pipe(sp(e=>t.svgText=e),$(()=>this._svgElementFromConfig(t)))}_loadSvgIconSetFromConfig(t){return t.svgText?fd(null):this._fetchIcon(t).pipe(sp(e=>t.svgText=e))}_extractSvgIconFromSet(t,e,n){const s=t.querySelector(`[id="${e}"]`);if(!s)return null;const r=s.cloneNode(!0);if(r.removeAttribute("id"),"svg"===r.nodeName.toLowerCase())return this._setSvgAttributes(r,n);if("symbol"===r.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(r),n);const i=this._svgElementFromString("<svg></svg>");return i.appendChild(r),this._setSvgAttributes(i,n)}_svgElementFromString(t){const e=this._document.createElement("DIV");e.innerHTML=t;const n=e.querySelector("svg");if(!n)throw Error("<svg> tag not found");return n}_toSvgElement(t){const e=this._svgElementFromString("<svg></svg>"),n=t.attributes;for(let s=0;s<n.length;s++){const{name:t,value:r}=n[s];"id"!==t&&e.setAttribute(t,r)}for(let s=0;s<t.childNodes.length;s++)t.childNodes[s].nodeType===this._document.ELEMENT_NODE&&e.appendChild(t.childNodes[s].cloneNode(!0));return e}_setSvgAttributes(t,e){return t.setAttribute("fit",""),t.setAttribute("height","100%"),t.setAttribute("width","100%"),t.setAttribute("preserveAspectRatio","xMidYMid meet"),t.setAttribute("focusable","false"),e&&e.viewBox&&t.setAttribute("viewBox",e.viewBox),t}_fetchIcon(t){var e;const{url:n,options:s}=t,r=null!==(e=null==s?void 0:s.withCredentials)&&void 0!==e&&e;if(!this._httpClient)throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.");if(null==n)throw Error(`Cannot fetch icon from URL "${n}".`);const i=this._sanitizer.sanitize(sr.RESOURCE_URL,n);if(!i)throw d1(n);const o=this._inProgressUrlFetches.get(i);if(o)return o;const a=this._httpClient.get(i,{responseType:"text",withCredentials:r}).pipe(op(()=>this._inProgressUrlFetches.delete(i)),st());return this._inProgressUrlFetches.set(i,a),a}_addSvgIconConfig(t,e,n){return this._svgIconConfigs.set(y1(t,e),n),this}_addSvgIconSetConfig(t,e){const n=this._iconSetConfigs.get(t);return n?n.push(e):this._iconSetConfigs.set(t,[e]),this}_svgElementFromConfig(t){if(!t.svgElement){const e=this._svgElementFromString(t.svgText);this._setSvgAttributes(e,t.options),t.svgElement=e}return t.svgElement}_getIconConfigFromResolvers(t,e){for(let s=0;s<this._resolvers.length;s++){const r=this._resolvers[s](e,t);if(r)return(n=r).url&&n.options?new f1(r.url,null,r.options):new f1(r,null)}var n}}return t.\u0275fac=function(e){return new(e||t)(fs(u1,8),fs(oh),fs(Ku,8),fs(dr))},t.\u0275prov=gt({factory:function(){return new t(fs(u1,8),fs(oh),fs(Ku,8),fs(dr))},token:t,providedIn:"root"}),t})();function g1(t){return t.cloneNode(!0)}function y1(t,e){return t+":"+e}class b1{constructor(t){this._elementRef=t}}const v1=KJ(b1),w1=new Zn("mat-icon-location",{providedIn:"root",factory:function(){const t=ms(Ku),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}}),x1=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],_1=x1.map(t=>`[${t}]`).join(", "),k1=/^url\(['"]?#(.*?)['"]?\)$/;let C1=(()=>{class t extends v1{constructor(t,e,n,s,r){super(t),this._iconRegistry=e,this._location=s,this._errorHandler=r,this._inline=!1,this._currentIconFetch=m.EMPTY,n||t.nativeElement.setAttribute("aria-hidden","true")}get inline(){return this._inline}set inline(t){this._inline=vZ(t)}get svgIcon(){return this._svgIcon}set svgIcon(t){t!==this._svgIcon&&(t?this._updateSvgIcon(t):this._svgIcon&&this._clearSvgElement(),this._svgIcon=t)}get fontSet(){return this._fontSet}set fontSet(t){const e=this._cleanupFontValue(t);e!==this._fontSet&&(this._fontSet=e,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(t){const e=this._cleanupFontValue(t);e!==this._fontIcon&&(this._fontIcon=e,this._updateFontIconClasses())}_splitIconName(t){if(!t)return["",""];const e=t.split(":");switch(e.length){case 1:return["",e[0]];case 2:return e;default:throw Error(`Invalid icon name: "${t}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const t=this._elementsWithExternalReferences;if(t&&t.size){const t=this._location.getPathname();t!==this._previousPath&&(this._previousPath=t,this._prependPathToReferences(t))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(t){this._clearSvgElement();const e=t.querySelectorAll("style");for(let s=0;s<e.length;s++)e[s].textContent+=" ";const n=this._location.getPathname();this._previousPath=n,this._cacheChildrenWithExternalReferences(t),this._prependPathToReferences(n),this._elementRef.nativeElement.appendChild(t)}_clearSvgElement(){const t=this._elementRef.nativeElement;let e=t.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();e--;){const n=t.childNodes[e];1===n.nodeType&&"svg"!==n.nodeName.toLowerCase()||t.removeChild(n)}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const t=this._elementRef.nativeElement,e=this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet):this._iconRegistry.getDefaultFontSetClass();e!=this._previousFontSetClass&&(this._previousFontSetClass&&t.classList.remove(this._previousFontSetClass),e&&t.classList.add(e),this._previousFontSetClass=e),this.fontIcon!=this._previousFontIconClass&&(this._previousFontIconClass&&t.classList.remove(this._previousFontIconClass),this.fontIcon&&t.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(t){return"string"==typeof t?t.trim().split(" ")[0]:t}_prependPathToReferences(t){const e=this._elementsWithExternalReferences;e&&e.forEach((e,n)=>{e.forEach(e=>{n.setAttribute(e.name,`url('${t}#${e.value}')`)})})}_cacheChildrenWithExternalReferences(t){const e=t.querySelectorAll(_1),n=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let s=0;s<e.length;s++)x1.forEach(t=>{const r=e[s],i=r.getAttribute(t),o=i?i.match(k1):null;if(o){let e=n.get(r);e||(e=[],n.set(r,e)),e.push({name:t,value:o[1]})}})}_updateSvgIcon(t){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),t){const[e,n]=this._splitIconName(t);e&&(this._svgNamespace=e),n&&(this._svgName=n),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(n,e).pipe(Ad(1)).subscribe(t=>this._setSvgElement(t),t=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${e}:${n}! ${t.message}`))})}}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(m1),qn("aria-hidden"),To(w1),To(dr))},t.\u0275cmp=qt({type:t,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:7,hostBindings:function(t,e){2&t&&(So("data-mat-icon-type",e._usingFontIcon()?"font":"svg")("data-mat-icon-name",e._svgName||e.fontIcon)("data-mat-icon-namespace",e._svgNamespace||e.fontSet),Xo("mat-icon-inline",e.inline)("mat-icon-no-color","primary"!==e.color&&"accent"!==e.color&&"warn"!==e.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[mo],ngContentSelectors:c1,decls:1,vars:0,template:function(t,e){1&t&&(jo(),Ho(0))},styles:[".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"],encapsulation:2,changeDetection:0}),t})(),I1=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ],GJ]}),t})();function S1(t,e){1&t&&Fo(0,"mat-spinner")}function E1(t,e){if(1&t){const t=Do();Ao(0,"input",11),Mo("change",function(e){return Me(t),Wo(2).onFileChange(e)}),Ro()}}function T1(t,e){if(1&t&&(Ao(0,"div",9),Eo(1,E1,1,0,"input",10),Ro()),2&t){const t=Wo();ni(1),No("ngIf",!t.picBuff)}}function N1(t,e){if(1&t){const t=Do();Ao(0,"div"),Fo(1,"img",12),Ao(2,"button",13),Mo("click",function(){return Me(t),Wo().deletePic()}),Ao(3,"mat-icon"),ea(4,"close"),Ro(),Ro(),Ro()}if(2&t){const t=Wo();ni(1),No("src",t.picBuff,ir)}}function $1(t,e){if(1&t){const t=Do();Ao(0,"div"),Fo(1,"img",14),Ao(2,"button",13),Mo("click",function(){return Me(t),Wo().deletePic()}),Ao(3,"mat-icon"),ea(4,"close"),Ro(),Ro(),Ro()}if(2&t){const t=Wo();ni(1),No("src",t.imageURL,ir)}}function A1(t,e){1&t&&(Ao(0,"div"),Ao(1,"h1"),ea(2," Detects chae "),Ro(),Ao(3,"h3"),ea(4," upload an image "),Fo(5,"br"),Ao(6,"mat-icon"),ea(7,"keyboard_backspace"),Ro(),Ro(),Ro())}function R1(t,e){if(1&t&&(Ao(0,"h2"),ea(1),Fo(2,"p",15),Ro()),2&t){const t=Wo(3);ni(1),na(" This is a ",t.prediction,"! "),ni(1),No("innerHTML",t.sb,rr)}}function F1(t,e){if(1&t&&(Ao(0,"h2"),ea(1),Ro()),2&t){const t=Wo(3);ni(1),na(" Probably a ",t.prediction,"! ")}}function D1(t,e){if(1&t&&(Ao(0,"h2"),ea(1),Ro()),2&t){const t=Wo(3);ni(1),na(" Looks like a ",t.prediction,"?? ")}}function O1(t,e){if(1&t&&(Ao(0,"span"),Eo(1,R1,3,2,"h2",4),Eo(2,F1,2,1,"h2",4),Eo(3,D1,2,1,"h2",4),Ro()),2&t){const t=Wo(2);ni(1),No("ngIf",.8<=t.certainty),ni(1),No("ngIf",.7<=t.certainty&&.8>t.certainty),ni(1),No("ngIf",.5<t.certainty&&.7>t.certainty)}}function L1(t,e){if(1&t&&(Ao(0,"h2"),ea(1),Ro()),2&t){const t=Wo(2);ni(1),na(" This is a ",t.prediction," ")}}function M1(t,e){if(1&t&&(Ao(0,"div"),Eo(1,O1,4,3,"span",4),Eo(2,L1,2,1,"h2",4),Ao(3,"h3"),ea(4),function(t,e){const n=Le();let s;n.firstCreatePass?(s=function(t,e){if(e)for(let n=e.length-1;n>=0;n--){const s=e[n];if(t===s.name)return s}throw new dt("302","The pipe 'percent' could not be found!")}("percent",n.pipeRegistry),n.data[25]=s,s.onDestroy&&(n.destroyHooks||(n.destroyHooks=[])).push(25,s.onDestroy)):s=n.data[25];const r=s.factory||(s.factory=he(s.type)),i=Et(To);try{const t=En(!1),e=r();En(t),function(t,e,n,s){25>=t.data.length&&(t.data[25]=null,t.blueprint[25]=null),e[25]=s}(n,Oe(),0,e)}finally{Et(i)}}(),Ro(),Ro()),2&t){const t=Wo();ni(1),No("ngIf",t.prediction===t.labels[0]),ni(1),No("ngIf",t.prediction!=t.labels[0]),ni(2),na(" ",El(5,3,t.certainty)," ")}}let P1=(()=>{class t{constructor(t){this.TfService=t,this.sb="&#127827",this.title="frontend",this.certainty=-1,this.prediction="",this.labels=[],this.imageURL="",this.form=new nd({pic:new ed(""),url:new ed("")}),this.modelLoaded=!1}ngOnInit(){this.form.reset(),this.picBuff=null,this.imageURL="",this.prediction="",this.certainty=-1,this.labels=[],this.modelSub=this.TfService.modelLoaded.subscribe(t=>{this.modelLoaded=t,this.labels=this.TfService.settings.LABELS})}onFileChange(t){const e=t.target.files;if(0===e.length)return;if(null==e[0].type.match(/image\/*/))return;const n=new FileReader;n.readAsDataURL(e[0]),n.onload=t=>{this.picBuff=n.result}}onUrlChange(t){var e;this.imageURL=null===(e=this.form.get("url"))||void 0===e?void 0:e.value}deletePic(){this.ngOnDestroy(),this.ngOnInit()}onSubmit(){if(this.picBuff){let t=document.getElementById("subject"),e=this.TfService.loadImage(t),n=this.TfService.predict(e).arraySync();this.certainty=Math.max(...n[0]),this.prediction=this.TfService.settings.LABELS[n[0].indexOf(this.certainty)]}else if(""!=this.imageURL){let t=document.getElementById("urlsubject"),e=this.TfService.loadImage(t),n=this.TfService.predict(e).arraySync();this.certainty=Math.max(...n[0]),this.prediction=this.TfService.settings.LABELS[n[0].indexOf(this.certainty)]}}ngOnDestroy(){this.modelSub.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(To(pZ))},t.\u0275cmp=qt({type:t,selectors:[["app-root"]],decls:16,vars:9,consts:[["color","accent",2,"top","0","position","sticky","z-index","1000"],["cols","4","rowHeight","200px"],[3,"formGroup","ngSubmit"],["colspan","3","rowspan","3",2,"background","rgb(203, 250, 203)"],[4,"ngIf"],["class","dropzone",4,"ngIf"],["colspan","1","rowspan","3",2,"background","lightblue"],["colspan","4","rowspan","1",2,"background","lightgreen"],["mat-raised-button","","mat-ripple","","color","primary",3,"onClick"],[1,"dropzone"],["type","file","formControlName","pic",3,"change",4,"ngIf"],["type","file","formControlName","pic",3,"change"],["id","subject",1,"upload",3,"src"],["mat-fab","","mat-ripple","","type","button",2,"z-index","3","position","absolute","top","2%","right","1%",3,"click"],["id","urlsubject","crossorigin","anonymous",1,"upload",3,"src"],[3,"innerHTML"]],template:function(t,e){1&t&&(Ao(0,"mat-toolbar",0),Ao(1,"span"),ea(2,"My Application"),Ro(),Ro(),Ao(3,"mat-grid-list",1),Ao(4,"form",2),Mo("ngSubmit",function(){return e.onSubmit()}),Ao(5,"mat-grid-tile",3),Eo(6,S1,1,0,"mat-spinner",4),Eo(7,T1,2,1,"div",5),Eo(8,N1,5,1,"div",4),Eo(9,$1,5,1,"div",4),Ro(),Ao(10,"mat-grid-tile",6),Eo(11,A1,8,0,"div",4),Eo(12,M1,6,5,"div",4),Ro(),Ao(13,"mat-grid-tile",7),Ao(14,"button",8),Mo("onClick",function(){return e.onSubmit()}),ea(15," Submit "),Ro(),Ro(),Ro(),Ro()),2&t&&(Xo("mat-elevation-z5",!0),ni(4),No("formGroup",e.form),ni(2),No("ngIf",!e.modelLoaded),ni(1),No("ngIf",!e.picBuff&&""===e.imageURL&&e.modelLoaded),ni(1),No("ngIf",e.picBuff&&e.modelLoaded),ni(1),No("ngIf",""!=e.imageURL&&e.modelLoaded),ni(2),No("ngIf",""===e.prediction),ni(1),No("ngIf",""!=e.prediction))},directives:[f0,N0,rd,Mh,ld,x0,_c,L0,i0,q0,vh,Lh,cd,C1],pipes:[Tc],styles:[".dropzone[_ngcontent-%COMP%]{align-items:center;display:flex;flex-direction:column;justify-content:space-around;text-align:center;height:50%;width:80%;z-index:5;border:1px dashed #979797}.upload[_ngcontent-%COMP%]{margin:5 auto;padding:auto;object-fit:scale-down;height:70vh}"]}),t})();function z1(t,e,n,s){return a(n)&&(s=n,n=void 0),s?z1(t,e,n).pipe($(t=>d(t)?s(...t):s(t))):new _(s=>{B1(t,e,function(t){s.next(arguments.length>1?Array.prototype.slice.call(arguments):t)},s,n)})}function B1(t,e,n,s,r){let i;if(function(t){return t&&"function"==typeof t.addEventListener&&"function"==typeof t.removeEventListener}(t)){const s=t;t.addEventListener(e,n,r),i=()=>s.removeEventListener(e,n,r)}else if(function(t){return t&&"function"==typeof t.on&&"function"==typeof t.off}(t)){const s=t;t.on(e,n),i=()=>s.off(e,n)}else if(function(t){return t&&"function"==typeof t.addListener&&"function"==typeof t.removeListener}(t)){const s=t;t.addListener(e,n),i=()=>s.removeListener(e,n)}else{if(!t||!t.length)throw new TypeError("Invalid event target");for(let i=0,o=t.length;i<o;i++)B1(t[i],e,n,s,r)}s.add(i)}class V1{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new W1(t,this.durationSelector))}}class W1 extends W{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let e;try{const{durationSelector:n}=this;e=n(t)}catch(X3){return this.destination.error(X3)}const n=U(e,new V(this));!n||n.closed?this.clearThrottle():this.add(this.throttled=n)}}clearThrottle(){const{value:t,hasValue:e,throttled:n}=this;n&&(this.remove(n),this.throttled=void 0,n.unsubscribe()),e&&(this.value=void 0,this.hasValue=!1,this.destination.next(t))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function U1(t){return!d(t)&&t-parseFloat(t)+1>=0}function j1(t){const{index:e,period:n,subscriber:s}=t;if(s.next(e),!s.closed){if(-1===n)return s.complete();t.index=e+1,this.schedule(t,n)}}function H1(t,e=bZ){return n=()=>function(t=0,e,n){let s=-1;return U1(e)?s=Number(e)<1?1:Number(e):N(e)&&(n=e),N(n)||(n=bZ),new _(e=>{const r=U1(t)?t:+t-n.now();return n.schedule(j1,r,{index:0,period:s,subscriber:e})})}(t,e),function(t){return t.lift(new V1(n))};var n}class G1{constructor(t){this.notifier=t}call(t,e){const n=new q1(t),s=U(this.notifier,new V(n));return s&&!n.seenValue?(n.add(s),e.subscribe(n)):n}}class q1 extends W{constructor(t){super(t),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}let K1=(()=>{class t{constructor(t,e,n){this._ngZone=t,this._platform=e,this._scrolled=new E,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=n}register(t){this.scrollContainers.has(t)||this.scrollContainers.set(t,t.elementScrolled().subscribe(()=>this._scrolled.next(t)))}deregister(t){const e=this.scrollContainers.get(t);e&&(e.unsubscribe(),this.scrollContainers.delete(t))}scrolled(t=20){return this._platform.isBrowser?new _(e=>{this._globalSubscription||this._addGlobalListener();const n=t>0?this._scrolled.pipe(H1(t)).subscribe(e):this._scrolled.subscribe(e);return this._scrolledCount++,()=>{n.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):fd()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((t,e)=>this.deregister(e)),this._scrolled.complete()}ancestorScrolled(t,e){const n=this.getAncestorScrollContainers(t);return this.scrolled(e).pipe(Pd(t=>!t||n.indexOf(t)>-1))}getAncestorScrollContainers(t){const e=[];return this.scrollContainers.forEach((n,s)=>{this._scrollableContainsElement(s,t)&&e.push(s)}),e}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(t,e){let n=kZ(e),s=t.getElementRef().nativeElement;do{if(n==s)return!0}while(n=n.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>z1(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return t.\u0275fac=function(e){return new(e||t)(fs(mu),fs(TZ),fs(Ku,8))},t.\u0275prov=gt({factory:function(){return new t(fs(mu),fs(TZ),fs(Ku,8))},token:t,providedIn:"root"}),t})(),X1=(()=>{class t{constructor(t,e,n){this._platform=t,this._change=new E,this._changeListener=t=>{this._change.next(t)},this._document=n,e.runOutsideAngular(()=>{if(t.isBrowser){const t=this._getWindow();t.addEventListener("resize",this._changeListener),t.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const t=this._getWindow();t.removeEventListener("resize",this._changeListener),t.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const t={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),t}getViewportRect(){const t=this.getViewportScrollPosition(),{width:e,height:n}=this.getViewportSize();return{top:t.top,left:t.left,bottom:t.top+n,right:t.left+e,height:n,width:e}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const t=this._document,e=this._getWindow(),n=t.documentElement,s=n.getBoundingClientRect();return{top:-s.top||t.body.scrollTop||e.scrollY||n.scrollTop||0,left:-s.left||t.body.scrollLeft||e.scrollX||n.scrollLeft||0}}change(t=20){return t>0?this._change.pipe(H1(t)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const t=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:t.innerWidth,height:t.innerHeight}:{width:0,height:0}}}return t.\u0275fac=function(e){return new(e||t)(fs(TZ),fs(mu),fs(Ku,8))},t.\u0275prov=gt({factory:function(){return new t(fs(TZ),fs(mu),fs(Ku,8))},token:t,providedIn:"root"}),t})(),Z1=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})(),Y1=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[tY,NZ,Z1],tY,Z1]}),t})();class Q1{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class J1 extends Q1{constructor(t,e,n,s){super(),this.component=t,this.viewContainerRef=e,this.injector=n,this.componentFactoryResolver=s}}class t2 extends Q1{constructor(t,e,n){super(),this.templateRef=t,this.viewContainerRef=e,this.context=n}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class e2 extends Q1{constructor(t){super(),this.element=t instanceof Ta?t.nativeElement:t}}class n2{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof J1?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof t2?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof e2?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class s2 extends n2{constructor(t,e,n,s,r){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=n,this._defaultInjector=s,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");e.parentNode.insertBefore(n,e),this.outletElement.appendChild(e),this._attachedPortal=t,super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=r}attachComponentPortal(t){const e=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let n;return t.viewContainerRef?(n=t.viewContainerRef.createComponent(e,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>n.destroy())):(n=e.create(t.injector||this._defaultInjector),this._appRef.attachView(n.hostView),this.setDisposeFn(()=>{this._appRef.detachView(n.hostView),n.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(n)),this._attachedPortal=t,n}attachTemplatePortal(t){let e=t.viewContainerRef,n=e.createEmbeddedView(t.templateRef,t.context);return n.rootNodes.forEach(t=>this.outletElement.appendChild(t)),n.detectChanges(),this.setDisposeFn(()=>{let t=e.indexOf(n);-1!==t&&e.remove(t)}),this._attachedPortal=t,n}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let r2=(()=>{class t extends n2{constructor(t,e,n){super(),this._componentFactoryResolver=t,this._viewContainerRef=e,this._isInitialized=!1,this.attached=new Nl,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");t.setAttachedHost(this),e.parentNode.insertBefore(n,e),this._getRootNode().appendChild(e),this._attachedPortal=t,super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=n}get portal(){return this._attachedPortal}set portal(t){(!this.hasAttached()||t||this._isInitialized)&&(this.hasAttached()&&super.detach(),t&&super.attach(t),this._attachedPortal=t)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(t){t.setAttachedHost(this);const e=null!=t.viewContainerRef?t.viewContainerRef:this._viewContainerRef,n=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component),s=e.createComponent(n,e.length,t.injector||e.injector);return e!==this._viewContainerRef&&this._getRootNode().appendChild(s.hostView.rootNodes[0]),super.setDisposeFn(()=>s.destroy()),this._attachedPortal=t,this._attachedRef=s,this.attached.emit(s),s}attachTemplatePortal(t){t.setAttachedHost(this);const e=this._viewContainerRef.createEmbeddedView(t.templateRef,t.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=t,this._attachedRef=e,this.attached.emit(e),e}_getRootNode(){const t=this._viewContainerRef.element.nativeElement;return t.nodeType===t.ELEMENT_NODE?t:t.parentNode}}return t.\u0275fac=function(e){return new(e||t)(To(Ca),To(dl),To(Ku))},t.\u0275dir=Jt({type:t,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[mo]}),t})(),i2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})();const o2=AZ();class a2{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=_Z(-this._previousScrollPosition.left),t.style.top=_Z(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,e=t.style,n=this._document.body.style,s=e.scrollBehavior||"",r=n.scrollBehavior||"";this._isEnabled=!1,e.left=this._previousHTMLStyles.left,e.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),o2&&(e.scrollBehavior=n.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),o2&&(e.scrollBehavior=s,n.scrollBehavior=r)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const t=this._document.body,e=this._viewportRuler.getViewportSize();return t.scrollHeight>e.height||t.scrollWidth>e.width}}class l2{constructor(t,e,n,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=n,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const t=this._viewportRuler.getViewportScrollPosition().top;Math.abs(t-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class u2{enable(){}disable(){}attach(){}}function c2(t,e){return e.some(e=>t.bottom<e.top||t.top>e.bottom||t.right<e.left||t.left>e.right)}function h2(t,e){return e.some(e=>t.top<e.top||t.bottom>e.bottom||t.left<e.left||t.right>e.right)}class d2{constructor(t,e,n,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const t=this._overlayRef.overlayElement.getBoundingClientRect(),{width:e,height:n}=this._viewportRuler.getViewportSize();c2(t,[{width:e,height:n,bottom:n,right:e,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let p2=(()=>{class t{constructor(t,e,n,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this.noop=()=>new u2,this.close=t=>new l2(this._scrollDispatcher,this._ngZone,this._viewportRuler,t),this.block=()=>new a2(this._viewportRuler,this._document),this.reposition=t=>new d2(this._scrollDispatcher,this._viewportRuler,this._ngZone,t),this._document=s}}return t.\u0275fac=function(e){return new(e||t)(fs(K1),fs(X1),fs(mu),fs(Ku))},t.\u0275prov=gt({factory:function(){return new t(fs(K1),fs(X1),fs(mu),fs(Ku))},token:t,providedIn:"root"}),t})();class f2{constructor(t){if(this.scrollStrategy=new u2,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const n of e)void 0!==t[n]&&(this[n]=t[n])}}}class m2{constructor(t,e,n,s,r){this.offsetX=n,this.offsetY=s,this.panelClass=r,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class g2{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let y2=(()=>{class t{constructor(t){this._attachedOverlays=[],this._document=t}ngOnDestroy(){this.detach()}add(t){this.remove(t),this._attachedOverlays.push(t)}remove(t){const e=this._attachedOverlays.indexOf(t);e>-1&&this._attachedOverlays.splice(e,1),0===this._attachedOverlays.length&&this.detach()}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku))},t.\u0275prov=gt({factory:function(){return new t(fs(Ku))},token:t,providedIn:"root"}),t})(),b2=(()=>{class t extends y2{constructor(t){super(t),this._keydownListener=t=>{const e=this._attachedOverlays;for(let n=e.length-1;n>-1;n--)if(e[n]._keydownEvents.observers.length>0){e[n]._keydownEvents.next(t);break}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku))},t.\u0275prov=gt({factory:function(){return new t(fs(Ku))},token:t,providedIn:"root"}),t})(),v2=(()=>{class t extends y2{constructor(t,e){super(t),this._platform=e,this._cursorStyleIsSet=!1,this._clickListener=t=>{const e=t.composedPath?t.composedPath()[0]:t.target,n=this._attachedOverlays.slice();for(let s=n.length-1;s>-1;s--){const r=n[s];if(!(r._outsidePointerEvents.observers.length<1)&&r.hasAttached()){if(r.overlayElement.contains(e))break;r._outsidePointerEvents.next(t)}}}}add(t){if(super.add(t),!this._isAttached){const t=this._document.body;t.addEventListener("click",this._clickListener,!0),t.addEventListener("auxclick",this._clickListener,!0),t.addEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=t.style.cursor,t.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const t=this._document.body;t.removeEventListener("click",this._clickListener,!0),t.removeEventListener("auxclick",this._clickListener,!0),t.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(t.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku),fs(TZ))},t.\u0275prov=gt({factory:function(){return new t(fs(Ku),fs(TZ))},token:t,providedIn:"root"}),t})();const w2=!("undefined"==typeof window||!window||!window.__karma__&&!window.jasmine);let x2=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}ngOnDestroy(){const t=this._containerElement;t&&t.parentNode&&t.parentNode.removeChild(t)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const t="cdk-overlay-container";if(this._platform.isBrowser||w2){const e=this._document.querySelectorAll(`.${t}[platform="server"], .${t}[platform="test"]`);for(let t=0;t<e.length;t++)e[t].parentNode.removeChild(e[t])}const e=this._document.createElement("div");e.classList.add(t),w2?e.setAttribute("platform","test"):this._platform.isBrowser||e.setAttribute("platform","server"),this._document.body.appendChild(e),this._containerElement=e}}return t.\u0275fac=function(e){return new(e||t)(fs(Ku),fs(TZ))},t.\u0275prov=gt({factory:function(){return new t(fs(Ku),fs(TZ))},token:t,providedIn:"root"}),t})();class _2{constructor(t,e,n,s,r,i,o,a,l){this._portalOutlet=t,this._host=e,this._pane=n,this._config=s,this._ngZone=r,this._keyboardDispatcher=i,this._document=o,this._location=a,this._outsideClickDispatcher=l,this._backdropElement=null,this._backdropClick=new E,this._attachments=new E,this._detachments=new E,this._locationChanges=m.EMPTY,this._backdropClickHandler=t=>this._backdropClick.next(t),this._keydownEvents=new E,this._outsidePointerEvents=new E,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Ad(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=_Z(this._config.width),t.height=_Z(this._config.height),t.minWidth=_Z(this._config.minWidth),t.minHeight=_Z(this._config.minHeight),t.maxWidth=_Z(this._config.maxWidth),t.maxHeight=_Z(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let t,e=this._backdropElement;if(!e)return;let n=()=>{e&&(e.removeEventListener("click",this._backdropClickHandler),e.removeEventListener("transitionend",n),e.parentNode&&e.parentNode.removeChild(e)),this._backdropElement==e&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(e,this._config.backdropClass,!1),clearTimeout(t)};e.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{e.addEventListener("transitionend",n)}),e.style.pointerEvents="none",t=this._ngZone.runOutsideAngular(()=>setTimeout(n,500))}_toggleClasses(t,e,n){const s=t.classList;xZ(e).forEach(t=>{t&&(n?s.add(t):s.remove(t))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe((e=X(this._attachments,this._detachments),t=>t.lift(new G1(e)))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())});var e})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}}const k2="cdk-overlay-connected-position-bounding-box",C2=/([A-Za-z%]+)$/;class I2{constructor(t,e,n,s,r){this._viewportRuler=e,this._document=n,this._platform=s,this._overlayContainer=r,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new E,this._resizeSubscription=m.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(k2),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,n=this._viewportRect,s=[];let r;for(let i of this._preferredPositions){let o=this._getOriginPoint(t,i),a=this._getOverlayPoint(o,e,i),l=this._getOverlayFit(a,e,n,i);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(i,o);this._canFitWithFlexibleDimensions(l,a,n)?s.push({position:i,origin:o,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(o,i)}):(!r||r.overlayFit.visibleArea<l.visibleArea)&&(r={overlayFit:l,overlayPoint:a,originPoint:o,position:i,overlayRect:e})}if(s.length){let t=null,e=-1;for(const n of s){const s=n.boundingBoxRect.width*n.boundingBoxRect.height*(n.position.weight||1);s>e&&(e=s,t=n)}return this._isPushed=!1,void this._applyPosition(t.position,t.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(r.position,r.originPoint);this._applyPosition(r.position,r.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&S2(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(k2),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let n,s;if("center"==e.originX)n=t.left+t.width/2;else{const s=this._isRtl()?t.right:t.left,r=this._isRtl()?t.left:t.right;n="start"==e.originX?s:r}return s="center"==e.originY?t.top+t.height/2:"top"==e.originY?t.top:t.bottom,{x:n,y:s}}_getOverlayPoint(t,e,n){let s,r;return s="center"==n.overlayX?-e.width/2:"start"===n.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,r="center"==n.overlayY?-e.height/2:"top"==n.overlayY?0:-e.height,{x:t.x+s,y:t.y+r}}_getOverlayFit(t,e,n,s){const r=T2(e);let{x:i,y:o}=t,a=this._getOffset(s,"x"),l=this._getOffset(s,"y");a&&(i+=a),l&&(o+=l);let u=0-o,c=o+r.height-n.height,h=this._subtractOverflows(r.width,0-i,i+r.width-n.width),d=this._subtractOverflows(r.height,u,c),p=h*d;return{visibleArea:p,isCompletelyWithinViewport:r.width*r.height===p,fitsInViewportVertically:d===r.height,fitsInViewportHorizontally:h==r.width}}_canFitWithFlexibleDimensions(t,e,n){if(this._hasFlexibleDimensions){const s=n.bottom-e.y,r=n.right-e.x,i=E2(this._overlayRef.getConfig().minHeight),o=E2(this._overlayRef.getConfig().minWidth),a=t.fitsInViewportHorizontally||null!=o&&o<=r;return(t.fitsInViewportVertically||null!=i&&i<=s)&&a}return!1}_pushOverlayOnScreen(t,e,n){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=T2(e),r=this._viewportRect,i=Math.max(t.x+s.width-r.width,0),o=Math.max(t.y+s.height-r.height,0),a=Math.max(r.top-n.top-t.y,0),l=Math.max(r.left-n.left-t.x,0);let u=0,c=0;return u=s.width<=r.width?l||-i:t.x<this._viewportMargin?r.left-n.left-t.x:0,c=s.height<=r.height?a||-o:t.y<this._viewportMargin?r.top-n.top-t.y:0,this._previousPushAmount={x:u,y:c},{x:t.x+u,y:t.y+c}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const e=this._getScrollVisibility(),n=new g2(t,e);this._positionChanges.next(n)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let n,s=t.overlayY;n="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let r=0;r<e.length;r++)e[r].style.transformOrigin=`${n} ${s}`}_calculateBoundingBoxRect(t,e){const n=this._viewportRect,s=this._isRtl();let r,i,o,a,l,u;if("top"===e.overlayY)i=t.y,r=n.height-i+this._viewportMargin;else if("bottom"===e.overlayY)o=n.height-t.y+2*this._viewportMargin,r=n.height-o+this._viewportMargin;else{const e=Math.min(n.bottom-t.y+n.top,t.y),s=this._lastBoundingBoxSize.height;r=2*e,i=t.y-e,r>s&&!this._isInitialRender&&!this._growAfterOpen&&(i=t.y-s/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)u=n.width-t.x+this._viewportMargin,a=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)l=t.x,a=n.right-t.x;else{const e=Math.min(n.right-t.x+n.left,t.x),s=this._lastBoundingBoxSize.width;a=2*e,l=t.x-e,a>s&&!this._isInitialRender&&!this._growAfterOpen&&(l=t.x-s/2)}return{top:i,left:l,bottom:o,right:u,width:a,height:r}}_setBoundingBoxStyles(t,e){const n=this._calculateBoundingBoxRect(t,e);this._isInitialRender||this._growAfterOpen||(n.height=Math.min(n.height,this._lastBoundingBoxSize.height),n.width=Math.min(n.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const t=this._overlayRef.getConfig().maxHeight,r=this._overlayRef.getConfig().maxWidth;s.height=_Z(n.height),s.top=_Z(n.top),s.bottom=_Z(n.bottom),s.width=_Z(n.width),s.left=_Z(n.left),s.right=_Z(n.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",t&&(s.maxHeight=_Z(t)),r&&(s.maxWidth=_Z(r))}this._lastBoundingBoxSize=n,S2(this._boundingBox.style,s)}_resetBoundingBoxStyles(){S2(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){S2(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const n={},s=this._hasExactPosition(),r=this._hasFlexibleDimensions,i=this._overlayRef.getConfig();if(s){const s=this._viewportRuler.getViewportScrollPosition();S2(n,this._getExactOverlayY(e,t,s)),S2(n,this._getExactOverlayX(e,t,s))}else n.position="static";let o="",a=this._getOffset(e,"x"),l=this._getOffset(e,"y");a&&(o+=`translateX(${a}px) `),l&&(o+=`translateY(${l}px)`),n.transform=o.trim(),i.maxHeight&&(s?n.maxHeight=_Z(i.maxHeight):r&&(n.maxHeight="")),i.maxWidth&&(s?n.maxWidth=_Z(i.maxWidth):r&&(n.maxWidth="")),S2(this._pane.style,n)}_getExactOverlayY(t,e,n){let s={top:"",bottom:""},r=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&&(r=this._pushOverlayOnScreen(r,this._overlayRect,n));let i=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return r.y-=i,"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(r.y+this._overlayRect.height)+"px":s.top=_Z(r.y),s}_getExactOverlayX(t,e,n){let s,r={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,n)),s=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===s?r.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":r.left=_Z(i.x),r}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),n=this._scrollables.map(t=>t.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:h2(t,n),isOriginOutsideView:c2(t,n),isOverlayClipped:h2(e,n),isOverlayOutsideView:c2(e,n)}}_subtractOverflows(t,...e){return e.reduce((t,e)=>t-Math.max(e,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,n=this._viewportRuler.getViewportScrollPosition();return{top:n.top+this._viewportMargin,left:n.left+this._viewportMargin,right:n.left+t-this._viewportMargin,bottom:n.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&xZ(t).forEach(t=>{""!==t&&-1===this._appliedPanelClasses.indexOf(t)&&(this._appliedPanelClasses.push(t),this._pane.classList.add(t))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof Ta)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,n=t.height||0;return{top:t.y,bottom:t.y+n,left:t.x,right:t.x+e,height:n,width:e}}}function S2(t,e){for(let n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function E2(t){if("number"!=typeof t&&null!=t){const[e,n]=t.split(C2);return n&&"px"!==n?null:parseFloat(e)}return t||null}function T2(t){return{top:Math.floor(t.top),right:Math.floor(t.right),bottom:Math.floor(t.bottom),left:Math.floor(t.left),width:Math.floor(t.width),height:Math.floor(t.height)}}class N2{constructor(t,e,n,s,r,i,o){this._preferredPositions=[],this._positionStrategy=new I2(n,s,r,i,o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e),this.onPositionChange=this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&&(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,n,s){const r=new m2(t,e,n,s);return this._preferredPositions.push(r),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}const $2="cdk-global-overlay-wrapper";class A2{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add($2),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._rightOffset="",this._leftOffset=t,this._justifyContent="flex-start",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._leftOffset="",this._rightOffset=t,this._justifyContent="flex-end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._justifyContent="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,n=this._overlayRef.getConfig(),{width:s,height:r,maxWidth:i,maxHeight:o}=n,a=!("100%"!==s&&"100vw"!==s||i&&"100%"!==i&&"100vw"!==i),l=!("100%"!==r&&"100vh"!==r||o&&"100%"!==o&&"100vh"!==o);t.position=this._cssPosition,t.marginLeft=a?"0":this._leftOffset,t.marginTop=l?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,a?e.justifyContent="flex-start":"center"===this._justifyContent?e.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?e.justifyContent="flex-end":"flex-end"===this._justifyContent&&(e.justifyContent="flex-start"):e.justifyContent=this._justifyContent,e.alignItems=l?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,n=e.style;e.classList.remove($2),n.justifyContent=n.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let R2=(()=>{class t{constructor(t,e,n,s){this._viewportRuler=t,this._document=e,this._platform=n,this._overlayContainer=s}global(){return new A2}connectedTo(t,e,n){return new N2(e,n,t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(t){return new I2(t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return t.\u0275fac=function(e){return new(e||t)(fs(X1),fs(Ku),fs(TZ),fs(x2))},t.\u0275prov=gt({factory:function(){return new t(fs(X1),fs(Ku),fs(TZ),fs(x2))},token:t,providedIn:"root"}),t})(),F2=0,D2=(()=>{class t{constructor(t,e,n,s,r,i,o,a,l,u,c){this.scrollStrategies=t,this._overlayContainer=e,this._componentFactoryResolver=n,this._positionBuilder=s,this._keyboardDispatcher=r,this._injector=i,this._ngZone=o,this._document=a,this._directionality=l,this._location=u,this._outsideClickDispatcher=c}create(t){const e=this._createHostElement(),n=this._createPaneElement(e),s=this._createPortalOutlet(n),r=new f2(t);return r.direction=r.direction||this._directionality.value,new _2(s,e,n,r,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(t){const e=this._document.createElement("div");return e.id="cdk-overlay-"+F2++,e.classList.add("cdk-overlay-pane"),t.appendChild(e),e}_createHostElement(){const t=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(t),t}_createPortalOutlet(t){return this._appRef||(this._appRef=this._injector.get(Lu)),new s2(t,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return t.\u0275fac=function(e){return new(e||t)(fs(p2),fs(x2),fs(Ca),fs(R2),fs(b2),fs(po),fs(mu),fs(Ku),fs(JZ),fs(uc),fs(v2))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})();const O2={provide:new Zn("cdk-connected-overlay-scroll-strategy"),deps:[D2],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let L2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[D2,O2],imports:[[tY,i2,Y1],Y1]}),t})(),M2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Nc,GJ,OZ],GJ]}),t})();const P2={provide:new Zn("mat-autocomplete-scroll-strategy"),deps:[D2],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let z2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[P2],imports:[[L2,l0,GJ,Nc],Z1,l0,GJ]}),t})(),B2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})(),V2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[o0,GJ,OZ,B2],GJ,B2]}),t})(),W2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[NZ]]}),t})(),U2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[ZJ],imports:[[W2,M2,GJ],W2,M2]}),t})(),j2=(()=>{class t{constructor(){this.changes=new E,this.calendarLabel="Calendar",this.openCalendarLabel="Open calendar",this.closeCalendarLabel="Close calendar",this.prevMonthLabel="Previous month",this.nextMonthLabel="Next month",this.prevYearLabel="Previous year",this.nextYearLabel="Next year",this.prevMultiYearLabel="Previous 24 years",this.nextMultiYearLabel="Next 24 years",this.switchToMonthViewLabel="Choose date",this.switchToMultiYearViewLabel="Choose month and year"}formatYearRange(t,e){return`${t} \u2013 ${e}`}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const H2={provide:new Zn("mat-datepicker-scroll-strategy"),deps:[D2],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let G2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[j2,H2],imports:[[Nc,M0,L2,YZ,i2,GJ],Z1]}),t})(),q2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[o0,GJ],GJ]}),t})();const K2={provide:new Zn("mat-select-scroll-strategy"),deps:[D2],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let X2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[K2],imports:[[Nc,L2,l0,GJ],Z1,M2,l0,GJ]}),t})(),Z2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Nc,GJ],GJ]}),t})(),Y2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})(),Q2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Y2,o0,GJ,OZ],Y2,GJ]}),t})();const J2={provide:new Zn("mat-menu-scroll-strategy"),deps:[D2],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let t3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[J2],imports:[GJ]}),t})(),e3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[J2],imports:[[Nc,GJ,o0,L2,t3],Z1,GJ,t3]}),t})(),n3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Nc,GJ,NZ,Z1],Z1,GJ]}),t})(),s3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ],GJ]}),t})(),r3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ],GJ]}),t})(),i3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})(),o3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Nc,GJ,i3,i2]]}),t})(),a3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[YJ,o0,GJ,a0,Nc],YJ,GJ,a0,r3]}),t})(),l3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[tY]]}),t})(),u3=(()=>{class t{constructor(){this.changes=new E,this.optionalLabel="Optional"}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const c3={provide:u3,deps:[[new vs,new ws,u3]],useFactory:function(t){return t||new u3}};let h3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[c3,ZJ],imports:[[GJ,Nc,i2,M0,l3,I1,o0],GJ]}),t})(),d3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Nc,GJ,i2,o0,OZ,YZ],GJ]}),t})(),p3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({}),t})(),f3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[p3,GJ],GJ]}),t})(),m3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[GJ,o0],GJ]}),t})(),g3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[YZ,GJ],GJ]}),t})();const y3=new Zn("mat-chips-default-options"),b3={separatorKeyCodes:[13]};let v3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[ZJ,{provide:y3,useValue:b3}],imports:[[GJ]]}),t})(),w3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Nc,GJ],GJ]}),t})(),x3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[L2,GJ,i2],GJ]}),t})();function _3(t,e){}class k3{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.autoFocus=!0,this.restoreFocus=!0,this.closeOnNavigation=!0}}const C3={dialogContainer:rY("dialogContainer",[lY("void, exit",aY({opacity:0,transform:"scale(0.7)"})),lY("enter",aY({transform:"none"})),uY("* => enter",iY("150ms cubic-bezier(0, 0, 0.2, 1)",aY({transform:"none",opacity:1}))),uY("* => void, * => exit",iY("75ms cubic-bezier(0.4, 0.0, 0.2, 1)",aY({opacity:0})))])};let I3=(()=>{class t extends n2{constructor(t,e,n,s,r,i){super(),this._elementRef=t,this._focusTrapFactory=e,this._changeDetectorRef=n,this._config=r,this._focusMonitor=i,this._animationStateChanged=new Nl,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=t=>(this._portalOutlet.hasAttached(),this._portalOutlet.attachDomPortal(t)),this._ariaLabelledBy=r.ariaLabelledBy||null,this._document=s}_initializeWithAttachedContent(){this._setupFocusTrap(),this._capturePreviouslyFocusedElement(),this._focusDialogContainer()}attachComponentPortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachComponentPortal(t)}attachTemplatePortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachTemplatePortal(t)}_recaptureFocus(){this._containsFocus()||(!this._config.autoFocus||!this._focusTrap.focusInitialElement())&&this._elementRef.nativeElement.focus()}_trapFocus(){this._config.autoFocus?this._focusTrap.focusInitialElementWhenReady():this._containsFocus()||this._elementRef.nativeElement.focus()}_restoreFocus(){const t=this._elementFocusedBeforeDialogWasOpened;if(this._config.restoreFocus&&t&&"function"==typeof t.focus){const e=FZ(),n=this._elementRef.nativeElement;e&&e!==this._document.body&&e!==n&&!n.contains(e)||(this._focusMonitor?(this._focusMonitor.focusVia(t,this._closeInteractionType),this._closeInteractionType=null):t.focus())}this._focusTrap&&this._focusTrap.destroy()}_setupFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement)}_capturePreviouslyFocusedElement(){this._document&&(this._elementFocusedBeforeDialogWasOpened=FZ())}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const t=this._elementRef.nativeElement,e=FZ();return t===e||t.contains(e)}}return t.\u0275fac=function(e){return new(e||t)(To(Ta),To(BZ),To(tl),To(Ku,8),To(k3),To(HZ))},t.\u0275dir=Jt({type:t,viewQuery:function(t,e){if(1&t&&Wl(r2,7),2&t){let t;Vl(t=jl())&&(e._portalOutlet=t.first)}},features:[mo]}),t})(),S3=(()=>{class t extends I3{constructor(){super(...arguments),this._state="enter"}_onAnimationDone({toState:t,totalTime:e}){"enter"===t?(this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:e})):"exit"===t&&(this._restoreFocus(),this._animationStateChanged.next({state:"closed",totalTime:e}))}_onAnimationStart({toState:t,totalTime:e}){"enter"===t?this._animationStateChanged.next({state:"opening",totalTime:e}):"exit"!==t&&"void"!==t||this._animationStateChanged.next({state:"closing",totalTime:e})}_startExitAnimation(){this._state="exit",this._changeDetectorRef.markForCheck()}}return t.\u0275fac=function(){let e;return function(n){return(e||(e=Hn(t)))(n||t)}}(),t.\u0275cmp=qt({type:t,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1","aria-modal","true",1,"mat-dialog-container"],hostVars:6,hostBindings:function(t,e){1&t&&Po("@dialogContainer.start",function(t){return e._onAnimationStart(t)})("@dialogContainer.done",function(t){return e._onAnimationDone(t)}),2&t&&(sa("id",e._id),So("role",e._config.role)("aria-labelledby",e._config.ariaLabel?null:e._ariaLabelledBy)("aria-label",e._config.ariaLabel)("aria-describedby",e._config.ariaDescribedBy||null),ra("@dialogContainer",e._state))},features:[mo],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(t,e){1&t&&Eo(0,_3,0,0,"ng-template",0)},directives:[r2],styles:[".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"],encapsulation:2,data:{animation:[C3.dialogContainer]}}),t})(),E3=0;class T3{constructor(t,e,n="mat-dialog-"+E3++){this._overlayRef=t,this._containerInstance=e,this.id=n,this.disableClose=this._containerInstance._config.disableClose,this._afterOpened=new E,this._afterClosed=new E,this._beforeClosed=new E,this._state=0,e._id=n,e._animationStateChanged.pipe(Pd(t=>"opened"===t.state),Ad(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),e._animationStateChanged.pipe(Pd(t=>"closed"===t.state),Ad(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._afterClosed.next(this._result),this._afterClosed.complete(),this.componentInstance=null,this._overlayRef.dispose()}),t.keydownEvents().pipe(Pd(t=>27===t.keyCode&&!this.disableClose&&!function(t,...e){return e.length?e.some(e=>t[e]):t.altKey||t.shiftKey||t.ctrlKey||t.metaKey}(t))).subscribe(t=>{t.preventDefault(),N3(this,"keyboard")}),t.backdropClick().subscribe(()=>{this.disableClose?this._containerInstance._recaptureFocus():N3(this,"mouse")})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(Pd(t=>"closing"===t.state),Ad(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._afterClosed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._overlayRef.backdropClick()}keydownEvents(){return this._overlayRef.keydownEvents()}updatePosition(t){let e=this._getPositionStrategy();return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._overlayRef.updatePosition(),this}updateSize(t="",e=""){return this._overlayRef.updateSize({width:t,height:e}),this._overlayRef.updatePosition(),this}addPanelClass(t){return this._overlayRef.addPanelClass(t),this}removePanelClass(t){return this._overlayRef.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._overlayRef.dispose()}_getPositionStrategy(){return this._overlayRef.getConfig().positionStrategy}}function N3(t,e,n){return void 0!==t._containerInstance&&(t._containerInstance._closeInteractionType=e),t.close(n)}const $3=new Zn("MatDialogData"),A3=new Zn("mat-dialog-default-options"),R3=new Zn("mat-dialog-scroll-strategy"),F3={provide:R3,deps:[D2],useFactory:function(t){return()=>t.scrollStrategies.block()}};let D3=(()=>{class t{constructor(t,e,n,s,r,i,o,a,l){this._overlay=t,this._injector=e,this._defaultOptions=n,this._parentDialog=s,this._overlayContainer=r,this._dialogRefConstructor=o,this._dialogContainerType=a,this._dialogDataToken=l,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new E,this._afterOpenedAtThisLevel=new E,this._ariaHiddenElements=new Map,this.afterAllClosed=Sd(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Dd(void 0))),this._scrollStrategy=i}get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const t=this._parentDialog;return t?t._getAfterAllClosed():this._afterAllClosedAtThisLevel}open(t,e){(e=function(t,e){return Object.assign(Object.assign({},e),t)}(e,this._defaultOptions||new k3)).id&&this.getDialogById(e.id);const n=this._createOverlay(e),s=this._attachDialogContainer(n,e),r=this._attachDialogContent(t,s,n,e);return this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(r),r.afterClosed().subscribe(()=>this._removeOpenDialog(r)),this.afterOpened.next(r),s._initializeWithAttachedContent(),r}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(t){return this.openDialogs.find(e=>e.id===t)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_createOverlay(t){const e=this._getOverlayConfig(t);return this._overlay.create(e)}_getOverlayConfig(t){const e=new f2({positionStrategy:this._overlay.position().global(),scrollStrategy:t.scrollStrategy||this._scrollStrategy(),panelClass:t.panelClass,hasBackdrop:t.hasBackdrop,direction:t.direction,minWidth:t.minWidth,minHeight:t.minHeight,maxWidth:t.maxWidth,maxHeight:t.maxHeight,disposeOnNavigation:t.closeOnNavigation});return t.backdropClass&&(e.backdropClass=t.backdropClass),e}_attachDialogContainer(t,e){const n=po.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:k3,useValue:e}]}),s=new J1(this._dialogContainerType,e.viewContainerRef,n,e.componentFactoryResolver);return t.attach(s).instance}_attachDialogContent(t,e,n,s){const r=new this._dialogRefConstructor(n,e,s.id);if(t instanceof il)e.attachTemplatePortal(new t2(t,null,{$implicit:s.data,dialogRef:r}));else{const n=this._createInjector(s,r,e),i=e.attachComponentPortal(new J1(t,s.viewContainerRef,n));r.componentInstance=i.instance}return r.updateSize(s.width,s.height).updatePosition(s.position),r}_createInjector(t,e,n){const s=t&&t.viewContainerRef&&t.viewContainerRef.injector,r=[{provide:this._dialogContainerType,useValue:n},{provide:this._dialogDataToken,useValue:t.data},{provide:this._dialogRefConstructor,useValue:e}];return!t.direction||s&&s.get(JZ,null)||r.push({provide:JZ,useValue:{value:t.direction,change:fd()}}),po.create({parent:s||this._injector,providers:r})}_removeOpenDialog(t){const e=this.openDialogs.indexOf(t);e>-1&&(this.openDialogs.splice(e,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((t,e)=>{t?e.setAttribute("aria-hidden",t):e.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const t=this._overlayContainer.getContainerElement();if(t.parentElement){const e=t.parentElement.children;for(let n=e.length-1;n>-1;n--){let s=e[n];s===t||"SCRIPT"===s.nodeName||"STYLE"===s.nodeName||s.hasAttribute("aria-live")||(this._ariaHiddenElements.set(s,s.getAttribute("aria-hidden")),s.setAttribute("aria-hidden","true"))}}}_closeDialogs(t){let e=t.length;for(;e--;)t[e].close()}}return t.\u0275fac=function(e){return new(e||t)(To(D2),To(po),To(void 0),To(void 0),To(x2),To(void 0),To(Qn),To(Qn),To(Zn))},t.\u0275dir=Jt({type:t}),t})(),O3=(()=>{class t extends D3{constructor(t,e,n,s,r,i,o){super(t,e,s,i,o,r,T3,S3,$3)}}return t.\u0275fac=function(e){return new(e||t)(fs(D2),fs(po),fs(uc,8),fs(A3,8),fs(R3),fs(t,12),fs(x2))},t.\u0275prov=gt({token:t,factory:t.\u0275fac}),t})(),L3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[O3,F3],imports:[[L2,i2,GJ],GJ]}),t})(),M3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[L2,i2,Nc,M0,GJ],GJ]}),t})();const P3={provide:new Zn("mat-tooltip-scroll-strategy"),deps:[D2],useFactory:function(t){return()=>t.scrollStrategies.reposition({scrollThrottle:20})}};let z3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[P3],imports:[[YZ,Nc,L2,GJ],GJ,Z1]}),t})(),B3=(()=>{class t{constructor(){this.changes=new E,this.itemsPerPageLabel="Items per page:",this.nextPageLabel="Next page",this.previousPageLabel="Previous page",this.firstPageLabel="First page",this.lastPageLabel="Last page",this.getRangeLabel=(t,e,n)=>{if(0==n||0==e)return`0 of ${n}`;const s=t*e;return`${s+1} \u2013 ${s<(n=Math.max(n,0))?Math.min(s+e,n):s+e} of ${n}`}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const V3={provide:B3,deps:[[new vs,new ws,B3]],useFactory:function(t){return t||new B3}};let W3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[V3],imports:[[Nc,M0,X2,z3,GJ]]}),t})(),U3=(()=>{class t{constructor(){this.changes=new E}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=gt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const j3={provide:U3,deps:[[new vs,new ws,U3]],useFactory:function(t){return t||new U3}};let H3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({providers:[j3],imports:[[Nc,GJ]]}),t})(),G3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[Y1]]}),t})(),q3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t}),t.\u0275inj=yt({imports:[[G3,GJ],GJ]}),t})(),K3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Yt({type:t,bootstrap:[P1]}),t.\u0275inj=yt({providers:[],imports:[[hh,og,WJ,dd,pd,z2,V2,G2,M2,U2,q2,X2,Z2,Q2,e3,n3,m0,s3,r3,o3,$0,a3,h3,d3,f3,M0,m3,g3,v3,I1,K0,w3,o0,x3,L3,M3,z3,W3,H3,q3],z2,V2,G2,M2,U2,q2,X2,Z2,Q2,e3,n3,m0,s3,r3,o3,$0,a3,h3,d3,f3,M0,m3,g3,v3,I1,K0,w3,o0,x3,L3,M3,z3,W3,H3,q3]}),t})();(function(){if(Tu)throw new Error("Cannot enable prod mode after platform setup.");Eu=!1})(),uh().bootstrapModule(K3).catch(t=>console.error(t))},410:()=>{},628:()=>{},601:()=>{},792:()=>{},42:()=>{}},t=>{"use strict";t(t.s=843)}]);