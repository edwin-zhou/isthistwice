(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[179],{255:t=>{function e(t){return Promise.resolve().then(()=>{var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e})}e.keys=()=>[],e.resolve=e,e.id=255,t.exports=e},929:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(S){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function s(t){return!0===(t&&t.__isLong__)}Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=s;var r={},i={};function a(t,e){var n,s,a;return e?(a=0<=(t>>>=0)&&t<256)&&(s=i[t])?s:(n=l(t,(0|t)<0?-1:0,!0),a&&(i[t]=n),n):(a=-128<=(t|=0)&&t<128)&&(s=r[t])?s:(n=l(t,t<0?-1:0,!1),a&&(r[t]=n),n)}function o(t,e){if(isNaN(t))return e?y:g;if(e){if(t<0)return y;if(t>=p)return x}else{if(t<=-f)return k;if(t+1>=f)return _}return t<0?o(-t,e).neg():l(t%d|0,t/d|0,e)}function l(t,e,s){return new n(t,e,s)}n.fromInt=a,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return g;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var s;if((s=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===s)return c(t.substring(1),e,n).neg();for(var r=o(u(n,8)),i=g,a=0;a<t.length;a+=8){var l=Math.min(8,t.length-a),h=parseInt(t.substring(a,a+l),n);if(l<8){var d=o(u(n,l));i=i.mul(d).add(o(h))}else i=(i=i.mul(r)).add(o(h))}return i.unsigned=e,i}function h(t,e){return"number"==typeof t?o(t,e):"string"==typeof t?c(t,e):l(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=a(1<<24),g=a(0);n.ZERO=g;var y=a(0,!0);n.UZERO=y;var b=a(1);n.ONE=b;var v=a(1,!0);n.UONE=v;var w=a(-1);n.NEG_ONE=w;var _=l(-1,2147483647,!1);n.MAX_VALUE=_;var x=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=x;var k=l(0,-2147483648,!1);n.MIN_VALUE=k;var C=n.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},C.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var e=o(t),n=this.div(e),s=n.mul(e).sub(this);return n.toString(t)+s.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var r=o(u(t,6),this.unsigned),i=this,a="";;){var l=i.div(r),c=(i.sub(l.mul(r)).toInt()>>>0).toString(t);if((i=l).isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1==(1&this.low)},C.isEven=function(){return 0==(1&this.low)},C.equals=function(t){return s(t)||(t=h(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},C.eq=C.equals,C.notEquals=function(t){return!this.eq(t)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(t){return this.comp(t)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(t){return this.comp(t)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(t){return this.comp(t)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(t){return this.comp(t)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(t){if(s(t)||(t=h(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(b)},C.neg=C.negate,C.add=function(t){s(t)||(t=h(t));var e=0,n=0,r=0,i=0;return r+=(i+=(65535&this.low)+(65535&t.low))>>>16,n+=(r+=(this.low>>>16)+(t.low>>>16))>>>16,e+=(n+=(65535&this.high)+(65535&t.high))>>>16,e+=(this.high>>>16)+(t.high>>>16),l((r&=65535)<<16|(i&=65535),(e&=65535)<<16|(n&=65535),this.unsigned)},C.subtract=function(t){return s(t)||(t=h(t)),this.add(t.neg())},C.sub=C.subtract,C.multiply=function(t){if(this.isZero())return g;if(s(t)||(t=h(t)),e)return l(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return g;if(this.eq(k))return t.isOdd()?k:g;if(t.eq(k))return this.isOdd()?k:g;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(m)&&t.lt(m))return o(this.toNumber()*t.toNumber(),this.unsigned);var n=65535&this.high,r=this.low>>>16,i=65535&this.low,a=65535&t.high,u=t.low>>>16,c=65535&t.low,d=0,p=0,f=0,y=0;return f+=(y+=i*c)>>>16,p+=(f+=r*c)>>>16,f&=65535,p+=(f+=i*u)>>>16,d+=(p+=n*c)>>>16,p&=65535,d+=(p+=r*u)>>>16,p&=65535,d+=(p+=i*a)>>>16,d+=(this.high>>>16)*c+n*u+r*a+i*(t.high>>>16),l((f&=65535)<<16|(y&=65535),(d&=65535)<<16|(p&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(t){if(s(t)||(t=h(t)),t.isZero())throw Error("division by zero");var n,r,i;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?l((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return y;if(t.gt(this.shru(1)))return v;i=y}else{if(this.eq(k))return t.eq(b)||t.eq(w)?k:t.eq(k)?b:(n=this.shr(1).div(t).shl(1)).eq(g)?t.isNegative()?b:w:(r=this.sub(t.mul(n)),i=n.add(r.div(t)));if(t.eq(k))return this.unsigned?y:g;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();i=g}for(r=this;r.gte(t);){n=Math.max(1,Math.floor(r.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),c=a<=48?1:u(2,a-48),d=o(n),p=d.mul(t);p.isNegative()||p.gt(r);)p=(d=o(n-=c,this.unsigned)).mul(t);d.isZero()&&(d=b),i=i.add(d),r=r.sub(p)}return i},C.div=C.divide,C.modulo=function(t){return s(t)||(t=h(t)),e?l((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return l(~this.low,~this.high,this.unsigned)},C.and=function(t){return s(t)||(t=h(t)),l(this.low&t.low,this.high&t.high,this.unsigned)},C.or=function(t){return s(t)||(t=h(t)),l(this.low|t.low,this.high|t.high,this.unsigned)},C.xor=function(t){return s(t)||(t=h(t)),l(this.low^t.low,this.high^t.high,this.unsigned)},C.shiftLeft=function(t){return s(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):l(0,this.low<<t-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(t){return s(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):l(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(t){if(s(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?l(this.low>>>t|e<<32-t,e>>>t,this.unsigned):l(32===t?e:e>>>t-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},C.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},C.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,s){return s?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},566:(t,e,n)=>{var s=n(683),r=n(669),i=n(64),a=n(763),o=n(553),l=n(464),u=n(147);u.alea=s,u.xor128=r,u.xorwow=i,u.xorshift7=a,u.xor4096=o,u.tychei=l,t.exports=u},683:function(t,e,n){var s;!function(t,r,i){function a(t){var e,n=this,s=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var s=.02519603282416938*(e+=t.charCodeAt(n));s-=e=s>>>0,e=(s*=e)>>>0,e+=4294967296*(s-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=s(" "),n.s1=s(" "),n.s2=s(" "),n.s0-=s(t),n.s0<0&&(n.s0+=1),n.s1-=s(t),n.s1<0&&(n.s1+=1),n.s2-=s(t),n.s2<0&&(n.s2+=1),s=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new a(t),s=e&&e.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.alea=l}(0,t=n.nmd(t))},464:function(t,e,n){var s;!function(t,r,i){function a(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,s=e.d,r=e.a;return t=t<<25^t>>>7^n,n=n-s|0,s=s<<24^s>>>8^r,r=r-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-s|0,e.d=s<<16^n>>>16^r,e.a=r-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var s=0;s<n.length+20;s++)e.b^=0|n.charCodeAt(s),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.tychei=l}(0,t=n.nmd(t))},669:function(t,e,n){var s;!function(t,r,i){function a(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var s=0;s<n.length+64;s++)e.x^=0|n.charCodeAt(s),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xor128=l}(0,t=n.nmd(t))},553:function(t,e,n){var s;!function(t,r,i){function a(t){var e=this;e.next=function(){var t,n,s=e.w,r=e.X,i=e.i;return e.w=s=s+1640531527|0,n=r[i+34&127],t=r[i=i+1&127],n^=n<<13,t^=t<<17,n=r[i]=(n^=n>>>15)^(t^=t>>>12),e.i=i,n+(s^s>>>16)|0},function(t,e){var n,s,r,i,a,o=[],l=128;for(e===(0|e)?(s=e,e=null):(e+="\0",s=0,l=Math.max(l,e.length)),r=0,i=-32;i<l;++i)e&&(s^=e.charCodeAt((i+32)%e.length)),0===i&&(a=s),s^=s<<10,s^=s>>>15,s^=s<<4,s^=s>>>13,i>=0&&(r=0==(n=o[127&i]^=s+(a=a+1640531527|0))?r+1:0);for(r>=128&&(o[127&(e&&e.length||0)]=-1),r=127,i=512;i>0;--i)s=o[r+34&127],n=o[r=r+1&127],s^=s<<13,n^=n<<17,o[r]=(s^=s>>>15)^(n^=n>>>12);t.w=a,t.X=o,t.i=r}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&(s.X&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xor4096=l}(0,t=n.nmd(t))},763:function(t,e,n){var s;!function(t,r,i){function a(t){var e=this;e.next=function(){var t,n,s=e.x,r=e.i;return t=s[r],n=(t^=t>>>7)^t<<24,n^=(t=s[r+1&7])^t>>>10,n^=(t=s[r+3&7])^t>>>3,n^=(t=s[r+4&7])^t<<7,t=s[r+7&7],s[r]=n^=(t^=t<<13)^t<<9,e.i=r+1&7,n},function(t,e){var n,s=[];if(e===(0|e))s[0]=e;else for(e=""+e,n=0;n<e.length;++n)s[7&n]=s[7&n]<<15^e.charCodeAt(n)+s[n+1&7]<<13;for(;s.length<8;)s.push(0);for(n=0;n<8&&0===s[n];++n);for(8==n&&(s[7]=-1),t.x=s,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&(s.x&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xorshift7=l}(0,t=n.nmd(t))},64:function(t,e,n){var s;!function(t,r,i){function a(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var s=0;s<n.length+64;s++)e.x^=0|n.charCodeAt(s),s==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xorwow=l}(0,t=n.nmd(t))},147:(t,e,n)=>{var s;!function(r,i){var a,o=this,l=256,u=i.pow(l,6),c=i.pow(2,52),h=2*c,d=255;function p(t,e,n){var s=[],d=y(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,b(r)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(l):(t=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(t)),b(t)}catch(s){var e=o.navigator,n=e&&e.plugins;return[+new Date,o,n,o.screen,b(r)]}}():t,3),s),p=new f(s),v=function(){for(var t=p.g(6),e=u,n=0;t<c;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),r),(e.pass||n||function(t,e,n,s){return s&&(s.S&&m(s,p),t.state=function(){return m(p,{})}),n?(i.random=t,e):t})(v,d,"global"in e?e.global:this==i,e.state)}function f(t){var e,n=t.length,s=this,r=0,i=s.i=s.j=0,a=s.S=[];for(n||(t=[n++]);r<l;)a[r]=r++;for(r=0;r<l;r++)a[r]=a[i=d&i+t[r%n]+(e=a[r])],a[i]=e;(s.g=function(t){for(var e,n=0,r=s.i,i=s.j,a=s.S;t--;)e=a[r=d&r+1],n=n*l+a[d&(a[r]=a[i=d&i+e])+(a[i]=e)];return s.i=r,s.j=i,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,s=[],r=typeof t;if(e&&"object"==r)for(n in t)try{s.push(g(t[n],e-1))}catch(i){}return s.length?s:"string"==r?t:t+"\0"}function y(t,e){for(var n,s=t+"",r=0;r<s.length;)e[d&r]=d&(n^=19*e[d&r])+s.charCodeAt(r++);return b(e)}function b(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=p,y(i.random(),r),t.exports){t.exports=p;try{a=n(42)}catch(v){}}else void 0===(s=(function(){return p}).call(e,n,e,t))||(t.exports=s)}([],Math)},998:(t,e,n)=>{"use strict";var s={};n.r(s),n.d(s,{assertParamsValid:()=>hk,computeFlatOffset:()=>Ck,computeOutShape:()=>pk,getNormalizedAxes:()=>yk,isSliceContinous:()=>kk,maskToAxes:()=>dk,parseSliceParams:()=>Sk,sliceInfo:()=>Ik,startForAxis:()=>_k,startIndicesWithElidedDims:()=>bk,stopForAxis:()=>xk,stopIndicesWithElidedDims:()=>vk,stridesForAxis:()=>wk,stridesWithElidedDims:()=>fk});var r={};n.r(r),n.d(r,{collectGatherOpShapeInfo:()=>dN,computeOutShape:()=>hN,segOpComputeOptimalWindowSize:()=>cN});var i={};n.r(i),n.d(i,{ERF_A1:()=>BE,ERF_A2:()=>WE,ERF_A3:()=>UE,ERF_A4:()=>jE,ERF_A5:()=>HE,ERF_P:()=>VE,PARALLELIZE_THRESHOLD:()=>IE,SELU_SCALE:()=>zE,SELU_SCALEALPHA:()=>PE,applyActivation:()=>iI,assertAndGetBroadcastShape:()=>TC,assertAxesAreInnerMostDims:()=>sS,assertParamsConsistent:()=>CE,assignToTypedArray:()=>JE,axesAreInnerMostDims:()=>JC,calculateShapes:()=>ME,checkEinsumDimSizes:()=>iN,combineLocations:()=>tS,complexWithEvenIndex:()=>ZE,complexWithOddIndex:()=>YE,computeConv2DInfo:()=>qk,computeConv3DInfo:()=>Kk,computeDefaultPad:()=>Xk,computeDilation2DInfo:()=>jk,computeOptimalWindowSize:()=>EE,computeOutAndReduceShapes:()=>eS,computeOutShape:()=>SE,computePool2DInfo:()=>Hk,computePool3DInfo:()=>Gk,convertConv2DDataFormat:()=>nC,decodeEinsumEquation:()=>sN,eitherStridesOrDilationsAreOne:()=>eC,expandShapeToKeepDim:()=>nS,exponent:()=>eN,exponents:()=>tN,fromStringArrayToUint8:()=>fN,fromUint8ToStringArray:()=>pN,getAxesPermutation:()=>rS,getBroadcastDims:()=>EC,getComplexWithIndex:()=>QE,getEinsumComputePath:()=>aN,getEinsumPermutation:()=>rN,getFusedBiasGradient:()=>rI,getFusedDyActivation:()=>sI,getImageCenter:()=>NE,getInnerMostAxes:()=>aS,getPermuted:()=>AE,getReductionAxes:()=>NC,getReshaped:()=>TE,getReshapedPermuted:()=>$E,getSliceBeginCoords:()=>RE,getSliceSize:()=>OE,getUndoAxesPermutation:()=>iS,isIdentityPermutation:()=>oN,log:()=>qE,mergeRealAndImagArrays:()=>KE,prepareAndValidate:()=>FE,prepareSplitSize:()=>uN,segment_util:()=>r,shouldFuse:()=>aI,slice_util:()=>s,splitRealAndImagArrays:()=>XE,tupleValuesAreOne:()=>tC,upcastType:()=>H_,validateInput:()=>LE,validateUpdateShape:()=>DE,warn:()=>GE});var a={};n.r(a),n.d(a,{json:()=>OL});var o={};n.r(o),n.d(o,{json:()=>FL});var l={};n.r(l),n.d(l,{json:()=>DL});var u={};n.r(u),n.d(u,{json:()=>LL});var c={};n.r(c),n.d(c,{json:()=>ML});var h={};n.r(h),n.d(h,{json:()=>PL});var d={};n.r(d),n.d(d,{json:()=>zL});var p={};n.r(p),n.d(p,{json:()=>VL});var f={};n.r(f),n.d(f,{json:()=>BL});var m={};n.r(m),n.d(m,{json:()=>WL});var g={};n.r(g),n.d(g,{json:()=>UL});var y={};n.r(y),n.d(y,{json:()=>jL});var b={};n.r(b),n.d(b,{json:()=>HL});var v={};n.r(v),n.d(v,{json:()=>GL});var w={};n.r(w),n.d(w,{json:()=>qL});var _={};n.r(_),n.d(_,{json:()=>KL});var x={};n.r(x),n.d(x,{json:()=>XL});var k={};n.r(k),n.d(k,{json:()=>ZL});var C={};n.r(C),n.d(C,{json:()=>YL});var S={};function I(t){return"function"==typeof t}n.r(S),n.d(S,{addImpl:()=>iz,bincountImpl:()=>Yz,bincountReduceImpl:()=>Qz,ceilImpl:()=>eV,concatImpl:()=>oV,equalImpl:()=>UV,expImpl:()=>tB,expm1Impl:()=>iB,floorImpl:()=>xB,gatherNdImpl:()=>AB,gatherV2Impl:()=>RB,greaterEqualImpl:()=>MB,greaterImpl:()=>FB,lessEqualImpl:()=>ZB,lessImpl:()=>qB,linSpaceImpl:()=>JB,logImpl:()=>eW,maxImpl:()=>gW,maximumImpl:()=>vW,minimumImpl:()=>TW,multiplyImpl:()=>DV,negImpl:()=>zW,notEqualImpl:()=>qW,prodImpl:()=>aU,rangeImpl:()=>lU,rsqrtImpl:()=>wU,simpleAbsImpl:()=>fz,sliceImpl:()=>qz,sparseFillEmptyRowsImpl:()=>VU,sparseReshapeImpl:()=>WU,sparseSegmentReductionImpl:()=>jU,squaredDifferenceImpl:()=>QU,stridedSliceImpl:()=>sj,stringNGramsImpl:()=>aj,stringSplitImpl:()=>uj,stringToHashBucketFastImpl:()=>hj,subImpl:()=>hB,tileImpl:()=>gj,topKImpl:()=>yj,transposeImpl:()=>_z,uniqueImpl:()=>xj});let E=!1;const N={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const t=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+t.stack)}else E&&console.log("RxJS: Back to a better error behavior. Thank you. <3");E=t},get useDeprecatedSynchronousErrorHandling(){return E}};function T(t){setTimeout(()=>{throw t},0)}const A={closed:!0,next(t){},error(t){if(N.useDeprecatedSynchronousErrorHandling)throw t;T(t)},complete(){}},$=(()=>Array.isArray||(t=>t&&"number"==typeof t.length))();function R(t){return null!==t&&"object"==typeof t}const O=(()=>{function t(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t,this}return t.prototype=Object.create(Error.prototype),t})();let F=(()=>{class t{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&&(this._ctorUnsubscribe=!0,this._unsubscribe=t)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:s,_unsubscribe:r,_subscriptions:i}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof t)n.remove(this);else if(null!==n)for(let t=0;t<n.length;++t)n[t].remove(this);if(I(r)){s&&(this._unsubscribe=void 0);try{r.call(this)}catch(a){e=a instanceof O?D(a.errors):[a]}}if($(i)){let t=-1,n=i.length;for(;++t<n;){const n=i[t];if(R(n))try{n.unsubscribe()}catch(a){e=e||[],a instanceof O?e=e.concat(D(a.errors)):e.push(a)}}}if(e)throw new O(e)}add(e){let n=e;if(!e)return t.EMPTY;switch(typeof e){case"function":n=new t(e);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof t)){const e=n;n=new t,n._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:s}=n;if(null===s)n._parentOrParents=this;else if(s instanceof t){if(s===this)return n;n._parentOrParents=[s,this]}else{if(-1!==s.indexOf(this))return n;s.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[n]:r.push(n),n}remove(t){const e=this._subscriptions;if(e){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}}return t.EMPTY=function(t){return t.closed=!0,t}(new t),t})();function D(t){return t.reduce((t,e)=>t.concat(e instanceof O?e.errors:e),[])}const L=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class M extends F{constructor(t,e,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=A;break;case 1:if(!t){this.destination=A;break}if("object"==typeof t){t instanceof M?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new P(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new P(this,t,e,n)}}[L](){return this}static create(t,e,n){const s=new M(t,e,n);return s.syncErrorThrowable=!1,s}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class P extends M{constructor(t,e,n,s){let r;super(),this._parentSubscriber=t;let i=this;I(e)?r=e:e&&(r=e.next,n=e.error,s=e.complete,e!==A&&(i=Object.create(e),I(i.unsubscribe)&&this.add(i.unsubscribe.bind(i)),i.unsubscribe=this.unsubscribe.bind(this))),this._context=i,this._next=r,this._error=n,this._complete=s}next(t){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;N.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:n}=N;if(this._error)n&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)n?(e.syncErrorValue=t,e.syncErrorThrown=!0):T(t),this.unsubscribe();else{if(this.unsubscribe(),n)throw t;T(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=>this._complete.call(this._context);N.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(n){if(this.unsubscribe(),N.useDeprecatedSynchronousErrorHandling)throw n;T(n)}}__tryOrSetError(t,e,n){if(!N.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,n)}catch(s){return N.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=s,t.syncErrorThrown=!0,!0):(T(s),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const z=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function V(t){return t}let B=(()=>{class t{constructor(t){this._isScalar=!1,t&&(this._subscribe=t)}lift(e){const n=new t;return n.source=this,n.operator=e,n}subscribe(t,e,n){const{operator:s}=this,r=function(t,e,n){if(t){if(t instanceof M)return t;if(t[L])return t[L]()}return t||e||n?new M(t,e,n):new M(A)}(t,e,n);if(r.add(s?s.call(r,this.source):this.source||N.useDeprecatedSynchronousErrorHandling&&!r.syncErrorThrowable?this._subscribe(r):this._trySubscribe(r)),N.useDeprecatedSynchronousErrorHandling&&r.syncErrorThrowable&&(r.syncErrorThrowable=!1,r.syncErrorThrown))throw r.syncErrorValue;return r}_trySubscribe(t){try{return this._subscribe(t)}catch(e){N.useDeprecatedSynchronousErrorHandling&&(t.syncErrorThrown=!0,t.syncErrorValue=e),function(t){for(;t;){const{closed:e,destination:n,isStopped:s}=t;if(e||s)return!1;t=n&&n instanceof M?n:null}return!0}(t)?t.error(e):console.warn(e)}}forEach(t,e){return new(e=W(e))((e,n)=>{let s;s=this.subscribe(e=>{try{t(e)}catch(r){n(r),s&&s.unsubscribe()}},n,e)})}_subscribe(t){const{source:e}=this;return e&&e.subscribe(t)}[z](){return this}pipe(...t){return 0===t.length?this:(0===(e=t).length?V:1===e.length?e[0]:function(t){return e.reduce((t,e)=>e(t),t)})(this);var e}toPromise(t){return new(t=W(t))((t,e)=>{let n;this.subscribe(t=>n=t,t=>e(t),()=>t(n))})}}return t.create=e=>new t(e),t})();function W(t){if(t||(t=N.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const U=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class j extends F{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const n=e.indexOf(this.subscriber);-1!==n&&e.splice(n,1)}}class H extends M{constructor(t){super(t),this.destination=t}}let G=(()=>{class t extends B{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[L](){return new H(this)}lift(t){const e=new q(this,this);return e.operator=t,e}next(t){if(this.closed)throw new U;if(!this.isStopped){const{observers:e}=this,n=e.length,s=e.slice();for(let r=0;r<n;r++)s[r].next(t)}}error(t){if(this.closed)throw new U;this.hasError=!0,this.thrownError=t,this.isStopped=!0;const{observers:e}=this,n=e.length,s=e.slice();for(let r=0;r<n;r++)s[r].error(t);this.observers.length=0}complete(){if(this.closed)throw new U;this.isStopped=!0;const{observers:t}=this,e=t.length,n=t.slice();for(let s=0;s<e;s++)n[s].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(t){if(this.closed)throw new U;return super._trySubscribe(t)}_subscribe(t){if(this.closed)throw new U;return this.hasError?(t.error(this.thrownError),F.EMPTY):this.isStopped?(t.complete(),F.EMPTY):(this.observers.push(t),new j(this,t))}asObservable(){const t=new B;return t.source=this,t}}return t.create=(t,e)=>new q(t,e),t})();class q extends G{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&&e.next&&e.next(t)}error(t){const{destination:e}=this;e&&e.error&&this.destination.error(t)}complete(){const{destination:t}=this;t&&t.complete&&this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):F.EMPTY}}function K(t){return t&&"function"==typeof t.schedule}function X(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new Z(t,e))}}class Z{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new Y(t,this.project,this.thisArg))}}class Y extends M{constructor(t,e,n){super(t),this.project=e,this.count=0,this.thisArg=n||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const Q=t=>e=>{for(let n=0,s=t.length;n<s&&!e.closed;n++)e.next(t[n]);e.complete()};function J(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const tt=J(),et=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function nt(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const st=t=>{if(t&&"function"==typeof t[z])return n=t,t=>{const e=n[z]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(et(t))return Q(t);if(nt(t))return(t=>e=>(t.then(t=>{e.closed||(e.next(t),e.complete())},t=>e.error(t)).then(null,T),e))(t);if(t&&"function"==typeof t[tt])return e=t,t=>{const n=e[tt]();for(;;){let e;try{e=n.next()}catch(s){return t.error(s),t}if(e.done){t.complete();break}if(t.next(e.value),t.closed)break}return"function"==typeof n.return&&t.add(()=>{n.return&&n.return()}),t};{const e=R(t)?"an invalid object":`'${t}'`;throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var e,n};function rt(t,e){return new B(n=>{const s=new F;let r=0;return s.add(e.schedule(function(){r!==t.length?(n.next(t[r++]),n.closed||s.add(this.schedule())):n.complete()})),s})}function it(t,e){return e?function(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[z]}(t))return function(t,e){return new B(n=>{const s=new F;return s.add(e.schedule(()=>{const r=t[z]();s.add(r.subscribe({next(t){s.add(e.schedule(()=>n.next(t)))},error(t){s.add(e.schedule(()=>n.error(t)))},complete(){s.add(e.schedule(()=>n.complete()))}}))})),s})}(t,e);if(nt(t))return function(t,e){return new B(n=>{const s=new F;return s.add(e.schedule(()=>t.then(t=>{s.add(e.schedule(()=>{n.next(t),s.add(e.schedule(()=>n.complete()))}))},t=>{s.add(e.schedule(()=>n.error(t)))}))),s})}(t,e);if(et(t))return rt(t,e);if(function(t){return t&&"function"==typeof t[tt]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new B(n=>{const s=new F;let r;return s.add(()=>{r&&"function"==typeof r.return&&r.return()}),s.add(e.schedule(()=>{r=t[tt](),s.add(e.schedule(function(){if(n.closed)return;let t,e;try{const n=r.next();t=n.value,e=n.done}catch(s){return void n.error(s)}e?n.complete():(n.next(t),this.schedule())}))})),s})}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,e):t instanceof B?t:new B(st(t))}class at extends M{constructor(t){super(),this.parent=t}_next(t){this.parent.notifyNext(t)}_error(t){this.parent.notifyError(t),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class ot extends M{notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.destination.complete()}}function lt(t,e){if(e.closed)return;if(t instanceof B)return t.subscribe(e);let n;try{n=st(t)(e)}catch(s){e.error(s)}return n}function ut(t,e,n=Number.POSITIVE_INFINITY){return"function"==typeof e?s=>s.pipe(ut((n,s)=>it(t(n,s)).pipe(X((t,r)=>e(n,t,s,r))),n)):("number"==typeof e&&(n=e),e=>e.lift(new ct(t,n)))}class ct{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new ht(t,this.project,this.concurrent))}}class ht extends ot{constructor(t,e,n=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(s){return void this.destination.error(s)}this.active++,this._innerSub(e)}_innerSub(t){const e=new at(this),n=this.destination;n.add(e);const s=lt(t,e);s!==e&&n.add(s)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyComplete(){const t=this.buffer;this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function dt(t=Number.POSITIVE_INFINITY){return ut(V,t)}function pt(t,e){return e?rt(t,e):new B(Q(t))}function ft(...t){let e=Number.POSITIVE_INFINITY,n=null,s=t[t.length-1];return K(s)?(n=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(e=t.pop())):"number"==typeof s&&(e=t.pop()),null===n&&1===t.length&&t[0]instanceof B?t[0]:dt(e)(pt(t,n))}function mt(){return function(t){return t.lift(new gt(t))}}class gt{constructor(t){this.connectable=t}call(t,e){const{connectable:n}=this;n._refCount++;const s=new yt(t,n),r=e.subscribe(s);return s.closed||(s.connection=n.connect()),r}}class yt extends M{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e<=0)return void(this.connection=null);if(t._refCount=e-1,e>1)return void(this.connection=null);const{connection:n}=this,s=t._connection;this.connection=null,!s||n&&s!==n||s.unsubscribe()}}class bt extends B{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new F,t.add(this.source.subscribe(new wt(this.getSubject(),this))),t.closed&&(this._connection=null,t=F.EMPTY)),t}refCount(){return mt()(this)}}const vt=(()=>{const t=bt.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class wt extends H{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}}}function _t(){return new G}function xt(){return t=>{return mt()((e=_t,function(t){let n;n="function"==typeof e?e:function(){return e};const s=Object.create(t,vt);return s.source=t,s.subjectFactory=n,s})(t));var e}}function kt(t){for(let e in t)if(t[e]===kt)return e;throw Error("Could not find renamed property on target object.")}function Ct(t,e){for(const n in e)e.hasOwnProperty(n)&&!t.hasOwnProperty(n)&&(t[n]=e[n])}function St(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(St).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const e=t.toString();if(null==e)return""+e;const n=e.indexOf("\n");return-1===n?e:e.substring(0,n)}function It(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const Et=kt({__forward_ref__:kt});function Nt(t){return t.__forward_ref__=Nt,t.toString=function(){return St(this())},t}function Tt(t){return At(t)?t():t}function At(t){return"function"==typeof t&&t.hasOwnProperty(Et)&&t.__forward_ref__===Nt}class $t extends Error{constructor(t,e){super(function(t,e){return`${t?`NG0${t}: `:""}${e}`}(t,e)),this.code=t}}function Rt(t){return"string"==typeof t?t:null==t?"":String(t)}function Ot(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():Rt(t)}function Ft(t,e){const n=e?` in ${e}`:"";throw new $t("201",`No provider for ${Ot(t)} found${n}`)}function Dt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Lt(t){return{providers:t.providers||[],imports:t.imports||[]}}function Mt(t){return Pt(t,Vt)||Pt(t,Wt)}function Pt(t,e){return t.hasOwnProperty(e)?t[e]:null}function zt(t){return t&&(t.hasOwnProperty(Bt)||t.hasOwnProperty(Ut))?t[Bt]:null}const Vt=kt({"\u0275prov":kt}),Bt=kt({"\u0275inj":kt}),Wt=kt({ngInjectableDef:kt}),Ut=kt({ngInjectorDef:kt});var jt=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}({});let Ht;function Gt(t){const e=Ht;return Ht=t,e}function qt(t,e,n){const s=Mt(t);return s&&"root"==s.providedIn?void 0===s.value?s.value=s.factory():s.value:n&jt.Optional?null:void 0!==e?e:void Ft(St(t),"Injector")}function Kt(t){return{toString:t}.toString()}var Xt=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}({}),Zt=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}({});const Yt="undefined"!=typeof globalThis&&globalThis,Qt="undefined"!=typeof window&&window,Jt="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,te="undefined"!=typeof global&&global,ee=Yt||te||Qt||Jt,ne={},se=[],re=kt({"\u0275cmp":kt}),ie=kt({"\u0275dir":kt}),ae=kt({"\u0275pipe":kt}),oe=kt({"\u0275mod":kt}),le=kt({"\u0275loc":kt}),ue=kt({"\u0275fac":kt}),ce=kt({__NG_ELEMENT_ID__:kt});let he=0;function de(t){return Kt(()=>{const e={},n={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===Xt.OnPush,directiveDefs:null,pipeDefs:null,selectors:t.selectors||se,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||Zt.Emulated,id:"c",styles:t.styles||se,_:null,setInput:null,schemas:t.schemas||null,tView:null},s=t.directives,r=t.features,i=t.pipes;return n.id+=he++,n.inputs=ye(t.inputs,e),n.outputs=ye(t.outputs),r&&r.forEach(t=>t(n)),n.directiveDefs=s?()=>("function"==typeof s?s():s).map(pe):null,n.pipeDefs=i?()=>("function"==typeof i?i():i).map(fe):null,n})}function pe(t){return we(t)||function(t){return t[ie]||null}(t)}function fe(t){return function(t){return t[ae]||null}(t)}const me={};function ge(t){const e={type:t.type,bootstrap:t.bootstrap||se,declarations:t.declarations||se,imports:t.imports||se,exports:t.exports||se,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null};return null!=t.id&&Kt(()=>{me[t.id]=t.type}),e}function ye(t,e){if(null==t)return ne;const n={};for(const s in t)if(t.hasOwnProperty(s)){let r=t[s],i=r;Array.isArray(r)&&(i=r[1],r=r[0]),n[r]=s,e&&(e[r]=i)}return n}const be=de;function ve(t){return{type:t.type,name:t.name,factory:null,pure:!1!==t.pure,onDestroy:t.type.prototype.ngOnDestroy||null}}function we(t){return t[re]||null}function _e(t,e){const n=t[oe]||null;if(!n&&!0===e)throw new Error(`Type ${St(t)} does not have '\u0275mod' property.`);return n}const xe=20,ke=10;function Ce(t){return Array.isArray(t)&&"object"==typeof t[1]}function Se(t){return Array.isArray(t)&&!0===t[1]}function Ie(t){return 0!=(8&t.flags)}function Ee(t){return 2==(2&t.flags)}function Ne(t){return 1==(1&t.flags)}function Te(t){return null!==t.template}function Ae(t,e){return t.hasOwnProperty(ue)?t[ue]:null}class $e{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}}function Re(){return Oe}function Oe(t){return t.type.prototype.ngOnChanges&&(t.setInput=De),Fe}function Fe(){const t=Le(this),e=null==t?void 0:t.current;if(e){const n=t.previous;if(n===ne)t.previous=e;else for(let t in e)n[t]=e[t];t.current=null,this.ngOnChanges(e)}}function De(t,e,n,s){const r=Le(t)||function(t,e){return t.__ngSimpleChanges__=e}(t,{previous:ne,current:null}),i=r.current||(r.current={}),a=r.previous,o=this.declaredInputs[n],l=a[o];i[o]=new $e(l&&l.currentValue,e,a===ne),t[s]=e}function Le(t){return t.__ngSimpleChanges__||null}Re.ngInherit=!0;const Me="http://www.w3.org/2000/svg";let Pe;function ze(){return void 0!==Pe?Pe:"undefined"!=typeof document?document:void 0}function Ve(t){return!!t.listen}const Be={createRenderer:(t,e)=>ze()};function We(t){for(;Array.isArray(t);)t=t[0];return t}function Ue(t,e){return We(e[t])}function je(t,e){return We(e[t.index])}function He(t,e){return t.data[e]}function Ge(t,e){const n=e[t];return Ce(n)?n:n[0]}function qe(t){return 4==(4&t[2])}function Ke(t){return 128==(128&t[2])}function Xe(t,e){return null==e?null:t[e]}function Ze(t){t[18]=0}function Ye(t,e){t[5]+=e;let n=t,s=t[3];for(;null!==s&&(1===e&&1===n[5]||-1===e&&0===n[5]);)s[5]+=e,n=s,s=s[3]}const Qe={lFrame:_n(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function Je(){return Qe.bindingsEnabled}function tn(){return Qe.lFrame.lView}function en(){return Qe.lFrame.tView}function nn(t){return Qe.lFrame.contextLView=t,t[8]}function sn(){let t=rn();for(;null!==t&&64===t.type;)t=t.parent;return t}function rn(){return Qe.lFrame.currentTNode}function an(t,e){const n=Qe.lFrame;n.currentTNode=t,n.isParent=e}function on(){return Qe.lFrame.isParent}function ln(){Qe.lFrame.isParent=!1}function un(){return Qe.isInCheckNoChangesMode}function cn(t){Qe.isInCheckNoChangesMode=t}function hn(){return Qe.lFrame.bindingIndex++}function dn(t,e){const n=Qe.lFrame;n.bindingIndex=n.bindingRootIndex=t,pn(e)}function pn(t){Qe.lFrame.currentDirectiveIndex=t}function fn(t){const e=Qe.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}function mn(){return Qe.lFrame.currentQueryIndex}function gn(t){Qe.lFrame.currentQueryIndex=t}function yn(t){const e=t[1];return 2===e.type?e.declTNode:1===e.type?t[6]:null}function bn(t,e,n){if(n&jt.SkipSelf){let s=e,r=t;for(;s=s.parent,!(null!==s||n&jt.Host||(s=yn(r),null===s)||(r=r[15],10&s.type)););if(null===s)return!1;e=s,t=r}const s=Qe.lFrame=wn();return s.currentTNode=e,s.lView=t,!0}function vn(t){const e=wn(),n=t[1];Qe.lFrame=e,e.currentTNode=n.firstChild,e.lView=t,e.tView=n,e.contextLView=t,e.bindingIndex=n.bindingStartIndex,e.inI18n=!1}function wn(){const t=Qe.lFrame,e=null===t?null:t.child;return null===e?_n(t):e}function _n(t){const e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=e),e}function xn(){const t=Qe.lFrame;return Qe.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const kn=xn;function Cn(){const t=xn();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function Sn(){return Qe.lFrame.selectedIndex}function In(t){Qe.lFrame.selectedIndex=t}function En(){const t=Qe.lFrame;return He(t.tView,t.selectedIndex)}function Nn(){Qe.lFrame.currentNamespace=Me}function Tn(t,e){for(let n=e.directiveStart,s=e.directiveEnd;n<s;n++){const e=t.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:r,ngAfterViewInit:i,ngAfterViewChecked:a,ngOnDestroy:o}=e;s&&(t.contentHooks||(t.contentHooks=[])).push(-n,s),r&&((t.contentHooks||(t.contentHooks=[])).push(n,r),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(n,r)),i&&(t.viewHooks||(t.viewHooks=[])).push(-n,i),a&&((t.viewHooks||(t.viewHooks=[])).push(n,a),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(n,a)),null!=o&&(t.destroyHooks||(t.destroyHooks=[])).push(n,o)}}function An(t,e,n){On(t,e,3,n)}function $n(t,e,n,s){(3&t[2])===n&&On(t,e,n,s)}function Rn(t,e){let n=t[2];(3&n)===e&&(n&=2047,n+=1,t[2]=n)}function On(t,e,n,s){const r=null!=s?s:-1,i=e.length-1;let a=0;for(let o=void 0!==s?65535&t[18]:0;o<i;o++)if("number"==typeof e[o+1]){if(a=e[o],null!=s&&a>=s)break}else e[o]<0&&(t[18]+=65536),(a<r||-1==r)&&(Fn(t,n,e,o),t[18]=(4294901760&t[18])+o+2),o++}function Fn(t,e,n,s){const r=n[s]<0,i=n[s+1],a=t[r?-n[s]:n[s]];if(r){if(t[2]>>11<t[18]>>16&&(3&t[2])===e){t[2]+=2048;try{i.call(a)}finally{}}}else try{i.call(a)}finally{}}const Dn=-1;class Ln{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}}function Mn(t,e,n){const s=Ve(t);let r=0;for(;r<n.length;){const i=n[r];if("number"==typeof i){if(0!==i)break;r++;const a=n[r++],o=n[r++],l=n[r++];s?t.setAttribute(e,o,l,a):e.setAttributeNS(a,o,l)}else{const a=i,o=n[++r];zn(a)?s&&t.setProperty(e,a,o):s?t.setAttribute(e,a,o):e.setAttribute(a,o),r++}}return r}function Pn(t){return 3===t||4===t||6===t}function zn(t){return 64===t.charCodeAt(0)}function Vn(t,e){if(null===e||0===e.length);else if(null===t||0===t.length)t=e.slice();else{let n=-1;for(let s=0;s<e.length;s++){const r=e[s];"number"==typeof r?n=r:0===n||Bn(t,n,r,null,-1===n||2===n?e[++s]:null)}}return t}function Bn(t,e,n,s,r){let i=0,a=t.length;if(-1===e)a=-1;else for(;i<t.length;){const n=t[i++];if("number"==typeof n){if(n===e){a=-1;break}if(n>e){a=i-1;break}}}for(;i<t.length;){const e=t[i];if("number"==typeof e)break;if(e===n){if(null===s)return void(null!==r&&(t[i+1]=r));if(s===t[i+1])return void(t[i+2]=r)}i++,null!==s&&i++,null!==r&&i++}-1!==a&&(t.splice(a,0,e),i=a+1),t.splice(i++,0,n),null!==s&&t.splice(i++,0,s),null!==r&&t.splice(i++,0,r)}function Wn(t){return t!==Dn}function Un(t){return 32767&t}function jn(t,e){let n=t>>16,s=e;for(;n>0;)s=s[15],n--;return s}let Hn=!0;function Gn(t){const e=Hn;return Hn=t,e}let qn=0;function Kn(t,e){const n=Zn(t,e);if(-1!==n)return n;const s=e[1];s.firstCreatePass&&(t.injectorIndex=e.length,Xn(s.data,t),Xn(e,null),Xn(s.blueprint,null));const r=Yn(t,e),i=t.injectorIndex;if(Wn(r)){const t=Un(r),n=jn(r,e),s=n[1].data;for(let r=0;r<8;r++)e[i+r]=n[t+r]|s[t+r]}return e[i+8]=r,i}function Xn(t,e){t.push(0,0,0,0,0,0,0,0,e)}function Zn(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===e[t.injectorIndex+8]?-1:t.injectorIndex}function Yn(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let n=0,s=null,r=e;for(;null!==r;){const t=r[1],e=t.type;if(s=2===e?t.declTNode:1===e?r[6]:null,null===s)return Dn;if(n++,r=r[15],-1!==s.injectorIndex)return s.injectorIndex|n<<16}return Dn}function Qn(t,e,n){!function(t,e,n){let s;"string"==typeof n?s=n.charCodeAt(0)||0:n.hasOwnProperty(ce)&&(s=n[ce]),null==s&&(s=n[ce]=qn++);const r=255&s;e.data[t+(r>>5)]|=1<<r}(t,e,n)}function Jn(t,e,n){if(n&jt.Optional)return t;Ft(e,"NodeInjector")}function ts(t,e,n,s){if(n&jt.Optional&&void 0===s&&(s=null),0==(n&(jt.Self|jt.Host))){const r=t[9],i=Gt(void 0);try{return r?r.get(e,s,n&jt.Optional):qt(e,s,n&jt.Optional)}finally{Gt(i)}}return Jn(s,e,n)}function es(t,e,n,s=jt.Default,r){if(null!==t){const i=function(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(ce)?t[ce]:void 0;return"number"==typeof e?e>=0?255&e:ss:e}(n);if("function"==typeof i){if(!bn(e,t,s))return s&jt.Host?Jn(r,n,s):ts(e,n,s,r);try{const t=i(s);if(null!=t||s&jt.Optional)return t;Ft(n)}finally{kn()}}else if("number"==typeof i){let r=null,a=Zn(t,e),o=Dn,l=s&jt.Host?e[16][6]:null;for((-1===a||s&jt.SkipSelf)&&(o=-1===a?Yn(t,e):e[a+8],o!==Dn&&ls(s,!1)?(r=e[1],a=Un(o),e=jn(o,e)):a=-1);-1!==a;){const t=e[1];if(os(i,a,t.data)){const t=rs(a,e,n,r,s,l);if(t!==ns)return t}o=e[a+8],o!==Dn&&ls(s,e[1].data[a+8]===l)&&os(i,a,e)?(r=t,a=Un(o),e=jn(o,e)):a=-1}}}return ts(e,n,s,r)}const ns={};function ss(){return new us(sn(),tn())}function rs(t,e,n,s,r,i){const a=e[1],o=a.data[t+8],l=is(o,a,n,null==s?Ee(o)&&Hn:s!=a&&0!=(3&o.type),r&jt.Host&&i===o);return null!==l?as(e,a,l,o):ns}function is(t,e,n,s,r){const i=t.providerIndexes,a=e.data,o=1048575&i,l=t.directiveStart,u=i>>20,c=r?o+u:t.directiveEnd;for(let h=s?o:o+u;h<c;h++){const t=a[h];if(h<l&&n===t||h>=l&&t.type===n)return h}if(r){const t=a[l];if(t&&Te(t)&&t.type===n)return l}return null}function as(t,e,n,s){let r=t[n];const i=e.data;if(r instanceof Ln){const a=r;a.resolving&&function(t,e){throw new $t("200",`Circular dependency in DI detected for ${t}`)}(Ot(i[n]));const o=Gn(a.canSeeViewProviders);a.resolving=!0;const l=a.injectImpl?Gt(a.injectImpl):null;bn(t,s,jt.Default);try{r=t[n]=a.factory(void 0,i,t,s),e.firstCreatePass&&n>=s.directiveStart&&function(t,e,n){const{ngOnChanges:s,ngOnInit:r,ngDoCheck:i}=e.type.prototype;if(s){const s=Oe(e);(n.preOrderHooks||(n.preOrderHooks=[])).push(t,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,s)}r&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-t,r),i&&((n.preOrderHooks||(n.preOrderHooks=[])).push(t,i),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,i))}(n,i[n],e)}finally{null!==l&&Gt(l),Gn(o),a.resolving=!1,kn()}}return r}function os(t,e,n){return!!(n[e+(t>>5)]&1<<t)}function ls(t,e){return!(t&jt.Self||t&jt.Host&&e)}class us{constructor(t,e){this._tNode=t,this._lView=e}get(t,e){return es(this._tNode,this._lView,t,void 0,e)}}function cs(t){return Kt(()=>{const e=t.prototype.constructor,n=e[ue]||hs(e),s=Object.prototype;let r=Object.getPrototypeOf(t.prototype).constructor;for(;r&&r!==s;){const t=r[ue]||hs(r);if(t&&t!==n)return t;r=Object.getPrototypeOf(r)}return t=>new t})}function hs(t){return At(t)?()=>{const e=hs(Tt(t));return e&&e()}:Ae(t)}function ds(t){return function(t,e){if("class"===e)return t.classes;if("style"===e)return t.styles;const n=t.attrs;if(n){const t=n.length;let s=0;for(;s<t;){const r=n[s];if(Pn(r))break;if(0===r)s+=2;else if("number"==typeof r)for(s++;s<t&&"string"==typeof n[s];)s++;else{if(r===e)return n[s+1];s+=2}}}return null}(sn(),t)}const ps="__parameters__";function fs(t,e,n){return Kt(()=>{const s=function(t){return function(...e){if(t){const n=t(...e);for(const t in n)this[t]=n[t]}}}(e);function r(...t){if(this instanceof r)return s.apply(this,t),this;const e=new r(...t);return n.annotation=e,n;function n(t,n,s){const r=t.hasOwnProperty(ps)?t[ps]:Object.defineProperty(t,ps,{value:[]})[ps];for(;r.length<=s;)r.push(null);return(r[s]=r[s]||[]).push(e),t}}return n&&(r.prototype=Object.create(n.prototype)),r.prototype.ngMetadataName=t,r.annotationCls=r,r})}class ms{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Dt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}const gs=new ms("AnalyzeForEntryComponents"),ys=Function;function bs(t,e){void 0===e&&(e=t);for(let n=0;n<t.length;n++){let s=t[n];Array.isArray(s)?(e===t&&(e=t.slice(0,n)),bs(s,e)):e!==t&&e.push(s)}return e}function vs(t,e){t.forEach(t=>Array.isArray(t)?vs(t,e):e(t))}function ws(t,e,n){e>=t.length?t.push(n):t.splice(e,0,n)}function _s(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function xs(t,e){const n=[];for(let s=0;s<t;s++)n.push(e);return n}function ks(t,e,n){let s=Ss(t,e);return s>=0?t[1|s]=n:(s=~s,function(t,e,n,s){let r=t.length;if(r==e)t.push(n,s);else if(1===r)t.push(s,t[0]),t[0]=n;else{for(r--,t.push(t[r-1],t[r]);r>e;)t[r]=t[r-2],r--;t[e]=n,t[e+1]=s}}(t,s,e,n)),s}function Cs(t,e){const n=Ss(t,e);if(n>=0)return t[1|n]}function Ss(t,e){return function(t,e,n){let s=0,r=t.length>>1;for(;r!==s;){const n=s+(r-s>>1),i=t[n<<1];if(e===i)return n<<1;i>e?r=n:s=n+1}return~(r<<1)}(t,e)}const Is={},Es=/\n/gm,Ns="__source",Ts=kt({provide:String,useValue:kt});let As;function $s(t){const e=As;return As=t,e}function Rs(t,e=jt.Default){if(void 0===As)throw new Error("inject() must be called from an injection context");return null===As?qt(t,void 0,e):As.get(t,e&jt.Optional?null:void 0,e)}function Os(t,e=jt.Default){return(Ht||Rs)(Tt(t),e)}const Fs=Os;function Ds(t){const e=[];for(let n=0;n<t.length;n++){const s=Tt(t[n]);if(Array.isArray(s)){if(0===s.length)throw new Error("Arguments array must have arguments.");let t,n=jt.Default;for(let e=0;e<s.length;e++){const r=s[e],i=r.__NG_DI_FLAG__;"number"==typeof i?-1===i?t=r.token:n|=i:t=r}e.push(Os(t,n))}else e.push(Os(s))}return e}function Ls(t,e){return t.__NG_DI_FLAG__=e,t.prototype.__NG_DI_FLAG__=e,t}const Ms=Ls(fs("Inject",t=>({token:t})),-1),Ps=Ls(fs("Optional"),8),zs=Ls(fs("SkipSelf"),4);let Vs,Bs;function Ws(t){var e;return(null===(e=function(){if(void 0===Vs&&(Vs=null,ee.trustedTypes))try{Vs=ee.trustedTypes.createPolicy("angular",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return Vs}())||void 0===e?void 0:e.createHTML(t))||t}function Us(t){var e;return(null===(e=function(){if(void 0===Bs&&(Bs=null,ee.trustedTypes))try{Bs=ee.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return Bs}())||void 0===e?void 0:e.createHTML(t))||t}class js{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}class Hs extends js{getTypeName(){return"HTML"}}class Gs extends js{getTypeName(){return"Style"}}class qs extends js{getTypeName(){return"Script"}}class Ks extends js{getTypeName(){return"URL"}}class Xs extends js{getTypeName(){return"ResourceURL"}}function Zs(t){return t instanceof js?t.changingThisBreaksApplicationSecurity:t}function Ys(t,e){const n=Qs(t);if(null!=n&&n!==e){if("ResourceURL"===n&&"URL"===e)return!0;throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`)}return n===e}function Qs(t){return t instanceof js&&t.getTypeName()||null}class Js{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(Ws(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch(e){return null}}}class tr{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const t=this.inertDocument.createElement("html");this.inertDocument.appendChild(t);const e=this.inertDocument.createElement("body");t.appendChild(e)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=Ws(t),e;const n=this.inertDocument.createElement("body");return n.innerHTML=Ws(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(n),n}stripCustomNsAttrs(t){const e=t.attributes;for(let s=e.length-1;0<s;s--){const n=e.item(s).name;"xmlns:ns1"!==n&&0!==n.indexOf("ns1:")||t.removeAttribute(n)}let n=t.firstChild;for(;n;)n.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(n),n=n.nextSibling}}const er=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,nr=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;function sr(t){return(t=String(t)).match(er)||t.match(nr)?t:"unsafe:"+t}function rr(t){const e={};for(const n of t.split(","))e[n]=!0;return e}function ir(...t){const e={};for(const n of t)for(const t in n)n.hasOwnProperty(t)&&(e[t]=!0);return e}const ar=rr("area,br,col,hr,img,wbr"),or=rr("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),lr=rr("rp,rt"),ur=ir(lr,or),cr=ir(ar,ir(or,rr("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),ir(lr,rr("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),ur),hr=rr("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),dr=rr("srcset"),pr=ir(hr,dr,rr("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),rr("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),fr=rr("script,style,template");class mr{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,n=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?n=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,n&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let t=this.checkClobberedElement(e,e.nextSibling);if(t){e=t;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!cr.hasOwnProperty(e))return this.sanitizedSomething=!0,!fr.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const n=t.attributes;for(let r=0;r<n.length;r++){const t=n.item(r),e=t.name,i=e.toLowerCase();if(!pr.hasOwnProperty(i)){this.sanitizedSomething=!0;continue}let a=t.value;hr[i]&&(a=sr(a)),dr[i]&&(s=a,a=(s=String(s)).split(",").map(t=>sr(t.trim())).join(", ")),this.buf.push(" ",e,'="',br(a),'"')}var s;return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();cr.hasOwnProperty(e)&&!ar.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(br(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const gr=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,yr=/([^\#-~ |!])/g;function br(t){return t.replace(/&/g,"&amp;").replace(gr,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(yr,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let vr;function wr(t,e){let n=null;try{vr=vr||function(t){const e=new tr(t);return function(){try{return!!(new window.DOMParser).parseFromString(Ws(""),"text/html")}catch(t){return!1}}()?new Js(e):e}(t);let s=e?String(e):"";n=vr.getInertBodyElement(s);let r=5,i=s;do{if(0===r)throw new Error("Failed to sanitize html because the input is unstable");r--,s=i,i=n.innerHTML,n=vr.getInertBodyElement(s)}while(s!==i);return Ws((new mr).sanitizeChildren(_r(n)||n))}finally{if(n){const t=_r(n)||n;for(;t.firstChild;)t.removeChild(t.firstChild)}}}function _r(t){return"content"in t&&function(t){return t.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===t.nodeName}(t)?t.content:null}var xr=function(t){return t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL",t}({});function kr(t){const e=Sr();return e?Us(e.sanitize(xr.HTML,t)||""):Ys(t,"HTML")?Us(Zs(t)):wr(ze(),Rt(t))}function Cr(t){const e=Sr();return e?e.sanitize(xr.URL,t)||"":Ys(t,"URL")?Zs(t):sr(Rt(t))}function Sr(){const t=tn();return t&&t[12]}function Ir(t,e){t.__ngContext__=e}function Er(t){const e=function(t){return t.__ngContext__||null}(t);return e?Array.isArray(e)?e:e.lView:null}function Nr(t){return t.ngDebugContext}function Tr(t){return t.ngOriginalError}function Ar(t,...e){t.error(...e)}class $r{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),n=this._findContext(t),s=function(t){return t.ngErrorLogger||Ar}(t);s(this._console,"ERROR",t),e&&s(this._console,"ORIGINAL ERROR",e),n&&s(this._console,"ERROR CONTEXT",n)}_findContext(t){return t?Nr(t)?Nr(t):this._findContext(Tr(t)):null}_findOriginalError(t){let e=Tr(t);for(;e&&Tr(e);)e=Tr(e);return e}}const Rr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(ee))();function Or(t){return t.ownerDocument.body}function Fr(t){return t instanceof Function?t():t}var Dr=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}({});function Lr(t,e){return(void 0)(t,e)}function Mr(t){const e=t[3];return Se(e)?e[3]:e}function Pr(t){return Vr(t[13])}function zr(t){return Vr(t[4])}function Vr(t){for(;null!==t&&!Se(t);)t=t[4];return t}function Br(t,e,n,s,r){if(null!=s){let i,a=!1;Se(s)?i=s:Ce(s)&&(a=!0,s=s[0]);const o=We(s);0===t&&null!==n?null==r?Xr(e,n,o):Kr(e,n,o,r||null,!0):1===t&&null!==n?Kr(e,n,o,r||null,!0):2===t?function(t,e,n){const s=Yr(t,e);s&&function(t,e,n,s){Ve(t)?t.removeChild(e,n,s):e.removeChild(n)}(t,s,e,n)}(e,o,a):3===t&&e.destroyNode(o),null!=i&&function(t,e,n,s,r){const i=n[7];i!==We(n)&&Br(e,t,s,i,r);for(let a=ke;a<n.length;a++){const r=n[a];ii(r[1],r,t,e,s,i)}}(e,t,i,n,r)}}function Wr(t,e,n){return Ve(t)?t.createElement(e,n):null===n?t.createElement(e):t.createElementNS(n,e)}function Ur(t,e){const n=t[9],s=n.indexOf(e),r=e[3];1024&e[2]&&(e[2]&=-1025,Ye(r,-1)),n.splice(s,1)}function jr(t,e){if(t.length<=ke)return;const n=ke+e,s=t[n];if(s){const i=s[17];null!==i&&i!==t&&Ur(i,s),e>0&&(t[n-1][4]=s[4]);const a=_s(t,ke+e);ii(s[1],r=s,r[11],2,null,null),r[0]=null,r[6]=null;const o=a[19];null!==o&&o.detachView(a[1]),s[3]=null,s[4]=null,s[2]&=-129}var r;return s}function Hr(t,e){if(!(256&e[2])){const n=e[11];Ve(n)&&n.destroyNode&&ii(t,e,n,3,null,null),function(t){let e=t[13];if(!e)return Gr(t[1],t);for(;e;){let n=null;if(Ce(e))n=e[13];else{const t=e[10];t&&(n=t)}if(!n){for(;e&&!e[4]&&e!==t;)Ce(e)&&Gr(e[1],e),e=e[3];null===e&&(e=t),Ce(e)&&Gr(e[1],e),n=e&&e[4]}e=n}}(e)}}function Gr(t,e){if(!(256&e[2])){e[2]&=-129,e[2]|=256,function(t,e){let n;if(null!=t&&null!=(n=t.destroyHooks))for(let s=0;s<n.length;s+=2){const t=e[n[s]];if(!(t instanceof Ln)){const e=n[s+1];if(Array.isArray(e))for(let n=0;n<e.length;n+=2){const s=t[e[n]],r=e[n+1];try{r.call(s)}finally{}}else try{e.call(t)}finally{}}}}(t,e),function(t,e){const n=t.cleanup,s=e[7];let r=-1;if(null!==n)for(let i=0;i<n.length-1;i+=2)if("string"==typeof n[i]){const t=n[i+1],a="function"==typeof t?t(e):We(e[t]),o=s[r=n[i+2]],l=n[i+3];"boolean"==typeof l?a.removeEventListener(n[i],o,l):l>=0?s[r=l]():s[r=-l].unsubscribe(),i+=2}else{const t=s[r=n[i+1]];n[i].call(t)}if(null!==s){for(let t=r+1;t<s.length;t++)(0,s[t])();e[7]=null}}(t,e),1===e[1].type&&Ve(e[11])&&e[11].destroy();const n=e[17];if(null!==n&&Se(e[3])){n!==e[3]&&Ur(n,e);const s=e[19];null!==s&&s.detachView(t)}}}function qr(t,e,n){return function(t,e,n){let s=e;for(;null!==s&&40&s.type;)s=(e=s).parent;if(null===s)return n[0];if(2&s.flags){const e=t.data[s.directiveStart].encapsulation;if(e===Zt.None||e===Zt.Emulated)return null}return je(s,n)}(t,e.parent,n)}function Kr(t,e,n,s,r){Ve(t)?t.insertBefore(e,n,s,r):e.insertBefore(n,s,r)}function Xr(t,e,n){Ve(t)?t.appendChild(e,n):e.appendChild(n)}function Zr(t,e,n,s,r){null!==s?Kr(t,e,n,s,r):Xr(t,e,n)}function Yr(t,e){return Ve(t)?t.parentNode(e):e.parentNode}function Qr(t,e,n){return Jr(t,e,n)}let Jr=function(t,e,n){return 40&t.type?je(t,n):null};function ti(t,e,n,s){const r=qr(t,s,e),i=e[11],a=Qr(s.parent||e[6],s,e);if(null!=r)if(Array.isArray(n))for(let o=0;o<n.length;o++)Zr(i,r,n[o],a,!1);else Zr(i,r,n,a,!1)}function ei(t,e){if(null!==e){const n=e.type;if(3&n)return je(e,t);if(4&n)return si(-1,t[e.index]);if(8&n){const n=e.child;if(null!==n)return ei(t,n);{const n=t[e.index];return Se(n)?si(-1,n):We(n)}}if(32&n)return Lr(e,t)()||We(t[e.index]);{const n=ni(t,e);return null!==n?Array.isArray(n)?n[0]:ei(Mr(t[16]),n):ei(t,e.next)}}return null}function ni(t,e){return null!==e?t[16][6].projection[e.projection]:null}function si(t,e){const n=ke+t+1;if(n<e.length){const t=e[n],s=t[1].firstChild;if(null!==s)return ei(t,s)}return e[7]}function ri(t,e,n,s,r,i,a){for(;null!=n;){const o=s[n.index],l=n.type;if(a&&0===e&&(o&&Ir(We(o),s),n.flags|=4),64!=(64&n.flags))if(8&l)ri(t,e,n.child,s,r,i,!1),Br(e,t,r,o,i);else if(32&l){const a=Lr(n,s);let l;for(;l=a();)Br(e,t,r,l,i);Br(e,t,r,o,i)}else 16&l?ai(t,e,s,n,r,i):Br(e,t,r,o,i);n=a?n.projectionNext:n.next}}function ii(t,e,n,s,r,i){ri(n,s,t.firstChild,e,r,i,!1)}function ai(t,e,n,s,r,i){const a=n[16],o=a[6].projection[s.projection];if(Array.isArray(o))for(let l=0;l<o.length;l++)Br(e,t,r,o[l],i);else ri(t,e,o,a[3],r,i,!0)}function oi(t,e,n){Ve(t)?t.setAttribute(e,"style",n):e.style.cssText=n}function li(t,e,n){Ve(t)?""===n?t.removeAttribute(e,"class"):t.setAttribute(e,"class",n):e.className=n}function ui(t,e,n){let s=t.length;for(;;){const r=t.indexOf(e,n);if(-1===r)return r;if(0===r||t.charCodeAt(r-1)<=32){const n=e.length;if(r+n===s||t.charCodeAt(r+n)<=32)return r}n=r+1}}const ci="ng-template";function hi(t,e,n){let s=0;for(;s<t.length;){let r=t[s++];if(n&&"class"===r){if(r=t[s],-1!==ui(r.toLowerCase(),e,0))return!0}else if(1===r){for(;s<t.length&&"string"==typeof(r=t[s++]);)if(r.toLowerCase()===e)return!0;return!1}}return!1}function di(t){return 4===t.type&&t.value!==ci}function pi(t,e,n){return e===(4!==t.type||n?t.value:ci)}function fi(t,e,n){let s=4;const r=t.attrs||[],i=function(t){for(let e=0;e<t.length;e++)if(Pn(t[e]))return e;return t.length}(r);let a=!1;for(let o=0;o<e.length;o++){const l=e[o];if("number"!=typeof l){if(!a)if(4&s){if(s=2|1&s,""!==l&&!pi(t,l,n)||""===l&&1===e.length){if(mi(s))return!1;a=!0}}else{const u=8&s?l:e[++o];if(8&s&&null!==t.attrs){if(!hi(t.attrs,u,n)){if(mi(s))return!1;a=!0}continue}const c=gi(8&s?"class":l,r,di(t),n);if(-1===c){if(mi(s))return!1;a=!0;continue}if(""!==u){let t;t=c>i?"":r[c+1].toLowerCase();const e=8&s?t:null;if(e&&-1!==ui(e,u,0)||2&s&&u!==t){if(mi(s))return!1;a=!0}}}}else{if(!a&&!mi(s)&&!mi(l))return!1;if(a&&mi(l))continue;a=!1,s=l|1&s}}return mi(s)||a}function mi(t){return 0==(1&t)}function gi(t,e,n,s){if(null===e)return-1;let r=0;if(s||!n){let n=!1;for(;r<e.length;){const s=e[r];if(s===t)return r;if(3===s||6===s)n=!0;else{if(1===s||2===s){let t=e[++r];for(;"string"==typeof t;)t=e[++r];continue}if(4===s)break;if(0===s){r+=4;continue}}r+=n?1:2}return-1}return function(t,e){let n=t.indexOf(4);if(n>-1)for(n++;n<t.length;){const s=t[n];if("number"==typeof s)return-1;if(s===e)return n;n++}return-1}(e,t)}function yi(t,e,n=!1){for(let s=0;s<e.length;s++)if(fi(t,e[s],n))return!0;return!1}function bi(t,e){t:for(let n=0;n<e.length;n++){const s=e[n];if(t.length===s.length){for(let e=0;e<t.length;e++)if(t[e]!==s[e])continue t;return!0}}return!1}function vi(t,e){return t?":not("+e.trim()+")":e}function wi(t){let e=t[0],n=1,s=2,r="",i=!1;for(;n<t.length;){let a=t[n];if("string"==typeof a)if(2&s){const e=t[++n];r+="["+a+(e.length>0?'="'+e+'"':"")+"]"}else 8&s?r+="."+a:4&s&&(r+=" "+a);else""===r||mi(a)||(e+=vi(i,r),r=""),s=a,i=i||!mi(s);n++}return""!==r&&(e+=vi(i,r)),e}const _i={};function xi(t){ki(en(),tn(),Sn()+t,un())}function ki(t,e,n,s){if(!s)if(3==(3&e[2])){const s=t.preOrderCheckHooks;null!==s&&An(e,s,n)}else{const s=t.preOrderHooks;null!==s&&$n(e,s,0,n)}In(n)}function Ci(t,e){return t<<17|e<<2}function Si(t){return t>>17&32767}function Ii(t){return 2|t}function Ei(t){return(131068&t)>>2}function Ni(t,e){return-131069&t|e<<2}function Ti(t){return 1|t}function Ai(t,e){const n=t.contentQueries;if(null!==n)for(let s=0;s<n.length;s+=2){const r=n[s],i=n[s+1];if(-1!==i){const n=t.data[i];gn(r),n.contentQueries(2,e[i],i)}}}function $i(t,e,n,s,r,i,a,o,l,u){const c=e.blueprint.slice();return c[0]=r,c[2]=140|s,Ze(c),c[3]=c[15]=t,c[8]=n,c[10]=a||t&&t[10],c[11]=o||t&&t[11],c[12]=l||t&&t[12]||null,c[9]=u||t&&t[9]||null,c[6]=i,c[16]=2==e.type?t[16]:c,c}function Ri(t,e,n,s,r){let i=t.data[e];if(null===i)i=function(t,e,n,s,r){const i=rn(),a=on(),o=t.data[e]=function(t,e,n,s,r,i){return{type:n,index:s,insertBeforeIndex:null,injectorIndex:e?e.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,a?i:i&&i.parent,n,e,s,r);return null===t.firstChild&&(t.firstChild=o),null!==i&&(a?null==i.child&&null!==o.parent&&(i.child=o):null===i.next&&(i.next=o)),o}(t,e,n,s,r),Qe.lFrame.inI18n&&(i.flags|=64);else if(64&i.type){i.type=n,i.value=s,i.attrs=r;const t=function(){const t=Qe.lFrame,e=t.currentTNode;return t.isParent?e:e.parent}();i.injectorIndex=null===t?-1:t.injectorIndex}return an(i,!0),i}function Oi(t,e,n,s){if(0===n)return-1;const r=e.length;for(let i=0;i<n;i++)e.push(s),t.blueprint.push(s),t.data.push(null);return r}function Fi(t,e,n){vn(e);try{const s=t.viewQuery;null!==s&&ca(1,s,n);const r=t.template;null!==r&&Mi(t,e,r,1,n),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&Ai(t,e),t.staticViewQueries&&ca(2,t.viewQuery,n);const i=t.components;null!==i&&function(t,e){for(let n=0;n<e.length;n++)ia(t,e[n])}(e,i)}catch(s){throw t.firstCreatePass&&(t.incompleteFirstPass=!0),s}finally{e[2]&=-5,Cn()}}function Di(t,e,n,s){const r=e[2];if(256==(256&r))return;vn(e);const i=un();try{Ze(e),Qe.lFrame.bindingIndex=t.bindingStartIndex,null!==n&&Mi(t,e,n,2,s);const a=3==(3&r);if(!i)if(a){const n=t.preOrderCheckHooks;null!==n&&An(e,n,null)}else{const n=t.preOrderHooks;null!==n&&$n(e,n,0,null),Rn(e,0)}if(function(t){for(let e=Pr(t);null!==e;e=zr(e)){if(!e[2])continue;const t=e[9];for(let e=0;e<t.length;e++){const n=t[e],s=n[3];0==(1024&n[2])&&Ye(s,1),n[2]|=1024}}}(e),function(t){for(let e=Pr(t);null!==e;e=zr(e))for(let t=ke;t<e.length;t++){const n=e[t],s=n[1];Ke(n)&&Di(s,n,s.template,n[8])}}(e),null!==t.contentQueries&&Ai(t,e),!i)if(a){const n=t.contentCheckHooks;null!==n&&An(e,n)}else{const n=t.contentHooks;null!==n&&$n(e,n,1),Rn(e,1)}!function(t,e){const n=t.hostBindingOpCodes;if(null!==n)try{for(let t=0;t<n.length;t++){const s=n[t];if(s<0)In(~s);else{const r=s,i=n[++t],a=n[++t];dn(i,r),a(2,e[r])}}}finally{In(-1)}}(t,e);const o=t.components;null!==o&&function(t,e){for(let n=0;n<e.length;n++)sa(t,e[n])}(e,o);const l=t.viewQuery;if(null!==l&&ca(2,l,s),!i)if(a){const n=t.viewCheckHooks;null!==n&&An(e,n)}else{const n=t.viewHooks;null!==n&&$n(e,n,2),Rn(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),i||(e[2]&=-73),1024&e[2]&&(e[2]&=-1025,Ye(e[3],-1))}finally{Cn()}}function Li(t,e,n,s){const r=e[10],i=!un(),a=qe(e);try{i&&!a&&r.begin&&r.begin(),a&&Fi(t,e,s),Di(t,e,n,s)}finally{i&&!a&&r.end&&r.end()}}function Mi(t,e,n,s,r){const i=Sn(),a=2&s;try{In(-1),a&&e.length>xe&&ki(t,e,xe,un()),n(s,r)}finally{In(i)}}function Pi(t,e,n){if(Ie(e)){const s=e.directiveEnd;for(let r=e.directiveStart;r<s;r++){const e=t.data[r];e.contentQueries&&e.contentQueries(1,n[r],r)}}}function zi(t,e,n){Je()&&(function(t,e,n,s){const r=n.directiveStart,i=n.directiveEnd;t.firstCreatePass||Kn(n,e),Ir(s,e);const a=n.initialInputs;for(let o=r;o<i;o++){const s=t.data[o],i=Te(s);i&&Ji(e,n,s);const l=as(e,t,o,n);Ir(l,e),null!==a&&ta(0,o-r,l,s,0,a),i&&(Ge(n.index,e)[8]=l)}}(t,e,n,je(n,e)),128==(128&n.flags)&&function(t,e,n){const s=n.directiveStart,r=n.directiveEnd,i=n.index,a=Qe.lFrame.currentDirectiveIndex;try{In(i);for(let n=s;n<r;n++){const s=t.data[n],r=e[n];pn(n),null===s.hostBindings&&0===s.hostVars&&null===s.hostAttrs||Ki(s,r)}}finally{In(-1),pn(a)}}(t,e,n))}function Vi(t,e,n=je){const s=e.localNames;if(null!==s){let r=e.index+1;for(let i=0;i<s.length;i+=2){const a=s[i+1],o=-1===a?n(e,t):t[a];t[r++]=o}}}function Bi(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=Wi(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):e}function Wi(t,e,n,s,r,i,a,o,l,u){const c=xe+s,h=c+r,d=function(t,e){const n=[];for(let s=0;s<e;s++)n.push(s<t?null:_i);return n}(c,h),p="function"==typeof u?u():u;return d[1]={type:t,blueprint:d,template:n,queries:null,viewQuery:o,declTNode:e,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof a?a():a,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function Ui(t,e,n,s){const r=da(e);null===n?r.push(s):(r.push(n),t.firstCreatePass&&pa(t).push(s,r.length-1))}function ji(t,e,n){for(let s in t)if(t.hasOwnProperty(s)){const r=t[s];(n=null===n?{}:n).hasOwnProperty(s)?n[s].push(e,r):n[s]=[e,r]}return n}function Hi(t,e,n,s,r,i,a,o){const l=je(e,n);let u,c=e.inputs;var h;!o&&null!=c&&(u=c[s])?(ga(t,n,u,s,r),Ee(e)&&function(t,e){const n=Ge(e,t);16&n[2]||(n[2]|=64)}(n,e.index)):3&e.type&&(s="class"===(h=s)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,r=null!=a?a(r,e.value||"",s):r,Ve(i)?i.setProperty(l,s,r):zn(s)||(l.setProperty?l.setProperty(s,r):l[s]=r))}function Gi(t,e,n,s){let r=!1;if(Je()){const i=function(t,e,n){const s=t.directiveRegistry;let r=null;if(s)for(let i=0;i<s.length;i++){const a=s[i];yi(n,a.selectors,!1)&&(r||(r=[]),Qn(Kn(n,e),t,a.type),Te(a)?(Xi(t,n),r.unshift(a)):r.push(a))}return r}(t,e,n),a=null===s?null:{"":-1};if(null!==i){r=!0,Yi(n,t.data.length,i.length);for(let t=0;t<i.length;t++){const e=i[t];e.providersResolver&&e.providersResolver(e)}let s=!1,o=!1,l=Oi(t,e,i.length,null);for(let r=0;r<i.length;r++){const u=i[r];n.mergedAttrs=Vn(n.mergedAttrs,u.hostAttrs),Qi(t,n,e,l,u),Zi(l,u,a),null!==u.contentQueries&&(n.flags|=8),null===u.hostBindings&&null===u.hostAttrs&&0===u.hostVars||(n.flags|=128);const c=u.type.prototype;!s&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(n.index),s=!0),o||!c.ngOnChanges&&!c.ngDoCheck||((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(n.index),o=!0),l++}!function(t,e){const n=e.directiveEnd,s=t.data,r=e.attrs,i=[];let a=null,o=null;for(let l=e.directiveStart;l<n;l++){const t=s[l],n=t.inputs,u=null===r||di(e)?null:ea(n,r);i.push(u),a=ji(n,l,a),o=ji(t.outputs,l,o)}null!==a&&(a.hasOwnProperty("class")&&(e.flags|=16),a.hasOwnProperty("style")&&(e.flags|=32)),e.initialInputs=i,e.inputs=a,e.outputs=o}(t,n)}a&&function(t,e,n){if(e){const s=t.localNames=[];for(let t=0;t<e.length;t+=2){const r=n[e[t+1]];if(null==r)throw new $t("301",`Export of name '${e[t+1]}' not found!`);s.push(e[t],r)}}}(n,s,a)}return n.mergedAttrs=Vn(n.mergedAttrs,n.attrs),r}function qi(t,e,n,s,r,i){const a=i.hostBindings;if(a){let n=t.hostBindingOpCodes;null===n&&(n=t.hostBindingOpCodes=[]);const i=~e.index;(function(t){let e=t.length;for(;e>0;){const n=t[--e];if("number"==typeof n&&n<0)return n}return 0})(n)!=i&&n.push(i),n.push(s,r,a)}}function Ki(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function Xi(t,e){e.flags|=2,(t.components||(t.components=[])).push(e.index)}function Zi(t,e,n){if(n){if(e.exportAs)for(let s=0;s<e.exportAs.length;s++)n[e.exportAs[s]]=t;Te(e)&&(n[""]=t)}}function Yi(t,e,n){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+n,t.providerIndexes=e}function Qi(t,e,n,s,r){t.data[s]=r;const i=r.factory||(r.factory=Ae(r.type)),a=new Ln(i,Te(r),null);t.blueprint[s]=a,n[s]=a,qi(t,e,0,s,Oi(t,n,r.hostVars,_i),r)}function Ji(t,e,n){const s=je(e,t),r=Bi(n),i=t[10],a=aa(t,$i(t,r,null,n.onPush?64:16,s,e,i,i.createRenderer(s,n),null,null));t[e.index]=a}function ta(t,e,n,s,r,i){const a=i[e];if(null!==a){const t=s.setInput;for(let e=0;e<a.length;){const r=a[e++],i=a[e++],o=a[e++];null!==t?s.setInput(n,o,r,i):n[i]=o}}}function ea(t,e){let n=null,s=0;for(;s<e.length;){const r=e[s];if(0!==r)if(5!==r){if("number"==typeof r)break;t.hasOwnProperty(r)&&(null===n&&(n=[]),n.push(r,t[r],e[s+1])),s+=2}else s+=2;else s+=4}return n}function na(t,e,n,s){return new Array(t,!0,!1,e,null,0,s,n,null,null)}function sa(t,e){const n=Ge(e,t);if(Ke(n)){const t=n[1];80&n[2]?Di(t,n,t.template,n[8]):n[5]>0&&ra(n)}}function ra(t){for(let n=Pr(t);null!==n;n=zr(n))for(let t=ke;t<n.length;t++){const e=n[t];if(1024&e[2]){const t=e[1];Di(t,e,t.template,e[8])}else e[5]>0&&ra(e)}const e=t[1].components;if(null!==e)for(let n=0;n<e.length;n++){const s=Ge(e[n],t);Ke(s)&&s[5]>0&&ra(s)}}function ia(t,e){const n=Ge(e,t),s=n[1];!function(t,e){for(let n=e.length;n<t.blueprint.length;n++)e.push(t.blueprint[n])}(s,n),Fi(s,n,n[8])}function aa(t,e){return t[13]?t[14][4]=e:t[13]=e,t[14]=e,e}function oa(t){for(;t;){t[2]|=64;const e=Mr(t);if(0!=(512&t[2])&&!e)return t;t=e}return null}function la(t,e,n){const s=e[10];s.begin&&s.begin();try{Di(t,e,t.template,n)}catch(r){throw ma(e,r),r}finally{s.end&&s.end()}}function ua(t){!function(t){for(let e=0;e<t.components.length;e++){const n=t.components[e],s=Er(n),r=s[1];Li(r,s,r.template,n)}}(t[8])}function ca(t,e,n){gn(0),e(t,n)}const ha=(()=>Promise.resolve(null))();function da(t){return t[7]||(t[7]=[])}function pa(t){return t.cleanup||(t.cleanup=[])}function fa(t,e,n){return(null===t||Te(t))&&(n=function(t){for(;Array.isArray(t);){if("object"==typeof t[1])return t;t=t[0]}return null}(n[e.index])),n[11]}function ma(t,e){const n=t[9],s=n?n.get($r,null):null;s&&s.handleError(e)}function ga(t,e,n,s,r){for(let i=0;i<n.length;){const a=n[i++],o=n[i++],l=e[a],u=t.data[a];null!==u.setInput?u.setInput(l,r,s,o):l[o]=r}}function ya(t,e,n){let s=n?t.styles:null,r=n?t.classes:null,i=0;if(null!==e)for(let a=0;a<e.length;a++){const t=e[a];"number"==typeof t?i=t:1==i?r=It(r,t):2==i&&(s=It(s,t+": "+e[++a]+";"))}n?t.styles=s:t.stylesWithoutHost=s,n?t.classes=r:t.classesWithoutHost=r}const ba=new ms("INJECTOR",-1);class va{get(t,e=Is){if(e===Is){const e=new Error(`NullInjectorError: No provider for ${St(t)}!`);throw e.name="NullInjectorError",e}return e}}const wa=new ms("Set Injector scope."),_a={},xa={};let ka;function Ca(){return void 0===ka&&(ka=new va),ka}function Sa(t,e=null,n=null,s){return new Ia(t,n,e||Ca(),s)}class Ia{constructor(t,e,n,s=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const r=[];e&&vs(e,n=>this.processProvider(n,t,e)),vs([t],t=>this.processInjectorType(t,[],r)),this.records.set(ba,Ta(void 0,this));const i=this.records.get(wa);this.scope=null!=i?i.value:null,this.source=s||("object"==typeof t?null:St(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=Is,n=jt.Default){this.assertNotDestroyed();const s=$s(this);try{if(!(n&jt.SkipSelf)){let e=this.records.get(t);if(void 0===e){const n=("function"==typeof(r=t)||"object"==typeof r&&r instanceof ms)&&Mt(t);e=n&&this.injectableDefInScope(n)?Ta(Ea(t),_a):null,this.records.set(t,e)}if(null!=e)return this.hydrate(t,e)}return(n&jt.Self?Ca():this.parent).get(t,e=n&jt.Optional&&e===Is?null:e)}catch(i){if("NullInjectorError"===i.name){if((i.ngTempTokenPath=i.ngTempTokenPath||[]).unshift(St(t)),s)throw i;return function(t,e,n,s){const r=t.ngTempTokenPath;throw e[Ns]&&r.unshift(e[Ns]),t.message=function(t,e,n,s=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.substr(2):t;let r=St(e);if(Array.isArray(e))r=e.map(St).join(" -> ");else if("object"==typeof e){let t=[];for(let n in e)if(e.hasOwnProperty(n)){let s=e[n];t.push(n+":"+("string"==typeof s?JSON.stringify(s):St(s)))}r=`{${t.join(", ")}}`}return`${n}${s?"("+s+")":""}[${r}]: ${t.replace(Es,"\n  ")}`}("\n"+t.message,r,n,s),t.ngTokenPath=r,t.ngTempTokenPath=null,t}(i,t,"R3InjectorError",this.source)}throw i}finally{$s(s)}var r}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((e,n)=>t.push(St(n))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(t,e,n){if(!(t=Tt(t)))return!1;let s=zt(t);const r=null==s&&t.ngModule||void 0,i=void 0===r?t:r,a=-1!==n.indexOf(i);if(void 0!==r&&(s=zt(r)),null==s)return!1;if(null!=s.imports&&!a){let t;n.push(i);try{vs(s.imports,s=>{this.processInjectorType(s,e,n)&&(void 0===t&&(t=[]),t.push(s))})}finally{}if(void 0!==t)for(let e=0;e<t.length;e++){const{ngModule:n,providers:s}=t[e];vs(s,t=>this.processProvider(t,n,s||se))}}this.injectorDefTypes.add(i);const o=Ae(i)||(()=>new i);this.records.set(i,Ta(o,_a));const l=s.providers;if(null!=l&&!a){const e=t;vs(l,t=>this.processProvider(t,e,l))}return void 0!==r&&void 0!==t.providers}processProvider(t,e,n){let s=$a(t=Tt(t))?t:Tt(t&&t.provide);const r=function(t,e,n){return Aa(t)?Ta(void 0,t.useValue):Ta(Na(t),_a)}(t);if($a(t)||!0!==t.multi)this.records.get(s);else{let e=this.records.get(s);e||(e=Ta(void 0,_a,!0),e.factory=()=>Ds(e.multi),this.records.set(s,e)),s=t,e.multi.push(t)}this.records.set(s,r)}hydrate(t,e){var n;return e.value===_a&&(e.value=xa,e.value=e.factory()),"object"==typeof e.value&&e.value&&null!==(n=e.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=Tt(t.providedIn);return"string"==typeof e?"any"===e||e===this.scope:this.injectorDefTypes.has(e)}}function Ea(t){const e=Mt(t),n=null!==e?e.factory:Ae(t);if(null!==n)return n;if(t instanceof ms)throw new Error(`Token ${St(t)} is missing a \u0275prov definition.`);if(t instanceof Function)return function(t){const e=t.length;if(e>0){const n=xs(e,"?");throw new Error(`Can't resolve all parameters for ${St(t)}: (${n.join(", ")}).`)}const n=function(t){const e=t&&(t[Vt]||t[Wt]);if(e){const n=function(t){if(t.hasOwnProperty("name"))return t.name;const e=(""+t).match(/^function\s*([^\s(]+)/);return null===e?"":e[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),e}return null}(t);return null!==n?()=>n.factory(t):()=>new t}(t);throw new Error("unreachable")}function Na(t,e,n){let s;if($a(t)){const e=Tt(t);return Ae(e)||Ea(e)}if(Aa(t))s=()=>Tt(t.useValue);else if((r=t)&&r.useFactory)s=()=>t.useFactory(...Ds(t.deps||[]));else if(function(t){return!(!t||!t.useExisting)}(t))s=()=>Os(Tt(t.useExisting));else{const e=Tt(t&&(t.useClass||t.provide));if(!function(t){return!!t.deps}(t))return Ae(e)||Ea(e);s=()=>new e(...Ds(t.deps))}var r;return s}function Ta(t,e,n=!1){return{factory:t,value:e,multi:n?[]:void 0}}function Aa(t){return null!==t&&"object"==typeof t&&Ts in t}function $a(t){return"function"==typeof t}const Ra=function(t,e,n){return function(t,e=null,n=null,s){const r=Sa(t,e,n,s);return r._resolveInjectorDefTypes(),r}({name:n},e,t,n)};let Oa=(()=>{class t{static create(t,e){return Array.isArray(t)?Ra(t,e,""):Ra(t.providers,t.parent,t.name||"")}}return t.THROW_IF_NOT_FOUND=Is,t.NULL=new va,t.\u0275prov=Dt({token:t,providedIn:"any",factory:()=>Os(ba)}),t.__NG_ELEMENT_ID__=-1,t})();function Fa(t,e){Tn(Er(t)[1],sn())}function Da(t){let e=Object.getPrototypeOf(t.type.prototype).constructor,n=!0;const s=[t];for(;e;){let r;if(Te(t))r=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new Error("Directives cannot inherit Components");r=e.\u0275dir}if(r){if(n){s.push(r);const e=t;e.inputs=La(t.inputs),e.declaredInputs=La(t.declaredInputs),e.outputs=La(t.outputs);const n=r.hostBindings;n&&za(t,n);const i=r.viewQuery,a=r.contentQueries;if(i&&Ma(t,i),a&&Pa(t,a),Ct(t.inputs,r.inputs),Ct(t.declaredInputs,r.declaredInputs),Ct(t.outputs,r.outputs),Te(r)&&r.data.animation){const e=t.data;e.animation=(e.animation||[]).concat(r.data.animation)}}const e=r.features;if(e)for(let s=0;s<e.length;s++){const r=e[s];r&&r.ngInherit&&r(t),r===Da&&(n=!1)}}e=Object.getPrototypeOf(e)}!function(t){let e=0,n=null;for(let s=t.length-1;s>=0;s--){const r=t[s];r.hostVars=e+=r.hostVars,r.hostAttrs=Vn(r.hostAttrs,n=Vn(n,r.hostAttrs))}}(s)}function La(t){return t===ne?{}:t===se?[]:t}function Ma(t,e){const n=t.viewQuery;t.viewQuery=n?(t,s)=>{e(t,s),n(t,s)}:e}function Pa(t,e){const n=t.contentQueries;t.contentQueries=n?(t,s,r)=>{e(t,s,r),n(t,s,r)}:e}function za(t,e){const n=t.hostBindings;t.hostBindings=n?(t,s)=>{e(t,s),n(t,s)}:e}let Va=null;function Ba(){if(!Va){const t=ee.Symbol;if(t&&t.iterator)Va=t.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const n=t[e];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(Va=n)}}}return Va}class Wa{constructor(t){this.wrapped=t}static wrap(t){return new Wa(t)}static unwrap(t){return Wa.isWrapped(t)?t.wrapped:t}static isWrapped(t){return t instanceof Wa}}function Ua(t){return!!ja(t)&&(Array.isArray(t)||!(t instanceof Map)&&Ba()in t)}function ja(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function Ha(t,e,n){return!Object.is(t[e],n)&&(t[e]=n,!0)}function Ga(t,e,n,s){const r=tn();return Ha(r,hn(),e)&&(en(),function(t,e,n,s,r,i){const a=je(t,e);!function(t,e,n,s,r,i,a){if(null==i)Ve(t)?t.removeAttribute(e,r,n):e.removeAttribute(r);else{const o=null==a?Rt(i):a(i,s||"",r);Ve(t)?t.setAttribute(e,r,o,n):n?e.setAttributeNS(n,r,o):e.setAttribute(r,o)}}(e[11],a,i,t.value,n,s,r)}(En(),r,t,e,n,s)),Ga}function qa(t,e,n,s){return Ha(t,hn(),n)?e+Rt(n)+s:_i}function Ka(t,e,n,s,r,i,a,o){const l=tn(),u=en(),c=t+xe,h=u.firstCreatePass?function(t,e,n,s,r,i,a,o,l){const u=e.consts,c=Ri(e,t,4,a||null,Xe(u,o));Gi(e,n,c,Xe(u,l)),Tn(e,c);const h=c.tViews=Wi(2,c,s,r,i,e.directiveRegistry,e.pipeRegistry,null,e.schemas,u);return null!==e.queries&&(e.queries.template(e,c),h.queries=e.queries.embeddedTView(c)),c}(c,u,l,e,n,s,r,i,a):u.data[c];an(h,!1);const d=l[11].createComment("");ti(u,l,d,h),Ir(d,l),aa(l,l[c]=na(d,l,d,h)),Ne(h)&&zi(u,l,h),null!=a&&Vi(l,h,o)}function Xa(t,e=jt.Default){const n=tn();return null===n?Os(t,e):es(sn(),n,Tt(t),e)}function Za(t,e,n){const s=tn();return Ha(s,hn(),e)&&Hi(en(),En(),s,t,e,s[11],n,!1),Za}function Ya(t,e,n,s,r){const i=r?"class":"style";ga(t,n,e.inputs[i],i,s)}function Qa(t,e,n,s){const r=tn(),i=en(),a=xe+t,o=r[11],l=r[a]=Wr(o,e,Qe.lFrame.currentNamespace),u=i.firstCreatePass?function(t,e,n,s,r,i,a){const o=e.consts,l=Ri(e,t,2,r,Xe(o,i));return Gi(e,n,l,Xe(o,a)),null!==l.attrs&&ya(l,l.attrs,!1),null!==l.mergedAttrs&&ya(l,l.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,l),l}(a,i,r,0,e,n,s):i.data[a];an(u,!0);const c=u.mergedAttrs;null!==c&&Mn(o,l,c);const h=u.classes;null!==h&&li(o,l,h);const d=u.styles;null!==d&&oi(o,l,d),64!=(64&u.flags)&&ti(i,r,l,u),0===Qe.lFrame.elementDepthCount&&Ir(l,r),Qe.lFrame.elementDepthCount++,Ne(u)&&(zi(i,r,u),Pi(i,u,r)),null!==s&&Vi(r,u)}function Ja(){let t=sn();on()?ln():(t=t.parent,an(t,!1));const e=t;Qe.lFrame.elementDepthCount--;const n=en();n.firstCreatePass&&(Tn(n,t),Ie(t)&&n.queries.elementEnd(t)),null!=e.classesWithoutHost&&function(t){return 0!=(16&t.flags)}(e)&&Ya(n,e,tn(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function(t){return 0!=(32&t.flags)}(e)&&Ya(n,e,tn(),e.stylesWithoutHost,!1)}function to(t,e,n,s){Qa(t,e,n,s),Ja()}function eo(t,e,n){const s=tn(),r=en(),i=t+xe,a=r.firstCreatePass?function(t,e,n,s,r){const i=e.consts,a=Xe(i,s),o=Ri(e,t,8,"ng-container",a);return null!==a&&ya(o,a,!0),Gi(e,n,o,Xe(i,r)),null!==e.queries&&e.queries.elementStart(e,o),o}(i,r,s,e,n):r.data[i];an(a,!0);const o=s[i]=s[11].createComment("");ti(r,s,o,a),Ir(o,s),Ne(a)&&(zi(r,s,a),Pi(r,a,s)),null!=n&&Vi(s,a)}function no(){let t=sn();const e=en();on()?ln():(t=t.parent,an(t,!1)),e.firstCreatePass&&(Tn(e,t),Ie(t)&&e.queries.elementEnd(t))}function so(){return tn()}function ro(t){return!!t&&"function"==typeof t.then}function io(t){return!!t&&"function"==typeof t.subscribe}const ao=io;function oo(t,e,n,s){const r=tn(),i=en(),a=sn();return uo(i,r,r[11],a,t,e,!!n,s),oo}function lo(t,e){const n=sn(),s=tn(),r=en();return uo(r,s,fa(fn(r.data),n,s),n,t,e,!1),lo}function uo(t,e,n,s,r,i,a,o){const l=Ne(s),u=t.firstCreatePass&&pa(t),c=da(e);let h=!0;if(3&s.type||o){const d=je(s,e),p=o?o(d):d,f=c.length,m=o?t=>o(We(t[s.index])):s.index;if(Ve(n)){let a=null;if(!o&&l&&(a=function(t,e,n,s){const r=t.cleanup;if(null!=r)for(let i=0;i<r.length-1;i+=2){const t=r[i];if(t===n&&r[i+1]===s){const t=e[7],n=r[i+2];return t.length>n?t[n]:null}"string"==typeof t&&(i+=2)}return null}(t,e,r,s.index)),null!==a)(a.__ngLastListenerFn__||a).__ngNextListenerFn__=i,a.__ngLastListenerFn__=i,h=!1;else{i=ho(s,e,0,i,!1);const t=n.listen(p,r,i);c.push(i,t),u&&u.push(r,m,f,f+1)}}else i=ho(s,e,0,i,!0),p.addEventListener(r,i,a),c.push(i),u&&u.push(r,m,f,a)}else i=ho(s,e,0,i,!1);const d=s.outputs;let p;if(h&&null!==d&&(p=d[r])){const t=p.length;if(t)for(let n=0;n<t;n+=2){const t=e[p[n]][p[n+1]].subscribe(i),a=c.length;c.push(i,t),u&&u.push(r,s.index,a,-(a+1))}}}function co(t,e,n,s){try{return!1!==n(s)}catch(r){return ma(t,r),!1}}function ho(t,e,n,s,r){return function n(i){if(i===Function)return s;const a=2&t.flags?Ge(t.index,e):e;0==(32&e[2])&&oa(a);let o=co(e,0,s,i),l=n.__ngNextListenerFn__;for(;l;)o=co(e,0,l,i)&&o,l=l.__ngNextListenerFn__;return r&&!1===o&&(i.preventDefault(),i.returnValue=!1),o}}function po(t=1){return function(t){return(Qe.lFrame.contextLView=function(t,e){for(;t>0;)e=e[15],t--;return e}(t,Qe.lFrame.contextLView))[8]}(t)}function fo(t,e){let n=null;const s=function(t){const e=t.attrs;if(null!=e){const t=e.indexOf(5);if(0==(1&t))return e[t+1]}return null}(t);for(let r=0;r<e.length;r++){const i=e[r];if("*"!==i){if(null===s?yi(t,i,!0):bi(s,i))return r}else n=r}return n}function mo(t){const e=tn()[16][6];if(!e.projection){const n=e.projection=xs(t?t.length:1,null),s=n.slice();let r=e.child;for(;null!==r;){const e=t?fo(r,t):0;null!==e&&(s[e]?s[e].projectionNext=r:n[e]=r,s[e]=r),r=r.next}}}function go(t,e=0,n){const s=tn(),r=en(),i=Ri(r,xe+t,16,null,n||null);null===i.projection&&(i.projection=e),ln(),64!=(64&i.flags)&&function(t,e,n){ai(e[11],0,e,n,qr(t,n,e),Qr(n.parent||e[6],n,e))}(r,s,i)}function yo(t,e,n){return bo(t,"",e,"",n),yo}function bo(t,e,n,s,r){const i=tn(),a=qa(i,e,n,s);return a!==_i&&Hi(en(),En(),i,t,a,i[11],r,!1),bo}function vo(t,e,n,s,r){const i=t[n+1],a=null===e;let o=s?Si(i):Ei(i),l=!1;for(;0!==o&&(!1===l||a);){const n=t[o+1];wo(t[o],e)&&(l=!0,t[o+1]=s?Ti(n):Ii(n)),o=s?Si(n):Ei(n)}l&&(t[n+1]=s?Ii(i):Ti(i))}function wo(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&Ss(t,e)>=0}function _o(t,e,n){return ko(t,e,n,!1),_o}function xo(t,e){return ko(t,e,null,!0),xo}function ko(t,e,n,s){const r=tn(),i=en(),a=function(t){const e=Qe.lFrame,n=e.bindingIndex;return e.bindingIndex=e.bindingIndex+2,n}();i.firstUpdatePass&&function(t,e,n,s){const r=t.data;if(null===r[n+1]){const i=r[Sn()],a=function(t,e){return e>=t.expandoStartIndex}(t,n);(function(t,e){return 0!=(t.flags&(e?16:32))})(i,s)&&null===e&&!a&&(e=!1),e=function(t,e,n,s){const r=fn(t);let i=s?e.residualClasses:e.residualStyles;if(null===r)0===(s?e.classBindings:e.styleBindings)&&(n=So(n=Co(null,t,e,n,s),e.attrs,s),i=null);else{const a=e.directiveStylingLast;if(-1===a||t[a]!==r)if(n=Co(r,t,e,n,s),null===i){let n=function(t,e,n){const s=n?e.classBindings:e.styleBindings;if(0!==Ei(s))return t[Si(s)]}(t,e,s);void 0!==n&&Array.isArray(n)&&(n=Co(null,t,e,n[1],s),n=So(n,e.attrs,s),function(t,e,n,s){t[Si(n?e.classBindings:e.styleBindings)]=s}(t,e,s,n))}else i=function(t,e,n){let s;const r=e.directiveEnd;for(let i=1+e.directiveStylingLast;i<r;i++)s=So(s,t[i].hostAttrs,n);return So(s,e.attrs,n)}(t,e,s)}return void 0!==i&&(s?e.residualClasses=i:e.residualStyles=i),n}(r,i,e,s),function(t,e,n,s,r,i){let a=i?e.classBindings:e.styleBindings,o=Si(a),l=Ei(a);t[s]=n;let u,c=!1;if(Array.isArray(n)){const t=n;u=t[1],(null===u||Ss(t,u)>0)&&(c=!0)}else u=n;if(r)if(0!==l){const e=Si(t[o+1]);t[s+1]=Ci(e,o),0!==e&&(t[e+1]=Ni(t[e+1],s)),t[o+1]=131071&t[o+1]|s<<17}else t[s+1]=Ci(o,0),0!==o&&(t[o+1]=Ni(t[o+1],s)),o=s;else t[s+1]=Ci(l,0),0===o?o=s:t[l+1]=Ni(t[l+1],s),l=s;c&&(t[s+1]=Ii(t[s+1])),vo(t,u,s,!0),vo(t,u,s,!1),function(t,e,n,s,r){const i=r?t.residualClasses:t.residualStyles;null!=i&&"string"==typeof e&&Ss(i,e)>=0&&(n[s+1]=Ti(n[s+1]))}(e,u,t,s,i),a=Ci(o,l),i?e.classBindings=a:e.styleBindings=a}(r,i,e,n,a,s)}}(i,t,a,s),e!==_i&&Ha(r,a,e)&&function(t,e,n,s,r,i,a,o){if(!(3&e.type))return;const l=t.data,u=l[o+1];Eo(1==(1&u)?Io(l,e,n,r,Ei(u),a):void 0)||(Eo(i)||function(t){return 2==(2&t)}(u)&&(i=Io(l,null,n,r,o,a)),function(t,e,n,s,r){const i=Ve(t);if(e)r?i?t.addClass(n,s):n.classList.add(s):i?t.removeClass(n,s):n.classList.remove(s);else{let e=-1===s.indexOf("-")?void 0:Dr.DashCase;if(null==r)i?t.removeStyle(n,s,e):n.style.removeProperty(s);else{const a="string"==typeof r&&r.endsWith("!important");a&&(r=r.slice(0,-10),e|=Dr.Important),i?t.setStyle(n,s,r,e):n.style.setProperty(s,r,a?"important":"")}}}(s,a,Ue(Sn(),n),r,i))}(i,i.data[Sn()],r,r[11],t,r[a+1]=function(t,e){return null==t||("string"==typeof e?t+=e:"object"==typeof t&&(t=St(Zs(t)))),t}(e,n),s,a)}function Co(t,e,n,s,r){let i=null;const a=n.directiveEnd;let o=n.directiveStylingLast;for(-1===o?o=n.directiveStart:o++;o<a&&(i=e[o],s=So(s,i.hostAttrs,r),i!==t);)o++;return null!==t&&(n.directiveStylingLast=o),s}function So(t,e,n){const s=n?1:2;let r=-1;if(null!==e)for(let i=0;i<e.length;i++){const a=e[i];"number"==typeof a?r=a:r===s&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),ks(t,a,!!n||e[++i]))}return void 0===t?null:t}function Io(t,e,n,s,r,i){const a=null===e;let o;for(;r>0;){const e=t[r],i=Array.isArray(e),l=i?e[1]:e,u=null===l;let c=n[r+1];c===_i&&(c=u?se:void 0);let h=u?Cs(c,s):l===s?c:void 0;if(i&&!Eo(h)&&(h=Cs(e,s)),Eo(h)&&(o=h,a))return o;const d=t[r+1];r=a?Si(d):Ei(d)}if(null!==e){let t=i?e.residualClasses:e.residualStyles;null!=t&&(o=Cs(t,s))}return o}function Eo(t){return void 0!==t}function No(t,e=""){const n=tn(),s=en(),r=t+xe,i=s.firstCreatePass?Ri(s,r,1,e,null):s.data[r],a=n[r]=function(t,e){return Ve(t)?t.createText(e):t.createTextNode(e)}(n[11],e);ti(s,n,a,i),an(i,!1)}function To(t){return Ao("",t,""),To}function Ao(t,e,n){const s=tn(),r=qa(s,t,e,n);return r!==_i&&function(t,e,n){const s=Ue(e,t);!function(t,e,n){Ve(t)?t.setValue(e,n):e.textContent=n}(t[11],s,n)}(s,Sn(),r),Ao}function $o(t,e,n){const s=tn();return Ha(s,hn(),e)&&Hi(en(),En(),s,t,e,s[11],n,!0),$o}function Ro(t,e,n){const s=tn();if(Ha(s,hn(),e)){const r=en(),i=En();Hi(r,i,s,t,e,fa(fn(r.data),i,s),n,!0)}return Ro}const Oo=void 0;var Fo=["en",[["a","p"],["AM","PM"],Oo],[["AM","PM"],Oo,Oo],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Oo,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Oo,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Oo,"{1} 'at' {0}",Oo],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(t){let e=Math.floor(Math.abs(t)),n=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===n?1:5}];let Do={};function Lo(t){const e=function(t){return t.toLowerCase().replace(/_/g,"-")}(t);let n=Mo(e);if(n)return n;const s=e.split("-")[0];if(n=Mo(s),n)return n;if("en"===s)return Fo;throw new Error(`Missing locale data for the locale "${t}".`)}function Mo(t){return t in Do||(Do[t]=ee.ng&&ee.ng.common&&ee.ng.common.locales&&ee.ng.common.locales[t]),Do[t]}var Po=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}({});const zo="en-US";let Vo=zo;function Bo(t){var e,n;n="Expected localeId to be defined",null==(e=t)&&function(t,e,n,s){throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`)}(n,e),"string"==typeof t&&(Vo=t.toLowerCase().replace(/_/g,"-"))}function Wo(t,e,n,s,r){if(t=Tt(t),Array.isArray(t))for(let i=0;i<t.length;i++)Wo(t[i],e,n,s,r);else{const i=en(),a=tn();let o=$a(t)?t:Tt(t.provide),l=Na(t);const u=sn(),c=1048575&u.providerIndexes,h=u.directiveStart,d=u.providerIndexes>>20;if($a(t)||!t.multi){const s=new Ln(l,r,Xa),p=Ho(o,e,r?c:c+d,h);-1===p?(Qn(Kn(u,a),i,o),Uo(i,t,e.length),e.push(o),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),n.push(s),a.push(s)):(n[p]=s,a[p]=s)}else{const p=Ho(o,e,c+d,h),f=Ho(o,e,c,c+d),m=p>=0&&n[p],g=f>=0&&n[f];if(r&&!g||!r&&!m){Qn(Kn(u,a),i,o);const c=function(t,e,n,s,r){const i=new Ln(t,n,Xa);return i.multi=[],i.index=e,i.componentProviders=0,jo(i,r,s&&!n),i}(r?qo:Go,n.length,r,s,l);!r&&g&&(n[f].providerFactory=c),Uo(i,t,e.length,0),e.push(o),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),n.push(c),a.push(c)}else Uo(i,t,p>-1?p:f,jo(n[r?f:p],l,!r&&s));!r&&s&&g&&n[f].componentProviders++}}}function Uo(t,e,n,s){const r=$a(e);if(r||e.useClass){const i=(e.useClass||e).prototype.ngOnDestroy;if(i){const a=t.destroyHooks||(t.destroyHooks=[]);if(!r&&e.multi){const t=a.indexOf(n);-1===t?a.push(n,[s,i]):a[t+1].push(s,i)}else a.push(n,i)}}}function jo(t,e,n){return n&&t.componentProviders++,t.multi.push(e)-1}function Ho(t,e,n,s){for(let r=n;r<s;r++)if(e[r]===t)return r;return-1}function Go(t,e,n,s){return Ko(this.multi,[])}function qo(t,e,n,s){const r=this.multi;let i;if(this.providerFactory){const t=this.providerFactory.componentProviders,e=as(n,n[1],this.providerFactory.index,s);i=e.slice(0,t),Ko(r,i);for(let n=t;n<e.length;n++)i.push(e[n])}else i=[],Ko(r,i);return i}function Ko(t,e){for(let n=0;n<t.length;n++)e.push((0,t[n])());return e}function Xo(t,e=[]){return n=>{n.providersResolver=(n,s)=>function(t,e,n){const s=en();if(s.firstCreatePass){const r=Te(t);Wo(n,s.data,s.blueprint,r,!0),Wo(e,s.data,s.blueprint,r,!1)}}(n,s?s(t):t,e)}}class Zo{}class Yo{resolveComponentFactory(t){throw function(t){const e=Error(`No component factory found for ${St(t)}. Did you add it to @NgModule.entryComponents?`);return e.ngComponent=t,e}(t)}}let Qo=(()=>{class t{}return t.NULL=new Yo,t})();function Jo(...t){}function tl(t,e){return new nl(je(t,e))}const el=function(){return tl(sn(),tn())};let nl=(()=>{class t{constructor(t){this.nativeElement=t}}return t.__NG_ELEMENT_ID__=el,t})();function sl(t){return t instanceof nl?t.nativeElement:t}class rl{}let il=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>al(),t})();const al=function(){const t=tn(),e=Ge(sn().index,t);return function(t){return t[11]}(Ce(e)?e:t)};let ol=(()=>{class t{}return t.\u0275prov=Dt({token:t,providedIn:"root",factory:()=>null}),t})();class ll{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const ul=new ll("12.0.4");class cl{constructor(){}supports(t){return Ua(t)}create(t){return new dl(t)}}const hl=(t,e)=>e;class dl{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||hl}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,s=0,r=null;for(;e||n;){const i=!n||e&&e.currentIndex<gl(n,s,r)?e:n,a=gl(i,s,r),o=i.currentIndex;if(i===n)s--,n=n._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{r||(r=[]);const t=a-s,e=o-s;if(t!=e){for(let n=0;n<t;n++){const s=n<r.length?r[n]:r[n]=0,i=s+n;e<=i&&i<t&&(r[n]=s+1)}r[i.previousIndex]=e-t}}a!==o&&t(i,a,o)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Ua(t))throw new Error(`Error trying to diff '${St(t)}'. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e,n,s,r=this._itHead,i=!1;if(Array.isArray(t)){this.length=t.length;for(let e=0;e<this.length;e++)n=t[e],s=this._trackByFn(e,n),null!==r&&Object.is(r.trackById,s)?(i&&(r=this._verifyReinsertion(r,n,s,e)),Object.is(r.item,n)||this._addIdentityChange(r,n)):(r=this._mismatch(r,n,s,e),i=!0),r=r._next}else e=0,function(t,e){if(Array.isArray(t))for(let n=0;n<t.length;n++)e(t[n]);else{const n=t[Ba()]();let s;for(;!(s=n.next()).done;)e(s.value)}}(t,t=>{s=this._trackByFn(e,t),null!==r&&Object.is(r.trackById,s)?(i&&(r=this._verifyReinsertion(r,t,s,e)),Object.is(r.item,t)||this._addIdentityChange(r,t)):(r=this._mismatch(r,t,s,e),i=!0),r=r._next,e++}),this.length=e;return this._truncate(r),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,s){let r;return null===t?r=this._itTail:(r=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,r,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(n,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,r,s)):t=this._addAfter(new pl(e,n),r,s),t}_verifyReinsertion(t,e,n,s){let r=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==r?t=this._reinsertAfter(r,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,r=t._nextRemoved;return null===s?this._removalsHead=r:s._nextRemoved=r,null===r?this._removalsTail=s:r._prevRemoved=s,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new ml),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,n=t._next;return null===e?this._itHead=n:e._next=n,null===n?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new ml),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class pl{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class fl{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===e||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){const e=t._prevDup,n=t._nextDup;return null===e?this._head=n:e._nextDup=n,null===n?this._tail=e:n._prevDup=e,null===this._head}}class ml{constructor(){this.map=new Map}put(t){const e=t.trackById;let n=this.map.get(e);n||(n=new fl,this.map.set(e,n)),n.add(t)}get(t,e){const n=this.map.get(t);return n?n.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function gl(t,e,n){const s=t.previousIndex;if(null===s)return s;let r=0;return n&&s<n.length&&(r=n[s]),s+e+r}class yl{constructor(){}supports(t){return t instanceof Map||ja(t)}create(){return new bl}}class bl{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||ja(t)))throw new Error(`Error trying to diff '${St(t)}'. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(t,n)=>{if(e&&e.key===n)this._maybeAddToChanges(e,t),this._appendAfter=e,e=e._next;else{const s=this._getOrCreateRecordForKey(n,t);e=this._insertBeforeOrAppend(e,s)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let t=e;null!==t;t=t._nextRemoved)t===this._mapHead&&(this._mapHead=null),this._records.delete(t.key),t._nextRemoved=t._next,t.previousValue=t.currentValue,t.currentValue=null,t._prev=null,t._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const n=t._prev;return e._next=t,e._prev=n,t._prev=e,n&&(n._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const n=this._records.get(t);this._maybeAddToChanges(n,e);const s=n._prev,r=n._next;return s&&(s._next=r),r&&(r._prev=s),n._next=null,n._prev=null,n}const n=new vl(t);return this._records.set(t,n),n.currentValue=e,this._addToAdditions(n),n}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(n=>e(t[n],n))}}class vl{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function wl(){return new _l([new cl])}let _l=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(null!=n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||wl()),deps:[[t,new zs,new Ps]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(null!=e)return e;throw new Error(`Cannot find a differ supporting object '${t}' of type '${n=t,n.name||typeof n}'`);var n}}return t.\u0275prov=Dt({token:t,providedIn:"root",factory:wl}),t})();function xl(){return new kl([new yl])}let kl=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||xl()),deps:[[t,new zs,new Ps]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(e)return e;throw new Error(`Cannot find a differ supporting object '${t}'`)}}return t.\u0275prov=Dt({token:t,providedIn:"root",factory:xl}),t})();function Cl(t,e,n,s,r=!1){for(;null!==n;){const i=e[n.index];if(null!==i&&s.push(We(i)),Se(i))for(let t=ke;t<i.length;t++){const e=i[t],n=e[1].firstChild;null!==n&&Cl(e[1],e,n,s)}const a=n.type;if(8&a)Cl(t,e,n.child,s);else if(32&a){const t=Lr(n,e);let r;for(;r=t();)s.push(r)}else if(16&a){const t=ni(e,n);if(Array.isArray(t))s.push(...t);else{const n=Mr(e[16]);Cl(n[1],n,t,s,!0)}}n=r?n.projectionNext:n.next}return s}class Sl{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Cl(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Se(t)){const e=t[8],n=e?e.indexOf(this):-1;n>-1&&(jr(t,n),_s(e,n))}this._attachedToViewContainer=!1}Hr(this._lView[1],this._lView)}onDestroy(t){Ui(this._lView[1],this._lView,null,t)}markForCheck(){oa(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){la(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(t,e,n){cn(!0);try{la(t,e,n)}finally{cn(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var t;this._appRef=null,ii(this._lView[1],t=this._lView,t[11],2,null,null)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=t}}class Il extends Sl{constructor(t){super(t),this._view=t}detectChanges(){ua(this._view)}checkNoChanges(){!function(t){cn(!0);try{ua(t)}finally{cn(!1)}}(this._view)}get context(){return null}}const El=function(t){return function(t,e,n){if(Ee(t)&&!n){const n=Ge(t.index,e);return new Sl(n,n)}return 47&t.type?new Sl(e[16],e):null}(sn(),tn(),16==(16&t))};let Nl=(()=>{class t{}return t.__NG_ELEMENT_ID__=El,t})();const Tl=[new yl],Al=new _l([new cl]),$l=new kl(Tl),Rl=function(){return Ll(sn(),tn())};let Ol=(()=>{class t{}return t.__NG_ELEMENT_ID__=Rl,t})();const Fl=Ol,Dl=class extends Fl{constructor(t,e,n){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=n}createEmbeddedView(t){const e=this._declarationTContainer.tViews,n=$i(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const s=this._declarationLView[19];return null!==s&&(n[19]=s.createEmbeddedView(e)),Fi(e,n,t),new Sl(n)}};function Ll(t,e){return 4&t.type?new Dl(e,t,tl(t,e)):null}class Ml{}class Pl{}const zl=function(){return Hl(sn(),tn())};let Vl=(()=>{class t{}return t.__NG_ELEMENT_ID__=zl,t})();const Bl=Vl,Wl=class extends Bl{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=n}get element(){return tl(this._hostTNode,this._hostLView)}get injector(){return new us(this._hostTNode,this._hostLView)}get parentInjector(){const t=Yn(this._hostTNode,this._hostLView);if(Wn(t)){const e=jn(t,this._hostLView),n=Un(t);return new us(e[1].data[n+8],e)}return new us(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=Ul(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-ke}createEmbeddedView(t,e,n){const s=t.createEmbeddedView(e||{});return this.insert(s,n),s}createComponent(t,e,n,s,r){const i=n||this.parentInjector;if(!r&&null==t.ngModule&&i){const t=i.get(Ml,null);t&&(r=t)}const a=t.create(i,s,void 0,r);return this.insert(a.hostView,e),a}insert(t,e){const n=t._lView,s=n[1];if(Se(n[3])){const e=this.indexOf(t);if(-1!==e)this.detach(e);else{const e=n[3],s=new Wl(e,e[6],e[3]);s.detach(s.indexOf(t))}}const r=this._adjustIndex(e),i=this._lContainer;!function(t,e,n,s){const r=ke+s,i=n.length;s>0&&(n[r-1][4]=e),s<i-ke?(e[4]=n[r],ws(n,ke+s,e)):(n.push(e),e[4]=null),e[3]=n;const a=e[17];null!==a&&n!==a&&function(t,e){const n=t[9];e[16]!==e[3][3][16]&&(t[2]=!0),null===n?t[9]=[e]:n.push(e)}(a,e);const o=e[19];null!==o&&o.insertView(t),e[2]|=128}(s,n,i,r);const a=si(r,i),o=n[11],l=Yr(o,i[7]);return null!==l&&function(t,e,n,s,r,i){s[0]=r,s[6]=e,ii(t,s,n,1,r,i)}(s,i[6],o,n,l,a),t.attachToViewContainerRef(),ws(jl(i),r,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=Ul(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),n=jr(this._lContainer,e);n&&(_s(jl(this._lContainer),e),Hr(n[1],n))}detach(t){const e=this._adjustIndex(t,-1),n=jr(this._lContainer,e);return n&&null!=_s(jl(this._lContainer),e)?new Sl(n):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function Ul(t){return t[8]}function jl(t){return t[8]||(t[8]=[])}function Hl(t,e){let n;const s=e[t.index];if(Se(s))n=s;else{let r;if(8&t.type)r=We(s);else{const n=e[11];r=n.createComment("");const s=je(t,e);Kr(n,Yr(n,s),r,function(t,e){return Ve(t)?t.nextSibling(e):e.nextSibling}(n,s),!1)}e[t.index]=n=na(s,e,r,t),aa(e,n)}return new Wl(n,t,e)}const Gl={};class ql extends Qo{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=we(t);return new Zl(e,this.ngModule)}}function Kl(t){const e=[];for(let n in t)t.hasOwnProperty(n)&&e.push({propName:t[n],templateName:n});return e}const Xl=new ms("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>Rr});class Zl extends Zo{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=t.selectors.map(wi).join(","),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return Kl(this.componentDef.inputs)}get outputs(){return Kl(this.componentDef.outputs)}create(t,e,n,s){const r=(s=s||this.ngModule)?function(t,e){return{get:(n,s,r)=>{const i=t.get(n,Gl,r);return i!==Gl||s===Gl?i:e.get(n,s,r)}}}(t,s.injector):t,i=r.get(rl,Be),a=r.get(ol,null),o=i.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",u=n?function(t,e,n){if(Ve(t))return t.selectRootElement(e,n===Zt.ShadowDom);let s="string"==typeof e?t.querySelector(e):e;return s.textContent="",s}(o,n,this.componentDef.encapsulation):Wr(i.createRenderer(null,this.componentDef),l,function(t){const e=t.toLowerCase();return"svg"===e?Me:"math"===e?"http://www.w3.org/1998/MathML/":null}(l)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:Rr,clean:ha,playerHandler:null,flags:0},d=Wi(0,null,null,1,0,null,null,null,null,null),p=$i(null,d,h,c,null,null,i,o,a,r);let f,m;vn(p);try{const t=function(t,e,n,s,r,i){const a=n[1];n[20]=t;const o=Ri(a,20,2,"#host",null),l=o.mergedAttrs=e.hostAttrs;null!==l&&(ya(o,l,!0),null!==t&&(Mn(r,t,l),null!==o.classes&&li(r,t,o.classes),null!==o.styles&&oi(r,t,o.styles)));const u=s.createRenderer(t,e),c=$i(n,Bi(e),null,e.onPush?64:16,n[20],o,s,u,null,null);return a.firstCreatePass&&(Qn(Kn(o,n),a,e.type),Xi(a,o),Yi(o,n.length,1)),aa(n,c),n[20]=c}(u,this.componentDef,p,i,o);if(u)if(n)Mn(o,u,["ng-version",ul.full]);else{const{attrs:t,classes:e}=function(t){const e=[],n=[];let s=1,r=2;for(;s<t.length;){let i=t[s];if("string"==typeof i)2===r?""!==i&&e.push(i,t[++s]):8===r&&n.push(i);else{if(!mi(r))break;r=i}s++}return{attrs:e,classes:n}}(this.componentDef.selectors[0]);t&&Mn(o,u,t),e&&e.length>0&&li(o,u,e.join(" "))}if(m=He(d,xe),void 0!==e){const t=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const s=e[n];t.push(null!=s?Array.from(s):null)}}f=function(t,e,n,s,r){const i=n[1],a=function(t,e,n){const s=sn();t.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Qi(t,s,e,Oi(t,e,1,null),n));const r=as(e,t,s.directiveStart,s);Ir(r,e);const i=je(s,e);return i&&Ir(i,e),r}(i,n,e);if(s.components.push(a),t[8]=a,r&&r.forEach(t=>t(a,e)),e.contentQueries){const t=sn();e.contentQueries(1,a,t.directiveStart)}const o=sn();return!i.firstCreatePass||null===e.hostBindings&&null===e.hostAttrs||(In(o.index),qi(n[1],o,0,o.directiveStart,o.directiveEnd,e),Ki(e,a)),a}(t,this.componentDef,p,h,[Fa]),Fi(d,p,null)}finally{Cn()}return new Yl(this.componentType,f,tl(m,p),p,m)}}class Yl extends class{}{constructor(t,e,n,s,r){super(),this.location=n,this._rootLView=s,this._tNode=r,this.instance=e,this.hostView=this.changeDetectorRef=new Il(s),this.componentType=t}get injector(){return new us(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}const Ql=new Map;class Jl extends Ml{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new ql(this);const n=_e(t),s=t[le]||null;s&&Bo(s),this._bootstrapComponents=Fr(n.bootstrap),this._r3Injector=Sa(t,e,[{provide:Ml,useValue:this},{provide:Qo,useValue:this.componentFactoryResolver}],St(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Oa.THROW_IF_NOT_FOUND,n=jt.Default){return t===Oa||t===Ml||t===ba?this:this._r3Injector.get(t,e,n)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class tu extends Pl{constructor(t){super(),this.moduleType=t,null!==_e(t)&&function(t){const e=new Set;!function t(n){const s=_e(n,!0),r=s.id;null!==r&&(function(t,e,n){if(e&&e!==n)throw new Error(`Duplicate module registered for ${t} - ${St(e)} vs ${St(e.name)}`)}(r,Ql.get(r),n),Ql.set(r,n));const i=Fr(s.imports);for(const a of i)e.has(a)||(e.add(a),t(a))}(t)}(t)}create(t){return new Jl(this.moduleType,t)}}function eu(t,e){const n=en();let s;const r=t+xe;n.firstCreatePass?(s=function(t,e){if(e)for(let n=e.length-1;n>=0;n--){const s=e[n];if(t===s.name)return s}throw new $t("302",`The pipe '${t}' could not be found!`)}(e,n.pipeRegistry),n.data[r]=s,s.onDestroy&&(n.destroyHooks||(n.destroyHooks=[])).push(r,s.onDestroy)):s=n.data[r];const i=s.factory||(s.factory=Ae(s.type)),a=Gt(Xa);try{const t=Gn(!1),e=i();return Gn(t),function(t,e,n,s){n>=t.data.length&&(t.data[n]=null,t.blueprint[n]=null),e[n]=s}(n,tn(),r,e),e}finally{Gt(a)}}function nu(t,e,n){const s=t+xe,r=tn(),i=function(t,e){return t[e]}(r,s);return function(t,e){return Wa.isWrapped(e)&&(e=Wa.unwrap(e),t[Qe.lFrame.bindingIndex]=_i),e}(r,function(t,e){return t[1].data[e].pure}(r,s)?function(t,e,n,s,r,i){const a=e+n;return Ha(t,a,r)?function(t,e,n){return t[e]=n}(t,a+1,i?s.call(i,r):s(r)):function(t,e){const n=t[e];return n===_i?void 0:n}(t,a+1)}(r,function(){const t=Qe.lFrame;let e=t.bindingRootIndex;return-1===e&&(e=t.bindingRootIndex=t.tView.bindingStartIndex),e}(),e,i.transform,n,i):i.transform(n))}function su(t){return e=>{setTimeout(t,void 0,e)}}const ru=class extends G{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,n){var s,r,i;let a=t,o=e||(()=>null),l=n;if(t&&"object"==typeof t){const e=t;a=null===(s=e.next)||void 0===s?void 0:s.bind(e),o=null===(r=e.error)||void 0===r?void 0:r.bind(e),l=null===(i=e.complete)||void 0===i?void 0:i.bind(e)}this.__isAsync&&(o=su(o),a&&(a=su(a)),l&&(l=su(l)));const u=super.subscribe({next:a,error:o,complete:l});return t instanceof F&&t.add(u),u}};function iu(){return this._results[Ba()]()}class au{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Ba(),n=au.prototype;n[e]||(n[e]=iu)}get changes(){return this._changes||(this._changes=new ru)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const n=this;n.dirty=!1;const s=bs(t);(this._changesDetected=!function(t,e,n){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++){let r=t[s],i=e[s];if(n&&(r=n(r),i=n(i)),i!==r)return!1}return!0}(n._results,s,e))&&(n._results=s,n.length=s.length,n.last=s[this.length-1],n.first=s[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class ou{constructor(t){this.queryList=t,this.matches=null}clone(){return new ou(this.queryList)}setDirty(){this.queryList.setDirty()}}class lu{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const n=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let t=0;t<n;t++){const n=e.getByIndex(t);s.push(this.queries[n.indexInDeclarationView].clone())}return new lu(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==xu(t,e).matches&&this.queries[e].setDirty()}}class uu{constructor(t,e,n=null){this.predicate=t,this.flags=e,this.read=n}}class cu{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){const s=null!==e?e.length:0,r=this.getByIndex(n).embeddedTView(t,s);r&&(r.indexInDeclarationView=n,null!==e?e.push(r):e=[r])}return null!==e?new cu(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class hu{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new hu(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let n=t.parent;for(;null!==n&&8&n.type&&n.index!==e;)n=n.parent;return e===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const n=this.metadata.predicate;if(Array.isArray(n))for(let s=0;s<n.length;s++){const r=n[s];this.matchTNodeWithReadOption(t,e,du(e,r)),this.matchTNodeWithReadOption(t,e,is(e,t,r,!1,!1))}else n===Ol?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,is(e,t,n,!1,!1))}matchTNodeWithReadOption(t,e,n){if(null!==n){const s=this.metadata.read;if(null!==s)if(s===nl||s===Vl||s===Ol&&4&e.type)this.addMatch(e.index,-2);else{const n=is(e,t,s,!1,!1);null!==n&&this.addMatch(e.index,n)}else this.addMatch(e.index,n)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function du(t,e){const n=t.localNames;if(null!==n)for(let s=0;s<n.length;s+=2)if(n[s]===e)return n[s+1];return null}function pu(t,e,n,s){return-1===n?function(t,e){return 11&t.type?tl(t,e):4&t.type?Ll(t,e):null}(e,t):-2===n?function(t,e,n){return n===nl?tl(e,t):n===Ol?Ll(e,t):n===Vl?Hl(e,t):void 0}(t,e,s):as(t,t[1],n,e)}function fu(t,e,n,s){const r=e[19].queries[s];if(null===r.matches){const s=t.data,i=n.matches,a=[];for(let t=0;t<i.length;t+=2){const r=i[t];a.push(r<0?null:pu(e,s[r],i[t+1],n.metadata.read))}r.matches=a}return r.matches}function mu(t,e,n,s){const r=t.queries.getByIndex(n),i=r.matches;if(null!==i){const a=fu(t,e,r,n);for(let t=0;t<i.length;t+=2){const n=i[t];if(n>0)s.push(a[t/2]);else{const r=i[t+1],a=e[-n];for(let t=ke;t<a.length;t++){const e=a[t];e[17]===e[3]&&mu(e[1],e,r,s)}if(null!==a[9]){const t=a[9];for(let e=0;e<t.length;e++){const n=t[e];mu(n[1],n,r,s)}}}}}return s}function gu(t){const e=tn(),n=en(),s=mn();gn(s+1);const r=xu(n,s);if(t.dirty&&qe(e)===(2==(2&r.metadata.flags))){if(null===r.matches)t.reset([]);else{const i=r.crossesNgTemplate?mu(n,e,s,[]):fu(n,e,r,s);t.reset(i,sl),t.notifyOnChanges()}return!0}return!1}function yu(t,e,n){const s=en();s.firstCreatePass&&(_u(s,new uu(t,e,n),-1),2==(2&e)&&(s.staticViewQueries=!0)),wu(s,tn(),e)}function bu(t,e,n,s){const r=en();if(r.firstCreatePass){const i=sn();_u(r,new uu(e,n,s),i.index),function(t,e){const n=t.contentQueries||(t.contentQueries=[]);e!==(n.length?n[n.length-1]:-1)&&n.push(t.queries.length-1,e)}(r,t),2==(2&n)&&(r.staticContentQueries=!0)}wu(r,tn(),n)}function vu(){return t=tn(),e=mn(),t[19].queries[e].queryList;var t,e}function wu(t,e,n){const s=new au(4==(4&n));Ui(t,e,s,s.destroy),null===e[19]&&(e[19]=new lu),e[19].queries.push(new ou(s))}function _u(t,e,n){null===t.queries&&(t.queries=new cu),t.queries.track(new hu(e,n))}function xu(t,e){return t.queries.getByIndex(e)}const ku=new ms("Application Initializer");let Cu=(()=>{class t{constructor(t){this.appInits=t,this.resolve=Jo,this.reject=Jo,this.initialized=!1,this.done=!1,this.donePromise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}runInitializers(){if(this.initialized)return;const t=[],e=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const e=this.appInits[n]();if(ro(e))t.push(e);else if(ao(e)){const n=new Promise((t,n)=>{e.subscribe({complete:t,error:n})});t.push(n)}}Promise.all(t).then(()=>{e()}).catch(t=>{this.reject(t)}),0===t.length&&e(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(Os(ku,8))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const Su=new ms("AppId"),Iu={provide:Su,useFactory:function(){return`${Eu()}${Eu()}${Eu()}`},deps:[]};function Eu(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const Nu=new ms("Platform Initializer"),Tu=new ms("Platform ID"),Au=new ms("appBootstrapListener");let $u=(()=>{class t{log(t){console.log(t)}warn(t){console.warn(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const Ru=new ms("LocaleId"),Ou=new ms("DefaultCurrencyCode");class Fu{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const Du=function(t){return new tu(t)},Lu=Du,Mu=function(t){return Promise.resolve(Du(t))},Pu=function(t){const e=Du(t),n=Fr(_e(t).declarations).reduce((t,e)=>{const n=we(e);return n&&t.push(new Zl(n)),t},[]);return new Fu(e,n)},zu=Pu,Vu=function(t){return Promise.resolve(Pu(t))};let Bu=(()=>{class t{constructor(){this.compileModuleSync=Lu,this.compileModuleAsync=Mu,this.compileModuleAndAllComponentsSync=zu,this.compileModuleAndAllComponentsAsync=Vu}clearCache(){}clearCacheFor(t){}getModuleId(t){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const Wu=(()=>Promise.resolve(0))();function Uu(t){"undefined"==typeof Zone?Wu.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class ju{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new ru(!1),this.onMicrotaskEmpty=new ru(!1),this.onStable=new ru(!1),this.onError=new ru(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!n&&e,s.shouldCoalesceRunChangeDetection=n,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function(){let t=ee.requestAnimationFrame,e=ee.cancelAnimationFrame;if("undefined"!=typeof Zone&&t&&e){const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n);const s=e[Zone.__symbol__("OriginalDelegate")];s&&(e=s)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function(t){const e=()=>{!function(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(ee,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,qu(t),t.isCheckStableRunning=!0,Gu(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),qu(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,s,r,i,a,o)=>{try{return Ku(t),n.invokeTask(r,i,a,o)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||t.shouldCoalesceRunChangeDetection)&&e(),Xu(t)}},onInvoke:(n,s,r,i,a,o,l)=>{try{return Ku(t),n.invoke(r,i,a,o,l)}finally{t.shouldCoalesceRunChangeDetection&&e(),Xu(t)}},onHasTask:(e,n,s,r)=>{e.hasTask(s,r),n===s&&("microTask"==r.change?(t._hasPendingMicrotasks=r.microTask,qu(t),Gu(t)):"macroTask"==r.change&&(t.hasPendingMacrotasks=r.macroTask))},onHandleError:(e,n,s,r)=>(e.handleError(s,r),t.runOutsideAngular(()=>t.onError.emit(r)),!1)})}(s)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!ju.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(ju.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,s){const r=this._inner,i=r.scheduleEventTask("NgZoneEvent: "+s,t,Hu,Jo,Jo);try{return r.runTask(i,e,n)}finally{r.cancelTask(i)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}}const Hu={};function Gu(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function qu(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function Ku(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function Xu(t){t._nesting--,Gu(t)}class Zu{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new ru,this.onMicrotaskEmpty=new ru,this.onStable=new ru,this.onError=new ru}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,s){return t.apply(e,n)}}let Yu=(()=>{class t{constructor(t){this._ngZone=t,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),t.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{ju.assertNotInAngularZone(),Uu(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Uu(()=>{for(;0!==this._callbacks.length;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb(this._didWork)}this._didWork=!1});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(e=>!e.updateCb||!e.updateCb(t)||(clearTimeout(e.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,e,n){let s=-1;e&&e>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(t=>t.timeoutId!==s),t(this._didWork,this.getPendingTasks())},e)),this._callbacks.push({doneCb:t,timeoutId:s,updateCb:n})}whenStable(t,e,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(t,e,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(t,e,n){return[]}}return t.\u0275fac=function(e){return new(e||t)(Os(ju))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),Qu=(()=>{class t{constructor(){this._applications=new Map,ec.addToWindow(this)}registerApplication(t,e){this._applications.set(t,e)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,e=!0){return ec.findTestabilityInTree(this,t,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();class Ju{addToWindow(t){}findTestabilityInTree(t,e,n){return null}}let tc,ec=new Ju,nc=!0,sc=!1;function rc(){return sc=!0,nc}const ic=new ms("AllowMultipleToken");class ac{constructor(t,e){this.name=t,this.token=e}}function oc(t,e,n=[]){const s=`Platform: ${e}`,r=new ms(s);return(e=[])=>{let i=lc();if(!i||i.injector.get(ic,!1))if(t)t(n.concat(e).concat({provide:r,useValue:!0}));else{const t=n.concat(e).concat({provide:r,useValue:!0},{provide:wa,useValue:"platform"});!function(t){if(tc&&!tc.destroyed&&!tc.injector.get(ic,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");tc=t.get(uc);const e=t.get(Nu,null);e&&e.forEach(t=>t())}(Oa.create({providers:t,name:s}))}return function(t){const e=lc();if(!e)throw new Error("No platform exists!");if(!e.injector.get(t,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return e}(r)}}function lc(){return tc&&!tc.destroyed?tc:null}let uc=(()=>{class t{constructor(t){this._injector=t,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(t,e){const n=function(t,e){let n;return n="noop"===t?new Zu:("zone.js"===t?void 0:t)||new ju({enableLongStackTrace:rc(),shouldCoalesceEventChangeDetection:!!(null==e?void 0:e.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==e?void 0:e.ngZoneRunCoalescing)}),n}(e?e.ngZone:void 0,{ngZoneEventCoalescing:e&&e.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:e&&e.ngZoneRunCoalescing||!1}),s=[{provide:ju,useValue:n}];return n.run(()=>{const e=Oa.create({providers:s,parent:this.injector,name:t.moduleType.name}),r=t.create(e),i=r.injector.get($r,null);if(!i)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const t=n.onError.subscribe({next:t=>{i.handleError(t)}});r.onDestroy(()=>{dc(this._modules,r),t.unsubscribe()})}),function(t,e,n){try{const s=n();return ro(s)?s.catch(n=>{throw e.runOutsideAngular(()=>t.handleError(n)),n}):s}catch(s){throw e.runOutsideAngular(()=>t.handleError(s)),s}}(i,n,()=>{const t=r.injector.get(Cu);return t.runInitializers(),t.donePromise.then(()=>(Bo(r.injector.get(Ru,zo)||zo),this._moduleDoBootstrap(r),r))})})}bootstrapModule(t,e=[]){const n=cc({},e);return function(t,e,n){const s=new tu(n);return Promise.resolve(s)}(0,0,t).then(t=>this.bootstrapModuleFactory(t,n))}_moduleDoBootstrap(t){const e=t.injector.get(hc);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(t=>e.bootstrap(t));else{if(!t.instance.ngDoBootstrap)throw new Error(`The module ${St(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);t.instance.ngDoBootstrap(e)}this._modules.push(t)}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(t=>t.destroy()),this._destroyListeners.forEach(t=>t()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(Os(Oa))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();function cc(t,e){return Array.isArray(e)?e.reduce(cc,t):Object.assign(Object.assign({},t),e)}let hc=(()=>{class t{constructor(t,e,n,s,r){this._zone=t,this._injector=e,this._exceptionHandler=n,this._componentFactoryResolver=s,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new B(t=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{t.next(this._stable),t.complete()})}),a=new B(t=>{let e;this._zone.runOutsideAngular(()=>{e=this._zone.onStable.subscribe(()=>{ju.assertNotInAngularZone(),Uu(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,t.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{ju.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{t.next(!1)}))});return()=>{e.unsubscribe(),n.unsubscribe()}});this.isStable=ft(i,a.pipe(xt()))}bootstrap(t,e){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=t instanceof Zo?t:this._componentFactoryResolver.resolveComponentFactory(t),this.componentTypes.push(n.componentType);const s=n.isBoundToModule?void 0:this._injector.get(Ml),r=n.create(Oa.NULL,[],e||n.selector,s),i=r.location.nativeElement,a=r.injector.get(Yu,null),o=a&&r.injector.get(Qu);return a&&o&&o.registerApplication(i,a),r.onDestroy(()=>{this.detachView(r.hostView),dc(this.components,r),o&&o.unregisterApplication(i)}),this._loadComponent(r),r}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let t of this._views)t.detectChanges()}catch(t){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(t))}finally{this._runningTick=!1}}attachView(t){const e=t;this._views.push(e),e.attachToAppRef(this)}detachView(t){const e=t;dc(this._views,e),e.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(Au,[]).concat(this._bootstrapListeners).forEach(e=>e(t))}ngOnDestroy(){this._views.slice().forEach(t=>t.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return t.\u0275fac=function(e){return new(e||t)(Os(ju),Os(Oa),Os($r),Os(Qo),Os(Cu))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();function dc(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class pc{}class fc{}const mc={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let gc=(()=>{class t{constructor(t,e){this._compiler=t,this._config=e||mc}load(t){return this.loadAndCompile(t)}loadAndCompile(t){let[e,s]=t.split("#");return void 0===s&&(s="default"),n(255)(e).then(t=>t[s]).then(t=>yc(t,e,s)).then(t=>this._compiler.compileModuleAsync(t))}loadFactory(t){let[e,s]=t.split("#"),r="NgFactory";return void 0===s&&(s="default",r=""),n(255)(this._config.factoryPathPrefix+e+this._config.factoryPathSuffix).then(t=>t[s+r]).then(t=>yc(t,e,s))}}return t.\u0275fac=function(e){return new(e||t)(Os(Bu),Os(fc,8))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();function yc(t,e,n){if(!t)throw new Error(`Cannot find '${n}' in '${e}'`);return t}const bc=oc(null,"core",[{provide:Tu,useValue:"unknown"},{provide:uc,deps:[Oa]},{provide:Qu,deps:[]},{provide:$u,deps:[]}]),vc=[{provide:hc,useClass:hc,deps:[ju,Oa,$r,Qo,Cu]},{provide:Xl,deps:[ju],useFactory:function(t){let e=[];return t.onStable.subscribe(()=>{for(;e.length;)e.pop()()}),function(t){e.push(t)}}},{provide:Cu,useClass:Cu,deps:[[new Ps,ku]]},{provide:Bu,useClass:Bu,deps:[]},Iu,{provide:_l,useFactory:function(){return Al},deps:[]},{provide:kl,useFactory:function(){return $l},deps:[]},{provide:Ru,useFactory:function(t){return Bo(t=t||"undefined"!=typeof $localize&&$localize.locale||zo),t},deps:[[new Ms(Ru),new Ps,new zs]]},{provide:Ou,useValue:"USD"}];let wc=(()=>{class t{constructor(t){}}return t.\u0275fac=function(e){return new(e||t)(Os(hc))},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:vc}),t})(),_c=null;function xc(){return _c}const kc=new ms("DocumentToken");let Cc=(()=>{class t{historyGo(t){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:Sc,token:t,providedIn:"platform"}),t})();function Sc(){return Os(Ec)}const Ic=new ms("Location Initialized");let Ec=(()=>{class t extends Cc{constructor(t){super(),this._doc=t,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return xc().getBaseHref(this._doc)}onPopState(t){const e=xc().getGlobalEventTarget(this._doc,"window");return e.addEventListener("popstate",t,!1),()=>e.removeEventListener("popstate",t)}onHashChange(t){const e=xc().getGlobalEventTarget(this._doc,"window");return e.addEventListener("hashchange",t,!1),()=>e.removeEventListener("hashchange",t)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(t){this.location.pathname=t}pushState(t,e,n){Nc()?this._history.pushState(t,e,n):this.location.hash=n}replaceState(t,e,n){Nc()?this._history.replaceState(t,e,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}historyGo(t=0){this._history.go(t)}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(Os(kc))},t.\u0275prov=Dt({factory:Tc,token:t,providedIn:"platform"}),t})();function Nc(){return!!window.history.pushState}function Tc(){return new Ec(Os(kc))}function Ac(t,e){if(0==t.length)return e;if(0==e.length)return t;let n=0;return t.endsWith("/")&&n++,e.startsWith("/")&&n++,2==n?t+e.substring(1):1==n?t+e:t+"/"+e}function $c(t){const e=t.match(/#|\?|$/),n=e&&e.index||t.length;return t.slice(0,n-("/"===t[n-1]?1:0))+t.slice(n)}function Rc(t){return t&&"?"!==t[0]?"?"+t:t}let Oc=(()=>{class t{historyGo(t){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:Fc,token:t,providedIn:"root"}),t})();function Fc(t){const e=Os(kc).location;return new Lc(Os(Cc),e&&e.origin||"")}const Dc=new ms("appBaseHref");let Lc=(()=>{class t extends Oc{constructor(t,e){if(super(),this._platformLocation=t,this._removeListenerFns=[],null==e&&(e=this._platformLocation.getBaseHrefFromDOM()),null==e)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=e}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(t){this._removeListenerFns.push(this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t))}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return Ac(this._baseHref,t)}path(t=!1){const e=this._platformLocation.pathname+Rc(this._platformLocation.search),n=this._platformLocation.hash;return n&&t?`${e}${n}`:e}pushState(t,e,n,s){const r=this.prepareExternalUrl(n+Rc(s));this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,s){const r=this.prepareExternalUrl(n+Rc(s));this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(t=0){var e,n;null===(n=(e=this._platformLocation).historyGo)||void 0===n||n.call(e,t)}}return t.\u0275fac=function(e){return new(e||t)(Os(Cc),Os(Dc,8))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),Mc=(()=>{class t extends Oc{constructor(t,e){super(),this._platformLocation=t,this._baseHref="",this._removeListenerFns=[],null!=e&&(this._baseHref=e)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(t){this._removeListenerFns.push(this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t))}getBaseHref(){return this._baseHref}path(t=!1){let e=this._platformLocation.hash;return null==e&&(e="#"),e.length>0?e.substring(1):e}prepareExternalUrl(t){const e=Ac(this._baseHref,t);return e.length>0?"#"+e:e}pushState(t,e,n,s){let r=this.prepareExternalUrl(n+Rc(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,s){let r=this.prepareExternalUrl(n+Rc(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(t=0){var e,n;null===(n=(e=this._platformLocation).historyGo)||void 0===n||n.call(e,t)}}return t.\u0275fac=function(e){return new(e||t)(Os(Cc),Os(Dc,8))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),Pc=(()=>{class t{constructor(t,e){this._subject=new ru,this._urlChangeListeners=[],this._platformStrategy=t;const n=this._platformStrategy.getBaseHref();this._platformLocation=e,this._baseHref=$c(Vc(n)),this._platformStrategy.onPopState(t=>{this._subject.emit({url:this.path(!0),pop:!0,state:t.state,type:t.type})})}path(t=!1){return this.normalize(this._platformStrategy.path(t))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(t,e=""){return this.path()==this.normalize(t+Rc(e))}normalize(e){return t.stripTrailingSlash(function(t,e){return t&&e.startsWith(t)?e.substring(t.length):e}(this._baseHref,Vc(e)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._platformStrategy.prepareExternalUrl(t)}go(t,e="",n=null){this._platformStrategy.pushState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+Rc(e)),n)}replaceState(t,e="",n=null){this._platformStrategy.replaceState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+Rc(e)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(t=0){var e,n;null===(n=(e=this._platformStrategy).historyGo)||void 0===n||n.call(e,t)}onUrlChange(t){this._urlChangeListeners.push(t),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(t=>{this._notifyUrlChangeListeners(t.url,t.state)}))}_notifyUrlChangeListeners(t="",e){this._urlChangeListeners.forEach(n=>n(t,e))}subscribe(t,e,n){return this._subject.subscribe({next:t,error:e,complete:n})}}return t.\u0275fac=function(e){return new(e||t)(Os(Oc),Os(Cc))},t.normalizeQueryParams=Rc,t.joinWithSlash=Ac,t.stripTrailingSlash=$c,t.\u0275prov=Dt({factory:zc,token:t,providedIn:"root"}),t})();function zc(){return new Pc(Os(Oc),Os(Cc))}function Vc(t){return t.replace(/\/index.html$/,"")}var Bc=function(t){return t[t.Decimal=0]="Decimal",t[t.Percent=1]="Percent",t[t.Currency=2]="Currency",t[t.Scientific=3]="Scientific",t}({}),Wc=function(t){return t[t.Zero=0]="Zero",t[t.One=1]="One",t[t.Two=2]="Two",t[t.Few=3]="Few",t[t.Many=4]="Many",t[t.Other=5]="Other",t}({}),Uc=function(t){return t[t.Decimal=0]="Decimal",t[t.Group=1]="Group",t[t.List=2]="List",t[t.PercentSign=3]="PercentSign",t[t.PlusSign=4]="PlusSign",t[t.MinusSign=5]="MinusSign",t[t.Exponential=6]="Exponential",t[t.SuperscriptingExponent=7]="SuperscriptingExponent",t[t.PerMille=8]="PerMille",t[t[1/0]=9]="Infinity",t[t.NaN=10]="NaN",t[t.TimeSeparator=11]="TimeSeparator",t[t.CurrencyDecimal=12]="CurrencyDecimal",t[t.CurrencyGroup=13]="CurrencyGroup",t}({});function jc(t,e){const n=Lo(t),s=n[Po.NumberSymbols][e];if(void 0===s){if(e===Uc.CurrencyDecimal)return n[Po.NumberSymbols][Uc.Decimal];if(e===Uc.CurrencyGroup)return n[Po.NumberSymbols][Uc.Group]}return s}const Hc=/^(\d+)?\.((\d+)(-(\d+))?)?$/,Gc=".",qc="0";function Kc(t){const e=parseInt(t);if(isNaN(e))throw new Error("Invalid integer literal when parsing "+t);return e}class Xc{}let Zc=(()=>{class t extends Xc{constructor(t){super(),this.locale=t}getPluralCategory(t,e){switch(function(t){return Lo(t)[Po.PluralCase]}(e||this.locale)(t)){case Wc.Zero:return"zero";case Wc.One:return"one";case Wc.Two:return"two";case Wc.Few:return"few";case Wc.Many:return"many";default:return"other"}}}return t.\u0275fac=function(e){return new(e||t)(Os(Ru))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();function Yc(t,e){e=encodeURIComponent(e);for(const n of t.split(";")){const t=n.indexOf("="),[s,r]=-1==t?[n,""]:[n.slice(0,t),n.slice(t+1)];if(s.trim()===e)return decodeURIComponent(r)}return null}let Qc=(()=>{class t{constructor(t,e,n,s){this._iterableDiffers=t,this._keyValueDiffers=e,this._ngEl=n,this._renderer=s,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(t){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof t?t.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(t){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof t?t.split(/\s+/):t,this._rawClass&&(Ua(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const t=this._iterableDiffer.diff(this._rawClass);t&&this._applyIterableChanges(t)}else if(this._keyValueDiffer){const t=this._keyValueDiffer.diff(this._rawClass);t&&this._applyKeyValueChanges(t)}}_applyKeyValueChanges(t){t.forEachAddedItem(t=>this._toggleClass(t.key,t.currentValue)),t.forEachChangedItem(t=>this._toggleClass(t.key,t.currentValue)),t.forEachRemovedItem(t=>{t.previousValue&&this._toggleClass(t.key,!1)})}_applyIterableChanges(t){t.forEachAddedItem(t=>{if("string"!=typeof t.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${St(t.item)}`);this._toggleClass(t.item,!0)}),t.forEachRemovedItem(t=>this._toggleClass(t.item,!1))}_applyClasses(t){t&&(Array.isArray(t)||t instanceof Set?t.forEach(t=>this._toggleClass(t,!0)):Object.keys(t).forEach(e=>this._toggleClass(e,!!t[e])))}_removeClasses(t){t&&(Array.isArray(t)||t instanceof Set?t.forEach(t=>this._toggleClass(t,!1)):Object.keys(t).forEach(t=>this._toggleClass(t,!1)))}_toggleClass(t,e){(t=t.trim())&&t.split(/\s+/g).forEach(t=>{e?this._renderer.addClass(this._ngEl.nativeElement,t):this._renderer.removeClass(this._ngEl.nativeElement,t)})}}return t.\u0275fac=function(e){return new(e||t)(Xa(_l),Xa(kl),Xa(nl),Xa(il))},t.\u0275dir=be({type:t,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),t})();class Jc{constructor(t,e,n,s){this.$implicit=t,this.ngForOf=e,this.index=n,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let th=(()=>{class t{constructor(t,e,n){this._viewContainer=t,this._template=e,this._differs=n,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(t){this._ngForOf=t,this._ngForOfDirty=!0}set ngForTrackBy(t){this._trackByFn=t}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(t){t&&(this._template=t)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;if(!this._differ&&n)try{this._differ=this._differs.find(n).create(this.ngForTrackBy)}catch(e){throw new Error(`Cannot find a differ supporting object '${n}' of type '${t=n,t.name||typeof t}'. NgFor only supports binding to Iterables such as Arrays.`)}}var t;if(this._differ){const t=this._differ.diff(this._ngForOf);t&&this._applyChanges(t)}}_applyChanges(t){const e=[];t.forEachOperation((t,n,s)=>{if(null==t.previousIndex){const n=this._viewContainer.createEmbeddedView(this._template,new Jc(null,this._ngForOf,-1,-1),null===s?void 0:s),r=new eh(t,n);e.push(r)}else if(null==s)this._viewContainer.remove(null===n?void 0:n);else if(null!==n){const r=this._viewContainer.get(n);this._viewContainer.move(r,s);const i=new eh(t,r);e.push(i)}});for(let n=0;n<e.length;n++)this._perViewChange(e[n].view,e[n].record);for(let n=0,s=this._viewContainer.length;n<s;n++){const t=this._viewContainer.get(n);t.context.index=n,t.context.count=s,t.context.ngForOf=this._ngForOf}t.forEachIdentityChange(t=>{this._viewContainer.get(t.currentIndex).context.$implicit=t.item})}_perViewChange(t,e){t.context.$implicit=e.item}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(Xa(Vl),Xa(Ol),Xa(_l))},t.\u0275dir=be({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),t})();class eh{constructor(t,e){this.record=t,this.view=e}}let nh=(()=>{class t{constructor(t,e){this._viewContainer=t,this._context=new sh,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=e}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){rh("ngIfThen",t),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){rh("ngIfElse",t),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(Xa(Vl),Xa(Ol))},t.\u0275dir=be({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),t})();class sh{constructor(){this.$implicit=null,this.ngIf=null}}function rh(t,e){if(e&&!e.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${St(e)}'.`)}class ih{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let ah=(()=>{class t{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(t){this._ngSwitch=t,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(t){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(t)}_matchCase(t){const e=t==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||e,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),e}_updateDefaultCases(t){if(this._defaultViews&&t!==this._defaultUsed){this._defaultUsed=t;for(let e=0;e<this._defaultViews.length;e++)this._defaultViews[e].enforceState(t)}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=be({type:t,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"}}),t})(),oh=(()=>{class t{constructor(t,e,n){this.ngSwitch=n,n._addCase(),this._view=new ih(t,e)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return t.\u0275fac=function(e){return new(e||t)(Xa(Vl),Xa(Ol),Xa(ah,9))},t.\u0275dir=be({type:t,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"}}),t})(),lh=(()=>{class t{constructor(t,e,n){this._ngEl=t,this._differs=e,this._renderer=n,this._ngStyle=null,this._differ=null}set ngStyle(t){this._ngStyle=t,!this._differ&&t&&(this._differ=this._differs.find(t).create())}ngDoCheck(){if(this._differ){const t=this._differ.diff(this._ngStyle);t&&this._applyChanges(t)}}_setStyle(t,e){const[n,s]=t.split(".");null!=(e=null!=e&&s?`${e}${s}`:e)?this._renderer.setStyle(this._ngEl.nativeElement,n,e):this._renderer.removeStyle(this._ngEl.nativeElement,n)}_applyChanges(t){t.forEachRemovedItem(t=>this._setStyle(t.key,null)),t.forEachAddedItem(t=>this._setStyle(t.key,t.currentValue)),t.forEachChangedItem(t=>this._setStyle(t.key,t.currentValue))}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(kl),Xa(il))},t.\u0275dir=be({type:t,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"}}),t})();function uh(t,e){return Error(`InvalidPipeArgument: '${e}' for pipe '${St(t)}'`)}class ch{createSubscription(t,e){return t.subscribe({next:e,error:t=>{throw t}})}dispose(t){t.unsubscribe()}onDestroy(t){t.unsubscribe()}}class hh{createSubscription(t,e){return t.then(e,t=>{throw t})}dispose(t){}onDestroy(t){}}const dh=new hh,ph=new ch;let fh=(()=>{class t{constructor(t){this._ref=t,this._latestValue=null,this._subscription=null,this._obj=null,this._strategy=null}ngOnDestroy(){this._subscription&&this._dispose()}transform(t){return this._obj?t!==this._obj?(this._dispose(),this.transform(t)):this._latestValue:(t&&this._subscribe(t),this._latestValue)}_subscribe(t){this._obj=t,this._strategy=this._selectStrategy(t),this._subscription=this._strategy.createSubscription(t,e=>this._updateLatestValue(t,e))}_selectStrategy(e){if(ro(e))return dh;if(io(e))return ph;throw uh(t,e)}_dispose(){this._strategy.dispose(this._subscription),this._latestValue=null,this._subscription=null,this._obj=null}_updateLatestValue(t,e){t===this._obj&&(this._latestValue=e,this._ref.markForCheck())}}return t.\u0275fac=function(e){return new(e||t)(Xa(Nl,16))},t.\u0275pipe=ve({name:"async",type:t,pure:!1}),t})(),mh=(()=>{class t{constructor(t){this._locale=t}transform(e,n,s){if(!function(t){return!(null==t||""===t||t!=t)}(e))return null;s=s||this._locale;try{return function(t,e,n){return function(t,e,n,s,r,i,a=!1){let o="",l=!1;if(isFinite(t)){let u=function(t){let e,n,s,r,i,a=Math.abs(t)+"",o=0;for((n=a.indexOf(Gc))>-1&&(a=a.replace(Gc,"")),(s=a.search(/e/i))>0?(n<0&&(n=s),n+=+a.slice(s+1),a=a.substring(0,s)):n<0&&(n=a.length),s=0;a.charAt(s)===qc;s++);if(s===(i=a.length))e=[0],n=1;else{for(i--;a.charAt(i)===qc;)i--;for(n-=s,e=[],r=0;s<=i;s++,r++)e[r]=Number(a.charAt(s))}return n>22&&(e=e.splice(0,21),o=n-1,n=1),{digits:e,exponent:o,integerLen:n}}(t);a&&(u=function(t){if(0===t.digits[0])return t;const e=t.digits.length-t.integerLen;return t.exponent?t.exponent+=2:(0===e?t.digits.push(0,0):1===e&&t.digits.push(0),t.integerLen+=2),t}(u));let c=e.minInt,h=e.minFrac,d=e.maxFrac;if(i){const t=i.match(Hc);if(null===t)throw new Error(`${i} is not a valid digit info`);const e=t[1],n=t[3],s=t[5];null!=e&&(c=Kc(e)),null!=n&&(h=Kc(n)),null!=s?d=Kc(s):null!=n&&h>d&&(d=h)}!function(t,e,n){if(e>n)throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${n}).`);let s=t.digits,r=s.length-t.integerLen;const i=Math.min(Math.max(e,r),n);let a=i+t.integerLen,o=s[a];if(a>0){s.splice(Math.max(t.integerLen,a));for(let t=a;t<s.length;t++)s[t]=0}else{r=Math.max(0,r),t.integerLen=1,s.length=Math.max(1,a=i+1),s[0]=0;for(let t=1;t<a;t++)s[t]=0}if(o>=5)if(a-1<0){for(let e=0;e>a;e--)s.unshift(0),t.integerLen++;s.unshift(1),t.integerLen++}else s[a-1]++;for(;r<Math.max(0,i);r++)s.push(0);let l=0!==i;const u=e+t.integerLen,c=s.reduceRight(function(t,e,n,s){return s[n]=(e+=t)<10?e:e-10,l&&(0===s[n]&&n>=u?s.pop():l=!1),e>=10?1:0},0);c&&(s.unshift(c),t.integerLen++)}(u,h,d);let p=u.digits,f=u.integerLen;const m=u.exponent;let g=[];for(l=p.every(t=>!t);f<c;f++)p.unshift(0);for(;f<0;f++)p.unshift(0);f>0?g=p.splice(f,p.length):(g=p,p=[0]);const y=[];for(p.length>=e.lgSize&&y.unshift(p.splice(-e.lgSize,p.length).join(""));p.length>e.gSize;)y.unshift(p.splice(-e.gSize,p.length).join(""));p.length&&y.unshift(p.join("")),o=y.join(jc(n,s)),g.length&&(o+=jc(n,r)+g.join("")),m&&(o+=jc(n,Uc.Exponential)+"+"+m)}else o=jc(n,Uc.Infinity);return o=t<0&&!l?e.negPre+o+e.negSuf:e.posPre+o+e.posSuf,o}(t,function(t,e="-"){const n={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},s=t.split(";"),r=s[0],i=s[1],a=-1!==r.indexOf(Gc)?r.split(Gc):[r.substring(0,r.lastIndexOf(qc)+1),r.substring(r.lastIndexOf(qc)+1)],o=a[0],l=a[1]||"";n.posPre=o.substr(0,o.indexOf("#"));for(let c=0;c<l.length;c++){const t=l.charAt(c);t===qc?n.minFrac=n.maxFrac=c+1:"#"===t?n.maxFrac=c+1:n.posSuf+=t}const u=o.split(",");if(n.gSize=u[1]?u[1].length:0,n.lgSize=u[2]||u[1]?(u[2]||u[1]).length:0,i){const t=r.length-n.posPre.length-n.posSuf.length,e=i.indexOf("#");n.negPre=i.substr(0,e).replace(/'/g,""),n.negSuf=i.substr(e+t).replace(/'/g,"")}else n.negPre=e+n.posPre,n.negSuf=n.posSuf;return n}(function(t,e){return Lo(t)[Po.NumberFormats][e]}(e,Bc.Percent),jc(e,Uc.MinusSign)),e,Uc.Group,Uc.Decimal,n,!0).replace(new RegExp("%","g"),jc(e,Uc.PercentSign))}(function(t){if("string"==typeof t&&!isNaN(Number(t)-parseFloat(t)))return Number(t);if("number"!=typeof t)throw new Error(`${t} is not a number`);return t}(e),s,n)}catch(r){throw uh(t,r.message)}}}return t.\u0275fac=function(e){return new(e||t)(Xa(Ru,16))},t.\u0275pipe=ve({name:"percent",type:t,pure:!0}),t})(),gh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[{provide:Xc,useClass:Zc}]}),t})(),yh=(()=>{class t{}return t.\u0275prov=Dt({token:t,providedIn:"root",factory:()=>new bh(Os(kc),window)}),t})();class bh{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function(t,e){const n=t.getElementById(e)||t.getElementsByName(e)[0];if(n)return n;if("function"==typeof t.createTreeWalker&&t.body&&(t.body.createShadowRoot||t.body.attachShadow)){const n=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let s=n.currentNode;for(;s;){const t=s.shadowRoot;if(t){const n=t.getElementById(e)||t.querySelector(`[name="${e}"]`);if(n)return n}s=n.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),this.attemptFocus(e))}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),n=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,r=this.offset();this.window.scrollTo(n-r[0],s-r[1])}attemptFocus(t){return t.focus(),this.document.activeElement===t}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=vh(this.window.history)||vh(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(t){return!1}}}function vh(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class wh{}class _h extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){var t;t=new _h,_c||(_c=t)}onAndCancel(t,e,n){return t.addEventListener(e,n,!1),()=>{t.removeEventListener(e,n,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=(kh=kh||document.querySelector("base"),kh?kh.getAttribute("href"):null);return null==e?null:function(t){xh=xh||document.createElement("a"),xh.setAttribute("href",t);const e=xh.pathname;return"/"===e.charAt(0)?e:`/${e}`}(e)}resetBaseElement(){kh=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return Yc(document.cookie,t)}}let xh,kh=null;const Ch=new ms("TRANSITION_ID"),Sh=[{provide:ku,useFactory:function(t,e,n){return()=>{n.get(Cu).donePromise.then(()=>{const n=xc();Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e=>e.getAttribute("ng-transition")===t).forEach(t=>n.remove(t))})}},deps:[Ch,kc,Oa],multi:!0}];class Ih{static init(){var t;t=new Ih,ec=t}addToWindow(t){ee.getAngularTestability=(e,n=!0)=>{const s=t.findTestabilityInTree(e,n);if(null==s)throw new Error("Could not find testability for element.");return s},ee.getAllAngularTestabilities=()=>t.getAllTestabilities(),ee.getAllAngularRootElements=()=>t.getAllRootElements(),ee.frameworkStabilizers||(ee.frameworkStabilizers=[]),ee.frameworkStabilizers.push(t=>{const e=ee.getAllAngularTestabilities();let n=e.length,s=!1;const r=function(e){s=s||e,n--,0==n&&t(s)};e.forEach(function(t){t.whenStable(r)})})}findTestabilityInTree(t,e,n){if(null==e)return null;const s=t.getTestability(e);return null!=s?s:n?xc().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}let Eh=(()=>{class t{build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const Nh=new ms("EventManagerPlugins");let Th=(()=>{class t{constructor(t,e){this._zone=e,this._eventNameToPlugin=new Map,t.forEach(t=>t.manager=this),this._plugins=t.slice().reverse()}addEventListener(t,e,n){return this._findPluginFor(e).addEventListener(t,e,n)}addGlobalEventListener(t,e,n){return this._findPluginFor(e).addGlobalEventListener(t,e,n)}getZone(){return this._zone}_findPluginFor(t){const e=this._eventNameToPlugin.get(t);if(e)return e;const n=this._plugins;for(let s=0;s<n.length;s++){const e=n[s];if(e.supports(t))return this._eventNameToPlugin.set(t,e),e}throw new Error(`No event manager plugin found for event ${t}`)}}return t.\u0275fac=function(e){return new(e||t)(Os(Nh),Os(ju))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();class Ah{constructor(t){this._doc=t}addGlobalEventListener(t,e,n){const s=xc().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,n)}}let $h=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(t){const e=new Set;t.forEach(t=>{this._stylesSet.has(t)||(this._stylesSet.add(t),e.add(t))}),this.onStylesAdded(e)}onStylesAdded(t){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),Rh=(()=>{class t extends $h{constructor(t){super(),this._doc=t,this._hostNodes=new Map,this._hostNodes.set(t.head,[])}_addStylesToHost(t,e,n){t.forEach(t=>{const s=this._doc.createElement("style");s.textContent=t,n.push(e.appendChild(s))})}addHost(t){const e=[];this._addStylesToHost(this._stylesSet,t,e),this._hostNodes.set(t,e)}removeHost(t){const e=this._hostNodes.get(t);e&&e.forEach(Oh),this._hostNodes.delete(t)}onStylesAdded(t){this._hostNodes.forEach((e,n)=>{this._addStylesToHost(t,n,e)})}ngOnDestroy(){this._hostNodes.forEach(t=>t.forEach(Oh))}}return t.\u0275fac=function(e){return new(e||t)(Os(kc))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();function Oh(t){xc().remove(t)}const Fh={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},Dh=/%COMP%/g;function Lh(t,e,n){for(let s=0;s<e.length;s++){let r=e[s];Array.isArray(r)?Lh(t,r,n):(r=r.replace(Dh,t),n.push(r))}return n}function Mh(t){return e=>{if("__ngUnwrap__"===e)return t;!1===t(e)&&(e.preventDefault(),e.returnValue=!1)}}let Ph=(()=>{class t{constructor(t,e,n){this.eventManager=t,this.sharedStylesHost=e,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new zh(t)}createRenderer(t,e){if(!t||!e)return this.defaultRenderer;switch(e.encapsulation){case Zt.Emulated:{let n=this.rendererByCompId.get(e.id);return n||(n=new Vh(this.eventManager,this.sharedStylesHost,e,this.appId),this.rendererByCompId.set(e.id,n)),n.applyToHost(t),n}case 1:case Zt.ShadowDom:return new Bh(this.eventManager,this.sharedStylesHost,t,e);default:if(!this.rendererByCompId.has(e.id)){const t=Lh(e.id,e.styles,[]);this.sharedStylesHost.addStyles(t),this.rendererByCompId.set(e.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(Os(Th),Os(Rh),Os(Su))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();class zh{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(Fh[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,n){t&&t.insertBefore(e,n)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let n="string"==typeof t?document.querySelector(t):t;if(!n)throw new Error(`The selector "${t}" did not match any elements`);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,s){if(s){e=s+":"+e;const r=Fh[s];r?t.setAttributeNS(r,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){const s=Fh[n];s?t.removeAttributeNS(s,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,s){s&(Dr.DashCase|Dr.Important)?t.style.setProperty(e,n,s&Dr.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&Dr.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t[e]=n}setValue(t,e){t.nodeValue=e}listen(t,e,n){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,Mh(n)):this.eventManager.addEventListener(t,e,Mh(n))}}class Vh extends zh{constructor(t,e,n,s){super(t),this.component=n;const r=Lh(s+"-"+n.id,n.styles,[]);e.addStyles(r),this.contentAttr="_ngcontent-%COMP%".replace(Dh,s+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(Dh,s+"-"+n.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}}class Bh extends zh{constructor(t,e,n,s){super(t),this.sharedStylesHost=e,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const r=Lh(s.id,s.styles,[]);for(let i=0;i<r.length;i++){const t=document.createElement("style");t.textContent=r[i],this.shadowRoot.appendChild(t)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let Wh=(()=>{class t extends Ah{constructor(t){super(t)}supports(t){return!0}addEventListener(t,e,n){return t.addEventListener(e,n,!1),()=>this.removeEventListener(t,e,n)}removeEventListener(t,e,n){return t.removeEventListener(e,n)}}return t.\u0275fac=function(e){return new(e||t)(Os(kc))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const Uh=["alt","control","meta","shift"],jh={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Hh={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Gh={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let qh=(()=>{class t extends Ah{constructor(t){super(t)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,n,s){const r=t.parseEventName(n),i=t.eventCallback(r.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>xc().onAndCancel(e,r.domEventName,i))}static parseEventName(e){const n=e.toLowerCase().split("."),s=n.shift();if(0===n.length||"keydown"!==s&&"keyup"!==s)return null;const r=t._normalizeKey(n.pop());let i="";if(Uh.forEach(t=>{const e=n.indexOf(t);e>-1&&(n.splice(e,1),i+=t+".")}),i+=r,0!=n.length||0===r.length)return null;const a={};return a.domEventName=s,a.fullKey=i,a}static getEventFullKey(t){let e="",n=function(t){let e=t.key;if(null==e){if(e=t.keyIdentifier,null==e)return"Unidentified";e.startsWith("U+")&&(e=String.fromCharCode(parseInt(e.substring(2),16)),3===t.location&&Hh.hasOwnProperty(e)&&(e=Hh[e]))}return jh[e]||e}(t);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),Uh.forEach(s=>{s!=n&&(0,Gh[s])(t)&&(e+=s+".")}),e+=n,e}static eventCallback(e,n,s){return r=>{t.getEventFullKey(r)===e&&s.runGuarded(()=>n(r))}}static _normalizeKey(t){switch(t){case"esc":return"escape";default:return t}}}return t.\u0275fac=function(e){return new(e||t)(Os(kc))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),Kh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:function(){return Os(Zh)},token:t,providedIn:"root"}),t})();function Xh(t){return new Zh(t.get(kc))}let Zh=(()=>{class t extends Kh{constructor(t){super(),this._doc=t}sanitize(t,e){if(null==e)return null;switch(t){case xr.NONE:return e;case xr.HTML:return Ys(e,"HTML")?Zs(e):wr(this._doc,String(e)).toString();case xr.STYLE:return Ys(e,"Style")?Zs(e):e;case xr.SCRIPT:if(Ys(e,"Script"))return Zs(e);throw new Error("unsafe value used in a script context");case xr.URL:return Qs(e),Ys(e,"URL")?Zs(e):sr(String(e));case xr.RESOURCE_URL:if(Ys(e,"ResourceURL"))return Zs(e);throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");default:throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`)}}bypassSecurityTrustHtml(t){return new Hs(t)}bypassSecurityTrustStyle(t){return new Gs(t)}bypassSecurityTrustScript(t){return new qs(t)}bypassSecurityTrustUrl(t){return new Ks(t)}bypassSecurityTrustResourceUrl(t){return new Xs(t)}}return t.\u0275fac=function(e){return new(e||t)(Os(kc))},t.\u0275prov=Dt({factory:function(){return Xh(Os(ba))},token:t,providedIn:"root"}),t})();const Yh=oc(bc,"browser",[{provide:Tu,useValue:"browser"},{provide:Nu,useValue:function(){_h.makeCurrent(),Ih.init()},multi:!0},{provide:kc,useFactory:function(){return function(t){Pe=t}(document),document},deps:[]}]),Qh=[[],{provide:wa,useValue:"root"},{provide:$r,useFactory:function(){return new $r},deps:[]},{provide:Nh,useClass:Wh,multi:!0,deps:[kc,ju,Tu]},{provide:Nh,useClass:qh,multi:!0,deps:[kc]},[],{provide:Ph,useClass:Ph,deps:[Th,Rh,Su]},{provide:rl,useExisting:Ph},{provide:$h,useExisting:Rh},{provide:Rh,useClass:Rh,deps:[kc]},{provide:Yu,useClass:Yu,deps:[ju]},{provide:Th,useClass:Th,deps:[Nh,ju]},{provide:wh,useClass:Eh,deps:[]},[]];let Jh=(()=>{class t{constructor(t){if(t)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:t,providers:[{provide:Su,useValue:e.appId},{provide:Ch,useExisting:Su},Sh]}}}return t.\u0275fac=function(e){return new(e||t)(Os(t,12))},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:Qh,imports:[gh,wc]}),t})();function td(...t){if(1===t.length){const e=t[0];if($(e))return ed(e,null);if(R(e)&&Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);return ed(t.map(t=>e[t]),t)}}if("function"==typeof t[t.length-1]){const e=t.pop();return ed(t=1===t.length&&$(t[0])?t[0]:t,null).pipe(X(t=>e(...t)))}return ed(t,null)}function ed(t,e){return new B(n=>{const s=t.length;if(0===s)return void n.complete();const r=new Array(s);let i=0,a=0;for(let o=0;o<s;o++){const l=it(t[o]);let u=!1;n.add(l.subscribe({next:t=>{u||(u=!0,a++),r[o]=t},error:t=>n.error(t),complete:()=>{i++,i!==s&&u||(a===s&&n.next(e?e.reduce((t,e,n)=>(t[e]=r[n],t),{}):r),n.complete())}}))}})}"undefined"!=typeof window&&window;let nd=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this.onChange=t=>{},this.onTouched=()=>{}}setProperty(t,e){this._renderer.setProperty(this._elementRef.nativeElement,t,e)}registerOnTouched(t){this.onTouched=t}registerOnChange(t){this.onChange=t}setDisabledState(t){this.setProperty("disabled",t)}}return t.\u0275fac=function(e){return new(e||t)(Xa(il),Xa(nl))},t.\u0275dir=be({type:t}),t})(),sd=(()=>{class t extends nd{}return t.\u0275fac=function(){let e;return function(n){return(e||(e=cs(t)))(n||t)}}(),t.\u0275dir=be({type:t,features:[Da]}),t})();const rd=new ms("NgValueAccessor"),id={provide:rd,useExisting:Nt(()=>od),multi:!0},ad=new ms("CompositionEventMode");let od=(()=>{class t extends nd{constructor(t,e,n){super(t,e),this._compositionMode=n,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function(){const t=xc()?xc().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(t){this.setProperty("value",null==t?"":t)}_handleInput(t){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(t)}_compositionStart(){this._composing=!0}_compositionEnd(t){this._composing=!1,this._compositionMode&&this.onChange(t)}}return t.\u0275fac=function(e){return new(e||t)(Xa(il),Xa(nl),Xa(ad,8))},t.\u0275dir=be({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(t,e){1&t&&oo("input",function(t){return e._handleInput(t.target.value)})("blur",function(){return e.onTouched()})("compositionstart",function(){return e._compositionStart()})("compositionend",function(t){return e._compositionEnd(t.target.value)})},features:[Xo([id]),Da]}),t})();const ld=new ms("NgValidators"),ud=new ms("NgAsyncValidators");function cd(t){return null!=t}function hd(t){const e=ro(t)?it(t):t;return ao(e),e}function dd(t){let e={};return t.forEach(t=>{e=null!=t?Object.assign(Object.assign({},e),t):e}),0===Object.keys(e).length?null:e}function pd(t,e){return e.map(e=>e(t))}function fd(t){return t.map(t=>function(t){return!t.validate}(t)?t:e=>t.validate(e))}function md(t){return null!=t?function(t){if(!t)return null;const e=t.filter(cd);return 0==e.length?null:function(t){return dd(pd(t,e))}}(fd(t)):null}function gd(t){return null!=t?function(t){if(!t)return null;const e=t.filter(cd);return 0==e.length?null:function(t){return td(pd(t,e).map(hd)).pipe(X(dd))}}(fd(t)):null}function yd(t,e){return null===t?[e]:Array.isArray(t)?[...t,e]:[t,e]}function bd(t){return t._rawValidators}function vd(t){return t._rawAsyncValidators}let wd=(()=>{class t{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=md(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=gd(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=be({type:t}),t})(),_d=(()=>{class t extends wd{get formDirective(){return null}get path(){return null}}return t.\u0275fac=function(){let e;return function(n){return(e||(e=cs(t)))(n||t)}}(),t.\u0275dir=be({type:t,features:[Da]}),t})();class xd extends wd{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class kd{constructor(t){this._cd=t}is(t){var e,n;return!!(null===(n=null===(e=this._cd)||void 0===e?void 0:e.control)||void 0===n?void 0:n[t])}}let Cd=(()=>{class t extends kd{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(Xa(xd,2))},t.\u0275dir=be({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(t,e){2&t&&xo("ng-untouched",e.is("untouched"))("ng-touched",e.is("touched"))("ng-pristine",e.is("pristine"))("ng-dirty",e.is("dirty"))("ng-valid",e.is("valid"))("ng-invalid",e.is("invalid"))("ng-pending",e.is("pending"))},features:[Da]}),t})(),Sd=(()=>{class t extends kd{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(Xa(_d,10))},t.\u0275dir=be({type:t,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:14,hostBindings:function(t,e){2&t&&xo("ng-untouched",e.is("untouched"))("ng-touched",e.is("touched"))("ng-pristine",e.is("pristine"))("ng-dirty",e.is("dirty"))("ng-valid",e.is("valid"))("ng-invalid",e.is("invalid"))("ng-pending",e.is("pending"))},features:[Da]}),t})();function Id(t,e){Td(t,e),e.valueAccessor.writeValue(t.value),function(t,e){e.valueAccessor.registerOnChange(n=>{t._pendingValue=n,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&$d(t,e)})}(t,e),function(t,e){const n=(t,n)=>{e.valueAccessor.writeValue(t),n&&e.viewToModelUpdate(t)};t.registerOnChange(n),e._registerOnDestroy(()=>{t._unregisterOnChange(n)})}(t,e),function(t,e){e.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&$d(t,e),"submit"!==t.updateOn&&t.markAsTouched()})}(t,e),function(t,e){if(e.valueAccessor.setDisabledState){const n=t=>{e.valueAccessor.setDisabledState(t)};t.registerOnDisabledChange(n),e._registerOnDestroy(()=>{t._unregisterOnDisabledChange(n)})}}(t,e)}function Ed(t,e,n=!0){const s=()=>{};e.valueAccessor&&(e.valueAccessor.registerOnChange(s),e.valueAccessor.registerOnTouched(s)),Ad(t,e),t&&(e._invokeOnDestroyCallbacks(),t._registerOnCollectionChange(()=>{}))}function Nd(t,e){t.forEach(t=>{t.registerOnValidatorChange&&t.registerOnValidatorChange(e)})}function Td(t,e){const n=bd(t);null!==e.validator?t.setValidators(yd(n,e.validator)):"function"==typeof n&&t.setValidators([n]);const s=vd(t);null!==e.asyncValidator?t.setAsyncValidators(yd(s,e.asyncValidator)):"function"==typeof s&&t.setAsyncValidators([s]);const r=()=>t.updateValueAndValidity();Nd(e._rawValidators,r),Nd(e._rawAsyncValidators,r)}function Ad(t,e){let n=!1;if(null!==t){if(null!==e.validator){const s=bd(t);if(Array.isArray(s)&&s.length>0){const r=s.filter(t=>t!==e.validator);r.length!==s.length&&(n=!0,t.setValidators(r))}}if(null!==e.asyncValidator){const s=vd(t);if(Array.isArray(s)&&s.length>0){const r=s.filter(t=>t!==e.asyncValidator);r.length!==s.length&&(n=!0,t.setAsyncValidators(r))}}}const s=()=>{};return Nd(e._rawValidators,s),Nd(e._rawAsyncValidators,s),n}function $d(t,e){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function Rd(t,e){Td(t,e)}function Od(t,e){t._syncPendingControls(),e.forEach(t=>{const e=t.control;"submit"===e.updateOn&&e._pendingChange&&(t.viewToModelUpdate(e._pendingValue),e._pendingChange=!1)})}function Fd(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}const Dd="VALID",Ld="INVALID",Md="PENDING",Pd="DISABLED";function zd(t){return(Ud(t)?t.validators:t)||null}function Vd(t){return Array.isArray(t)?md(t):t||null}function Bd(t,e){return(Ud(e)?e.asyncValidators:t)||null}function Wd(t){return Array.isArray(t)?gd(t):t||null}function Ud(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}class jd{constructor(t,e){this._hasOwnPendingAsyncValidator=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=t,this._rawAsyncValidators=e,this._composedValidatorFn=Vd(this._rawValidators),this._composedAsyncValidatorFn=Wd(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===Dd}get invalid(){return this.status===Ld}get pending(){return this.status==Md}get disabled(){return this.status===Pd}get enabled(){return this.status!==Pd}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._rawValidators=t,this._composedValidatorFn=Vd(t)}setAsyncValidators(t){this._rawAsyncValidators=t,this._composedAsyncValidatorFn=Wd(t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(t=>{t.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(t=>{t.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=Md,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Pd,this.errors=null,this._forEachChild(e=>{e.disable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Dd,this._forEachChild(e=>{e.enable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),this.status!==Dd&&this.status!==Md||this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Pd:Dd}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=Md,this._hasOwnPendingAsyncValidator=!0;const e=hd(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(e=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(e,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){return function(t,e,n){if(null==e)return null;if(Array.isArray(e)||(e=e.split(".")),Array.isArray(e)&&0===e.length)return null;let s=t;return e.forEach(t=>{s=s instanceof Gd?s.controls.hasOwnProperty(t)?s.controls[t]:null:s instanceof qd&&s.at(t)||null}),s}(this,t)}getError(t,e){const n=e?this.get(e):this;return n&&n.errors?n.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new ru,this.statusChanges=new ru}_calculateStatus(){return this._allControlsDisabled()?Pd:this.errors?Ld:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(Md)?Md:this._anyControlsHaveStatus(Ld)?Ld:Dd}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_isBoxedValue(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){Ud(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}}class Hd extends jd{constructor(t=null,e,n){super(zd(e),Bd(n,e)),this._onChange=[],this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(t=>t(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=null,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){Fd(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){Fd(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){this._isBoxedValue(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}}class Gd extends jd{constructor(t,e,n){super(zd(e),Bd(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e,n={}){this.registerControl(t,e),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}removeControl(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(t,e,n={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){this._checkAllValuesPresent(t),Object.keys(t).forEach(n=>{this._throwIfControlMissing(n),this.controls[n].setValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(n=>{this.controls[n]&&this.controls[n].patchValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((n,s)=>{n.reset(t[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,n)=>(t[n]=e instanceof Hd?e.value:e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(t,e)=>!!e._syncPendingControls()||t);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!Object.keys(this.controls).length)throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.controls[t])throw new Error(`Cannot find form control with name: ${t}.`)}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const n=this.controls[e];n&&t(n,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const e of Object.keys(this.controls)){const n=this.controls[e];if(this.contains(e)&&t(n))return!0}return!1}_reduceValue(){return this._reduceChildren({},(t,e,n)=>((e.enabled||this.disabled)&&(t[n]=e.value),t))}_reduceChildren(t,e){let n=t;return this._forEachChild((t,s)=>{n=e(n,t,s)}),n}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control with name: '${n}'.`)})}}class qd extends jd{constructor(t,e,n){super(zd(e),Bd(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}at(t){return this.controls[t]}push(t,e={}){this.controls.push(t),this._registerControl(t),this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}insert(t,e,n={}){this.controls.splice(t,0,e),this._registerControl(e),this.updateValueAndValidity({emitEvent:n.emitEvent})}removeAt(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),this.updateValueAndValidity({emitEvent:e.emitEvent})}setControl(t,e,n={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),e&&(this.controls.splice(t,0,e),this._registerControl(e)),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(t,e={}){this._checkAllValuesPresent(t),t.forEach((t,n)=>{this._throwIfControlMissing(n),this.at(n).setValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(t.forEach((t,n)=>{this.at(n)&&this.at(n).patchValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t=[],e={}){this._forEachChild((n,s)=>{n.reset(t[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this.controls.map(t=>t instanceof Hd?t.value:t.getRawValue())}clear(t={}){this.controls.length<1||(this._forEachChild(t=>t._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:t.emitEvent}))}_syncPendingControls(){let t=this.controls.reduce((t,e)=>!!e._syncPendingControls()||t,!1);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!this.controls.length)throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.at(t))throw new Error(`Cannot find form control at index ${t}`)}_forEachChild(t){this.controls.forEach((e,n)=>{t(e,n)})}_updateValue(){this.value=this.controls.filter(t=>t.enabled||this.disabled).map(t=>t.value)}_anyControls(t){return this.controls.some(e=>e.enabled&&t(e))}_setUpControls(){this._forEachChild(t=>this._registerControl(t))}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control at index: ${n}.`)})}_allControlsDisabled(){for(const t of this.controls)if(t.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(t){t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)}}const Kd={provide:_d,useExisting:Nt(()=>Zd)},Xd=(()=>Promise.resolve(null))();let Zd=(()=>{class t extends _d{constructor(t,e){super(),this.submitted=!1,this._directives=[],this.ngSubmit=new ru,this.form=new Gd({},md(t),gd(e))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(t){Xd.then(()=>{const e=this._findContainer(t.path);t.control=e.registerControl(t.name,t.control),Id(t.control,t),t.control.updateValueAndValidity({emitEvent:!1}),this._directives.push(t)})}getControl(t){return this.form.get(t.path)}removeControl(t){Xd.then(()=>{const e=this._findContainer(t.path);e&&e.removeControl(t.name),Fd(this._directives,t)})}addFormGroup(t){Xd.then(()=>{const e=this._findContainer(t.path),n=new Gd({});Rd(n,t),e.registerControl(t.name,n),n.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(t){Xd.then(()=>{const e=this._findContainer(t.path);e&&e.removeControl(t.name)})}getFormGroup(t){return this.form.get(t.path)}updateModel(t,e){Xd.then(()=>{this.form.get(t.path).setValue(e)})}setValue(t){this.control.setValue(t)}onSubmit(t){return this.submitted=!0,Od(this.form,this._directives),this.ngSubmit.emit(t),!1}onReset(){this.resetForm()}resetForm(t){this.form.reset(t),this.submitted=!1}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(t){return t.pop(),t.length?this.form.get(t):this.form}}return t.\u0275fac=function(e){return new(e||t)(Xa(ld,10),Xa(ud,10))},t.\u0275dir=be({type:t,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(t,e){1&t&&oo("submit",function(t){return e.onSubmit(t)})("reset",function(){return e.onReset()})},inputs:{options:["ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[Xo([Kd]),Da]}),t})(),Yd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=be({type:t,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),t})(),Qd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})();const Jd=new ms("NgModelWithFormControlWarning"),tp={provide:_d,useExisting:Nt(()=>ep)};let ep=(()=>{class t extends _d{constructor(t,e){super(),this.validators=t,this.asyncValidators=e,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new ru,this._setValidators(t),this._setAsyncValidators(e)}ngOnChanges(t){this._checkFormPresent(),t.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(Ad(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(t){const e=this.form.get(t.path);return Id(e,t),e.updateValueAndValidity({emitEvent:!1}),this.directives.push(t),e}getControl(t){return this.form.get(t.path)}removeControl(t){Ed(t.control||null,t,!1),Fd(this.directives,t)}addFormGroup(t){this._setUpFormContainer(t)}removeFormGroup(t){this._cleanUpFormContainer(t)}getFormGroup(t){return this.form.get(t.path)}addFormArray(t){this._setUpFormContainer(t)}removeFormArray(t){this._cleanUpFormContainer(t)}getFormArray(t){return this.form.get(t.path)}updateModel(t,e){this.form.get(t.path).setValue(e)}onSubmit(t){return this.submitted=!0,Od(this.form,this.directives),this.ngSubmit.emit(t),!1}onReset(){this.resetForm()}resetForm(t){this.form.reset(t),this.submitted=!1}_updateDomValue(){this.directives.forEach(t=>{const e=t.control,n=this.form.get(t.path);e!==n&&(Ed(e||null,t),n instanceof Hd&&(Id(n,t),t.control=n))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(t){const e=this.form.get(t.path);Rd(e,t),e.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(t){if(this.form){const e=this.form.get(t.path);e&&function(t,e){return Ad(t,e)}(e,t)&&e.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){Td(this.form,this),this._oldForm&&Ad(this._oldForm,this)}_checkFormPresent(){}}return t.\u0275fac=function(e){return new(e||t)(Xa(ld,10),Xa(ud,10))},t.\u0275dir=be({type:t,selectors:[["","formGroup",""]],hostBindings:function(t,e){1&t&&oo("submit",function(t){return e.onSubmit(t)})("reset",function(){return e.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[Xo([tp]),Da,Re]}),t})();const np={provide:xd,useExisting:Nt(()=>sp)};let sp=(()=>{class t extends xd{constructor(t,e,n,s,r){super(),this._ngModelWarningConfig=r,this._added=!1,this.update=new ru,this._ngModelWarningSent=!1,this._parent=t,this._setValidators(e),this._setAsyncValidators(n),this.valueAccessor=function(t,e){if(!e)return null;let n,s,r;return Array.isArray(e),e.forEach(t=>{t.constructor===od?n=t:Object.getPrototypeOf(t.constructor)===sd?s=t:r=t}),r||s||n||null}(0,s)}set isDisabled(t){}ngOnChanges(t){this._added||this._setUpControl(),function(t,e){if(!t.hasOwnProperty("model"))return!1;const n=t.model;return!!n.isFirstChange()||!Object.is(e,n.currentValue)}(t,this.viewModel)&&(this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}viewToModelUpdate(t){this.viewModel=t,this.update.emit(t)}get path(){return t=null==this.name?this.name:this.name.toString(),[...this._parent.path,t];var t}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}_setUpControl(){this._checkParentType(),this.control=this.formDirective.addControl(this),this.control.disabled&&this.valueAccessor.setDisabledState&&this.valueAccessor.setDisabledState(!0),this._added=!0}}return t.\u0275fac=function(e){return new(e||t)(Xa(_d,13),Xa(ld,10),Xa(ud,10),Xa(rd,10),Xa(Jd,8))},t.\u0275dir=be({type:t,selectors:[["","formControlName",""]],inputs:{isDisabled:["disabled","isDisabled"],name:["formControlName","name"],model:["ngModel","model"]},outputs:{update:"ngModelChange"},features:[Xo([np]),Da,Re]}),t._ngModelWarningSentOnce=!1,t})(),rp=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[Qd]]}),t})(),ip=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[rp]}),t})(),ap=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:Jd,useValue:e.warnOnNgModelWithFormControl}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[rp]}),t})();function op(...t){let e=t[t.length-1];return K(e)?(t.pop(),rt(t,e)):pt(t)}class lp extends G{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&&!e.closed&&t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new U;return this._value}next(t){super.next(this._value=t)}}class up extends M{notifyNext(t,e,n,s,r){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}class cp extends M{constructor(t,e,n){super(),this.parent=t,this.outerValue=e,this.outerIndex=n,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function hp(t,e,n,s,r=new cp(t,n,s)){if(!r.closed)return e instanceof B?e.subscribe(r):st(e)(r)}const dp={};function pp(...t){let e,n;return K(t[t.length-1])&&(n=t.pop()),"function"==typeof t[t.length-1]&&(e=t.pop()),1===t.length&&$(t[0])&&(t=t[0]),pt(t,n).lift(new fp(e))}class fp{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new mp(t,this.resultSelector))}}class mp extends up{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(dp),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let n=0;n<e;n++)this.add(hp(this,t[n],void 0,n))}}notifyComplete(t){0==(this.active-=1)&&this.destination.complete()}notifyNext(t,e,n){const s=this.values,r=this.toRespond?s[n]===dp?--this.toRespond:this.toRespond:0;s[n]=e,0===r&&(this.resultSelector?this._tryResultSelector(s):this.destination.next(s.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const gp=(()=>{function t(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return t.prototype=Object.create(Error.prototype),t})();function yp(...t){return dt(1)(op(...t))}const bp=new B(t=>t.complete());function vp(t){return t?function(t){return new B(e=>t.schedule(()=>e.complete()))}(t):bp}function wp(t){return new B(e=>{let n;try{n=t()}catch(s){return void e.error(s)}return(n?it(n):vp()).subscribe(e)})}function _p(t,e){return"function"==typeof e?n=>n.pipe(_p((n,s)=>it(t(n,s)).pipe(X((t,r)=>e(n,t,s,r))))):e=>e.lift(new xp(t))}class xp{constructor(t){this.project=t}call(t,e){return e.subscribe(new kp(t,this.project))}}class kp extends ot{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(s){return void this.destination.error(s)}this._innerSub(e)}_innerSub(t){const e=this.innerSubscription;e&&e.unsubscribe();const n=new at(this),s=this.destination;s.add(n),this.innerSubscription=lt(t,n),this.innerSubscription!==n&&s.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;t&&!t.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(t){this.destination.next(t)}}const Cp=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})();function Sp(t){return e=>0===t?vp():e.lift(new Ip(t))}class Ip{constructor(t){if(this.total=t,this.total<0)throw new Cp}call(t,e){return e.subscribe(new Ep(t,this.total))}}class Ep extends M{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,n=++this.count;n<=e&&(this.destination.next(t),n===e&&(this.destination.complete(),this.unsubscribe()))}}function Np(...t){const e=t[t.length-1];return K(e)?(t.pop(),n=>yp(t,n,e)):e=>yp(t,e)}function Tp(t,e){let n=!1;return arguments.length>=2&&(n=!0),function(s){return s.lift(new Ap(t,e,n))}}class Ap{constructor(t,e,n=!1){this.accumulator=t,this.seed=e,this.hasSeed=n}call(t,e){return e.subscribe(new $p(t,this.accumulator,this.seed,this.hasSeed))}}class $p extends M{constructor(t,e,n,s){super(t),this.accumulator=e,this._seed=n,this.hasSeed=s,this.index=0}get seed(){return this._seed}set seed(t){this.hasSeed=!0,this._seed=t}_next(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)}_tryNext(t){const e=this.index++;let n;try{n=this.accumulator(this.seed,t,e)}catch(s){this.destination.error(s)}this.seed=n,this.destination.next(n)}}function Rp(t,e){return function(n){return n.lift(new Op(t,e))}}class Op{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new Fp(t,this.predicate,this.thisArg))}}class Fp extends M{constructor(t,e,n){super(t),this.predicate=e,this.thisArg=n,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}e&&this.destination.next(t)}}function Dp(t){return function(e){const n=new Lp(t),s=e.lift(n);return n.caught=s}}class Lp{constructor(t){this.selector=t}call(t,e){return e.subscribe(new Mp(t,this.selector,this.caught))}}class Mp extends ot{constructor(t,e,n){super(t),this.selector=e,this.caught=n}error(t){if(!this.isStopped){let n;try{n=this.selector(t,this.caught)}catch(e){return void super.error(e)}this._unsubscribeAndRecycle();const s=new at(this);this.add(s);const r=lt(n,s);r!==s&&this.add(r)}}}function Pp(t,e){return ut(t,e,1)}function zp(t){return function(e){return 0===t?vp():e.lift(new Vp(t))}}class Vp{constructor(t){if(this.total=t,this.total<0)throw new Cp}call(t,e){return e.subscribe(new Bp(t,this.total))}}class Bp extends M{constructor(t,e){super(t),this.total=e,this.ring=new Array,this.count=0}_next(t){const e=this.ring,n=this.total,s=this.count++;e.length<n?e.push(t):e[s%n]=t}_complete(){const t=this.destination;let e=this.count;if(e>0){const n=this.count>=this.total?this.total:this.count,s=this.ring;for(let r=0;r<n;r++){const r=e++%n;t.next(s[r])}}t.complete()}}function Wp(t=Hp){return e=>e.lift(new Up(t))}class Up{constructor(t){this.errorFactory=t}call(t,e){return e.subscribe(new jp(t,this.errorFactory))}}class jp extends M{constructor(t,e){super(t),this.errorFactory=e,this.hasValue=!1}_next(t){this.hasValue=!0,this.destination.next(t)}_complete(){if(this.hasValue)return this.destination.complete();{let e;try{e=this.errorFactory()}catch(t){e=t}this.destination.error(e)}}}function Hp(){return new gp}function Gp(t=null){return e=>e.lift(new qp(t))}class qp{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new Kp(t,this.defaultValue))}}class Kp extends M{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Xp(t,e){const n=arguments.length>=2;return s=>s.pipe(t?Rp((e,n)=>t(e,n,s)):V,Sp(1),n?Gp(e):Wp(()=>new gp))}function Zp(){}function Yp(t,e,n){return function(s){return s.lift(new Qp(t,e,n))}}class Qp{constructor(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}call(t,e){return e.subscribe(new Jp(t,this.nextOrObserver,this.error,this.complete))}}class Jp extends M{constructor(t,e,n,s){super(t),this._tapNext=Zp,this._tapError=Zp,this._tapComplete=Zp,this._tapError=n||Zp,this._tapComplete=s||Zp,I(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||Zp,this._tapError=e.error||Zp,this._tapComplete=e.complete||Zp)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}function tf(t){return e=>e.lift(new ef(t))}class ef{constructor(t){this.callback=t}call(t,e){return e.subscribe(new nf(t,this.callback))}}class nf extends M{constructor(t,e){super(t),this.add(new F(e))}}class sf{constructor(t,e){this.id=t,this.url=e}}class rf extends sf{constructor(t,e,n="imperative",s=null){super(t,e),this.navigationTrigger=n,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class af extends sf{constructor(t,e,n){super(t,e),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class of extends sf{constructor(t,e,n){super(t,e),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class lf extends sf{constructor(t,e,n){super(t,e),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class uf extends sf{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class cf extends sf{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class hf extends sf{constructor(t,e,n,s,r){super(t,e),this.urlAfterRedirects=n,this.state=s,this.shouldActivate=r}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class df extends sf{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class pf extends sf{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class ff{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class mf{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class gf{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class yf{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class bf{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class vf{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class wf{constructor(t,e,n){this.routerEvent=t,this.position=e,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const _f="primary";class xf{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function kf(t){return new xf(t)}function Cf(t){const e=Error("NavigationCancelingError: "+t);return e.ngNavigationCancelingError=!0,e}function Sf(t,e,n){const s=n.path.split("/");if(s.length>t.length)return null;if("full"===n.pathMatch&&(e.hasChildren()||s.length<t.length))return null;const r={};for(let i=0;i<s.length;i++){const e=s[i],n=t[i];if(e.startsWith(":"))r[e.substring(1)]=n;else if(e!==n.path)return null}return{consumed:t.slice(0,s.length),posParams:r}}function If(t,e){const n=t?Object.keys(t):void 0,s=e?Object.keys(e):void 0;if(!n||!s||n.length!=s.length)return!1;let r;for(let i=0;i<n.length;i++)if(r=n[i],!Ef(t[r],e[r]))return!1;return!0}function Ef(t,e){if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;const n=[...t].sort(),s=[...e].sort();return n.every((t,e)=>s[e]===t)}return t===e}function Nf(t){return Array.prototype.concat.apply([],t)}function Tf(t){return t.length>0?t[t.length-1]:null}function Af(t,e){for(const n in t)t.hasOwnProperty(n)&&e(t[n],n)}function $f(t){return ao(t)?t:ro(t)?it(Promise.resolve(t)):op(t)}const Rf={exact:function t(e,n,s){if(!Bf(e.segments,n.segments))return!1;if(!Mf(e.segments,n.segments,s))return!1;if(e.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children){if(!e.children[r])return!1;if(!t(e.children[r],n.children[r],s))return!1}return!0},subset:Df},Of={exact:function(t,e){return If(t,e)},subset:function(t,e){return Object.keys(e).length<=Object.keys(t).length&&Object.keys(e).every(n=>Ef(t[n],e[n]))},ignored:()=>!0};function Ff(t,e,n){return Rf[n.paths](t.root,e.root,n.matrixParams)&&Of[n.queryParams](t.queryParams,e.queryParams)&&!("exact"===n.fragment&&t.fragment!==e.fragment)}function Df(t,e,n){return Lf(t,e,e.segments,n)}function Lf(t,e,n,s){if(t.segments.length>n.length){const r=t.segments.slice(0,n.length);return!!Bf(r,n)&&!e.hasChildren()&&!!Mf(r,n,s)}if(t.segments.length===n.length){if(!Bf(t.segments,n))return!1;if(!Mf(t.segments,n,s))return!1;for(const n in e.children){if(!t.children[n])return!1;if(!Df(t.children[n],e.children[n],s))return!1}return!0}{const r=n.slice(0,t.segments.length),i=n.slice(t.segments.length);return!!Bf(t.segments,r)&&!!Mf(t.segments,r,s)&&!!t.children.primary&&Lf(t.children.primary,e,i,s)}}function Mf(t,e,n){return e.every((e,s)=>Of[n](t[s].parameters,e.parameters))}class Pf{constructor(t,e,n){this.root=t,this.queryParams=e,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=kf(this.queryParams)),this._queryParamMap}toString(){return jf.serialize(this)}}class zf{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Af(e,(t,e)=>t.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Hf(this)}}class Vf{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=kf(this.parameters)),this._parameterMap}toString(){return Qf(this)}}function Bf(t,e){return t.length===e.length&&t.every((t,n)=>t.path===e[n].path)}class Wf{}class Uf{parse(t){const e=new sm(t);return new Pf(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){var e;return`/${Gf(t.root,!0)}${function(t){const e=Object.keys(t).map(e=>{const n=t[e];return Array.isArray(n)?n.map(t=>`${Kf(e)}=${Kf(t)}`).join("&"):`${Kf(e)}=${Kf(n)}`}).filter(t=>!!t);return e.length?`?${e.join("&")}`:""}(t.queryParams)}${"string"==typeof t.fragment?`#${e=t.fragment,encodeURI(e)}`:""}`}}const jf=new Uf;function Hf(t){return t.segments.map(t=>Qf(t)).join("/")}function Gf(t,e){if(!t.hasChildren())return Hf(t);if(e){const e=t.children.primary?Gf(t.children.primary,!1):"",n=[];return Af(t.children,(t,e)=>{e!==_f&&n.push(`${e}:${Gf(t,!1)}`)}),n.length>0?`${e}(${n.join("//")})`:e}{const e=function(t,e){let n=[];return Af(t.children,(t,s)=>{s===_f&&(n=n.concat(e(t,s)))}),Af(t.children,(t,s)=>{s!==_f&&(n=n.concat(e(t,s)))}),n}(t,(e,n)=>n===_f?[Gf(t.children.primary,!1)]:[`${n}:${Gf(e,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children.primary?`${Hf(t)}/${e[0]}`:`${Hf(t)}/(${e.join("//")})`}}function qf(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Kf(t){return qf(t).replace(/%3B/gi,";")}function Xf(t){return qf(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Zf(t){return decodeURIComponent(t)}function Yf(t){return Zf(t.replace(/\+/g,"%20"))}function Qf(t){return`${Xf(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${Xf(t)}=${Xf(e[t])}`).join("")}`;var e}const Jf=/^[^\/()?;=#]+/;function tm(t){const e=t.match(Jf);return e?e[0]:""}const em=/^[^=?&#]+/,nm=/^[^?&#]+/;class sm{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new zf([],{}):new zf([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(n.primary=new zf(t,e)),n}parseSegment(){const t=tm(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new Vf(Zf(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=tm(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=tm(this.remaining);t&&(n=t,this.capture(n))}t[Zf(e)]=Zf(n)}parseQueryParam(t){const e=function(t){const e=t.match(em);return e?e[0]:""}(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=function(t){const e=t.match(nm);return e?e[0]:""}(this.remaining);t&&(n=t,this.capture(n))}const s=Yf(e),r=Yf(n);if(t.hasOwnProperty(s)){let e=t[s];Array.isArray(e)||(e=[e],t[s]=e),e.push(r)}else t[s]=r}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=tm(this.remaining),s=this.remaining[n.length];if("/"!==s&&")"!==s&&";"!==s)throw new Error(`Cannot parse url '${this.url}'`);let r;n.indexOf(":")>-1?(r=n.substr(0,n.indexOf(":")),this.capture(r),this.capture(":")):t&&(r=_f);const i=this.parseChildren();e[r]=1===Object.keys(i).length?i.primary:new zf([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class rm{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=im(t,this._root);return e?e.children.map(t=>t.value):[]}firstChild(t){const e=im(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=am(t,this._root);return e.length<2?[]:e[e.length-2].children.map(t=>t.value).filter(e=>e!==t)}pathFromRoot(t){return am(t,this._root).map(t=>t.value)}}function im(t,e){if(t===e.value)return e;for(const n of e.children){const e=im(t,n);if(e)return e}return null}function am(t,e){if(t===e.value)return[e];for(const n of e.children){const s=am(t,n);if(s.length)return s.unshift(e),s}return[]}class om{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function lm(t){const e={};return t&&t.children.forEach(t=>e[t.value.outlet]=t),e}class um extends rm{constructor(t,e){super(t),this.snapshot=e,mm(this,t)}toString(){return this.snapshot.toString()}}function cm(t,e){const n=function(t,e){const n=new pm([],{},{},"",{},_f,e,null,t.root,-1,{});return new fm("",new om(n,[]))}(t,e),s=new lp([new Vf("",{})]),r=new lp({}),i=new lp({}),a=new lp({}),o=new lp(""),l=new hm(s,r,a,o,i,_f,e,n.root);return l.snapshot=n.root,new um(new om(l,[]),n)}class hm{constructor(t,e,n,s,r,i,a,o){this.url=t,this.params=e,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=i,this.component=a,this._futureSnapshot=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(X(t=>kf(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(X(t=>kf(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function dm(t,e="emptyOnly"){const n=t.pathFromRoot;let s=0;if("always"!==e)for(s=n.length-1;s>=1;){const t=n[s],e=n[s-1];if(t.routeConfig&&""===t.routeConfig.path)s--;else{if(e.component)break;s--}}return function(t){return t.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(s))}class pm{constructor(t,e,n,s,r,i,a,o,l,u,c){this.url=t,this.params=e,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=i,this.component=a,this.routeConfig=o,this._urlSegment=l,this._lastPathIndex=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=kf(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=kf(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class fm extends rm{constructor(t,e){super(e),this.url=t,mm(this,e)}toString(){return gm(this._root)}}function mm(t,e){e.value._routerState=t,e.children.forEach(e=>mm(t,e))}function gm(t){const e=t.children.length>0?` { ${t.children.map(gm).join(", ")} } `:"";return`${t.value}${e}`}function ym(t){if(t.snapshot){const e=t.snapshot,n=t._futureSnapshot;t.snapshot=n,If(e.queryParams,n.queryParams)||t.queryParams.next(n.queryParams),e.fragment!==n.fragment&&t.fragment.next(n.fragment),If(e.params,n.params)||t.params.next(n.params),function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;++n)if(!If(t[n],e[n]))return!1;return!0}(e.url,n.url)||t.url.next(n.url),If(e.data,n.data)||t.data.next(n.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function bm(t,e){var n,s;return If(t.params,e.params)&&Bf(n=t.url,s=e.url)&&n.every((t,e)=>If(t.parameters,s[e].parameters))&&!(!t.parent!=!e.parent)&&(!t.parent||bm(t.parent,e.parent))}function vm(t,e,n){if(n&&t.shouldReuseRoute(e.value,n.value.snapshot)){const s=n.value;s._futureSnapshot=e.value;const r=function(t,e,n){return e.children.map(e=>{for(const s of n.children)if(t.shouldReuseRoute(e.value,s.value.snapshot))return vm(t,e,s);return vm(t,e)})}(t,e,n);return new om(s,r)}{if(t.shouldAttach(e.value)){const n=t.retrieve(e.value);if(null!==n){const t=n.route;return wm(e,t),t}}const n=new hm(new lp((s=e.value).url),new lp(s.params),new lp(s.queryParams),new lp(s.fragment),new lp(s.data),s.outlet,s.component,s),r=e.children.map(e=>vm(t,e));return new om(n,r)}var s}function wm(t,e){if(t.value.routeConfig!==e.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(t.children.length!==e.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");e.value._futureSnapshot=t.value;for(let n=0;n<t.children.length;++n)wm(t.children[n],e.children[n])}function _m(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function xm(t){return"object"==typeof t&&null!=t&&t.outlets}function km(t,e,n,s,r){let i={};return s&&Af(s,(t,e)=>{i[e]=Array.isArray(t)?t.map(t=>`${t}`):`${t}`}),new Pf(n.root===t?e:Cm(n.root,t,e),i,r)}function Cm(t,e,n){const s={};return Af(t.children,(t,r)=>{s[r]=t===e?n:Cm(t,e,n)}),new zf(t.segments,s)}class Sm{constructor(t,e,n){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=n,t&&n.length>0&&_m(n[0]))throw new Error("Root segment cannot have matrix parameters");const s=n.find(xm);if(s&&s!==Tf(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Im{constructor(t,e,n){this.segmentGroup=t,this.processChildren=e,this.index=n}}function Em(t,e,n){if(t||(t=new zf([],{})),0===t.segments.length&&t.hasChildren())return Nm(t,e,n);const s=function(t,e,n){let s=0,r=e;const i={match:!1,pathIndex:0,commandIndex:0};for(;r<t.segments.length;){if(s>=n.length)return i;const e=t.segments[r],a=n[s];if(xm(a))break;const o=`${a}`,l=s<n.length-1?n[s+1]:null;if(r>0&&void 0===o)break;if(o&&l&&"object"==typeof l&&void 0===l.outlets){if(!Rm(o,l,e))return i;s+=2}else{if(!Rm(o,{},e))return i;s++}r++}return{match:!0,pathIndex:r,commandIndex:s}}(t,e,n),r=n.slice(s.commandIndex);if(s.match&&s.pathIndex<t.segments.length){const e=new zf(t.segments.slice(0,s.pathIndex),{});return e.children.primary=new zf(t.segments.slice(s.pathIndex),t.children),Nm(e,0,r)}return s.match&&0===r.length?new zf(t.segments,{}):s.match&&!t.hasChildren()?Tm(t,e,n):s.match?Nm(t,0,r):Tm(t,e,n)}function Nm(t,e,n){if(0===n.length)return new zf(t.segments,{});{const s=function(t){return xm(t[0])?t[0].outlets:{[_f]:t}}(n),r={};return Af(s,(n,s)=>{"string"==typeof n&&(n=[n]),null!==n&&(r[s]=Em(t.children[s],e,n))}),Af(t.children,(t,e)=>{void 0===s[e]&&(r[e]=t)}),new zf(t.segments,r)}}function Tm(t,e,n){const s=t.segments.slice(0,e);let r=0;for(;r<n.length;){const i=n[r];if(xm(i)){const t=Am(i.outlets);return new zf(s,t)}if(0===r&&_m(n[0])){s.push(new Vf(t.segments[e].path,$m(n[0]))),r++;continue}const a=xm(i)?i.outlets.primary:`${i}`,o=r<n.length-1?n[r+1]:null;a&&o&&_m(o)?(s.push(new Vf(a,$m(o))),r+=2):(s.push(new Vf(a,{})),r++)}return new zf(s,{})}function Am(t){const e={};return Af(t,(t,n)=>{"string"==typeof t&&(t=[t]),null!==t&&(e[n]=Tm(new zf([],{}),0,t))}),e}function $m(t){const e={};return Af(t,(t,n)=>e[n]=`${t}`),e}function Rm(t,e,n){return t==n.path&&If(e,n.parameters)}class Om{constructor(t,e,n,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=n,this.forwardEvent=s}activate(t){const e=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,n,t),ym(this.futureState.root),this.activateChildRoutes(e,n,t)}deactivateChildRoutes(t,e,n){const s=lm(e);t.children.forEach(t=>{const e=t.value.outlet;this.deactivateRoutes(t,s[e],n),delete s[e]}),Af(s,(t,e)=>{this.deactivateRouteAndItsChildren(t,n)})}deactivateRoutes(t,e,n){const s=t.value,r=e?e.value:null;if(s===r)if(s.component){const r=n.getContext(s.outlet);r&&this.deactivateChildRoutes(t,e,r.children)}else this.deactivateChildRoutes(t,e,n);else r&&this.deactivateRouteAndItsChildren(e,n)}deactivateRouteAndItsChildren(t,e){this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const n=e.getContext(t.value.outlet);if(n&&n.outlet){const e=n.outlet.detach(),s=n.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:e,route:t,contexts:s})}}deactivateRouteAndOutlet(t,e){const n=e.getContext(t.value.outlet),s=n&&t.value.component?n.children:e,r=lm(t);for(const i of Object.keys(r))this.deactivateRouteAndItsChildren(r[i],s);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(t,e,n){const s=lm(e);t.children.forEach(t=>{this.activateRoutes(t,s[t.value.outlet],n),this.forwardEvent(new vf(t.value.snapshot))}),t.children.length&&this.forwardEvent(new yf(t.value.snapshot))}activateRoutes(t,e,n){const s=t.value,r=e?e.value:null;if(ym(s),s===r)if(s.component){const r=n.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,r.children)}else this.activateChildRoutes(t,e,n);else if(s.component){const e=n.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const t=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),e.children.onOutletReAttached(t.contexts),e.attachRef=t.componentRef,e.route=t.route.value,e.outlet&&e.outlet.attach(t.componentRef,t.route.value),Fm(t.route)}else{const n=function(t){for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig;if(t&&t.component)return null}return null}(s.snapshot),r=n?n.module.componentFactoryResolver:null;e.attachRef=null,e.route=s,e.resolver=r,e.outlet&&e.outlet.activateWith(s,r),this.activateChildRoutes(t,null,e.children)}}else this.activateChildRoutes(t,null,n)}}function Fm(t){ym(t.value),t.children.forEach(Fm)}class Dm{constructor(t,e){this.routes=t,this.module=e}}function Lm(t){return"function"==typeof t}function Mm(t){return t instanceof Pf}const Pm=Symbol("INITIAL_VALUE");function zm(){return _p(t=>pp(t.map(t=>t.pipe(Sp(1),Np(Pm)))).pipe(Tp((t,e)=>{let n=!1;return e.reduce((t,s,r)=>{if(t!==Pm)return t;if(s===Pm&&(n=!0),!n){if(!1===s)return s;if(r===e.length-1||Mm(s))return s}return t},t)},Pm),Rp(t=>t!==Pm),X(t=>Mm(t)?t:!0===t),Sp(1)))}let Vm=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=de({type:t,selectors:[["ng-component"]],decls:1,vars:0,template:function(t,e){1&t&&to(0,"router-outlet")},directives:function(){return[Fg]},encapsulation:2}),t})();function Bm(t,e=""){for(let n=0;n<t.length;n++){const s=t[n];Wm(s,Um(e,s))}}function Wm(t,e){t.children&&Bm(t.children,e)}function Um(t,e){return e?t||e.path?t&&!e.path?`${t}/`:!t&&e.path?e.path:`${t}/${e.path}`:"":t}function jm(t){const e=t.children&&t.children.map(jm),n=e?Object.assign(Object.assign({},t),{children:e}):Object.assign({},t);return!n.component&&(e||n.loadChildren)&&n.outlet&&n.outlet!==_f&&(n.component=Vm),n}function Hm(t){return t.outlet||_f}function Gm(t,e){const n=t.filter(t=>Hm(t)===e);return n.push(...t.filter(t=>Hm(t)!==e)),n}const qm={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function Km(t,e,n){var s;if(""===e.path)return"full"===e.pathMatch&&(t.hasChildren()||n.length>0)?Object.assign({},qm):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const r=(e.matcher||Sf)(n,t,e);if(!r)return Object.assign({},qm);const i={};Af(r.posParams,(t,e)=>{i[e]=t.path});const a=r.consumed.length>0?Object.assign(Object.assign({},i),r.consumed[r.consumed.length-1].parameters):i;return{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:a,positionalParamSegments:null!==(s=r.posParams)&&void 0!==s?s:{}}}function Xm(t,e,n,s,r="corrected"){if(n.length>0&&function(t,e,n){return n.some(n=>Zm(t,e,n)&&Hm(n)!==_f)}(t,n,s)){const r=new zf(e,function(t,e,n,s){const r={};r.primary=s,s._sourceSegment=t,s._segmentIndexShift=e.length;for(const i of n)if(""===i.path&&Hm(i)!==_f){const n=new zf([],{});n._sourceSegment=t,n._segmentIndexShift=e.length,r[Hm(i)]=n}return r}(t,e,s,new zf(n,t.children)));return r._sourceSegment=t,r._segmentIndexShift=e.length,{segmentGroup:r,slicedSegments:[]}}if(0===n.length&&function(t,e,n){return n.some(n=>Zm(t,e,n))}(t,n,s)){const i=new zf(t.segments,function(t,e,n,s,r,i){const a={};for(const o of s)if(Zm(t,n,o)&&!r[Hm(o)]){const n=new zf([],{});n._sourceSegment=t,n._segmentIndexShift="legacy"===i?t.segments.length:e.length,a[Hm(o)]=n}return Object.assign(Object.assign({},r),a)}(t,e,n,s,t.children,r));return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}const i=new zf(t.segments,t.children);return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}function Zm(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path}function Ym(t,e,n,s){return!!(Hm(t)===s||s!==_f&&Zm(e,n,t))&&("**"===t.path||Km(e,t,n).matched)}function Qm(t,e,n){return 0===e.length&&!t.children[n]}class Jm{constructor(t){this.segmentGroup=t||null}}class tg{constructor(t){this.urlTree=t}}function eg(t){return new B(e=>e.error(new Jm(t)))}function ng(t){return new B(e=>e.error(new tg(t)))}function sg(t){return new B(e=>e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`)))}class rg{constructor(t,e,n,s,r){this.configLoader=e,this.urlSerializer=n,this.urlTree=s,this.config=r,this.allowRedirects=!0,this.ngModule=t.get(Ml)}apply(){const t=Xm(this.urlTree.root,[],[],this.config).segmentGroup,e=new zf(t.segments,t.children);return this.expandSegmentGroup(this.ngModule,this.config,e,_f).pipe(X(t=>this.createUrlTree(ig(t),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Dp(t=>{if(t instanceof tg)return this.allowRedirects=!1,this.match(t.urlTree);if(t instanceof Jm)throw this.noMatchError(t);throw t}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,_f).pipe(X(e=>this.createUrlTree(ig(e),t.queryParams,t.fragment))).pipe(Dp(t=>{if(t instanceof Jm)throw this.noMatchError(t);throw t}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,n){const s=t.segments.length>0?new zf([],{[_f]:t}):t;return new Pf(s,e,n)}expandSegmentGroup(t,e,n,s){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(t,e,n).pipe(X(t=>new zf([],t))):this.expandSegment(t,n,e,n.segments,s,!0)}expandChildren(t,e,n){const s=[];for(const r of Object.keys(n.children))"primary"===r?s.unshift(r):s.push(r);return it(s).pipe(Pp(s=>{const r=n.children[s],i=Gm(e,s);return this.expandSegmentGroup(t,i,r,s).pipe(X(t=>({segment:t,outlet:s})))}),Tp((t,e)=>(t[e.outlet]=e.segment,t),{}),function(t,e){const n=arguments.length>=2;return s=>s.pipe(t?Rp((e,n)=>t(e,n,s)):V,zp(1),n?Gp(e):Wp(()=>new gp))}())}expandSegment(t,e,n,s,r,i){return it(n).pipe(Pp(a=>this.expandSegmentAgainstRoute(t,e,n,a,s,r,i).pipe(Dp(t=>{if(t instanceof Jm)return op(null);throw t}))),Xp(t=>!!t),Dp((t,n)=>{if(t instanceof gp||"EmptyError"===t.name){if(Qm(e,s,r))return op(new zf([],{}));throw new Jm(e)}throw t}))}expandSegmentAgainstRoute(t,e,n,s,r,i,a){return Ym(s,e,r,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,r,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i):eg(e):eg(e)}expandSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,n,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,n,s){const r=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?ng(r):this.lineralizeSegments(n,r).pipe(ut(n=>{const r=new zf(n,{});return this.expandSegment(t,r,e,n,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i){const{matched:a,consumedSegments:o,lastChild:l,positionalParamSegments:u}=Km(e,s,r);if(!a)return eg(e);const c=this.applyRedirectCommands(o,s.redirectTo,u);return s.redirectTo.startsWith("/")?ng(c):this.lineralizeSegments(s,c).pipe(ut(s=>this.expandSegment(t,e,n,s.concat(r.slice(l)),i,!1)))}matchSegmentAgainstRoute(t,e,n,s,r){if("**"===n.path)return n.loadChildren?(n._loadedConfig?op(n._loadedConfig):this.configLoader.load(t.injector,n)).pipe(X(t=>(n._loadedConfig=t,new zf(s,{})))):op(new zf(s,{}));const{matched:i,consumedSegments:a,lastChild:o}=Km(e,n,s);if(!i)return eg(e);const l=s.slice(o);return this.getChildConfig(t,n,s).pipe(ut(t=>{const s=t.module,i=t.routes,{segmentGroup:o,slicedSegments:u}=Xm(e,a,l,i),c=new zf(o.segments,o.children);if(0===u.length&&c.hasChildren())return this.expandChildren(s,i,c).pipe(X(t=>new zf(a,t)));if(0===i.length&&0===u.length)return op(new zf(a,{}));const h=Hm(n)===r;return this.expandSegment(s,c,i,u,h?_f:r,!0).pipe(X(t=>new zf(a.concat(t.segments),t.children)))}))}getChildConfig(t,e,n){return e.children?op(new Dm(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?op(e._loadedConfig):this.runCanLoadGuards(t.injector,e,n).pipe(ut(n=>n?this.configLoader.load(t.injector,e).pipe(X(t=>(e._loadedConfig=t,t))):function(t){return new B(e=>e.error(Cf(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)))}(e))):op(new Dm([],t))}runCanLoadGuards(t,e,n){const s=e.canLoad;return s&&0!==s.length?op(s.map(s=>{const r=t.get(s);let i;if(function(t){return t&&Lm(t.canLoad)}(r))i=r.canLoad(e,n);else{if(!Lm(r))throw new Error("Invalid CanLoad guard");i=r(e,n)}return $f(i)})).pipe(zm(),Yp(t=>{if(!Mm(t))return;const e=Cf(`Redirecting to "${this.urlSerializer.serialize(t)}"`);throw e.url=t,e}),X(t=>!0===t)):op(!0)}lineralizeSegments(t,e){let n=[],s=e.root;for(;;){if(n=n.concat(s.segments),0===s.numberOfChildren)return op(n);if(s.numberOfChildren>1||!s.children.primary)return sg(t.redirectTo);s=s.children.primary}}applyRedirectCommands(t,e,n){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,n)}applyRedirectCreatreUrlTree(t,e,n,s){const r=this.createSegmentGroup(t,e.root,n,s);return new Pf(r,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const n={};return Af(t,(t,s)=>{if("string"==typeof t&&t.startsWith(":")){const r=t.substring(1);n[s]=e[r]}else n[s]=t}),n}createSegmentGroup(t,e,n,s){const r=this.createSegments(t,e.segments,n,s);let i={};return Af(e.children,(e,r)=>{i[r]=this.createSegmentGroup(t,e,n,s)}),new zf(r,i)}createSegments(t,e,n,s){return e.map(e=>e.path.startsWith(":")?this.findPosParam(t,e,s):this.findOrReturn(e,n))}findPosParam(t,e,n){const s=n[e.path.substring(1)];if(!s)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return s}findOrReturn(t,e){let n=0;for(const s of e){if(s.path===t.path)return e.splice(n),s;n++}return t}}function ig(t){const e={};for(const n of Object.keys(t.children)){const s=ig(t.children[n]);(s.segments.length>0||s.hasChildren())&&(e[n]=s)}return function(t){if(1===t.numberOfChildren&&t.children.primary){const e=t.children.primary;return new zf(t.segments.concat(e.segments),e.children)}return t}(new zf(t.segments,e))}class ag{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class og{constructor(t,e){this.component=t,this.route=e}}function lg(t,e,n){const s=t._root;return cg(s,e?e._root:null,n,[s.value])}function ug(t,e,n){const s=function(t){if(!t)return null;for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig}return null}(e);return(s?s.module.injector:n).get(t)}function cg(t,e,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=lm(e);return t.children.forEach(t=>{!function(t,e,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=t.value,a=e?e.value:null,o=n?n.getContext(t.value.outlet):null;if(a&&i.routeConfig===a.routeConfig){const l=function(t,e,n){if("function"==typeof n)return n(t,e);switch(n){case"pathParamsChange":return!Bf(t.url,e.url);case"pathParamsOrQueryParamsChange":return!Bf(t.url,e.url)||!If(t.queryParams,e.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!bm(t,e)||!If(t.queryParams,e.queryParams);case"paramsChange":default:return!bm(t,e)}}(a,i,i.routeConfig.runGuardsAndResolvers);l?r.canActivateChecks.push(new ag(s)):(i.data=a.data,i._resolvedData=a._resolvedData),cg(t,e,i.component?o?o.children:null:n,s,r),l&&o&&o.outlet&&o.outlet.isActivated&&r.canDeactivateChecks.push(new og(o.outlet.component,a))}else a&&hg(e,o,r),r.canActivateChecks.push(new ag(s)),cg(t,null,i.component?o?o.children:null:n,s,r)}(t,i[t.value.outlet],n,s.concat([t.value]),r),delete i[t.value.outlet]}),Af(i,(t,e)=>hg(t,n.getContext(e),r)),r}function hg(t,e,n){const s=lm(t),r=t.value;Af(s,(t,s)=>{hg(t,r.component?e?e.children.getContext(s):null:e,n)}),n.canDeactivateChecks.push(new og(r.component&&e&&e.outlet&&e.outlet.isActivated?e.outlet.component:null,r))}class dg{}function pg(t){return new B(e=>e.error(t))}class fg{constructor(t,e,n,s,r,i){this.rootComponentType=t,this.config=e,this.urlTree=n,this.url=s,this.paramsInheritanceStrategy=r,this.relativeLinkResolution=i}recognize(){const t=Xm(this.urlTree.root,[],[],this.config.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,_f);if(null===e)return null;const n=new pm([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},_f,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new om(n,e),r=new fm(this.url,s);return this.inheritParamsAndData(r._root),r}inheritParamsAndData(t){const e=t.value,n=dm(e,this.paramsInheritanceStrategy);e.params=Object.freeze(n.params),e.data=Object.freeze(n.data),t.children.forEach(t=>this.inheritParamsAndData(t))}processSegmentGroup(t,e,n){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,n)}processChildren(t,e){const n=[];for(const r of Object.keys(e.children)){const s=e.children[r],i=Gm(t,r),a=this.processSegmentGroup(i,s,r);if(null===a)return null;n.push(...a)}const s=gg(n);return s.sort((t,e)=>t.value.outlet===_f?-1:e.value.outlet===_f?1:t.value.outlet.localeCompare(e.value.outlet)),s}processSegment(t,e,n,s){for(const r of t){const t=this.processSegmentAgainstRoute(r,e,n,s);if(null!==t)return t}return Qm(e,n,s)?[]:null}processSegmentAgainstRoute(t,e,n,s){if(t.redirectTo||!Ym(t,e,n,s))return null;let r,i=[],a=[];if("**"===t.path){const s=n.length>0?Tf(n).parameters:{};r=new pm(n,s,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,vg(t),Hm(t),t.component,t,yg(e),bg(e)+n.length,wg(t))}else{const s=Km(e,t,n);if(!s.matched)return null;i=s.consumedSegments,a=n.slice(s.lastChild),r=new pm(i,s.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,vg(t),Hm(t),t.component,t,yg(e),bg(e)+i.length,wg(t))}const o=function(t){return t.children?t.children:t.loadChildren?t._loadedConfig.routes:[]}(t),{segmentGroup:l,slicedSegments:u}=Xm(e,i,a,o.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution);if(0===u.length&&l.hasChildren()){const t=this.processChildren(o,l);return null===t?null:[new om(r,t)]}if(0===o.length&&0===u.length)return[new om(r,[])];const c=Hm(t)===s,h=this.processSegment(o,l,u,c?_f:s);return null===h?null:[new om(r,h)]}}function mg(t){const e=t.value.routeConfig;return e&&""===e.path&&void 0===e.redirectTo}function gg(t){const e=[],n=new Set;for(const s of t){if(!mg(s)){e.push(s);continue}const t=e.find(t=>s.value.routeConfig===t.value.routeConfig);void 0!==t?(t.children.push(...s.children),n.add(t)):e.push(s)}for(const s of n){const t=gg(s.children);e.push(new om(s.value,t))}return e.filter(t=>!n.has(t))}function yg(t){let e=t;for(;e._sourceSegment;)e=e._sourceSegment;return e}function bg(t){let e=t,n=e._segmentIndexShift?e._segmentIndexShift:0;for(;e._sourceSegment;)e=e._sourceSegment,n+=e._segmentIndexShift?e._segmentIndexShift:0;return n-1}function vg(t){return t.data||{}}function wg(t){return t.resolve||{}}function _g(t){return _p(e=>{const n=t(e);return n?it(n).pipe(X(()=>e)):op(e)})}class xg extends class{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}{}const kg=new ms("ROUTES");class Cg{constructor(t,e,n,s){this.loader=t,this.compiler=e,this.onLoadStartListener=n,this.onLoadEndListener=s}load(t,e){if(e._loader$)return e._loader$;this.onLoadStartListener&&this.onLoadStartListener(e);const n=this.loadModuleFactory(e.loadChildren).pipe(X(n=>{this.onLoadEndListener&&this.onLoadEndListener(e);const s=n.create(t);return new Dm(Nf(s.injector.get(kg,void 0,jt.Self|jt.Optional)).map(jm),s)}),Dp(t=>{throw e._loader$=void 0,t}));return e._loader$=new bt(n,()=>new G).pipe(mt()),e._loader$}loadModuleFactory(t){return"string"==typeof t?it(this.loader.load(t)):$f(t()).pipe(ut(t=>t instanceof Pl?op(t):it(this.compiler.compileModuleAsync(t))))}}class Sg{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new Ig,this.attachRef=null}}class Ig{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const n=this.getOrCreateContext(t);n.outlet=e,this.contexts.set(t,n)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new Sg,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}class Eg{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function Ng(t){throw t}function Tg(t,e,n){return e.parse("/")}function Ag(t,e){return op(null)}const $g={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Rg={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Og=(()=>{class t{constructor(t,e,n,s,r,i,a,o){this.rootComponentType=t,this.urlSerializer=e,this.rootContexts=n,this.location=s,this.config=o,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new G,this.errorHandler=Ng,this.malformedUriErrorHandler=Tg,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:Ag,afterPreactivation:Ag},this.urlHandlingStrategy=new Eg,this.routeReuseStrategy=new xg,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.ngModule=r.get(Ml),this.console=r.get($u);const l=r.get(ju);this.isNgZoneEnabled=l instanceof ju&&ju.isInAngularZone(),this.resetConfig(o),this.currentUrlTree=new Pf(new zf([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new Cg(i,a,t=>this.triggerEvent(new ff(t)),t=>this.triggerEvent(new mf(t))),this.routerState=cm(this.currentUrlTree,this.rootComponentType),this.transitions=new lp({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(t){const e=this.events;return t.pipe(Rp(t=>0!==t.id),X(t=>Object.assign(Object.assign({},t),{extractedUrl:this.urlHandlingStrategy.extract(t.rawUrl)})),_p(t=>{let n=!1,s=!1;return op(t).pipe(Yp(t=>{this.currentNavigation={id:t.id,initialUrl:t.currentRawUrl,extractedUrl:t.extractedUrl,trigger:t.source,extras:t.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),_p(t=>{const n=!this.navigated||t.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl))return op(t).pipe(_p(t=>{const n=this.transitions.getValue();return e.next(new rf(t.id,this.serializeUrl(t.extractedUrl),t.source,t.restoredState)),n!==this.transitions.getValue()?bp:Promise.resolve(t)}),function(t,e,n,s){return _p(r=>function(t,e,n,s,r){return new rg(t,e,n,s,r).apply()}(t,e,n,r.extractedUrl,s).pipe(X(t=>Object.assign(Object.assign({},r),{urlAfterRedirects:t}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),Yp(t=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:t.urlAfterRedirects})}),function(t,e,n,s,r){return ut(i=>function(t,e,n,s,r="emptyOnly",i="legacy"){try{const a=new fg(t,e,n,s,r,i).recognize();return null===a?pg(new dg):op(a)}catch(a){return pg(a)}}(t,e,i.urlAfterRedirects,n(i.urlAfterRedirects),s,r).pipe(X(t=>Object.assign(Object.assign({},i),{targetSnapshot:t}))))}(this.rootComponentType,this.config,t=>this.serializeUrl(t),this.paramsInheritanceStrategy,this.relativeLinkResolution),Yp(t=>{"eager"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(t.urlAfterRedirects,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects);const n=new uf(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);e.next(n)}));if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:s,source:r,restoredState:i,extras:a}=t,o=new rf(n,this.serializeUrl(s),r,i);e.next(o);const l=cm(s,this.rootComponentType).snapshot;return op(Object.assign(Object.assign({},t),{targetSnapshot:l,urlAfterRedirects:s,extras:Object.assign(Object.assign({},a),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=t.rawUrl,this.browserUrlTree=t.urlAfterRedirects,t.resolve(null),bp}),_g(t=>{const{targetSnapshot:e,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:i,replaceUrl:a}}=t;return this.hooks.beforePreactivation(e,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!i,replaceUrl:!!a})}),Yp(t=>{const e=new cf(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),X(t=>Object.assign(Object.assign({},t),{guards:lg(t.targetSnapshot,t.currentSnapshot,this.rootContexts)})),function(t,e){return ut(n=>{const{targetSnapshot:s,currentSnapshot:r,guards:{canActivateChecks:i,canDeactivateChecks:a}}=n;return 0===a.length&&0===i.length?op(Object.assign(Object.assign({},n),{guardsResult:!0})):function(t,e,n,s){return it(t).pipe(ut(t=>function(t,e,n,s,r){const i=e&&e.routeConfig?e.routeConfig.canDeactivate:null;return i&&0!==i.length?op(i.map(i=>{const a=ug(i,e,r);let o;if(function(t){return t&&Lm(t.canDeactivate)}(a))o=$f(a.canDeactivate(t,e,n,s));else{if(!Lm(a))throw new Error("Invalid CanDeactivate guard");o=$f(a(t,e,n,s))}return o.pipe(Xp())})).pipe(zm()):op(!0)}(t.component,t.route,n,e,s)),Xp(t=>!0!==t,!0))}(a,s,r,t).pipe(ut(n=>n&&"boolean"==typeof n?function(t,e,n,s){return it(e).pipe(Pp(e=>yp(function(t,e){return null!==t&&e&&e(new gf(t)),op(!0)}(e.route.parent,s),function(t,e){return null!==t&&e&&e(new bf(t)),op(!0)}(e.route,s),function(t,e,n){const s=e[e.length-1],r=e.slice(0,e.length-1).reverse().map(t=>function(t){const e=t.routeConfig?t.routeConfig.canActivateChild:null;return e&&0!==e.length?{node:t,guards:e}:null}(t)).filter(t=>null!==t).map(e=>wp(()=>op(e.guards.map(r=>{const i=ug(r,e.node,n);let a;if(function(t){return t&&Lm(t.canActivateChild)}(i))a=$f(i.canActivateChild(s,t));else{if(!Lm(i))throw new Error("Invalid CanActivateChild guard");a=$f(i(s,t))}return a.pipe(Xp())})).pipe(zm())));return op(r).pipe(zm())}(t,e.path,n),function(t,e,n){const s=e.routeConfig?e.routeConfig.canActivate:null;return s&&0!==s.length?op(s.map(s=>wp(()=>{const r=ug(s,e,n);let i;if(function(t){return t&&Lm(t.canActivate)}(r))i=$f(r.canActivate(e,t));else{if(!Lm(r))throw new Error("Invalid CanActivate guard");i=$f(r(e,t))}return i.pipe(Xp())}))).pipe(zm()):op(!0)}(t,e.route,n))),Xp(t=>!0!==t,!0))}(s,i,t,e):op(n)),X(t=>Object.assign(Object.assign({},n),{guardsResult:t})))})}(this.ngModule.injector,t=>this.triggerEvent(t)),Yp(t=>{if(Mm(t.guardsResult)){const e=Cf(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`);throw e.url=t.guardsResult,e}const e=new hf(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot,!!t.guardsResult);this.triggerEvent(e)}),Rp(t=>{if(!t.guardsResult){this.resetUrlToCurrentUrlTree();const n=new of(t.id,this.serializeUrl(t.extractedUrl),"");return e.next(n),t.resolve(!1),!1}return!0}),_g(t=>{if(t.guards.canActivateChecks.length)return op(t).pipe(Yp(t=>{const e=new df(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),_p(t=>{let n=!1;return op(t).pipe((s=this.paramsInheritanceStrategy,r=this.ngModule.injector,ut(t=>{const{targetSnapshot:e,guards:{canActivateChecks:n}}=t;if(!n.length)return op(t);let i=0;return it(n).pipe(Pp(t=>function(t,e,n,s){return function(t,e,n,s){const r=Object.keys(t);if(0===r.length)return op({});const i={};return it(r).pipe(ut(r=>function(t,e,n,s){const r=ug(t,e,s);return $f(r.resolve?r.resolve(e,n):r(e,n))}(t[r],e,n,s).pipe(Yp(t=>{i[r]=t}))),zp(1),ut(()=>Object.keys(i).length===r.length?op(i):bp))}(t._resolve,t,e,s).pipe(X(e=>(t._resolvedData=e,t.data=Object.assign(Object.assign({},t.data),dm(t,n).resolve),null)))}(t.route,e,s,r)),Yp(()=>i++),zp(1),ut(e=>i===n.length?op(t):bp))})),Yp({next:()=>n=!0,complete:()=>{if(!n){const n=new of(t.id,this.serializeUrl(t.extractedUrl),"At least one route resolver didn't emit any value.");e.next(n),t.resolve(!1)}}}));var s,r}),Yp(t=>{const e=new pf(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}))}),_g(t=>{const{targetSnapshot:e,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:i,replaceUrl:a}}=t;return this.hooks.afterPreactivation(e,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!i,replaceUrl:!!a})}),X(t=>{const e=function(t,e,n){const s=vm(t,e._root,n?n._root:void 0);return new um(s,e)}(this.routeReuseStrategy,t.targetSnapshot,t.currentRouterState);return Object.assign(Object.assign({},t),{targetRouterState:e})}),Yp(t=>{this.currentUrlTree=t.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.rawUrl),this.routerState=t.targetRouterState,"deferred"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),(r=this.rootContexts,i=this.routeReuseStrategy,a=t=>this.triggerEvent(t),X(t=>(new Om(i,t.targetRouterState,t.currentRouterState,a).activate(r),t))),Yp({next(){n=!0},complete(){n=!0}}),tf(()=>{if(!n&&!s){this.resetUrlToCurrentUrlTree();const n=new of(t.id,this.serializeUrl(t.extractedUrl),`Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);e.next(n),t.resolve(!1)}this.currentNavigation=null}),Dp(n=>{if(s=!0,(r=n)&&r.ngNavigationCancelingError){const s=Mm(n.url);s||(this.navigated=!0,this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl));const r=new of(t.id,this.serializeUrl(t.extractedUrl),n.message);e.next(r),s?setTimeout(()=>{const e=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(e,"imperative",null,{skipLocationChange:t.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:t.resolve,reject:t.reject,promise:t.promise})},0):t.resolve(!1)}else{this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl);const s=new lf(t.id,this.serializeUrl(t.extractedUrl),n);e.next(s);try{t.resolve(this.errorHandler(n))}catch(i){t.reject(i)}}var r;return bp}));var r,i,a}))}resetRootComponentType(t){this.rootComponentType=t,this.routerState.root.component=this.rootComponentType}getTransition(){const t=this.transitions.value;return t.urlAfterRedirects=this.browserUrlTree,t}setTransition(t){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),t))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(t=>{const e=this.extractLocationChangeInfoFromEvent(t);this.shouldScheduleNavigation(this.lastLocationChangeInfo,e)&&setTimeout(()=>{const{source:t,state:n,urlTree:s}=e,r={replaceUrl:!0};if(n){const t=Object.assign({},n);delete t.navigationId,0!==Object.keys(t).length&&(r.state=t)}this.scheduleNavigation(s,t,n,r)},0),this.lastLocationChangeInfo=e}))}extractLocationChangeInfoFromEvent(t){var e;return{source:"popstate"===t.type?"popstate":"hashchange",urlTree:this.parseUrl(t.url),state:(null===(e=t.state)||void 0===e?void 0:e.navigationId)?t.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(t,e){if(!t)return!0;const n=e.urlTree.toString()===t.urlTree.toString();return!(e.transitionId===t.transitionId&&n&&("hashchange"===e.source&&"popstate"===t.source||"popstate"===e.source&&"hashchange"===t.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(t){this.events.next(t)}resetConfig(t){Bm(t),this.config=t.map(jm),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(t,e={}){const{relativeTo:n,queryParams:s,fragment:r,queryParamsHandling:i,preserveFragment:a}=e,o=n||this.routerState.root,l=a?this.currentUrlTree.fragment:r;let u=null;switch(i){case"merge":u=Object.assign(Object.assign({},this.currentUrlTree.queryParams),s);break;case"preserve":u=this.currentUrlTree.queryParams;break;default:u=s||null}return null!==u&&(u=this.removeEmptyProps(u)),function(t,e,n,s,r){if(0===n.length)return km(e.root,e.root,e,s,r);const i=function(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new Sm(!0,0,t);let e=0,n=!1;const s=t.reduce((t,s,r)=>{if("object"==typeof s&&null!=s){if(s.outlets){const e={};return Af(s.outlets,(t,n)=>{e[n]="string"==typeof t?t.split("/"):t}),[...t,{outlets:e}]}if(s.segmentPath)return[...t,s.segmentPath]}return"string"!=typeof s?[...t,s]:0===r?(s.split("/").forEach((s,r)=>{0==r&&"."===s||(0==r&&""===s?n=!0:".."===s?e++:""!=s&&t.push(s))}),t):[...t,s]},[]);return new Sm(n,e,s)}(n);if(i.toRoot())return km(e.root,new zf([],{}),e,s,r);const a=function(t,e,n){if(t.isAbsolute)return new Im(e.root,!0,0);if(-1===n.snapshot._lastPathIndex){const t=n.snapshot._urlSegment;return new Im(t,t===e.root,0)}const s=_m(t.commands[0])?0:1;return function(t,e,n){let s=t,r=e,i=n;for(;i>r;){if(i-=r,s=s.parent,!s)throw new Error("Invalid number of '../'");r=s.segments.length}return new Im(s,!1,r-i)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+s,t.numberOfDoubleDots)}(i,e,t),o=a.processChildren?Nm(a.segmentGroup,a.index,i.commands):Em(a.segmentGroup,a.index,i.commands);return km(a.segmentGroup,o,e,s,r)}(o,this.currentUrlTree,t,u,null!=l?l:null)}navigateByUrl(t,e={skipLocationChange:!1}){const n=Mm(t)?t:this.parseUrl(t),s=this.urlHandlingStrategy.merge(n,this.rawUrlTree);return this.scheduleNavigation(s,"imperative",null,e)}navigate(t,e={skipLocationChange:!1}){return function(t){for(let e=0;e<t.length;e++){const n=t[e];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${e}`)}}(t),this.navigateByUrl(this.createUrlTree(t,e),e)}serializeUrl(t){return this.urlSerializer.serialize(t)}parseUrl(t){let e;try{e=this.urlSerializer.parse(t)}catch(n){e=this.malformedUriErrorHandler(n,this.urlSerializer,t)}return e}isActive(t,e){let n;if(n=!0===e?Object.assign({},$g):!1===e?Object.assign({},Rg):e,Mm(t))return Ff(this.currentUrlTree,t,n);const s=this.parseUrl(t);return Ff(this.currentUrlTree,s,n)}removeEmptyProps(t){return Object.keys(t).reduce((e,n)=>{const s=t[n];return null!=s&&(e[n]=s),e},{})}processNavigations(){this.navigations.subscribe(t=>{this.navigated=!0,this.lastSuccessfulId=t.id,this.events.next(new af(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,t.resolve(!0)},t=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(t,e,n,s,r){if(this.disposed)return Promise.resolve(!1);const i=this.getTransition(),a="imperative"!==e&&"imperative"===(null==i?void 0:i.source),o=(this.lastSuccessfulId===i.id||this.currentNavigation?i.rawUrl:i.urlAfterRedirects).toString()===t.toString();if(a&&o)return Promise.resolve(!0);let l,u,c;r?(l=r.resolve,u=r.reject,c=r.promise):c=new Promise((t,e)=>{l=t,u=e});const h=++this.navigationId;return this.setTransition({id:h,source:e,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:t,extras:s,resolve:l,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(t=>Promise.reject(t))}setBrowserUrl(t,e,n,s){const r=this.urlSerializer.serialize(t);s=s||{},this.location.isCurrentPathEqualTo(r)||e?this.location.replaceState(r,"",Object.assign(Object.assign({},s),{navigationId:n})):this.location.go(r,"",Object.assign(Object.assign({},s),{navigationId:n}))}resetStateAndUrl(t,e,n){this.routerState=t,this.currentUrlTree=e,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return t.\u0275fac=function(e){return new(e||t)(Os(ys),Os(Wf),Os(Ig),Os(Pc),Os(Oa),Os(pc),Os(Bu),Os(void 0))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),Fg=(()=>{class t{constructor(t,e,n,s,r){this.parentContexts=t,this.location=e,this.resolver=n,this.changeDetector=r,this.activated=null,this._activatedRoute=null,this.activateEvents=new ru,this.deactivateEvents=new ru,this.name=s||_f,t.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const t=this.parentContexts.getContext(this.name);t&&t.route&&(t.attachRef?this.attach(t.attachRef,t.route):this.activateWith(t.route,t.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const t=this.activated;return this.activated=null,this._activatedRoute=null,t}attach(t,e){this.activated=t,this._activatedRoute=e,this.location.insert(t.hostView)}deactivate(){if(this.activated){const t=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(t)}}activateWith(t,e){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=t;const n=(e=e||this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),s=this.parentContexts.getOrCreateContext(this.name).children,r=new Dg(t,s,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,r),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)(Xa(Ig),Xa(Vl),Xa(Qo),ds("name"),Xa(Nl))},t.\u0275dir=be({type:t,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),t})();class Dg{constructor(t,e,n){this.route=t,this.childContexts=e,this.parent=n}get(t,e){return t===hm?this.route:t===Ig?this.childContexts:this.parent.get(t,e)}}class Lg{}class Mg{preload(t,e){return op(null)}}let Pg=(()=>{class t{constructor(t,e,n,s,r){this.router=t,this.injector=s,this.preloadingStrategy=r,this.loader=new Cg(e,n,e=>t.triggerEvent(new ff(e)),e=>t.triggerEvent(new mf(e)))}setUpPreloading(){this.subscription=this.router.events.pipe(Rp(t=>t instanceof af),Pp(()=>this.preload())).subscribe(()=>{})}preload(){const t=this.injector.get(Ml);return this.processRoutes(t,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(t,e){const n=[];for(const s of e)if(s.loadChildren&&!s.canLoad&&s._loadedConfig){const t=s._loadedConfig;n.push(this.processRoutes(t.module,t.routes))}else s.loadChildren&&!s.canLoad?n.push(this.preloadConfig(t,s)):s.children&&n.push(this.processRoutes(t,s.children));return it(n).pipe(dt(),X(t=>{}))}preloadConfig(t,e){return this.preloadingStrategy.preload(e,()=>(e._loadedConfig?op(e._loadedConfig):this.loader.load(t.injector,e)).pipe(ut(t=>(e._loadedConfig=t,this.processRoutes(t.module,t.routes)))))}}return t.\u0275fac=function(e){return new(e||t)(Os(Og),Os(pc),Os(Bu),Os(Oa),Os(Lg))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),zg=(()=>{class t{constructor(t,e,n={}){this.router=t,this.viewportScroller=e,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(t=>{t instanceof rf?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=t.navigationTrigger,this.restoredId=t.restoredState?t.restoredState.navigationId:0):t instanceof af&&(this.lastId=t.id,this.scheduleScrollEvent(t,this.router.parseUrl(t.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(t=>{t instanceof wf&&(t.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(t.position):t.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(t.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(t,e){this.router.triggerEvent(new wf(t,"popstate"===this.lastSource?this.store[this.restoredId]:null,e))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Os(Og),Os(yh),Os(void 0))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const Vg=new ms("ROUTER_CONFIGURATION"),Bg=new ms("ROUTER_FORROOT_GUARD"),Wg=[Pc,{provide:Wf,useClass:Uf},{provide:Og,useFactory:function(t,e,n,s,r,i,a,o={},l,u){const c=new Og(null,t,e,n,s,r,i,Nf(a));return l&&(c.urlHandlingStrategy=l),u&&(c.routeReuseStrategy=u),function(t,e){t.errorHandler&&(e.errorHandler=t.errorHandler),t.malformedUriErrorHandler&&(e.malformedUriErrorHandler=t.malformedUriErrorHandler),t.onSameUrlNavigation&&(e.onSameUrlNavigation=t.onSameUrlNavigation),t.paramsInheritanceStrategy&&(e.paramsInheritanceStrategy=t.paramsInheritanceStrategy),t.relativeLinkResolution&&(e.relativeLinkResolution=t.relativeLinkResolution),t.urlUpdateStrategy&&(e.urlUpdateStrategy=t.urlUpdateStrategy)}(o,c),o.enableTracing&&c.events.subscribe(t=>{var e,n;null===(e=console.group)||void 0===e||e.call(console,`Router Event: ${t.constructor.name}`),console.log(t.toString()),console.log(t),null===(n=console.groupEnd)||void 0===n||n.call(console)}),c},deps:[Wf,Ig,Pc,Oa,pc,Bu,kg,Vg,[class{},new Ps],[class{},new Ps]]},Ig,{provide:hm,useFactory:function(t){return t.routerState.root},deps:[Og]},{provide:pc,useClass:gc},Pg,Mg,class{preload(t,e){return e().pipe(Dp(()=>op(null)))}},{provide:Vg,useValue:{enableTracing:!1}}];function Ug(){return new ac("Router",Og)}let jg=(()=>{class t{constructor(t,e){}static forRoot(e,n){return{ngModule:t,providers:[Wg,Kg(e),{provide:Bg,useFactory:qg,deps:[[Og,new Ps,new zs]]},{provide:Vg,useValue:n||{}},{provide:Oc,useFactory:Gg,deps:[Cc,[new Ms(Dc),new Ps],Vg]},{provide:zg,useFactory:Hg,deps:[Og,yh,Vg]},{provide:Lg,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:Mg},{provide:ac,multi:!0,useFactory:Ug},[Xg,{provide:ku,multi:!0,useFactory:Zg,deps:[Xg]},{provide:Qg,useFactory:Yg,deps:[Xg]},{provide:Au,multi:!0,useExisting:Qg}]]}}static forChild(e){return{ngModule:t,providers:[Kg(e)]}}}return t.\u0275fac=function(e){return new(e||t)(Os(Bg,8),Os(Og,8))},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})();function Hg(t,e,n){return n.scrollOffset&&e.setOffset(n.scrollOffset),new zg(t,e,n)}function Gg(t,e,n={}){return n.useHash?new Mc(t,e):new Lc(t,e)}function qg(t){return"guarded"}function Kg(t){return[{provide:gs,multi:!0,useValue:t},{provide:kg,multi:!0,useValue:t}]}let Xg=(()=>{class t{constructor(t){this.injector=t,this.initNavigation=!1,this.resultOfPreactivationDone=new G}appInitializer(){return this.injector.get(Ic,Promise.resolve(null)).then(()=>{let t=null;const e=new Promise(e=>t=e),n=this.injector.get(Og),s=this.injector.get(Vg);return"disabled"===s.initialNavigation?(n.setUpLocationChangeListener(),t(!0)):"enabled"===s.initialNavigation||"enabledBlocking"===s.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?op(null):(this.initNavigation=!0,t(!0),this.resultOfPreactivationDone),n.initialNavigation()):t(!0),e})}bootstrapListener(t){const e=this.injector.get(Vg),n=this.injector.get(Pg),s=this.injector.get(zg),r=this.injector.get(Og),i=this.injector.get(hc);t===i.components[0]&&("enabledNonBlocking"!==e.initialNavigation&&void 0!==e.initialNavigation||r.initialNavigation(),n.setUpPreloading(),s.init(),r.resetRootComponentType(i.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return t.\u0275fac=function(e){return new(e||t)(Os(Oa))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();function Zg(t){return t.appInitializer.bind(t)}function Yg(t){return t.bootstrapListener.bind(t)}const Qg=new ms("Router Initializer"),Jg=[];let ty=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[jg.forRoot(Jg)],jg]}),t})();function ey(t,e,n,s,r,i,a){try{var o=t[i](a),l=o.value}catch(u){return void n(u)}o.done?e(l):Promise.resolve(l).then(s,r)}function ny(t){return function(){var e=this,n=arguments;return new Promise(function(s,r){var i=t.apply(e,n);function a(t){ey(i,s,r,a,o,"next",t)}function o(t){ey(i,s,r,a,o,"throw",t)}a(void 0)})}}const sy={production:!0,mainURL:"https://isthistwice.herokuapp.com",modelURL:"https://isthistwice.herokuapp.com/models/ot9/model.json",LABELS:["Tzuyu","Chaeyoung","Dahyun","Mina","Jihyo","Sana","Momo","Jeongyeon","Nayeon"],colors:["Blue","Red","White","Mint","Apricot","Purple","Pink","Yellow-Green","Sky-Blue"],colorsRGB:["#0000ff","#ff0000","#FFFFFF","#3EB489","#FBCEB1","#800080","#FFC0CB","#9acd32","#87CEEB"]};class ry{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class iy{refCount(t){return ay("refCount")}incRef(t){return ay("incRef")}timerAvailable(){return!0}time(t){return ay("time")}read(t){return ay("read")}readSync(t){return ay("readSync")}numDataIds(){return ay("numDataIds")}disposeData(t,e){return ay("disposeData")}write(t,e,n){return ay("write")}move(t,e,n,s,r){return ay("move")}memory(){return ay("memory")}floatPrecision(){return ay("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return ay("dispose")}}function ay(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function oy(t){let e=t.length,n=0,s=0;for(;e>0;)s=Math.random()*e|0,e--,n=t[e],t[e]=t[s],t[s]=n}function ly(t,e,n){return Math.max(t,Math.min(e,n))}function uy(t){return t%2==0?t:t+1}function cy(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function hy(t,e,n=""){cy(my(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function dy(t){cy(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function py(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||Iy(t)&&!n)for(let s=0;s<t.length;++s)py(t[s],e,n);else e.push(t);return e}function fy(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function my(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function gy(t){return t%1==0}function yy(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function by(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function vy(t,e=(t=>0),n){return new Promise((s,r)=>{let i=0;const a=()=>{if(t())return void s();i++;const o=e(i);null!=n&&i>=n?r():setTimeout(a,o)};a()})}function wy(t,e){let n=1,s=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(-1===t[i]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(-1===s){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function _y(t,e){const n=e.length;return cy((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),cy(t.every(t=>gy(t)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(t=>t<0?n+t:t)}function xy(t,e){const n=[],s=[],r=null!=e&&Array.isArray(e)&&0===e.length,i=null==e||r?null:_y(e,t).sort();let a=0;for(let o=0;o<t.length;++o){if(null!=i){if(i[a]===o&&1!==t[o])throw new Error(`Can't squeeze axis ${o} since its dim '${t[o]}' is not 1`);(null==i[a]||i[a]>o)&&1===t[o]&&(n.push(t[o]),s.push(o)),i[a]<=o&&a++}1!==t[o]&&(n.push(t[o]),s.push(o))}return{newShape:n,keptDims:s}}function ky(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function Cy(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function Sy(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function Iy(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function Ey(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function Ny(t){return"string"==typeof t||t instanceof String}function Ty(t){return"number"==typeof t}function Ay(t){return Array.isArray(t)?Ay(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":Ty(t)?"float32":Ny(t)?"string":"boolean"==typeof t?"bool":"float32"}function $y(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Ry(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function Oy(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function Fy(t,e,n,s=!1){const r=new Array;if(1===e.length){const i=e[0]*(s?2:1);for(let e=0;e<i;e++)r[e]=n[t+e]}else{const i=e[0],a=e.slice(1),o=a.reduce((t,e)=>t*e)*(s?2:1);for(let e=0;e<i;e++)r[e]=Fy(t+e*o,a,n,s)}return r}function Dy(t,e,n=!1){if(0===t.length)return e[0];const s=t.reduce((t,e)=>t*e)*(n?2:1);if(0===s)return[];if(s!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Fy(0,t,e,n)}function Ly(t,e){const n=My(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function My(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Py(t,e){const n=t.reduce((t,e)=>t*e,1);if(null==e||"float32"===e)return Dy(t,new Float32Array(n));if("int32"===e)return Dy(t,new Int32Array(n));if("bool"===e)return Dy(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function zy(t){t.forEach(e=>{cy(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Vy(t,e,n){if(0===e)return 0;if(1===e)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function By(t,e,n){if(0===e)return[];if(1===e)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function Wy(t){return t&&t.then&&"function"==typeof t.then}class Uy{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=jy,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}getAsync(t){var e=this;return ny(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Wy(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function jy(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}function Hy(){return qy}let Gy,qy=null;function Ky(){if(null==Gy){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Gy=t}return Gy}function Xy(t,e){const n=function(){const t=Ky();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const Zy="Abs",Yy="Acos",Qy="Acosh",Jy="Add",tb="AddN",eb="All",nb="Any",sb="ArgMax",rb="ArgMin",ib="Asin",ab="Asinh",ob="Atan",lb="Atanh",ub="Atan2",cb="AvgPool",hb="AvgPoolGrad",db="AvgPool3D",pb="AvgPool3DGrad",fb="BatchMatMul",mb="BatchToSpaceND",gb="Bincount",yb="Cast",bb="Ceil",vb="ClipByValue",wb="Complex",_b="ComplexAbs",xb="Concat",kb="Conv2D",Cb="Conv2DBackpropFilter",Sb="Conv2DBackpropInput",Ib="Conv3D",Eb="Conv3DBackpropFilterV2",Nb="Conv3DBackpropInputV2",Tb="Cos",Ab="Cosh",$b="Cumsum",Rb="CropAndResize",Ob="DenseBincount",Fb="DepthToSpace",Db="DepthwiseConv2dNative",Lb="DepthwiseConv2dNativeBackpropFilter",Mb="DepthwiseConv2dNativeBackpropInput",Pb="Diag",zb="Dilation2D",Vb="Dilation2DBackpropInput",Bb="Dilation2DBackpropFilter",Wb="RealDiv",Ub="Einsum",jb="Elu",Hb="EluGrad",Gb="Erf",qb="Equal",Kb="Exp",Xb="ExpandDims",Zb="Expm1",Yb="FFT",Qb="Fill",Jb="FlipLeftRight",tv="Floor",ev="FloorDiv",nv="FusedBatchNorm",sv="GatherV2",rv="GatherNd",iv="Greater",av="GreaterEqual",ov="Identity",lv="IFFT",uv="Imag",cv="IsFinite",hv="IsInf",dv="IsNan",pv="LeakyRelu",fv="Less",mv="LessEqual",gv="LinSpace",yv="Log",bv="Log1p",vv="LogicalAnd",wv="LogicalNot",_v="LogicalOr",xv="LRN",kv="LRNGrad",Cv="Max",Sv="Maximum",Iv="MaxPool",Ev="MaxPoolGrad",Nv="MaxPool3D",Tv="MaxPool3DGrad",Av="MaxPoolWithArgmax",$v="Mean",Rv="Min",Ov="Minimum",Fv="MirrorPad",Dv="Mod",Lv="Multinomial",Mv="Multiply",Pv="Neg",zv="NotEqual",Vv="NonMaxSuppressionV3",Bv="NonMaxSuppressionV4",Wv="NonMaxSuppressionV5",Uv="OnesLike",jv="OneHot",Hv="Pack",Gv="PadV2",qv="Pow",Kv="Prelu",Xv="Prod",Zv="Range",Yv="Real",Qv="Reciprocal",Jv="Relu",tw="Reshape",ew="ResizeNearestNeighbor",nw="ResizeNearestNeighborGrad",sw="ResizeBilinear",rw="ResizeBilinearGrad",iw="Relu6",aw="Reverse",ow="Round",lw="Rsqrt",uw="ScatterNd",cw="Select",hw="Selu",dw="Slice",pw="Sin",fw="Sinh",mw="Sign",gw="Sigmoid",yw="Softplus",bw="Sqrt",vw="Sum",ww="SpaceToBatchND",_w="SplitV",xw="Softmax",kw="SparseFillEmptyRows",Cw="SparseReshape",Sw="SparseSegmentMean",Iw="SparseSegmentSum",Ew="SparseToDense",Nw="SquaredDifference",Tw="Square",Aw="StridedSlice",$w="StringNGrams",Rw="StringSplit",Ow="StringToHashBucketFast",Fw="Sub",Dw="Tan",Lw="Tanh",Mw="Tile",Pw="TopK",zw="Transform",Vw="Transpose",Bw="Unique",Ww="Unpack",Uw="UnsortedSegmentSum",jw="ZerosLike",Hw="Step",Gw="FromPixels",qw="RotateWithOffset",Kw="_FusedMatMul",Xw="FusedConv2D",Zw="FusedDepthwiseConv2D",Yw=Xy("kernelRegistry",()=>new Map),Qw=Xy("gradRegistry",()=>new Map);function Jw(t,e){const n=r_(t,e);return Yw.get(n)}function t_(t){return Qw.get(t)}function e_(t){const e=Yw.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===t&&n.push(a)}return n}function n_(t){const{kernelName:e,backendName:n}=t,s=r_(e,n);Yw.has(s)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),Yw.set(s,t)}function s_(t){const{kernelName:e}=t;Qw.has(e)&&Hy().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),Qw.set(e,t)}function r_(t,e){return`${e}_${t}`}var i_=n(929);const a_=n.n(i_)()||i_;function o_(t){return a_.fromString(t,!0,16)}const l_=o_("c3a5c85c97cb3127"),u_=o_("b492b66fbe98f273"),c_=o_("9ae16a3b2f90404f");function h_(t){return t.xor(t.shru(47))}function d_(t,e,n){const s=t.slice(e,e+n);return a_.fromBytes(Array.from(s),!0,!0)}function p_(t,e){return d_(t,e,8)}function f_(t,e){return d_(t,e,4)}function m_(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function g_(t,e,n=o_("9ddfea08eb382d69")){let s=t.xor(e).mul(n);s=s.xor(s.shru(47));let r=e.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function y_(t,e,n,s){return function(t,e,n,s,r,i){r=r.add(t),i=m_(i.add(r).add(s),21);const a=r;return r=(r=r.add(e)).add(n),i=i.add(m_(r,44)),[r.add(s),i.add(a)]}(p_(t,e),p_(t,e+8),p_(t,e+16),p_(t,e+24),n,s)}function b_(t,e=t.length){const n=a_.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=c_.add(2*e),s=p_(t,0).add(c_),r=p_(t,e-8);return g_(m_(r,37).mul(n).add(s),m_(s,25).add(r).mul(n),n)}if(e>=4){const n=c_.add(2*e);return g_(f_(t,0).shl(3).add(e),f_(t,e-4),n)}if(e>0){const n=e+(t[e-1]<<2);return h_(c_.mul(t[0]+(t[e>>1]<<8)).xor(l_.mul(n))).mul(c_)}return c_}(t,e):function(t,e=t.length){const n=c_.add(2*e),s=p_(t,0).mul(u_),r=p_(t,8),i=p_(t,e-8).mul(n),a=p_(t,e-16).mul(c_);return g_(m_(s.add(r),43).add(m_(i,30)).add(a),s.add(m_(r.add(c_),18)).add(i),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=c_.add(2*e),s=p_(t,0).mul(c_),r=p_(t,8),i=p_(t,e-8).mul(n),a=p_(t,e-16).mul(c_),o=m_(s.add(r),43).add(m_(i,30)).add(a),l=g_(o,s.add(m_(r.add(c_),18)).add(i),n),u=p_(t,16).mul(n),c=p_(t,24),h=o.add(p_(t,e-32)).mul(n),d=l.add(p_(t,e-24)).mul(n);return g_(m_(u.add(c),43).add(m_(h,30)).add(d),u.add(m_(c.add(s),18)).add(h),n)}(t,e);let s=n,r=n.mul(u_).add(113),i=h_(r.mul(c_).add(113)).mul(c_),a=[a_.UZERO,a_.UZERO],o=[a_.UZERO,a_.UZERO];s=s.mul(c_).add(p_(t,0));let l=0;const u=64*(e-1>>6),c=u+(e-1&63)-63;do{s=m_(s.add(r).add(a[0]).add(p_(t,l+8)),37).mul(u_),r=m_(r.add(a[1]).add(p_(t,l+48)),42).mul(u_),s=s.xor(o[1]),r=r.add(a[0]).add(p_(t,l+40)),i=m_(i.add(o[0]),33).mul(u_),a=y_(t,l,a[1].mul(u_),s.add(o[0])),o=y_(t,l+32,i.add(o[1]),r.add(p_(t,l+16))),[i,s]=[s,i],l+=64}while(l!==u);const h=u_.add(i.and(255).shl(1));return l=c,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=m_(s.add(r).add(a[0]).add(p_(t,l+8)),37).mul(h),r=m_(r.add(a[1]).add(p_(t,l+48)),42).mul(h),s=s.xor(o[1].mul(9)),r=r.add(a[0].mul(9).add(p_(t,l+40))),i=m_(i.add(o[0]),33).mul(h),a=y_(t,l,a[1].mul(h),s.add(o[0])),o=y_(t,l+32,i.add(o[1]),r.add(p_(t,l+16))),[i,s]=[s,i],g_(g_(a[0],o[0],h).add(h_(r).mul(l_)).add(i),g_(a[1],o[1],h).add(s),h)}function v_(t,e){return"string"===e?x_(t):w_([t],e)}function w_(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=py(t)),Hy().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function __(){return Hy().platform.now()}function x_(t,e="utf-8"){return e=e||"utf-8",Hy().platform.encode(t,e)}function k_(t,e="utf-8"){return e=e||"utf-8",Hy().platform.decode(t,e)}class C_{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new I_)}profileKernel(t,e,n){let s;const r=()=>{s=n()};let i;const a=__();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(r);else{r();for(const t of s)t.dataSync();i=Promise.resolve({kernelMs:__()-a})}if(Hy().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<s.length;o++){const e=s[o];e.data().then(n=>{S_(n,e.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:i.then(t=>t.kernelMs),extraInfo:i.then(t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:s,inputs:r,extraInfo:i}=t;n.forEach(t=>{Promise.all([t.data(),s,i]).then(n=>{this.logger.logKernelProfile(e,t,n[0],n[1],r,n[2])})})}}function S_(t,e,n){if("float32"!==e)return!1;for(let s=0;s<t.length;s++){const e=t[s];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}return!1}class I_{logKernelProfile(t,e,n,s,r,i){const a="number"==typeof s?by(`${s}ms`,9):s.error,o=by(t,25),l=e.rank,u=e.size,c=by(e.shape.toString(),14);let h="";for(const d in r){const t=r[d];if(null!=t){const n=t.shape||e.shape,s=n.length;h+=`${d}: ${s}D ${s>0?n:""} `}}console.log(`%c${o}\t%c${a}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function E_(t,e,n,s){const r=Oy(e),i=function(t,e,n,s){const r=fy(e),i=s[s.length-1],a=new Array(i).fill(0),o=e.length,l="complex64"===n?$_(t):t;if(o>1)for(let u=0;u<r/i;u++){const t=u*i;for(let e=0;e<i;e++)a[e]=Math.max(a[e],N_(l[t+e],0,n).length)}return a}(t,e,n,r),a=e.length,o=A_(t,e,n,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(t=>"    "+t).join("\n")),l.join("\n")}function N_(t,e,n){let s;return s=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:Ny(t)?`'${t}'`:"bool"===n?T_(t):parseFloat(t.toFixed(7)).toString(),by(s,e)}function T_(t){return 0===t?"false":"true"}function A_(t,e,n,s,r,i=!0){const a="complex64"===n?2:1,o=e[0],l=e.length;if(0===l)return"complex64"===n?[N_($_(t)[0],0,n)]:"bool"===n?[T_(t[0])]:[t[0].toString()];if(1===l){if(o>20){let e=Array.from(t.slice(0,3*a)),s=Array.from(t.slice((o-3)*a,o*a));return"complex64"===n&&(e=$_(e),s=$_(s)),["["+e.map((t,e)=>N_(t,r[e],n)).join(", ")+", ..., "+s.map((t,e)=>N_(t,r[o-3+e],n)).join(", ")+"]"]}return["["+("complex64"===n?$_(t):Array.from(t)).map((t,e)=>N_(t,r[e],n)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*a,d=[];if(o>20){for(let e=0;e<3;e++){const s=e*h;d.push(...A_(t.slice(s,s+h),u,n,c,r,!1))}d.push("...");for(let e=o-3;e<o;e++){const s=e*h;d.push(...A_(t.slice(s,s+h),u,n,c,r,e===o-1))}}else for(let m=0;m<o;m++){const e=m*h;d.push(...A_(t.slice(e,e+h),u,n,c,r,m===o-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function $_(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class R_{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=fy(t),null!=n){const t=n.length;cy(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Cy(e,this.size),this.strides=Oy(t)}set(t,...e){0===e.length&&(e=[0]),cy(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return O_().makeTensor(this.values,this.shape,this.dtype)}}let O_=null,F_=null,D_=null;class L_{constructor(t,e,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=fy(t),this.strides=Oy(t),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return ny(function*(){const e=yield t.data();return F_.buffer(t.shape,t.dtype,e)})()}bufferSync(){return F_.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return ny(function*(){const e=yield t.data();return Dy(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return Dy(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return ny(function*(){t.throwIfDisposed();const e=O_().read(t.dataId);if("string"===t.dtype){const t=yield e;try{return t.map(t=>k_(t))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataSync(){this.throwIfDisposed();const t=O_().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>k_(t))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return ny(function*(){t.throwIfDisposed();const e=yield O_().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(O_().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return F_.print(this,t)}clone(){return this.throwIfDisposed(),F_.clone(this)}toString(t=!1){return E_(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),F_.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),O_().makeVariable(this,t,e,n)}}function M_(){return Xy("Tensor",()=>L_)}Object.defineProperty(L_,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),M_();class P_ extends L_{constructor(t,e,n,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!my(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);O_().disposeTensor(this),this.dataId=t.dataId,O_().incRef(this,null)}dispose(){O_().disposeVariable(this),this.isDisposedInternal=!0}}var z_,V_,B_,W_,U_;Object.defineProperty(P_,Symbol.hasInstance,{value:t=>t instanceof L_&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(z_||(z_={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(V_||(V_={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(B_||(B_={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(W_||(W_={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(U_||(U_={}));const j_={float32:W_,int32:V_,bool:B_,complex64:U_};function H_(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return j_[t][e]}function G_(t){return H_(t,"int32")}function q_(t,e){if(t.dtype===e.dtype)return[t,e];const n=H_(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function K_(t,e){return e.some(e=>e.id===t.id)}function X_(t){const e=[];return Z_(t,e,new Set),e}function Z_(t,e,n){if(null==t)return;if(t instanceof L_)return void e.push(t);if(s=t,!Array.isArray(s)&&"object"!=typeof s)return;var s;const r=t;for(const i in r){const t=r[i];n.has(t)||(n.add(t),Z_(t,e,n))}}function Y_(t){return null!=t.kernelName}class Q_{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class J_{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Q_}ready(){var t=this;return ny(function*(){if(null!=t.pendingBackendInit)return t.pendingBackendInit.then(()=>{});if(null!=t.backendInstance)return;const e=t.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n];if(yield t.initializeBackend(s).success)return void(yield t.setBackend(s))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}setBackend(t){var e=this;return ny(function*(){if(null==e.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(e.backendName=t,null==e.registry[t]){e.backendInstance=null;const{success:n,asyncInit:s}=e.initializeBackend(t);if(!(s?yield n:n))return!1}return e.backendInstance=e.registry[t],e.setupRegisteredKernels(),e.profiler=new C_(e.backendInstance),!0})()}setupRegisteredKernels(){e_(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){e_(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof iy||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,s=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:s,asyncInit:r}=this.initializeBackend(n);if(r||s)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),s=n.backend,r=this.readSync(e),i=s.refCount(e);s.disposeData(e,!0),n.backend=t,t.move(e,r,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,s=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(s){throw e(),s}}nextTensorId(){return J_.nextTensorId++}nextVariableId(){return J_.nextVariableId++}clone(t){const e=ex.runKernel(ov,{x:t});return this.addTapeNode(this.state.activeScope.name,{x:t},[e],t=>({x:()=>ex.runKernel(yb,{x:t},{dtype:"float32"})}),[],{}),e}runKernel(t,e,n){if(null==Jw(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const s=this.backend.numDataIds();let r=0;n.forEach(t=>{r+="complex64"===t.dtype?3:1});const i=s-e-r-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const s=this.isTapeOn(),r=this.state.numBytes,i=this.state.numTensors;let a,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const l=Y_(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Y_(t)){const{kernelName:e,inputs:r,attrs:i}=t,l=Jw(e,this.backendName);cy(null!=l,()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`),a=()=>{const t=this.backend.numDataIds();o=l.kernelFunc({inputs:r,attrs:i,backend:this.backend});const a=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,a);const u=a.map(t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:s}=t;return this.makeTensorFromDataId(e,n,s)});if(s){const t=this.getTensorsForGradient(e,r,u);n=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:e}=t,r=t=>{s&&(n=t.map(t=>this.keep(this.clone(t))))};a=()=>{const t=this.backend.numDataIds();o=this.tidy(()=>e(this.backend,r));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:u,attrs:c}=t,h=Y_(t)?null:t.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=a()}),s&&this.addTapeNode(l,u,e,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(t=>null!=u[t]?u[t].shape:null),outputShapes:e.map(t=>t.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const s=t_(t);if(null!=s){const t=s.inputsToSave||[],r=s.outputsToSave||[];let i;s.saveAllInputs?(cy(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(t=>e[t])):i=t.map(t=>e[t]);const a=n.filter((t,e)=>r[e]);return i.concat(a)}return[]}makeTensor(t,e,n,s){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");s=s||this.backend;let r=t;"string"===(n=n||"float32")&&Ny(t[0])&&(r=t.map(t=>x_(t)));const i=s.write(r,e,n),a=new L_(e,n,i,this.nextTensorId());if(this.trackTensor(a,s),"string"===n){const t=this.state.tensorInfo.get(i),e=function(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}(r);this.state.numBytes+=e-t.bytes,t.bytes=e}return a}makeTensorFromDataId(t,e,n,s){const r=new L_(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(r,s),r}makeVariable(t,e=!0,n,s){n=n||this.nextVariableId().toString(),null!=s&&s!==t.dtype&&(t=t.cast(s));const r=new P_(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*Ey(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof P_||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*Ey(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}profile(t){var e=this;return ny(function*(){e.state.profiling=!0;const n=e.state.numBytes,s=e.state.numTensors;e.state.activeProfile.kernels=[],e.state.activeProfile.result=yield t(),e.state.profiling=!1,e.state.activeProfile.peakBytes=Math.max(...e.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),e.state.activeProfile.newBytes=e.state.numBytes-n,e.state.activeProfile.newTensors=e.state.numTensors-s;for(const t of e.state.activeProfile.kernels)t.kernelTimeMs=yield t.kernelTimeMs,t.extraInfo=yield t.extraInfo;return e.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,s,r,i){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:r},o=t_(t);null!=o&&(s=o.gradFunc),null!=s&&(a.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],s=My(t.size,t.dtype);return this.makeTensor(s,t.shape,t.dtype)}return t}),s(t.length>1?t:t[0],r,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=X_(t),n=new Set(e.map(t=>t.id));for(let r=0;r<this.state.activeScope.track.length;r++){const t=this.state.activeScope.track[r];t.kept||n.has(t.id)||t.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==s.id||this.track(t)})}gradients(t,e,n,s=!1){if(cy(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));cy(r instanceof L_,()=>"The result y returned by f() must be a tensor.");const i=function(t,e,n){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],i=n.inputs;for(const t in i){const a=i[t];let o=!1;for(let t=0;t<e.length;t++)if(s[a.id]){n.outputs.forEach(t=>s[t.id]=!0),o=!0,r[n.id]=!0;break}if(o)break}}const i={};i[n.id]=!0;const a={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(i[e.outputs[t].id]){for(const t in n)i[n[t].id]=!0,a[e.id]=!0;break}}const o=[];for(let l=0;l<t.length;l++){const e=t[l];if(r[e.id]&&a[e.id]){const t={};for(const r in e.inputs){const n=e.inputs[r];s[n.id]&&(t[r]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,o.push(n)}}return o}(this.state.activeTape,e,r);if(!s&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[r.id]=null==n?function(t){const e=Ly(fy(t),"float32");return ex.makeTensor(e,t,"float32")}(r.shape):n,function(t,e,n,s){for(let r=e.length-1;r>=0;r--){const i=e[r],a=[];if(i.outputs.forEach(e=>{const n=t[e.id];a.push(null!=n?n:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const e in i.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const r=n(()=>o[e]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${r.dtype}'`);const a=i.inputs[e];if(!my(r.shape,a.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${e}' has shape '${r.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=r;else{const e=t[a.id];t[a.id]=s(e,r),e.dispose()}}}}(t,i,t=>this.tidy(t),nx);const s=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:r,grads:s}})}customGrad(t){return cy($y(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;cy(e.every(t=>t instanceof L_),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return e.forEach((t,e)=>{s[e]=t}),this.runKernelFunc({forwardFunc:(s,r)=>(n=t(...e,r),cy(n.value instanceof L_,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),cy($y(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(t,s)=>{const r=n.gradFunc(t,s),i=Array.isArray(r)?r:[r];cy(i.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),cy(i.every(t=>t instanceof L_),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const a={};return i.forEach((t,e)=>{a[e]=()=>t}),a},inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}time(t){var e=this;return ny(function*(){const n=__(),s=yield e.backend.time(t);return s.wallMs=__()-n,s})()}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Q_;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function tx(){const t=Ky();if(null==t._tfengine){const e=new Uy(t);t._tfengine=new J_(e)}return function(t){qy=t}(t._tfengine.ENV),O_=()=>t._tfengine,t._tfengine}J_.nextTensorId=0,J_.nextVariableId=0;const ex=tx();function nx(t,e){return ex.runKernel(Jy,{a:t,b:e})}function sx(t){if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function rx(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ix=Hy();function ax(t,e){let n=t;if(Iy(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||Iy(n)&&"string"!==e;)s.push(n.length),n=n[0];return Array.isArray(t)&&Hy().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ox(t,s,[]),s}function ox(t,e,n){if(n=n||[],!Array.isArray(t)&&!Iy(t))return void cy(0===e.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);cy(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),cy(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)ox(t[r],s,n.concat(r))}function lx(t,e,n,s){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function ux(t,e,n,s="numeric"){if(t instanceof L_)return lx(s,t.dtype,e,n),t;let r=Ay(t);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),lx(s,r,e,n),null==t||!Iy(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const i=ax(t,r);Iy(t)||Array.isArray(t)||(t=[t]);const a="string"!==r?w_(t,r):py(t,[],!0);return ex.makeTensor(a,i,r)}function cx(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>ux(t,`${e}[${r}]`,n,s))}function hx(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...t)=>{ex.startScope(n);try{const e=s(...t);return Wy(e)&&console.error("Cannot return a Promise inside of tidy."),ex.endScope(e),e}catch(e){throw ex.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}ix.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ix.registerFlag("IS_BROWSER",()=>rx()),ix.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),ix.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ix.registerFlag("PROD",()=>!1),ix.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ix.getBool("DEBUG")),ix.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ix.registerFlag("IS_TEST",()=>!1),ix.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ix.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const dx=hx({complex_:function(t,e){const n=ux(t,"real","complex"),s=ux(e,"imag","complex");return hy(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`),ex.runKernel(wb,{real:n,imag:s})}});function px(t,e,n,s){if(null==s&&(s=Ay(t)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Iy(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){zy(e);const t=fy(e),s=fy(n);cy(t===s,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${s}`);for(let r=0;r<n.length;++r){const t=n[r],s=r!==n.length-1||t!==fy(e.slice(r));cy(n[r]===e[r]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return Iy(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==s?w_(t,s):py(t,[],!0),ex.makeTensor(t,e,s)}function fx(t,e,n){return px(t,e,ax(t,n),n)}const mx={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function gx(t,e){return yx.apply(this,arguments)}function yx(){return(yx=ny(function*(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let i=0;i<r.length;++i){const a=r[i],o=Array.isArray(t)?t[i].tensor:t[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const l={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const t=new Promise(function(){var t=ny(function*(t){const e=yield o.bytes(),n=e.reduce((t,e)=>t+e.length,0)+4*e.length,s=new Uint8Array(n);let r=0;for(let i=0;i<e.length;i++){const t=e[i],n=new Uint8Array(new Uint32Array([t.length]).buffer);s.set(n,r),r+=4,s.set(t,r),r+=t.length}t(s)});return function(e){return t.apply(this,arguments)}}());s.push(t)}else s.push(o.data());null!=e&&(l.group=e),n.push(l)}return{data:bx(yield Promise.all(s)),specs:n}})).apply(this,arguments)}function bx(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(t=>{s.set(new Uint8Array(t.buffer),r),r+=t.byteLength}),s.buffer}const vx="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function wx(t){return vx?Buffer.byteLength(t):new Blob([t]).size}function _x(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let s=0;return t.forEach(t=>{n.set(new Uint8Array(t),s),s+=t.byteLength}),n.buffer}function xx(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:wx(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:wx(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function kx(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let a=0;a<s.length;a++){const r=s[a];i[a]=t[n[r>>10]+(1023&r)]+e[r>>10]}return new Float32Array(r)}}class Cx{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Cx.instance&&(Cx.instance=new Cx),Cx.instance}static registerSaveRouter(t){Cx.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Cx.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Cx.getHandlers(t,"save")}static getLoadHandlers(t,e){return Cx.getHandlers(t,"load",e)}static getHandlers(t,e,n){const s=[];return("load"===e?Cx.getInstance().loadRouters:Cx.getInstance().saveRouters).forEach(e=>{const r=e(t,n);null!==r&&s.push(r)}),s}}const Sx=t=>Cx.getSaveHandlers(t),Ix="tensorflowjs",Ex="models_store",Nx="model_info_store";function Tx(){if(!Hy().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ax(t){const e=t.result;e.createObjectStore(Ex,{keyPath:"modelPath"}),e.createObjectStore(Nx,{keyPath:"modelPath"})}class $x{constructor(t){if(this.indexedDB=Tx(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}save(t){var e=this;return ny(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return e.databaseAction(e.modelPath,t)})()}load(){var t=this;return ny(function*(){return t.databaseAction(t.modelPath)})()}databaseAction(t,e){return new Promise((t,n)=>{const s=this.indexedDB.open(Ix,1);s.onupgradeneeded=()=>Ax(s),s.onsuccess=()=>{const r=s.result;if(null==e){const e=r.transaction(Ex,"readonly"),s=e.objectStore(Ex).get(this.modelPath);s.onsuccess=()=>{if(null==s.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(s.result.modelArtifacts)},s.onerror=t=>(r.close(),n(s.error)),e.oncomplete=()=>r.close()}else{const s=xx(e),i=r.transaction(Nx,"readwrite");let a=i.objectStore(Nx);const o=a.put({modelPath:this.modelPath,modelArtifactsInfo:s});let l;o.onsuccess=()=>{l=r.transaction(Ex,"readwrite");const o=l.objectStore(Ex).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:s});o.onsuccess=()=>t({modelArtifactsInfo:s}),o.onerror=t=>{a=i.objectStore(Nx);const e=a.delete(this.modelPath);e.onsuccess=()=>(r.close(),n(o.error)),e.onerror=t=>(r.close(),n(o.error))}},o.onerror=t=>(r.close(),n(o.error)),i.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}}},s.onerror=t=>n(s.error)})}}$x.URL_SCHEME="indexeddb://";const Rx=t=>{return Hy().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith($x.URL_SCHEME)?(e=t.slice($x.URL_SCHEME.length),new $x(e)):null;var e};Cx.registerSaveRouter(Rx),Cx.registerLoadRouter(Rx);class Ox{constructor(){this.indexedDB=Tx()}listModels(){var t=this;return ny(function*(){return new Promise((e,n)=>{const s=t.indexedDB.open(Ix,1);s.onupgradeneeded=()=>Ax(s),s.onsuccess=()=>{const t=s.result,r=t.transaction(Nx,"readonly"),i=r.objectStore(Nx).getAll();i.onsuccess=()=>{const t={};for(const e of i.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},i.onerror=e=>(t.close(),n(i.error)),r.oncomplete=()=>t.close()},s.onerror=t=>n(s.error)})})()}removeModel(t){var e=this;return ny(function*(){var n;return t=(n=t).startsWith($x.URL_SCHEME)?n.slice($x.URL_SCHEME.length):n,new Promise((n,s)=>{const r=e.indexedDB.open(Ix,1);r.onupgradeneeded=()=>Ax(r),r.onsuccess=()=>{const e=r.result,i=e.transaction(Nx,"readwrite"),a=i.objectStore(Nx),o=a.get(t);let l;o.onsuccess=()=>{if(null==o.result)return e.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=a.delete(t),i=()=>{l=e.transaction(Ex,"readwrite");const r=l.objectStore(Ex).delete(t);r.onsuccess=()=>n(o.result.modelArtifactsInfo),r.onerror=t=>s(o.error)};r.onsuccess=i,r.onerror=t=>(i(),e.close(),s(o.error))}},o.onerror=t=>(e.close(),s(o.error)),i.oncomplete=()=>{null==l?e.close():l.oncomplete=()=>e.close()}},r.onerror=t=>s(r.error)})})()}}const Fx="/",Dx="tensorflowjs_models",Lx="info",Mx="model_topology",Px="weight_specs",zx="weight_data",Vx="model_metadata";function Bx(t){return{info:[Dx,t,Lx].join(Fx),topology:[Dx,t,Mx].join(Fx),weightSpecs:[Dx,t,Px].join(Fx),weightData:[Dx,t,zx].join(Fx),modelMetadata:[Dx,t,Vx].join(Fx)}}function Wx(t){const e=t.split(Fx);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Fx)}class Ux{constructor(t){if(!Hy().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Bx(this.modelPath)}save(t){var e=this;return ny(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),i=xx(t);try{e.LS.setItem(e.keys.info,JSON.stringify(i)),e.LS.setItem(e.keys.topology,s),e.LS.setItem(e.keys.weightSpecs,r),e.LS.setItem(e.keys.weightData,function(t){if(vx)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}(t.weightData));const n={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),e.LS.setItem(e.keys.modelMetadata,JSON.stringify(n)),{modelArtifactsInfo:i}}catch(n){throw e.LS.removeItem(e.keys.info),e.LS.removeItem(e.keys.topology),e.LS.removeItem(e.keys.weightSpecs),e.LS.removeItem(e.keys.weightData),e.LS.removeItem(e.keys.modelMetadata),new Error(`Failed to save model '${e.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var t=this;return ny(function*(){const e=JSON.parse(t.LS.getItem(t.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${t.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(t.LS.getItem(t.keys.topology));if(null==s)throw new Error(`In local storage, the topology of model '${t.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(t.LS.getItem(t.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${t.modelPath}' are missing.`);n.weightSpecs=r;const i=t.LS.getItem(t.keys.modelMetadata);if(null!=i){const t=JSON.parse(i);n.format=t.format,n.generatedBy=t.generatedBy,n.convertedBy=t.convertedBy,null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer)}const a=t.LS.getItem(t.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${t.modelPath}' are missing.`);return n.weightData=function(t){if(vx){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}(a),n})()}}Ux.URL_SCHEME="localstorage://";const jx=t=>{return Hy().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Ux.URL_SCHEME)?(e=t.slice(Ux.URL_SCHEME.length),new Ux(e)):null;var e};Cx.registerSaveRouter(jx),Cx.registerLoadRouter(jx);class Hx{constructor(){cy(Hy().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),cy("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return ny(function*(){const e={},n=Dx+Fx,s=Fx+Lx;for(let r=0;r<t.LS.length;++r){const i=t.LS.key(r);i.startsWith(n)&&i.endsWith(s)&&(e[Wx(i)]=JSON.parse(t.LS.getItem(i)))}return e})()}removeModel(t){var e=this;return ny(function*(){var n;const s=Bx(t=(n=t).startsWith(Ux.URL_SCHEME)?n.slice(Ux.URL_SCHEME.length):n);if(null==e.LS.getItem(s.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(e.LS.getItem(s.info));return e.LS.removeItem(s.info),e.LS.removeItem(s.topology),e.LS.removeItem(s.weightSpecs),e.LS.removeItem(s.weightData),r})()}}class Gx{constructor(){this.managers={}}static getInstance(){return null==Gx.instance&&(Gx.instance=new Gx),Gx.instance}static registerManager(t,e){cy(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),cy(t.length>0,()=>"scheme must not be an empty string.");const n=Gx.getInstance();cy(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}class qx{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(Hy().get("IS_BROWSER")){Hy().setPlatform("browser",new qx);try{Gx.registerManager(Ux.URL_SCHEME,new Hx)}catch(D7){}try{Gx.registerManager($x.URL_SCHEME,new Ox)}catch(D7){}}let Kx;function Xx(t,e="float32",n){return e=e||"float32",zy(t),new R_(t,e,n)}Hy().get("IS_NODE")&&Hy().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Hy().global.fetch?Hy().global.fetch(t,e):(null==Kx&&(Kx=n(410)),Kx(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const Zx=hx({cast_:function(t,e){const n=ux(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return ex.runKernel(yb,{x:n},{dtype:e})}}),Yx=hx({clone_:function(t){const e=ux(t,"x","clone","string_or_numeric");return ex.runKernel(ov,{x:e})}});function Qx(t){return new Promise(t=>setTimeout(t)).then(t)}tx(),F_={buffer:Xx,cast:Zx,clone:Yx,print:function(t,e=!1){console.log(t.toString(e))}};class Jx{constructor(t){if(!Hy().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Jx.URL_SCHEME)&&(t=t.slice(Jx.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}save(t){var e=this;return ny(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./"+e.weightDataFileName],weights:t.weightSpecs}]};null!=t.signature&&(s.signature=t.signature),null!=t.userDefinedMetadata&&(s.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(s.modelInitializer=t.modelInitializer);const r=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),i=null==e.jsonAnchor?document.createElement("a"):e.jsonAnchor;if(i.download=e.modelTopologyFileName,i.href=r,yield Qx(()=>i.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==e.weightDataAnchor?document.createElement("a"):e.weightDataAnchor;t.download=e.weightDataFileName,t.href=n,yield Qx(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:xx(t)}}})()}}function tk(t,e,n,s){!function(t){cy(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){cy(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`),cy(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`),cy(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`)}(n=null==n?0:n,s=null==s?1:s);let r=0;return Promise.all(t.map(i=>(i.then(i=>{const a=n+ ++r/t.length*(s-n);return e(a),i}),i)))}function ek(t,e){return nk.apply(this,arguments)}function nk(){return(nk=ny(function*(t,e){null==e&&(e={});const n=null==e.fetchFunc?Hy().platform.fetch:e.fetchFunc,s=t.map(t=>n(t,e.requestInit,{isBinary:!0})),r=(null==e.onProgress?yield Promise.all(s):yield tk(s,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?yield Promise.all(r):yield tk(r,e.onProgress,.5,1)})).apply(this,arguments)}Jx.URL_SCHEME="downloads://",Cx.registerSaveRouter(t=>Hy().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Jx.URL_SCHEME)?function(t="model"){return new Jx(t)}(t.slice(Jx.URL_SCHEME.length)):null);class sk{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(cy("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=Hy().platform.fetch,cy(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&cy(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}save(t){var e=this;return ny(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:e.DEFAULT_METHOD},e.requestInit);n.body=new FormData;const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:t.weightSpecs}]};null!=t.signature&&(s.signature=t.signature),null!=t.userDefinedMetadata&&(s.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(s.modelInitializer=t.modelInitializer),n.body.append("model.json",new Blob([JSON.stringify(s)],{type:"application/json"}),"model.json"),null!=t.weightData&&n.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=yield e.fetch(e.path,n);if(r.ok)return{modelArtifactsInfo:xx(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)})()}load(){var t=this;return ny(function*(){const e=yield t.fetch(t.path,t.requestInit);if(!e.ok)throw new Error(`Request to ${t.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield e.json()}catch(f){let e=`Failed to parse model JSON of response from ${t.path}.`;throw t.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const s=n.modelTopology,r=n.weightsManifest,i=n.generatedBy,a=n.convertedBy,o=n.format,l=n.signature,u=n.userDefinedMetadata;if(null==s&&null==r)throw new Error(`The JSON from HTTP path ${t.path} contains neither model topology or manifest for weights.`);let c,h;if(null!=r){const e=yield t.loadWeights(r);[c,h]=e}const d={modelTopology:s,weightSpecs:c,weightData:h,generatedBy:i,convertedBy:a,format:o};null!=l&&(d.signature=l),null!=u&&(d.userDefinedMetadata=u);const p=n.modelInitializer;return p&&(d.modelInitializer=p),d})()}loadWeights(t){var e=this;return ny(function*(){const n=Array.isArray(e.path)?e.path[1]:e.path,[s,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(n),i=e.weightPathPrefix||s,a=[];for(const e of t)a.push(...e.weights);const o=[],l=[];for(const u of t)for(const t of u.paths)null!=e.weightUrlConverter?l.push(e.weightUrlConverter(t)):o.push(i+t+r);return e.weightUrlConverter&&o.push(...yield Promise.all(l)),[a,_x(yield ek(o,{requestInit:e.requestInit,fetchFunc:e.fetch,onProgress:e.onProgress}))]})()}}function rk(t){return null!=t.match(sk.URL_SCHEME_REGEX)}sk.URL_SCHEME_REGEX=/^https?:\/\//;const ik=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>rk(t)):rk(t),n)return ak(t,e)}return null};function ak(t,e){return new sk(t,e)}function ok(t,e){return ak(t,e)}let lk;function uk(){return(uk=ny(function*(t,e){let n=ux(t,"img","toPixels");if(!(t instanceof L_)){const t=n;n=Zx(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[s,r]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2];if(i>4||2===i)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${i}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const a=yield n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(r*s*4);for(let u=0;u<s*r;++u){const t=[0,0,0,255];for(let s=0;s<i;s++){const e=a[u*i+s];if("float32"===n.dtype){if(e<0||e>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${e}.`)}else if("int32"===n.dtype&&(e<0||e>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${e}.`);1===i?(t[0]=e*o,t[1]=e*o,t[2]=e*o):t[s]=e*o}const e=4*u;l[e+0]=Math.round(t[0]),l[e+1]=Math.round(t[1]),l[e+2]=Math.round(t[2]),l[e+3]=Math.round(t[3])}if(null!=e){e.width=r,e.height=s;const t=e.getContext("2d"),n=new ImageData(l,r,s);t.putImageData(n,0,0)}return n!==t&&n.dispose(),l})).apply(this,arguments)}Cx.registerSaveRouter(ik),Cx.registerLoadRouter(ik);const ck=hx({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,i=!1,a=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)s=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)i=!0;else if(null!=t.getContext)a=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);o=!0}if(r){const e=2;if(r&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Jw(Gw,ex.backendName))return ex.runKernel(Gw,{pixels:t},{numChannels:e});const[l,u]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let c,h;if(a?c=t.getContext("2d").getImageData(0,0,l,u).data:s||n?c=t.data:(i||r||o)&&(null==lk&&(lk=document.createElement("canvas").getContext("2d")),lk.canvas.width=l,lk.canvas.height=u,lk.drawImage(t,0,0,l,u),c=lk.getImageData(0,0,l,u).data),4===e)h=new Int32Array(c);else{const t=l*u;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=c[4*n+t]}return function(t,e,n){if(dy(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const s=ax(t,n);if(3!==s.length&&1!==s.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return px(t,e,s,n)}(h,[u,l,e],"int32")}});function hk(t,e,n){const s=t.shape.length;cy(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),cy(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)cy(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function dk(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function pk(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function fk(t,e,n,s){const r=[...t];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<n;i++)0===i?r[e]=1:(r.splice(e,0,1),r.pop());return r}function mk(t,e,n){return n<=t?n:n-(e-1)}function gk(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function yk(t,e,n,s,r,i,a,o,l){const u=t.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&n>0){const l=e[0],u=n+1;c=bk(a,l,u,s,t),h=vk(o,l,u,r,t),d=fk(i,l,u,t)}else for(let p=0;p<u;p++)c[p]=_k(a,s,i,t,p,l),h[p]=xk(o,r,i,t,p,l),d[p]=wk(i,p,l);return{begin:c,end:h,strides:d}}function bk(t,e,n,s,r){const i=[...r],a=gk(n,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const r=mk(e,n,o);let a=s[r];t&1<<r&&(a=0),i[o]=a}return i}function vk(t,e,n,s,r){const i=[...r],a=gk(n,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const r=mk(e,n,o);let a=s[r];t&1<<r&&(a=Number.MAX_SAFE_INTEGER),i[o]=a}for(let o=0;o<i.length;o++){const t=r[o];i[o]<0&&(i[o]+=t),i[o]=ly(0,i[o],r[o])}return i}function wk(t,e,n){let s=t[e];return(n&1<<e||null==s)&&(s=1),s}function _k(t,e,n,s,r,i){let a=e[r];(t&1<<r||i&1<<r||null==a)&&(a=(n[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const o=s[r];return a<0&&(a+=o),a=ly(0,a,o-1),a}function xk(t,e,n,s,r,i){let a=e[r];const o=n[r]||1;(t&1<<r||i&1<<r||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=o>0?ly(0,a,l):ly(-1,a,l-1),a}function kk(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function Ck(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function Sk(t,e,n){let s;const r=t.shape.length;let i;return s="number"==typeof e?[e,...new Array(r-1).fill(0)]:e.length<r?e.concat(new Array(r-e.length).fill(0)):e.slice(),s.forEach(t=>{cy(-1!==t,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,i=i.map((e,n)=>e>=0?e:(cy(-1===e,()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`),t.shape[n]-s[n])),[s,i]}function Ik(t,e,n,s,r,i,a,o,l){let u=e.slice(),c=n.slice(),h=s;null==s&&(h=new Array(u.length));const d=dk(a);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==a&&0!==o)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==a&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=t.length-u.length,f=dk(o),m=t.slice();f.forEach(t=>{u[t]=0,c[t]=1,m.splice(t,0,1)});const{begin:g,end:y,strides:b}=yk(m,d,p,u,c,h,r,i,a);u=g,c=y,h=b;const v=dk(l);v.forEach(t=>{c[t]=u[t]+1,h[t]=1});const w=pk(u,c,h),_=w.filter((t,e)=>-1===v.indexOf(e));return{nonStrided:h.every(t=>1===t),$begin:u,$end:c,$strides:h,size:w,newShape:m,outShape:_}}class Ek{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Nk{constructor(){this.classNameMap={}}static getMap(){return null==Nk.instance&&(Nk.instance=new Nk),Nk.instance}static register(t){Nk.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Tk(t){cy(null!=t.className,()=>"Class being registered does not have the static className property defined."),cy("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),cy(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Nk.register(t)}function Ak(){return ex}function $k(){return ex.memory()}function Rk(t,e){return ex.tidy(t,e)}function Ok(t){X_(t).forEach(t=>t.dispose())}function Fk(t){return ex.keep(t)}function Dk(t,e,n=1){return ex.registerBackend(t,e,n)}function Lk(t){return ex.customGrad(t)}function Mk(t,e){if((Iy(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&Iy(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return px(t,[],[],e)}D_=function(t){Hy().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class Pk extends Ek{minimize(t,e=!1,n){const{value:s,grads:r}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:r[t.name]}));this.applyGradients(t)}else this.applyGradients(r);return Ok(r),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){cy($y(t),()=>"The f passed in variableGrads(f) must be a function"),cy(null==e||Array.isArray(e)&&e.every(t=>t instanceof P_),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in ex.registeredVariables)e.push(ex.registeredVariables[t])}const s=n?e.filter(t=>!t.trainable):null,r=e.length;cy((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:i,grads:a}=ex.gradients(t,e,null,!0);cy(a.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),cy(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const o={};return e.forEach((t,e)=>{null!=a[e]&&(o[t.name]=a[e])}),null!=s&&s.forEach(t=>o[t.name]=null),{value:i,grads:o}}(t,e)}dispose(){null!=this.iterations_&&Ok(this.iterations_)}saveIterations(){var t=this;return ny(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Mk(t.iterations_,"int32")}})()}getWeights(){return ny(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return ny(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return ny(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(Pk,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const zk=hx({abs_:function(t){const e=ux(t,"x","abs");return ex.runKernel("complex64"===e.dtype?_b:Zy,{x:e})}}),Vk=hx({add_:function(t,e){let n=ux(t,"a","add"),s=ux(e,"b","add");return[n,s]=q_(n,s),ex.runKernel(Jy,{a:n,b:s})}}),Bk=hx({all_:function(t,e=null,n=!1){const s=ux(t,"x","all","bool");return ex.runKernel(eb,{x:s},{axis:e,keepDims:n})}}),Wk=hx({any_:function(t,e=null,n=!1){const s=ux(t,"x","any","bool");return ex.runKernel(nb,{x:s},{axis:e,keepDims:n})}}),Uk=hx({argMax_:function(t,e=0){const n=ux(t,"x","argMax");return ex.runKernel(sb,{x:n},{axis:e})}});function jk(t,e,n,s,r="NHWC",i){return qk(t,[...e,t[3]],n,i,s,null,null,nC(r))}function Hk(t,e,n,s,r,i,a="channelsLast"){const[o,l]=Zk(e);let u;if("channelsLast"===a)u=[o,l,t[3],t[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);u=[o,l,t[1],t[1]]}return qk(t,u,n,s,r,i,!1,a)}function Gk(t,e,n,s,r,i,a="NDHWC"){const[o,l,u]=Yk(e);let c,h;if("NDHWC"===a)h="channelsLast",c=[o,l,u,t[4],t[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);h="channelsFirst",c=[o,l,u,t[1],t[1]]}return Kk(t,c,n,s,r,!1,h,i)}function qk(t,e,n,s,r,i,a=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=t}const[d,p,,f]=e,[m,g]=Zk(n),[y,b]=Zk(s),v=Qk(d,y),w=Qk(p,b),{padInfo:_,outHeight:x,outWidth:k}=function(t,e,n,s,r,i,a,o,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const r=function(t,e,n,s,r){null==s&&(s=Xk(t,e,n));const i=t[1];return[Jk((t[0]-e+2*s)/n+1,r),Jk((i-e+2*s)/n+1,r)]}([e,n],i,s,t,o);c=r[0],h=r[1]}else if("same"===t){c=Math.ceil(e/s),h=Math.ceil(n/r);const t=Math.max(0,(c-1)*s+i-e),o=Math.max(0,(h-1)*r+a-n),l=Math.floor(t/2),d=t-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/s),h=Math.ceil((n-a+1)/r);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Jk((e-i+d+p)/s+1,o),h=Jk((n-a+f+m)/r+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(r,u,c,m,g,v,w,i,o),C=a?f*h:f;let S;return"channelsFirst"===o?S=[l,C,x,k]:"channelsLast"===o&&(S=[l,x,k,C]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:x,outWidth:k,outChannels:C,padInfo:_,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:t,outShape:S,filterShape:e}}function Kk(t,e,n,s,r,i=!1,a="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c,h]=t}const[p,f,m,,g]=e,[y,b,v]=Yk(n),[w,_,x]=Yk(s),k=Qk(p,w),C=Qk(f,_),S=Qk(m,x),{padInfo:I,outDepth:E,outHeight:N,outWidth:T}=function(t,e,n,s,r,i,a,o,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,s,r,i){null==r&&(r=Xk(t,e,s));const a=t[1],o=t[2];return[Jk((t[0]-e+2*r)/s+1,i),Jk((a-e+2*r)/s+1,i),Jk((o-e+2*r)/s+1,i),1]}([e,n,s,1],o,0,r,t,c);d=i[0],p=i[1],f=i[2]}else if("same"===t){d=Math.ceil(e/r),p=Math.ceil(n/i),f=Math.ceil(s/a);const t=(d-1)*r+o-e,c=(p-1)*i+l-n,m=(f-1)*a+u-s,g=Math.floor(t/2),y=t-g,b=Math.floor(c/2),v=c-b,w=Math.floor(m/2);h={top:b,bottom:v,left:w,right:m-w,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-o+1)/r),p=Math.ceil((n-l+1)/i),f=Math.ceil((s-u+1)/a)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,u,c,h,y,b,v,k,C,S,o),A=i?g*d:g;let $;return"channelsFirst"===a?$=[l,A,E,N,T]:"channelsLast"===a&&($=[l,E,N,T,A]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:E,outHeight:N,outWidth:T,outChannels:A,padInfo:I,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:S,dilationDepth:w,dilationHeight:_,dilationWidth:x,inShape:t,outShape:$,filterShape:e}}function Xk(t,e,n,s=1){const r=Qk(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function Zk(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function Yk(t){return"number"==typeof t?[t,t,t]:t}function Qk(t,e){return e<=1?t:t+(t-1)*(e-1)}function Jk(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function tC(t){const[e,n,s]=Zk(t);return 1===e&&1===n&&1===s}function eC(t,e){return tC(t)||tC(e)}function nC(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const sC=hx({reshape_:function(t,e){const n=ux(t,"x","reshape","string_or_numeric");return ex.runKernel(tw,{x:n},{shape:e})}}),rC=hx({avgPool_:function(t,e,n,s,r){const i=ux(t,"x","avgPool","float32");cy(eC(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let a=i,o=!1;3===i.rank&&(o=!0,a=sC(i,[1,i.shape[0],i.shape[1],i.shape[2]])),cy(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),null!=r&&cy(gy(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let l=ex.runKernel(cb,{x:a},{filterSize:e,strides:n,pad:s,dimRoundingMode:r});return l=Zx(l,i.dtype),o?sC(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),iC=hx({avgPool3d_:function(t,e,n,s,r,i="NDHWC"){const a=ux(t,"x","avgPool3d","float32");let o=a,l=!1;4===a.rank&&(l=!0,o=sC(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),cy(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),cy("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=r&&cy(gy(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let u=ex.runKernel(db,{x:o},{filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i});return u=Zx(u,o.dtype),l?sC(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),aC=hx({batchNorm_:function(t,e,n,s,r,i){null==i&&(i=.001);const a=ux(t,"x","batchNorm"),o=ux(e,"mean","batchNorm"),l=ux(n,"variance","batchNorm");let u,c;null!=r&&(u=ux(r,"scale","batchNorm")),null!=s&&(c=ux(s,"offset","batchNorm")),cy(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),cy(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),cy(null==u||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(t){let e;return e=0===t.rank||1===t.rank?sC(t,[1,1,1,t.size]):2===t.rank?sC(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?sC(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(a),d=ex.runKernel(nv,{x:h,scale:u,offset:c,mean:o,variance:l},{varianceEpsilon:i});return sC(d,a.shape)}}),oC=hx({batchNorm2d_:function(t,e,n,s,r,i){const a=ux(t,"x","batchNorm"),o=ux(e,"mean","batchNorm"),l=ux(n,"variance","batchNorm");let u,c;return null!=r&&(u=ux(r,"scale","batchNorm")),null!=s&&(c=ux(s,"offset","batchNorm")),cy(2===a.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),cy(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),cy(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&cy(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&cy(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),aC(a,o,l,c,u,i)}}),lC=hx({batchNorm3d_:function(t,e,n,s,r,i){const a=ux(t,"x","batchNorm"),o=ux(e,"mean","batchNorm"),l=ux(n,"variance","batchNorm");let u,c;return null!=r&&(u=ux(r,"scale","batchNorm")),null!=s&&(c=ux(s,"offset","batchNorm")),cy(3===a.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),cy(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),cy(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&cy(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&cy(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),aC(a,o,l,c,u,i)}}),uC=hx({batchNorm4d_:function(t,e,n,s,r,i){const a=ux(t,"x","batchNorm"),o=ux(e,"mean","batchNorm"),l=ux(n,"variance","batchNorm");let u,c;return null!=r&&(u=ux(r,"scale","batchNorm")),null!=s&&(c=ux(s,"offset","batchNorm")),cy(4===a.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),cy(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),cy(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&cy(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&cy(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),aC(a,o,l,c,u,i)}}),cC=hx({clipByValue_:function(t,e,n){const s=ux(t,"x","clipByValue");return cy(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),ex.runKernel(vb,{x:s},{clipValueMin:e,clipValueMax:n})}}),hC=hx({concat_:function(t,e=0){cy(t.length>=1,()=>"Pass at least one tensor to concat");const n=cx(t,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}),1===n.length?Yx(n[0]):ex.runKernel(xb,n,{axis:e})}}),dC=hx({concat1d_:function(t){return hC(t,0)}}),pC=hx({concat2d_:function(t,e){return hC(t,e)}}),fC=hx({concat3d_:function(t,e){return hC(t,e)}}),mC=hx({concat4d_:function(t,e){return hC(t,e)}}),gC=hx({conv2d_:function(t,e,n,s,r="NHWC",i=[1,1],a){const o=ux(t,"x","conv2d"),l=ux(e,"filter","conv2d");let u=o,c=!1;3===o.rank&&(c=!0,u=sC(o,[1,o.shape[0],o.shape[1],o.shape[2]])),cy(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),cy(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=a&&cy(gy(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const h="NHWC"===r?u.shape[3]:u.shape[1];cy(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),cy(eC(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const d=ex.runKernel(kb,{x:u,filter:l},{strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a});return c?sC(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),yC=hx({conv1d_:function(t,e,n,s,r="NWC",i=1,a){const o=ux(t,"x","conv1d"),l=ux(e,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=sC(o,[1,o.shape[0],o.shape[1]])),cy(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),cy(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=a&&cy(gy(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),cy(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),cy(eC(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),cy("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=sC(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=sC(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=gC(d,h,[1,n],s,"NHWC",[1,i],a);return sC(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),bC=hx({conv2DBackpropInput_:function(t,e,n,s,r,i="NHWC",a){cy(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,l=e,u=!1;3===e.rank&&(u=!0,l=sC(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),cy(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),cy(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),cy(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===i?o[3]:o[1],h="NHWC"===i?l.shape[3]:l.shape[1];cy(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),cy(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=a&&cy(gy(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const d=ex.runKernel(Sb,{dy:l,filter:n},{strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o});return u?sC(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),vC=hx({conv2dTranspose_:function(t,e,n,s,r,i){const a=ux(t,"x","conv2dTranspose"),o=ux(e,"filter","conv2dTranspose");return bC(n,a,o,s,r,"NHWC",i)}}),wC=hx({conv3d_:function(t,e,n,s,r="NDHWC",i=[1,1,1]){const a=ux(t,"x","conv3d"),o=ux(e,"filter","conv3d");let l=a,u=!1;4===a.rank&&(u=!0,l=sC(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),cy(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),cy(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),cy(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),cy(eC(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),cy("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const c=ex.runKernel(Ib,{x:l,filter:o},{strides:n,pad:s,dataFormat:r,dilations:i});return u?sC(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),_C=hx({conv3DBackpropInput_:function(t,e,n,s,r){cy(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,a=e,o=!1;4===e.rank&&(o=!0,a=sC(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=a.shape[4];cy(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),cy(5===a.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),cy(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),cy(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),cy(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c=ex.runKernel(Nb,{dy:a,filter:n},{pad:r,strides:s,inputShape:i});return o?sC(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),xC=hx({conv3dTranspose_:function(t,e,n,s,r){const i=ux(t,"x","conv3dTranspose"),a=ux(e,"filter","conv3dTranspose");return _C(n,i,a,s,r)}}),kC=hx({depthwiseConv2d_:function(t,e,n,s,r="NHWC",i=[1,1],a){const o=ux(t,"x","depthwiseConv2d"),l=ux(e,"filter","depthwiseConv2d");let u=o,c=!1;3===o.rank&&(c=!0,u=sC(o,[1,o.shape[0],o.shape[1],o.shape[2]])),cy(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),cy(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),cy(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=a&&cy(gy(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const h=ex.runKernel(Db,{x:u,filter:l},{strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a});return c?sC(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),CC=hx({floorDiv_:function(t,e){let n=ux(t,"a","floorDiv"),s=ux(e,"b","floorDiv");return[n,s]=q_(n,s),ex.runKernel(ev,{a:n,b:s})}}),SC=hx({div_:function(t,e){let n=ux(t,"a","div"),s=ux(e,"b","div");return[n,s]=q_(n,s),"int32"===n.dtype&&"int32"===s.dtype?CC(n,s):ex.runKernel(Wb,{a:n,b:s},{})}}),IC=hx({elu_:function(t){const e=ux(t,"x","elu");return ex.runKernel(jb,{x:e})}});function EC(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const i=n-1-r,a=t[i]||1;(e[e.length-1-r]||1)>1&&1===a&&s.unshift(i)}return s}function NC(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],i=e.length-s-1,a=e[i];(null==r||1===r&&a>1)&&n.unshift(i)}return n}function TC(t,e){const n=[],s=Math.max(t.length,e.length);for(let r=0;r<s;r++){let s=t[t.length-r-1];null==s&&(s=1);let i=e[e.length-r-1];if(null==i&&(i=1),1===s)n.unshift(i);else if(1===i)n.unshift(s);else{if(s!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(s)}}return n}const AC=hx({equal_:function(t,e){let n=ux(t,"a","equal","string_or_numeric"),s=ux(e,"b","equal","string_or_numeric");return[n,s]=q_(n,s),TC(n.shape,s.shape),ex.runKernel(qb,{a:n,b:s})}}),$C=hx({expandDims_:function(t,e=0){const n=ux(t,"x","expandDims","string_or_numeric");return cy(e<=n.rank,()=>"Axis must be <= rank of the tensor"),ex.runKernel(Xb,{input:n},{dim:e})}}),RC=hx({tile_:function(t,e){const n=ux(t,"x","tile","string_or_numeric");return cy(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`),ex.runKernel(Mw,{x:n},{reps:e})}}),OC=hx({eye_:function(t,e,n,s="float32"){null==e&&(e=t);const r=Xx([t,e],s),i=t<=e?t:e;for(let o=0;o<i;++o)r.set(1,o,o);const a=sC(r.toTensor(),[t,e]);if(null==n)return a;if(1===n.length)return RC($C(a,0),[n[0],1,1]);if(2===n.length)return RC($C($C(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return RC($C($C($C(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function FC(t,e,n){return ex.runKernel(Qb,{},{shape:t,value:e,dtype:n})}const DC=hx({floor_:function(t){const e=ux(t,"x","floor");return ex.runKernel(tv,{x:e})}}),LC=hx({gather_:function(t,e,n=0,s=0){const r=ux(t,"x","gather"),i=ux(e,"indices","gather","int32");return ex.runKernel(sv,{x:r,indices:i},{axis:n,batchDims:s})}}),MC=hx({greater_:function(t,e){let n=ux(t,"a","greater","string_or_numeric"),s=ux(e,"b","greater","string_or_numeric");return[n,s]=q_(n,s),TC(n.shape,s.shape),ex.runKernel(iv,{a:n,b:s})}}),PC=hx({greaterEqual_:function(t,e){let n=ux(t,"a","greaterEqual","string_or_numeric"),s=ux(e,"b","greaterEqual","string_or_numeric");return[n,s]=q_(n,s),TC(n.shape,s.shape),ex.runKernel(av,{a:n,b:s})}}),zC=hx({leakyRelu_:function(t,e=.2){const n=ux(t,"x","leakyRelu");return ex.runKernel(pv,{x:n},{alpha:e})}}),VC=hx({log_:function(t){const e=ux(t,"x","log");return ex.runKernel(yv,{x:e})}}),BC=hx({exp_:function(t){const e=ux(t,"x","exp");return ex.runKernel(Kb,{x:e})}}),WC=hx({max_:function(t,e=null,n=!1){const s=ux(t,"x","max");return ex.runKernel(Cv,{x:s},{reductionIndices:e,keepDims:n})}}),UC=hx({mul_:function(t,e){let n=ux(t,"a","mul"),s=ux(e,"b","mul");return[n,s]=q_(n,s),ex.runKernel(Mv,{a:n,b:s})}}),jC=hx({sub_:function(t,e){let n=ux(t,"a","sub"),s=ux(e,"b","sub");return[n,s]=q_(n,s),ex.runKernel(Fw,{a:n,b:s})}}),HC=hx({sum_:function(t,e=null,n=!1){let s=ux(t,"x","sum");return"bool"===s.dtype&&(s=Zx(s,"int32")),ex.runKernel(vw,{x:s},{axis:e,keepDims:n})}}),GC=hx({logSoftmax_:function(t,e=-1){const n=ux(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Lk((t,n)=>{const s=WC(t,e,!0),r=jC(t,s),i=jC(Zx(r,"float32"),VC(HC(BC(r),e,!0)));return n([i]),{value:i,gradFunc:(t,n)=>{const[s]=n,r=BC(s);return jC(t,UC(HC(t,e,!0),r))}}})(n)}}),qC=hx({logicalAnd_:function(t,e){const n=ux(t,"a","logicalAnd","bool"),s=ux(e,"b","logicalAnd","bool");return TC(n.shape,s.shape),ex.runKernel(vv,{a:n,b:s})}}),KC=hx({maxPool_:function(t,e,n,s,r){const i=ux(t,"x","maxPool");let a=i,o=!1;3===i.rank&&(o=!0,a=sC(i,[1,i.shape[0],i.shape[1],i.shape[2]])),cy(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),cy(eC(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=r&&cy(gy(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l=ex.runKernel(Iv,{x:a},{filterSize:e,strides:n,pad:s,dimRoundingMode:r});return o?sC(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),XC=hx({maxPool3d_:function(t,e=[1,1,1],n,s,r,i="NDHWC"){const a=ux(t,"x","maxPool3d");let o=a,l=!1;4===a.rank&&(l=!0,o=sC(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),cy(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),cy("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=r&&cy(gy(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const u=ex.runKernel(Nv,{x:o},{filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i});return l?sC(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),ZC=hx({maximum_:function(t,e){let n=ux(t,"a","maximum"),s=ux(e,"b","maximum");return[n,s]=q_(n,s),"bool"===n.dtype&&(n=Zx(n,"int32"),s=Zx(s,"int32")),TC(n.shape,s.shape),ex.runKernel(Sv,{a:n,b:s})}}),YC=hx({mean_:function(t,e=null,n=!1){const s=ux(t,"x","mean");return ex.runKernel($v,{x:s},{axis:e,keepDims:n})}}),QC=hx({minimum_:function(t,e){let n=ux(t,"a","minimum"),s=ux(e,"b","minimum");return[n,s]=q_(n,s),"bool"===n.dtype&&(n=Zx(n,"int32"),s=Zx(s,"int32")),TC(n.shape,s.shape),ex.runKernel(Ov,{a:n,b:s})}});function JC(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function tS(t,e,n){const s=t.length+e.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)-1===n.indexOf(o)?r.push(t[i++]):r.push(e[a++]);return r}function eS(t,e){const n=[],s=t.length;for(let r=0;r<s;r++)-1===e.indexOf(r)&&n.push(t[r]);return[n,e.map(e=>t[e])]}function nS(t,e){return tS(t,e.map(t=>1),e)}function sS(t,e,n){cy(JC(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function rS(t,e){if(JC(t,e))return null;const n=[];for(let s=0;s<e;++s)-1===t.indexOf(s)&&n.push(s);return t.forEach(t=>n.push(t)),n}function iS(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function aS(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}const oS=hx({square_:function(t){const e=ux(t,"x","square");return ex.runKernel("Square",{x:e},{})}}),lS=hx({moments_:function(t,e=null,n=!1){const s=_y(e,(t=ux(t,"x","moments")).shape),r=YC(t,s,n);let i=r.shape;n||(i=nS(r.shape,s));const a=oS(jC(Zx(t,"float32"),sC(r,i)));return{mean:r,variance:YC(a,s,n)}}}),uS=hx({neg_:function(t){const e=ux(t,"x","neg");return ex.runKernel(Pv,{x:e})}}),cS=hx({notEqual_:function(t,e){let n=ux(t,"a","notEqual","string_or_numeric"),s=ux(e,"b","notEqual","string_or_numeric");return[n,s]=q_(n,s),TC(n.shape,s.shape),ex.runKernel(zv,{a:n,b:s})}}),hS=hx({oneHot_:function(t,e,n=1,s=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const r=ux(t,"indices","oneHot","int32");return ex.runKernel(jv,{indices:r},{depth:e,onValue:n,offValue:s})}});function dS(t,e="float32"){if("complex64"===e){const e=dS(t,"float32"),n=dS(t,"float32");return dx(e,n)}const n=My(fy(t),e);return ex.makeTensor(n,t,e)}function pS(t,e="float32"){if("complex64"===e){const e=pS(t,"float32"),n=dS(t,"float32");return dx(e,n)}const n=Ly(fy(t),e);return ex.makeTensor(n,t,e)}const fS=hx({onesLike_:function(t){const e=ux(t,"x","onesLike");return ex.runKernel(Uv,{x:e})}}),mS=hx({pad_:function(t,e,n=0){const s=ux(t,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return ex.runKernel(Gv,{x:s},{paddings:e,constantValue:n})}}),gS=hx({prelu_:function(t,e){const n=ux(t,"x","prelu"),s=ux(e,"alpha","prelu");return ex.runKernel(Kv,{x:n,alpha:s})}});var yS=n(566);class bS{constructor(t,e,n,s,r){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=r||Math.random();this.random=yS.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let s,r,i;do{s=2*this.random()-1,r=2*this.random()-1,i=s*s+r*r}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*r*a,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class vS{constructor(t=0,e=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=yS.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const wS=hx({randomNormal_:function(t,e=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const i=new bS(e,n,s,!1,r),a=Xx(t,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),_S=hx({randomUniform_:function(t,e=0,n=1,s="float32",r){const i=Xx(t,s),a=new vS(e,n,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),xS=hx({relu_:function(t){const e=ux(t,"x","relu");return ex.runKernel(Jv,{x:e})}}),kS=hx({reverse_:function(t,e){const n=ux(t,"x","reverse");return ex.runKernel(aw,{x:n},{dims:e})}}),CS=hx({selu_:function(t){const e=ux(t,"x","selu");return ex.runKernel(hw,{x:e})}}),SS=hx({separableConv2d_:function(t,e,n,s,r,i=[1,1],a="NHWC"){const o=ux(t,"x","separableConv2d"),l=ux(e,"depthwiseFilter","separableConv2d"),u=ux(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=sC(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");cy(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),cy(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),cy(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),cy(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),cy(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];cy(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=kC(c,l,s,r,a,i),m=gC(f,u,1,"valid",a);return h?sC(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),IS=hx({sigmoid_:function(t){const e=ux(t,"x","sigmoid");return ex.runKernel(gw,{x:e})}}),ES=hx({slice_:function(t,e,n){const s=ux(t,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");return ex.runKernel(dw,{x:s},{begin:e,size:n})}}),NS=hx({slice1d_:function(t,e,n){const s=ux(t,"x","slice1d");return cy(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),ES(s,[e],[n])}}),TS=hx({slice2d_:function(t,e,n){const s=ux(t,"x","slice2d");return cy(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),ES(s,e,n)}}),AS=hx({slice3d_:function(t,e,n){const s=ux(t,"x","slice3d");return cy(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),ES(s,e,n)}}),$S=hx({slice4d_:function(t,e,n){const s=ux(t,"x","slice4d");return cy(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),ES(s,e,n)}}),RS=hx({softmax_:function(t,e=-1){const n=ux(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);return ex.runKernel(xw,{logits:n},{dim:e})}}),OS=hx({softplus_:function(t){const e=ux(t,"x","softplus");return ex.runKernel(yw,{x:e})}}),FS=hx({split_:function(t,e,n=0){const s=ux(t,"x","split");return ex.runKernel(_w,{x:s},{numOrSizeSplits:e,axis:n})}}),DS=hx({sqrt_:function(t){const e=ux(t,"x","sqrt");return ex.runKernel(bw,{x:e})}}),LS=hx({squeeze_:function(t,e){const n=ux(t,"x","squeeze");return sC(n,xy(n.shape,e).newShape)}}),MS=hx({stack_:function(t,e=0){const n=cx(t,"tensors","stack","string_or_numeric");return cy(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&cy(e<=n[0].rank,()=>"Axis must be <= rank of the tensor"),ex.runKernel(Hv,n,{axis:e})}}),PS=hx({tanh_:function(t){const e=ux(t,"x","tanh");return ex.runKernel(Lw,{x:e})}});function zS(t,e){dy(t);const n=ax(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return px(t,null,n,e)}function VS(t,e,n){if(dy(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const s=ax(t,n);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return px(t,e,s,n)}const BS=hx({truncatedNormal_:function(t,e=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const i=new bS(e,n,s,!0,r),a=Xx(t,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),WS=hx({unstack_:function(t,e=0){const n=ux(t,"x","unstack","string_or_numeric");return cy(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`),ex.runKernel(Ww,{value:n},{axis:e})}}),US=hx({broadcastTo_:function(t,e){let n=ux(t,"broadcastTo","x");const s=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=sC(n,t)}const r=n.shape,i=Array.from(e);for(let a=e.length-1;a>=0;a--)if(r[a]===e[a])i[a]=1;else if(1!==n.shape[a])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);return 0===i.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length?Yx(n):ex.runKernel(Mw,{x:n},{reps:i})}}),jS=hx({where_:function(t,e,n){const s=ux(e,"a","where"),r=ux(n,"b","where"),i=ux(t,"condition","where","bool"),a=TC(TC(i.shape,s.shape),r.shape),o=US(i,a),l=US(s,a),u=US(r,a);return ex.runKernel(cw,{condition:o,t:l,e:u})}}),HS=hx({zerosLike_:function(t){const e=ux(t,"x","zerosLike");return ex.runKernel(jw,{x:e})}}),GS=hx({transpose_:function(t,e){const n=ux(t,"x","transpose");return null==e&&(e=n.shape.map((t,e)=>e).reverse()),cy(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{cy(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`)}),n.rank<=1?n.clone():ex.runKernel(Vw,{x:n},{perm:e})}}),qS=hx({dropout_:function(t,e,n,s){const r=ux(t,"x","dropout");if(cy("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),cy(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof L_?r.clone():r;const i=function(t,e){if(null==e)return t.shape.slice();if(my(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)n.push(null==e[s]&&null!=t.shape[s]?t.shape[s]:e[s]);return n}return e}(r,n),a=1-e,o=SC(DC(Vk(_S(i,0,1,"float32",s),a)),a);return UC(r,o)}}),KS=hx({imag_:function(t){const e=ux(t,"input","imag");return ex.runKernel(uv,{input:e})}}),XS=hx({real_:function(t){const e=ux(t,"input","real");return ex.runKernel(Yv,{input:e})}}),ZS=hx({fft_:function(t){return cy("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),ex.runKernel(Yb,{input:t})}}),YS=hx({rfft_:function(t,e){cy("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(null!=e&&e<n){const s=t.shape.map(t=>0),i=t.shape.map(t=>t);i[t.shape.length-1]=e,r=ES(t,s,i),n=e}else if(null!=e&&e>n){const s=t.shape.map(t=>t);s[t.shape.length-1]=e-n,r=hC([t,dS(s)],t.shape.length-1),n=e}else r=t;const i=HS(r),a=sC(dx(r,i),[s,n]),o=ZS(a),l=Math.floor(n/2)+1,u=XS(o),c=KS(o),h=FS(u,[l,n-l],u.shape.length-1),d=FS(c,[l,n-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,sC(dx(h[0],d[0]),p)}}),QS=hx({ifft_:function(t){return cy("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),ex.runKernel(lv,{input:t})}}),JS=hx({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=sC(t,[n,e]);s=QS(r)}else{const r=[n,2*(e-1)],i=sC(XS(t),[n,e]),a=sC(KS(t),[n,e]),o=kS(ES(i,[0,1],[n,e-2]),1),l=UC(kS(ES(a,[0,1],[n,e-2]),1),Mk(-1)),u=hC([i,o],1),c=hC([a,l],1),h=sC(dx(u,c),[r[0],r[1]]);s=QS(h)}if(s=XS(s),3===t.rank&&0!==t.shape[0]){const e=s,n=t.shape[0];s=sC(s,[n,s.shape[0]/n,s.shape[1]]),e.dispose()}return s}}),tI=hx({conv2DBackpropFilter_:function(t,e,n,s,r,i="NHWC",a){let o=t;3===t.rank&&(o=sC(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=sC(e,[1,e.shape[0],e.shape[1],e.shape[2]])),cy(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),cy(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),cy(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u="NHWC"===i?o.shape[3]:o.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];return cy(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),cy(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=a&&cy(gy(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),ex.runKernel(Cb,{x:o,dy:l},{strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:n})}}),eI=hx({relu6_:function(t){const e=ux(t,"x","relu6");return ex.runKernel(iw,{x:e})}}),nI=hx({step_:function(t,e=0){const n=ux(t,"x","step");return ex.runKernel(Hw,{x:n},{alpha:e})}});function sI(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return UC(t,nI(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function rI(t,e){let n=e;const s=NC(t.shape,e.shape);return s.length>0&&(n=HC(n,s)),sC(n,t.shape)}function iI(t,e,n,s){if("linear"===e)return t;if("relu"===e)return xS(t);if("elu"===e)return IC(t);if("relu6"===e)return eI(t);if("prelu"===e)return gS(t,n);if("leakyrelu"===e)return zC(t,s);if("sigmoid"===e)return IS(t);throw new Error(`Unknown fused activation ${e}.`)}const aI=(t,e)=>!(t>0)||"linear"===e,oI=hx({fusedConv2d_:function({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===aI(ex.state.gradientDepth,l=l||"linear")){let h=gC(t,e,n,s,r,i,a);return null!=o&&(h=Vk(h,o)),iI(h,l,u,c)}const h=ux(t,"x","conv2d"),d=ux(e,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=sC(h,[1,h.shape[0],h.shape[1],h.shape[2]])),cy(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),cy(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=a&&cy(gy(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),cy(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),cy(eC(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),cy("NHWC"===r,()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=qk(p.shape,d.shape,n,i,s,a);let g,y;null!=o&&(g=ux(o,"bias","fused conv2d"),[g]=q_(g,h),TC(m.outShape,g.shape)),null!=u&&(y=ux(u,"prelu weights","fused conv2d"));const b=(t,e)=>{const[r,a,o,u]=e,c=sI(t,o,l);cy(tC(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const h=[bC(a.shape,c,r,n,s),tI(a,c,r.shape,n,s)];if(null!=u){const t=rI(u,c);h.push(t)}return h},v={x:p,filter:d,bias:g,preluActivationWeights:y},w={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return null==o?Lk((t,e,n)=>{let s=ex.runKernel(Xw,v,w);return n([e,t,s]),f&&(s=sC(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d):Lk((t,e,n,s)=>{let r=ex.runKernel(Xw,v,w);return s([e,t,r,n]),f&&(r=sC(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d,g)}}),lI=hx({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,s,r,i=[1,1],a){let o=t;3===t.rank&&(o=sC(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;return 3===l.rank&&(l=sC(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ex.runKernel(Lb,{x:o,dy:l},{strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:n})}}),uI=hx({depthwiseConv2dNativeBackpropInput_:function(t,e,n,s,r,i=[1,1],a){let o=e,l=!1;3===e.rank&&(l=!0,o=sC(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u=ex.runKernel(Mb,{dy:o,filter:n},{strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:t});return l?sC(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),cI=hx({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===aI(ex.state.gradientDepth,l)){let h=kC(t,e,n,s,r,i,a);return null!=o&&(h=Vk(h,o)),iI(h,l,u,c)}const h=ux(t,"x","depthwiseConv2d"),d=ux(e,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=sC(h,[1,h.shape[0],h.shape[1],h.shape[2]])),cy(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),cy(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),cy(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==i&&(i=[1,1]),cy(eC(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),null!=a&&cy(gy(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${s}.`);const m=qk(p.shape,d.shape,n,i,s,a,!0);let g,y;null!=o&&(g=ux(o,"bias","fused conv2d"),[g]=q_(g,h),TC(m.outShape,g.shape)),null!=u&&(y=ux(u,"prelu weights","fused depthwiseConv2d"));const b=(t,e)=>{cy(tC(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[r,o,u,c]=e,h=sI(t,u,l),d=uI(o.shape,h,r,n,s,i,a),p=lI(o,h,r.shape,n,s,i,a);return null!=c?[d,p,rI(g,h)]:[d,p]},v={x:p,filter:d,bias:g,preluActivationWeights:y},w={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return null==o?Lk((t,e,n)=>{let s=ex.runKernel(Zw,v,w);return n([e,t,s]),f&&(s=sC(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d):Lk((t,e,n,s)=>{let r=ex.runKernel(Zw,v,w);return s([e,t,r,n]),f&&(r=sC(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d,g)}}),hI=hx({matMul_:function(t,e,n=!1,s=!1){let r=ux(t,"a","matMul"),i=ux(e,"b","matMul");return[r,i]=q_(r,i),ex.runKernel(fb,{a:r,b:i},{transposeA:n,transposeB:s})}}),dI=hx({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o}){if(!1===aI(ex.state.gradientDepth,i)){let l=hI(t,e,n,s);return null!=r&&(l=Vk(l,r)),iI(l,i,a,o)}let l=ux(t,"a","fused matMul"),u=ux(e,"b","fused matMul");[l,u]=q_(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=fy(f),y=fy(m);cy(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),cy(my(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),cy(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${s} must match.`);const b=l.shape.slice(0,-2).concat([d,p]),v=sC(l,n?[g,c,d]:[g,d,c]),w=sC(u,s?[y,p,h]:[y,h,p]);let _,x;null!=r&&(_=ux(r,"bias","fused matMul"),[_]=q_(_,l),TC(b,_.shape)),null!=a&&(x=ux(a,"prelu weights","fused matMul"));const k=(t,e)=>{const[a,o,l,u]=e,c=sI(sC(t,l.shape),l,i);let h,d;return n||s?!n&&s?(h=hI(c,o,!1,!1),d=hI(c,a,!0,!1)):n&&!s?(h=hI(o,c,!1,!0),d=hI(a,c,!1,!1)):(h=hI(o,c,!0,!0),d=hI(c,a,!0,!0)):(h=hI(c,o,!1,!0),d=hI(a,c,!0,!1)),null!=r?[h,d,rI(u,c)]:[h,d]},C={a:v,b:w,bias:_,preluActivationWeights:x},S={transposeA:n,transposeB:s,activation:i,leakyreluAlpha:o};return null==r?Lk((t,e,n)=>{const s=ex.runKernel(Kw,C,S);return n([t,e,s]),{value:sC(s,b),gradFunc:k}})(v,w):Lk((t,e,n,s)=>{const r=ex.runKernel(Kw,C,S);return s([t,e,r,n]),{value:sC(r,b),gradFunc:k}})(v,w,_)}});function pI(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let i=0;i<t;++i){const a=2*Math.PI*i/(t+s-1);r[i]=e-n*Math.cos(a)}return zS(r,"float32")}hx({hammingWindow_:function(t){return pI(t,.54,.46)}});const fI=hx({hannWindow_:function(t){return pI(t,.5,.5)}}),mI=hx({frame_:function(t,e,n,s=!1,r=0){let i=0;const a=[];for(;i+e<=t.size;)a.push(ES(t,i,e)),i+=n;if(s)for(;i<t.size;){const s=i+e-t.size,o=hC([ES(t,i,e-s),FC([s],r)]);a.push(o),i+=n}return 0===a.length?VS([],[0,e]):sC(hC(a),[a.length,e])}});hx({stft_:function(t,e,n,s,r=fI){null==s&&(s=Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2)))));const i=mI(t,e,n),a=UC(i,r(e));return YS(a,s)}});const gI=hx({cropAndResize_:function(t,e,n,s,r="bilinear",i=0){const a=ux(t,"image","cropAndResize"),o=ux(e,"boxes","cropAndResize","float32"),l=ux(n,"boxInd","cropAndResize","int32"),u=o.shape[0];return cy(4===a.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),cy(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),cy(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),cy(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),cy(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),cy("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),ex.runKernel(Rb,{image:a,boxes:o,boxInd:l},{method:r,extrapolationValue:i,cropSize:s})}}),yI=hx({flipLeftRight_:function(t){const e=ux(t,"image","flipLeftRight","float32");return cy(4===e.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`),ex.runKernel(Jb,{image:e},{})}}),bI=hx({rotateWithOffset_:function(t,e,n=0,s=.5){const r=ux(t,"image","rotateWithOffset","float32");return cy(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),ex.runKernel(qw,{image:r},{radians:e,fillValue:n,center:s})}});function vI(t,e,n,s,r,i){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==i&&(i=0);const a=t.shape[0];return n=Math.min(n,a),cy(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),cy(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),cy(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),cy(1===e.rank,()=>"scores must be a 1D tensor"),cy(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),cy(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}const wI=hx({nonMaxSuppression_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=ux(t,"boxes","nonMaxSuppression"),a=ux(e,"scores","nonMaxSuppression"),o=vI(i,a,n,s,r);return ex.runKernel(Vv,{boxes:i,scores:a},{maxOutputSize:n=o.maxOutputSize,iouThreshold:s=o.iouThreshold,scoreThreshold:r=o.scoreThreshold})}});function _I(t,e,n){const s=function(t,e,n){return function(t,e,n){let s=0,r=t.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=n(e,t[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}(t,e,n||xI)}(t,e,n);t.splice(s<0?-(s+1):s,0,e)}function xI(t,e){return t>e?1:t<e?-1:0}function kI(t,e,n,s,r){return II(t,e,n,s,r,0)}function CI(t,e,n,s,r,i){return II(t,e,n,s,r,0,!1,i,!0)}function SI(t,e,n,s,r,i){return II(t,e,n,s,r,i,!0)}function II(t,e,n,s,r,i,a=!1,o=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>r&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(TI);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:a}=e;if(n<r)break;let o=!1;for(let l=h.length-1;l>=a;--l){const n=EI(t,i,h[l]);if(n>=s){o=!0;break}if(e.score=e.score*NI(s,c,n),e.score<=r)break}e.suppressBeginIndex=h.length,o||(e.score===n?(h.push(i),d.push(e.score)):e.score>r&&_I(u,e,TI))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return a&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function EI(t,e,n){const s=t.subarray(4*e,4*e+4),r=t.subarray(4*n,4*n+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(o-i)*(l-a),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(i,u),g=Math.max(a,c),y=Math.min(o,h),b=Math.min(l,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function NI(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function TI(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}function AI(){return(AI=ny(function*(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=ux(t,"boxes","nonMaxSuppressionAsync"),a=ux(e,"scores","nonMaxSuppressionAsync"),o=vI(i,a,n,s,r);n=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l=yield Promise.all([i.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:h}=kI(u,c,n,s,r);return i!==t&&i.dispose(),a!==e&&a.dispose(),zS(h,"int32")})).apply(this,arguments)}const $I=hx({nonMaxSuppressionWithScore_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=ux(t,"boxes","nonMaxSuppression"),o=ux(e,"scores","nonMaxSuppression"),l=vI(a,o,n,s,r,i),u=ex.runKernel(Wv,{boxes:a,scores:o},{maxOutputSize:n=l.maxOutputSize,iouThreshold:s=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:u[0],selectedScores:u[1]}}});function RI(){return(RI=ny(function*(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=ux(t,"boxes","nonMaxSuppressionAsync"),o=ux(e,"scores","nonMaxSuppressionAsync"),l=vI(a,o,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const u=yield Promise.all([a.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=SI(c,h,n,s,r,i);return a!==t&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:zS(d,"int32"),selectedScores:zS(p)}})).apply(this,arguments)}const OI=hx({nonMaxSuppressionPadded_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=ux(t,"boxes","nonMaxSuppression"),o=ux(e,"scores","nonMaxSuppression"),l=vI(a,o,n,s,r,null),u=ex.runKernel(Bv,{boxes:a,scores:o},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:u[0],validOutputs:u[1]}}});function FI(){return(FI=ny(function*(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=ux(t,"boxes","nonMaxSuppressionAsync"),o=ux(e,"scores","nonMaxSuppressionAsync"),l=vI(a,o,n,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=yield Promise.all([a.data(),o.data()]),{selectedIndices:f,validOutputs:m}=CI(d,p,u,c,h,i);return a!==t&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:zS(f,"int32"),validOutputs:Mk(m,"int32")}})).apply(this,arguments)}const DI=hx({resizeBilinear_:function(t,e,n=!1,s=!1){const r=ux(t,"images","resizeBilinear");cy(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),cy(2===e.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),cy(!1===s||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;3===r.rank&&(a=!0,i=sC(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,o=ex.runKernel(sw,{images:i},{alignCorners:n,halfPixelCenters:s,size:e});return a?sC(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),LI=hx({resizeNearestNeighbor_:function(t,e,n=!1,s=!1){const r=ux(t,"images","resizeNearestNeighbor");cy(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),cy(2===e.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),cy("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),cy(!1===s||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;3===r.rank&&(a=!0,i=sC(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,o=ex.runKernel(ew,{images:i},{alignCorners:n,halfPixelCenters:s,size:e});return a?sC(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),MI=hx({bincount_:function(t,e,n){const s=ux(t,"x","bincount"),r=ux(e,"weights","bincount");return cy("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),cy(n>=0,()=>`size must be non-negative, but got ${n}.`),cy(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),ex.runKernel(gb,{x:s,weights:r},{size:n})}}),PI=hx({lessEqual_:function(t,e){let n=ux(t,"a","lessEqual","string_or_numeric"),s=ux(e,"b","lessEqual","string_or_numeric");return[n,s]=q_(n,s),TC(n.shape,s.shape),ex.runKernel(mv,{a:n,b:s})}}),zI=hx({round_:function(t){const e=ux(t,"x","round");return ex.runKernel(ow,{x:e})}});function VI(t,e,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");return ex.runKernel(Zv,{},{start:t,stop:e,step:n,dtype:s})}const BI=hx({threshold_:function(t,e="binary",n=!1,s=.5){const r=ux(t,"image","threshold"),i=r.shape[0]*r.shape[1];let a,o,l,u,c=UC(zS([s]),255);if(cy(3===r.rank,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),cy(3===r.shape[2]||1===r.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),cy("int32"===r.dtype||"float32"===r.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),cy("otsu"===e||"binary"===e,()=>`Method must be binary or otsu, but was ${e}`),3===r.shape[2]){[a,o,l]=FS(r,[1,1,1],-1);const t=UC(a,.2989),e=UC(o,.587),n=UC(l,.114);u=Vk(Vk(t,e),n)}else u=t;"otsu"===e&&(c=function(t,e){let n,s,r,i,a,o,l=zS([-1]),u=zS([0]),c=zS([0]);for(let h=0;h<t.size-1;h++){n=ES(t,0,h+1),s=ES(t,h+1),a=SC(HC(n),e),o=SC(HC(s),e);const d=HC(UC(n,VI(0,n.size)));r=SC(d,HC(n));const p=FC(s.shape,n.size),f=Vk(VI(0,s.size),p),m=UC(s,f);i=SC(HC(m),HC(s));const g=jC(r,i),y=jC(r,i),b=UC(a,o);c=UC(UC(b,g),y);const v=MC(c,u);u=jS(v,c,u),l=jS(v,zS([h]),l)}return l}(MI(Zx(zI(u),"int32"),fx([]),256),i));const h=n?PI(u,c):MC(u,c);return Zx(UC(h,255),"int32")}}),WI=hx({transform_:function(t,e,n="nearest",s="constant",r=0,i){const a=ux(t,"image","transform","float32"),o=ux(e,"transforms","transform","float32");return cy(4===a.rank,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),cy(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),cy(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),ex.runKernel(zw,{image:a,transforms:o},{interpolation:n,fillMode:s,fillValue:r,outputShape:i})}}),UI=hx({bandPart_:function(t,e,n){cy(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),cy(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=ux(t,"a","bandPart");cy(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,a]=s.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=i),n<0&&(n=a);const o=sC(VI(0,i,1,"int32"),[-1,1]),l=VI(0,a,1,"int32"),u=jC(o,l),c=qC(PI(u,Mk(+e,"int32")),PC(u,Mk(-n,"int32"))),h=dS([i,a],s.dtype);return sC(MS(WS(sC(s,[-1,i,a])).map(t=>jS(c,t,h))),r)}}),jI=hx({min_:function(t,e=null,n=!1){const s=ux(t,"x","min");return ex.runKernel(Rv,{x:s},{axis:e,keepDims:n})}}),HI=hx({pow_:function(t,e){let n=ux(t,"base","pow"),s=ux(e,"exp","pow");return[n,s]=q_(n,s),ex.runKernel(qv,{a:n,b:s})}});function GI(t,e,n=null){if(0===t.rank)return zk(t);if(1!==t.rank&&null===n)return GI(sC(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return HC(zk(t),n);if(e===1/0)return WC(zk(t),n);if(e===-1/0)return jI(zk(t),n);if("euclidean"===e||2===e)return DS(HC(HI(zk(t),Mk(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return WC(HC(zk(t),n[0]),n[1]-1);if(e===1/0)return WC(HC(zk(t),n[1]),n[0]);if(e===-1/0)return jI(HC(zk(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return DS(HC(oS(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const qI=hx({norm_:function(t,e="euclidean",n=null,s=!1){const r=GI(t=ux(t,"x","norm"),e,n);let i=r.shape;if(s){const e=_y(n,t.shape);i=nS(r.shape,e)}return sC(r,i)}}),KI=hx({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,cy(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)cy(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=FS(t,t.shape[0],0).map(t=>LS(t,[0]));cy(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(ex.tidy(()=>{let t=s[r];if(r>0)for(let e=0;e<r;++e){const s=UC(HC(UC(n[e],t)),n[e]);t=jC(t,s)}return SC(t,qI(t,"euclidean"))}));return e?MS(n,0):n}});function XI(t,e=!1){return ex.tidy(()=>{cy(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=OC(n),i=Yx(t);const a=VS([[1]],[1,1]);let o=Yx(a);const l=n>=s?s:n;for(let t=0;t<l;++t){const e=i,l=o,u=r;[o,i,r]=ex.tidy(()=>{const e=ES(i,[t,t],[n-t,1]),l=qI(e),u=ES(i,[t,t],[1,1]),c=jS(MC(u,0),VS([[-1]]),VS([[1]])),h=jC(u,UC(c,l)),d=SC(e,h);o=1===d.shape[0]?Yx(a):hC([a,ES(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=uS(SC(hI(c,h),l)),f=ES(i,[t,0],[n-t,s]),m=UC(p,o),g=GS(o);if(0===t)i=jC(f,hI(m,hI(g,f)));else{const e=jC(f,hI(m,hI(g,f)));i=hC([ES(i,[0,0],[t,s]),e],0)}const y=GS(m),b=ES(r,[0,t],[n,r.shape[1]-t]);if(0===t)r=jC(b,hI(hI(b,o),y));else{const e=jC(b,hI(hI(b,o),y));r=hC([ES(r,[0,0],[n,t]),e],1)}return[o,i,r]}),Ok([e,l,u])}return!e&&n>s&&(r=ES(r,[0,0],[n,s]),i=ES(i,[0,0],[s,s])),[r,i]})}const ZI=hx({qr_:function(t,e=!1){if(cy(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return XI(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),s=WS(sC(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],i=[];return s.forEach(t=>{const[n,s]=XI(t,e);r.push(n),i.push(s)}),[sC(MS(r,0),t.shape),sC(MS(i,0),t.shape)]}}});var YI;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(YI||(YI={}));const QI=hx({computeWeightedLoss_:function(t,e,n=YI.SUM_BY_NONZERO_WEIGHTS){const s=ux(t,"losses","computeWeightedLoss");let r=null;null!=e&&(r=ux(e,"weights","computeWeightedLoss"));const i=null==r?s:UC(s,r);if(n===YI.NONE)return i;if(n===YI.SUM)return HC(i);if(n===YI.MEAN){if(null==r)return YC(i);{const t=s.size/r.size,e=SC(HC(i),HC(r));return t>1?SC(e,Mk(t)):e}}if(n===YI.SUM_BY_NONZERO_WEIGHTS){if(null==r)return SC(HC(i),Mk(s.size));{const t=UC(r,pS(s.shape)),e=Zx(HC(cS(t,Mk(0))),"float32");return SC(HC(i),e)}}throw Error(`Unknown reduction: ${n}`)}});hx({absoluteDifference_:function(t,e,n,s=YI.SUM_BY_NONZERO_WEIGHTS){const r=ux(t,"labels","absoluteDifference"),i=ux(e,"predictions","absoluteDifference");let a=null;null!=n&&(a=ux(n,"weights","absoluteDifference")),hy(r.shape,i.shape,"Error in absoluteDifference: ");const o=zk(jC(r,i));return QI(o,a,s)}}),hx({cosineDistance_:function(t,e,n,s,r=YI.SUM_BY_NONZERO_WEIGHTS){const i=ux(t,"labels","cosineDistance"),a=ux(e,"predictions","cosineDistance");let o=null;null!=s&&(o=ux(s,"weights","cosineDistance")),hy(i.shape,a.shape,"Error in cosineDistance: ");const l=Mk(1),u=jC(l,HC(UC(i,a),n,!0));return QI(u,o,r)}}),hx({hingeLoss_:function(t,e,n,s=YI.SUM_BY_NONZERO_WEIGHTS){let r=ux(t,"labels","hingeLoss");const i=ux(e,"predictions","hingeLoss");let a=null;null!=n&&(a=ux(n,"weights","hingeLoss")),hy(r.shape,i.shape,"Error in hingeLoss: ");const o=Mk(1);r=jC(UC(Mk(2),r),o);const l=xS(jC(o,UC(r,i)));return QI(l,a,s)}}),hx({huberLoss_:function(t,e,n,s=1,r=YI.SUM_BY_NONZERO_WEIGHTS){const i=ux(t,"labels","huberLoss"),a=ux(e,"predictions","huberLoss");let o=null;null!=n&&(o=ux(n,"weights","huberLoss")),hy(i.shape,a.shape,"Error in huberLoss: ");const l=Mk(s),u=zk(jC(a,i)),c=QC(u,l),h=jC(u,c),d=Vk(UC(Mk(.5),oS(c)),UC(l,h));return QI(d,o,r)}}),hx({logLoss_:function(t,e,n,s=1e-7,r=YI.SUM_BY_NONZERO_WEIGHTS){const i=ux(t,"labels","logLoss"),a=ux(e,"predictions","logLoss");let o=null;null!=n&&(o=ux(n,"weights","logLoss")),hy(i.shape,a.shape,"Error in logLoss: ");const l=Mk(1),u=Mk(s),c=uS(UC(i,VC(Vk(a,u)))),h=UC(jC(l,i),VC(Vk(jC(l,a),u))),d=jC(c,h);return QI(d,o,r)}});const JI=hx({squaredDifference_:function(t,e){let n=ux(t,"a","squaredDifference"),s=ux(e,"b","squaredDifference");return[n,s]=q_(n,s),TC(n.shape,s.shape),ex.runKernel(Nw,{a:n,b:s},{})}});hx({meanSquaredError_:function(t,e,n,s=YI.SUM_BY_NONZERO_WEIGHTS){const r=ux(t,"labels","meanSquaredError"),i=ux(e,"predictions","meanSquaredError");let a=null;null!=n&&(a=ux(n,"weights","meanSquaredError")),hy(r.shape,i.shape,"Error in meanSquaredError: ");const o=JI(r,i);return QI(o,a,s)}});const tE=hx({log1p_:function(t){const e=ux(t,"x","log1p");return ex.runKernel(bv,{x:e})}});hx({sigmoidCrossEntropy_:function(t,e,n,s=0,r=YI.SUM_BY_NONZERO_WEIGHTS){let i=ux(t,"multiClassLabels","sigmoidCrossEntropy");const a=ux(e,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=ux(n,"weights","sigmoidCrossEntropy")),hy(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const t=Mk(s),e=Mk(1),n=Mk(.5);i=Vk(UC(i,jC(e,t)),UC(n,t))}const l=function(t,e){const n=ux(t,"labels","sigmoidCrossEntropyWithLogits"),s=ux(e,"logits","sigmoidCrossEntropyWithLogits");hy(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=xS(s),i=UC(s,n),a=tE(BC(uS(zk(s))));return Vk(jC(r,i),a)}(i,a);return QI(l,o,r)}});const eE=hx({logSumExp_:function(t,e=null,n=!1){const s=ux(t,"x","logSumExp"),r=_y(e,s.shape),i=WC(s,r,!0),a=jC(s,i),o=BC(a),l=HC(o,r),u=VC(l),c=Vk(sC(i,u.shape),u);if(n){const t=nS(c.shape,r);return sC(c,t)}return c}});hx({softmaxCrossEntropy_:function(t,e,n,s=0,r=YI.SUM_BY_NONZERO_WEIGHTS){let i=ux(t,"onehotLabels","softmaxCrossEntropy");const a=ux(e,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=ux(n,"weights","softmaxCrossEntropy")),hy(i.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const t=Mk(s),e=Mk(1),n=Mk(i.shape[1]);i=Vk(UC(i,jC(e,t)),SC(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Lk((t,e,s)=>{const r=eE(e,[n],!0),i=jC(Zx(e,"float32"),r);s([t,i]);const a=uS(UC(i,t));return{value:HC(a,[n]),gradFunc:(t,e)=>{const[s,r]=e,i=nS(t.shape,[n]);return[UC(sC(t,i),jC(Zx(s,"float32"),BC(r))),UC(sC(t,i),jC(BC(r),Zx(s,"float32")))]}}})(t,e)}(i,a);return QI(l,o,r)}});const nE=hx({sparseFillEmptyRows_:function(t,e,n,s){const r=ux(t,"indices","sparseFillEmptyRows"),i=ux(e,"values","sparseFillEmptyRows"),a=ux(n,"denseShape","sparseFillEmptyRows"),o=ux(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==r.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==a.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l=ex.runKernel(kw,{indices:r,values:i,denseShape:a,defaultValue:o});return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),sE=hx({sparseReshape_:function(t,e,n){const s=ux(t,"inputIndices","sparseReshape"),r=ux(e,"inputShape","sparseReshape"),i=ux(n,"newShape","sparseReshape");if(2!==s.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==r.rank)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a=ex.runKernel(Cw,{inputIndices:s,inputShape:r,newShape:i});return{outputIndices:a[0],outputShape:a[1]}}}),rE=hx({sparseSegmentMean_:function(t,e,n){const s=ux(t,"data","sparseSegmentMean"),r=ux(e,"indices","sparseSegmentMean"),i=ux(n,"segmentIds","sparseSegmentMean");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return ex.runKernel(Sw,{data:s,indices:r,segmentIds:i})}}),iE=hx({sparseSegmentSum_:function(t,e,n){const s=ux(t,"data","sparseSegmentSum"),r=ux(e,"indices","sparseSegmentSum"),i=ux(n,"segmentIds","sparseSegmentSum");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return ex.runKernel(Iw,{data:s,indices:r,segmentIds:i})}}),aE=hx({stringNGrams_:function(t,e,n,s,r,i,a,o){const l=ux(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=ux(e,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c=ex.runKernel($w,{data:l,dataSplits:u},{separator:n,nGramWidths:s,leftPad:r,rightPad:i,padWidth:a,preserveShortSequences:o});return{nGrams:c[0],nGramsSplits:c[1]}}}),oE=hx({stringSplit_:function(t,e,n=!0){const s=ux(t,"input","stringSplit","string"),r=ux(e,"delimiter","stringSplit","string");if(1!==s.rank)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(0!==r.rank)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i=ex.runKernel(Rw,{input:s,delimiter:r},{skipEmpty:n});return{indices:i[0],values:i[1],shape:i[2]}}}),lE=hx({stringToHashBucketFast_:function(t,e){const n=ux(t,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");return ex.runKernel(Ow,{input:n},s)}}),uE={flipLeftRight:yI,resizeNearestNeighbor:LI,resizeBilinear:DI,rotateWithOffset:bI,cropAndResize:gI,nonMaxSuppression:wI,nonMaxSuppressionAsync:function(t,e,n){return AI.apply(this,arguments)},nonMaxSuppressionWithScore:$I,nonMaxSuppressionWithScoreAsync:function(t,e,n){return RI.apply(this,arguments)},nonMaxSuppressionPadded:OI,nonMaxSuppressionPaddedAsync:function(t,e,n){return FI.apply(this,arguments)},threshold:BI,transform:WI},cE={bandPart:UI,gramSchmidt:KI,qr:ZI},hE={sparseFillEmptyRows:nE,sparseReshape:sE,sparseSegmentMean:rE,sparseSegmentSum:iE},dE={stringNGrams:aE,stringSplit:oE,stringToHashBucketFast:lE};class pE extends Pk{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=ex.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=ex.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:Rk(()=>HS(s).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:Rk(()=>HS(s).variable(!1))});const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedGrads[n].variable,a=this.accumulatedUpdates[n].variable;Rk(()=>{const t=Vk(UC(i,this.rho),UC(oS(r),1-this.rho)),e=UC(SC(DS(Vk(a,this.epsilon)),DS(Vk(i,this.epsilon))),r),n=Vk(UC(a,this.rho),UC(oS(e),1-this.rho));i.assign(t),a.assign(n);const o=Vk(UC(e,-this.learningRate),s);s.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Ok(this.accumulatedGrads.map(t=>t.variable)),Ok(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return ny(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return ny(function*(){const n=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,n).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(n,2*n).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}pE.className="Adadelta",Tk(pE);class fE extends Pk{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=ex.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:Rk(()=>FC(s.shape,this.initialAccumulatorValue).variable(t))}}const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedGrads[n].variable;Rk(()=>{const t=Vk(i,oS(r));i.assign(t);const e=Vk(UC(SC(r,DS(Vk(t,ex.backend.epsilon()))),-this.learningRate),s);s.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Ok(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return ny(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return ny(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}fE.className="Adagrad",Tk(fE);class mE extends Pk{constructor(t,e,n,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Rk(()=>{this.accBeta1=Mk(e).variable(),this.accBeta2=Mk(n).variable()}),null==s&&(this.epsilon=ex.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);Rk(()=>{const n=jC(1,this.accBeta1),s=jC(1,this.accBeta2);e.forEach((e,r)=>{const i=ex.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:Rk(()=>HS(i).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${e}/v`,variable:Rk(()=>HS(i).variable(!1))});const a=Array.isArray(t)?t[r].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=Vk(UC(o,this.beta1),UC(a,1-this.beta1)),c=Vk(UC(l,this.beta2),UC(oS(a),1-this.beta2)),h=SC(u,n),d=SC(c,s);o.assign(u),l.assign(c);const p=Vk(UC(SC(h,Vk(DS(d),this.epsilon)),-this.learningRate),i);i.assign(p)}),this.accBeta1.assign(UC(this.accBeta1,this.beta1)),this.accBeta2.assign(UC(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Ok(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&Ok(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return ny(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return ny(function*(){t=yield e.extractIterations(t),Rk(()=>{e.accBeta1.assign(HI(e.beta1,e.iterations_+1)),e.accBeta2.assign(HI(e.beta2,e.iterations_+1))});const n=t.length/2;e.accumulatedFirstMoment=t.slice(0,n).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(n,2*n).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}mE.className="Adam",Tk(mE);class gE extends Pk{constructor(t,e,n,s=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Rk(()=>{this.iteration=Mk(0).variable(),this.accBeta1=Mk(e).variable()}),null==s&&(this.epsilon=ex.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);Rk(()=>{const n=jC(1,this.accBeta1),s=SC(-this.learningRate,Vk(UC(this.iteration,this.decay),1));e.forEach((e,r)=>{const i=ex.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:HS(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${e}/v`,variable:HS(i).variable(!1)});const a=Array.isArray(t)?t[r].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=Vk(UC(o,this.beta1),UC(a,1-this.beta1)),c=UC(l,this.beta2),h=zk(a),d=ZC(c,h);o.assign(u),l.assign(d);const p=Vk(UC(SC(s,n),SC(u,Vk(d,this.epsilon))),i);i.assign(p)}),this.iteration.assign(Vk(this.iteration,1)),this.accBeta1.assign(UC(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Ok(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&Ok(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return ny(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return ny(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}gE.className="Adamax",Tk(gE);class yE extends Pk{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const r=ex.registeredVariables[e];Rk(()=>{const t=Vk(UC(this.c,s),r);r.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Fk(Mk(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return ny(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return ny(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}yE.className="SGD",Tk(yE);class bE extends yE{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=Mk(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=ex.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:Rk(()=>HS(s).variable(t))}}const r=this.accumulations[n].variable,i=Array.isArray(t)?t[n].tensor:t[e];null!=i&&Rk(()=>{let t;const e=Vk(UC(this.m,r),i);t=Vk(UC(this.c,this.useNesterov?Vk(i,UC(e,this.m)):e),s),r.assign(e),s.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Ok(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return ny(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return ny(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}bE.className="Momentum",Tk(bE);class vE extends Pk{constructor(t,e=.9,n=0,s=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==s&&(this.epsilon=ex.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=ex.registeredVariables[e],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:Rk(()=>HS(s).variable(r))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:Rk(()=>HS(s).variable(r))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:Rk(()=>HS(s).variable(r))});const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Rk(()=>{const t=Vk(UC(a,this.decay),UC(oS(i),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,r=Vk(UC(e,this.decay),UC(i,1-this.decay)),l=SC(UC(i,this.learningRate),DS(jC(t,Vk(oS(r),this.epsilon)))),u=Vk(UC(o,this.momentum),l);a.assign(t),e.assign(r),o.assign(u);const c=jC(s,u);s.assign(c)}else{const t=Vk(UC(a,this.decay),UC(oS(i),1-this.decay)),e=Vk(UC(o,this.momentum),SC(UC(i,this.learningRate),DS(Vk(t,this.epsilon))));a.assign(t),o.assign(e);const n=jC(s,e);s.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Ok(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Ok(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&Ok(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return ny(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(t){var e=this;return ny(function*(){t=yield e.extractIterations(t);const n=e.centered?t.length/3:t.length/2,s=!1;e.accumulatedMeanSquares=t.slice(0,n).map(t=>({originalName:t.name,variable:t.tensor.variable(s)})),e.accumulatedMoments=t.slice(n,2*n).map(t=>({originalName:t.name,variable:t.tensor.variable(s)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*n,3*n).map(t=>({originalName:t.name,variable:t.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}vE.className="RMSProp",Tk(vE);class wE{static sgd(t){return new yE(t)}static momentum(t,e,n=!1){return new bE(t,e,n)}static rmsprop(t,e=.9,n=0,s=null,r=!1){return new vE(t,e,n,s,r)}static adam(t=.001,e=.9,n=.999,s=null){return new mE(t,e,n,s)}static adadelta(t=.001,e=.95,n=null){return new pE(t,e,n)}static adamax(t=.002,e=.9,n=.999,s=null,r=0){return new gE(t,e,n,s,r)}static adagrad(t,e=.1){return new fE(t,e)}}const _E={sgd:wE.sgd,momentum:wE.momentum,adadelta:wE.adadelta,adagrad:wE.adagrad,rmsprop:wE.rmsprop,adamax:wE.adamax,adam:wE.adam},xE="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function kE(){return new Promise(t=>xE(()=>t()))}function CE(t,e){const n=t[0].length;t.forEach((t,e)=>{cy(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),cy(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((t,r)=>{for(let i=0;i<n;i++)cy(i===e||t[i]===s[i],()=>`Error in concat${n}D: Shape of tensors[${r}] (${t}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function SE(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}const IE=30;function EE(t){return t<=IE?t:Ry(t,Math.floor(Math.sqrt(t)))}function NE(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function TE(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let s=0;s<n;++s)r=r.concat([t[s+1]/e[s],e[s]]);r=r.concat(t.slice(n+1))}return r}function AE(t,e,n=!0){const s=[];if(n){s.push(e);for(let n=e+1;n<t;++n)n<=2*e?(s.push(n),s.push(n-(e+1))):s.push(n)}else{const n=[],r=[];for(let s=1;s<t;++s)s>=2*e+1||s%2==1?r.push(s):n.push(s);s.push(...n),s.push(0),s.push(...r)}return s}function $E(t,e,n,s=!0){const r=[];r.push(s?t[0]/n:t[0]*n);for(let i=1;i<t.length;++i)r.push(i<=e.length?s?e[i-1]*t[i]:t[i]/e[i-1]:t[i]);return r}function RE(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function OE(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}function FE(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(0===fy(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,i=r[r.length-1];let a=1;for(let h=0;h<r.length-1;++h)a*=r[h];const o=t.shape,l=r.slice();l.pop();let u=1;for(let h=i;h<n;++h)u*=o[h],l.push(o[h]);const c=[...Oy(t.shape).map(t=>t/u),1].slice(0,i);return[l,a,u,c]}function DE(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(i+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(i+" update.rank != "+(r+t.length-s));for(let a=0;a<r;++a)if(n.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<n.rank-r;++a)if(n.shape[a+r]!==t[a+s])throw new Error(i+` updates.shape[${a+r}] (${n.shape[a+r]}) != shape[${a+r}] (${t[a+r]})`)}function LE(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}DE(n,e,t)}function ME(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=n.length;let a=1;for(let l=r;l<i;++l)a*=n[l];const o=r<1?1:r;return{sliceRank:r,numUpdates:fy(e.shape)/o,sliceSize:a,strides:[...Oy(n.slice(0,r)),1],outputSize:fy(n)}}const PE=1.7580993408473768,zE=1.0507009873554805,VE=.3275911,BE=.254829592,WE=-.284496736,UE=1.421413741,jE=-1.453152027,HE=1.061405429;function GE(...t){Hy().getBool("IS_TEST")||console.warn(...t)}function qE(...t){Hy().getBool("IS_TEST")||console.log(...t)}function KE(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function XE(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function ZE(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function YE(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function QE(t,e){return{real:t[2*e],imag:t[2*e+1]}}function JE(t,e,n,s){t[2*s]=e,t[2*s+1]=n}function tN(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const i=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:n,imag:s}}function eN(t,e,n){const s=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(s),imag:Math.sin(s)}}const nN=/->/g;function sN(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(nN,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[s,r]=t.split("->");cy(-1===s.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const i=s.split(","),a=i.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<r.length;++h){const t=r[h];if(!i.some(e=>-1!==e.indexOf(t)))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let h=0;h<s.length;++h){const t=s[h];-1===o.indexOf(t)&&","!==t&&o.push(t)}const l=new Array(i.length);for(let h=0;h<a;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let t=0;t<i[h].length;++t)l[h].push(o.indexOf(i[h][t]))}const u=o.length,c=[];for(let h=r.length;h<u;++h)c.push(h);return{allDims:o,summedDims:c,idDims:l}}function rN(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const s=[];for(let r=0;r<t;++r)-1===n[r]&&s.push(r);return n=n.filter(t=>-1!==t),{permutationIndices:n,expandDims:s}}function iN(t,e,n){const s=new Array(t);for(let r=0;r<n.length;++r){const t=n[r].shape;for(let n=0;n<e[r].length;++n)void 0===s[e[r][n]]?s[e[r][n]]=t[n]:cy(s[e[r][n]]===t[n],()=>`Expected dimension ${s[e[r][n]]} at axis ${n} of input shaped ${JSON.stringify(t)}, but got dimension ${t[n]}`)}}function aN(t,e){const n=t,s=[];let r=0;0===t.length&&n.push(-1),r=t.length+1;for(let a=0;a<r;++a)s.push([]);const i=[];for(let a=0;a<n.length;++a){const t=lN(e,n[a]);for(const e of t)-1===i.indexOf(e)&&(s[a].push(e),i.push(e))}return{path:n,steps:s}}function oN(t){return t.every((t,e)=>t===e)}function lN(t,e){const n=[];for(let s=0;s<t.length;++s)0!==t[s].length&&-1===t[s].indexOf(e)&&-1!==e||n.push(s);return n}function uN(t,e,n=0){let s=[];if("number"==typeof e)cy(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{cy(e.reduce((t,e)=>(-1===e&&(t+=1),t),0)<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(-1!==r){const s=e.reduce((t,e)=>e>0?t+e:t);e[r]=t.shape[n]-s}cy(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function cN(t,e){let n,s=!1;for(t<=IE?(n=t,s=!0):n=Ry(t,Math.floor(Math.sqrt(t)));!s;)n>e||n===t?s=!0:n=Ry(t,n+1);return n}function hN(t,e,n){const s=[],r=t.length;for(let i=0;i<r;i++)s.push(i!==e?t[i]:n);return s}function dN(t,e,n,s){const r=e.shape.length,i=t.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${i}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const a=t.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)o.push(t.shape[h]),l*=t.shape[h];for(let h=s;h<n;h++)o.push(t.shape[h]),u*=t.shape[h];for(let h=s;h<r;h++)o.push(e.shape[h]);for(let h=n+1;h<i;h++)o.push(t.shape[h]),c*=t.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:o}}function pN(t){try{return t.map(t=>k_(t))}catch(D7){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${D7}`)}}function fN(t){return t.map(t=>x_(t))}function mN(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const s=Xx(t,"int32"),r=Xx([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const e=s.indexToLoc(n[i]);r.values.set(e,i*t.length)}return r.toTensor()}const gN={kernelName:Zy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(t,nI(Zx(n,"float32"),-1))}}},yN={kernelName:Yy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=oS(Zx(n,"float32")),s=DS(jC(Mk(1),e));return uS(SC(t,s))}}}},bN={kernelName:Qy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=DS(jC(oS(Zx(n,"float32")),1));return SC(t,e)}}}},vN={kernelName:Jy,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=TC(n.shape,s.shape);return{a:()=>{let e=t;const s=NC(n.shape,r);return s.length>0&&(e=HC(e,s)),sC(e,n.shape)},b:()=>{let e=t;const n=NC(s.shape,r);return n.length>0&&(e=HC(e,n)),sC(e,s.shape)}}}},wN={kernelName:tb,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((e,s)=>{n[s]=()=>t.clone()}),n}},_N={kernelName:sb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>HS(n)}}},xN={kernelName:rb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>HS(n)}}},kN={kernelName:ib,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SC(t,DS(jC(Mk(1),oS(Zx(n,"float32")))))}}},CN={kernelName:ab,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=DS(Vk(Mk(1),oS(Zx(n,"float32"))));return SC(t,e)}}}},SN={kernelName:ub,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=TC(n.shape,s.shape);return{a:()=>{const e=Vk(oS(n),oS(s));let i=UC(t,SC(s,e));const a=NC(n.shape,r);return a.length>0&&(i=HC(i,a)),sC(i,n.shape)},b:()=>{const e=Vk(oS(n),oS(s));let i=uS(UC(t,SC(n,e)));const a=NC(s.shape,r);return a.length>0&&(i=HC(i,a)),sC(i,s.shape)}}}},IN={kernelName:ob,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SC(t,Vk(oS(Zx(n,"float32")),1))}}},EN={kernelName:lb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SC(t,jC(Mk(1),oS(Zx(n,"float32"))))}}},NN=hx({avgPool3dGrad_:function(t,e,n,s,r,i){const a=ux(t,"dy","avgPool3dGrad"),o=ux(e,"input","avgPool3dGrad");let l=a,u=o,c=!1;4===o.rank&&(c=!0,l=sC(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=sC(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),cy(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),cy(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),null!=i&&cy(gy(r),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h=ex.runKernel(pb,{dy:l,input:u},{filterSize:n,strides:s,pad:r,dimRoundingMode:i});return c?sC(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),TN={kernelName:db,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:a,dimRoundingMode:o}=n;return{x:()=>NN(t,s,r,i,a,o)}}},AN=hx({avgPoolGrad_:function(t,e,n,s,r){const i=ux(t,"dy","avgPoolGrad"),a=ux(e,"input","avgPoolGrad");cy(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let o=a,l=i,u=!1;3===a.rank&&(u=!0,o=sC(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=sC(i,[1,i.shape[0],i.shape[1],i.shape[2]])),cy(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),cy(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c=ex.runKernel(hb,{dy:l,input:o},{filterSize:n,strides:s,pad:r});return u?sC(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),$N={kernelName:cb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:a}=n;return{x:()=>AN(t,s,r,i,a)}}},RN={kernelName:fb,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:i,transposeB:a}=n;return i||a?!i&&a?{a:()=>hI(t,r,!1,!1),b:()=>hI(t,s,!0,!1)}:i&&!a?{a:()=>hI(r,t,!1,!0),b:()=>hI(s,t,!1,!1)}:{a:()=>hI(r,t,!0,!0),b:()=>hI(t,s,!0,!0)}:{a:()=>hI(t,r,!1,!0),b:()=>hI(s,t,!0,!1)}}},ON=hx({spaceToBatchND_:function(t,e,n){const s=ux(t,"x","spaceToBatchND");return cy(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),cy(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),cy(s.shape.reduce((t,s,r)=>r>0&&r<=e.length?t&&(s+n[r-1][0]+n[r-1][1])%e[r-1]==0:t,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`),ex.runKernel(ww,{x:s},{blockShape:e,paddings:n})}}),FN={kernelName:mb,gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>ON(t,s,r)}}},DN={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const s=n.inputShape,r=n.shape,i=Array.from(r);for(let o=s.length-1;o>=0;o--)if(s[o]===r[o])i[o]=1;else if(1!==s[o])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${r}].`);const a=[];for(let o=0;o<i.length;o++)i[o]>1&&a.push(o);return{x:()=>HC(t,a,!0)}}},LN={kernelName:yb,gradFunc:t=>({x:()=>t.clone()})},MN={kernelName:bb,gradFunc:t=>({x:()=>HS(t)})},PN={kernelName:vb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=n;return{x:()=>jS(qC(PC(s,r),PI(s,i)),t,HS(t))}}},zN={kernelName:_b,inputsToSave:["x"],gradFunc:gN.gradFunc},VN={kernelName:xb,saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(t=>t.shape),{axis:r}=n,i=_y(r,e[0].shape)[0],a=s.map(t=>t[i]);return FS(t,a,i).map(t=>()=>t)}},BN={kernelName:kb,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:i,strides:a,pad:o,dataFormat:l}=n;return cy(tC(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>bC(s.shape,t,r,a,o,l),filter:()=>tI(s,t,r.shape,a,o,l)}}},WN={kernelName:Sb,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:i,pad:a,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>gC(t,r,i,a,o,1,l),filter:()=>tI(t,s,r.shape,i,a,o,l)}}},UN=hx({conv3DBackpropFilter_:function(t,e,n,s,r){let i=t;4===t.rank&&(i=sC(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let a=e;return 4===a.rank&&(a=sC(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),cy(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),cy(5===a.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),cy(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),cy(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),cy(a.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`),ex.runKernel(Eb,{x:i,dy:a},{strides:s,pad:r,filterShape:n})}}),jN={kernelName:Ib,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i}=n;cy(tC(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=e;return{x:()=>_C(a.shape,t,o,r,i),filter:()=>UN(a,t,o.shape,r,i)}}},HN=hx({sin_:function(t){const e=ux(t,"x","sin");return ex.runKernel(pw,{x:e})}}),GN={kernelName:Tb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(uS(HN(Zx(n,"float32"))),t)}}},qN=hx({sinh_:function(t){const e=ux(t,"x","sinh");return ex.runKernel(fw,{x:e})}}),KN={kernelName:Ab,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(qN(Zx(n,"float32")),t)}}},XN=hx({cumsum_:function(t,e=0,n=!1,s=!1){const r=ux(t,"x","cumsum");return ex.runKernel($b,{x:r},{axis:e,exclusive:n,reverse:s})}}),ZN={kernelName:$b,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:i,reverse:a}=n;return{x:()=>{const e=rS([r],s.rank);let n=XN(t,r,i,!a);return null!=e&&(n=GS(n,e)),n}}}},YN={kernelName:Db,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=n,o=null==s?[1,1]:s;cy(tC(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=e;return cy(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),cy(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),cy(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),cy(eC(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),null!=a&&cy(gy(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`),{x:()=>uI(l.shape,t,u,r,i,s,a),filter:()=>lI(l,t,u.shape,r,i,s,a)}}},QN={kernelName:zb,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,i={x:s,filter:r,dy:t},a={x:s,filter:r,dy:t};return{x:()=>ex.runKernel(Vb,i,n),filter:()=>ex.runKernel(Bb,a,n)}}},JN={kernelName:jb,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>ex.runKernel(Hb,s)}}},tT={kernelName:Gb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=UC(BC(uS(oS(n))),2/Math.sqrt(Math.PI));return{x:()=>UC(t,s)}}},eT={kernelName:Kb,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(t,n)}}},nT={kernelName:Xb,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>sC(t,n.shape)}}},sT={kernelName:Zb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(t,BC(n))}}},rT={kernelName:tv,gradFunc:t=>({x:()=>HS(t)})},iT={kernelName:ev,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=TC(n.shape,s.shape);return{a:()=>{const e=SC(t,Zx(s,"float32")),i=NC(n.shape,r);return i.length>0?sC(HC(e,i),n.shape):e},b:()=>{let e=UC(t,Zx(n,"float32"));const i=NC(s.shape,r);i.length>0&&(e=sC(HC(e,i),s.shape));const a=oS(s);return uS(SC(e,Zx(a,"float32")))}}}},aT=hx({rsqrt_:function(t){const e=ux(t,"x","rsqrt");return ex.runKernel(lw,{x:e})}}),oT={kernelName:nv,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,i,a,o]=e,l=null==o?Mk(1):o,u=NC(i.shape,r.shape),c=[];if(1===i.rank){for(let t=0;t<r.shape.length-1;++t)c.push(r.shape[t]);c.push(1)}const h=jC(r,i),d=UC(t,l),p=aT(Vk(a,Mk(s))),f=UC(UC(UC(p,p),p),Mk(-.5));return{x:()=>sC(UC(UC(t,1===i.rank?RC(sC(p,[1,1,1,i.shape[0]]),c):p),l),r.shape),mean:()=>{let t=UC(UC(p,Mk(-1)),d);return 1===i.rank&&(t=HC(t,u)),sC(t,i.shape)},variance:()=>{let t=UC(UC(f,h),d);return 1===i.rank&&(t=HC(t,u)),sC(t,i.shape)},scale:()=>{const e=UC(h,p);let n=UC(t,e);return 1===i.rank&&(n=HC(n,u)),sC(n,i.shape)},offset:()=>{let e=t;return 1===i.rank&&(e=HC(e,u)),sC(e,i.shape)}}}},lT=hx({unsortedSegmentSum_:function(t,e,n){const s=ux(t,"x","unsortedSegmentSum"),r=ux(e,"segmentIds","unsortedSegmentSum","int32");return cy(gy(n),()=>"numSegments must be of dtype int"),ex.runKernel(Uw,{x:s,segmentIds:r},{numSegments:n})}}),uT={kernelName:sv,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:i}=n,a=_y(i,s.shape)[0];return{x:()=>{const e=s.shape,n=r.size,o=e.slice(0,a),l=o.length,u=e.slice(i,e.length).slice(1),c=u.length,h=cT(0,l),d=cT(l+1,l+1+c),p=hT([o,[n],u]),f=sC(t,p),m=sC(r,[n]),g=hT([[l],h,d]),y=GS(f,g);let b=lT(y,m,s.shape[a]);const v=iS(g);return b=GS(b,v),b},indices:()=>r}}};function cT(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function hT(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}const dT={kernelName:av,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>HS(n),b:()=>HS(s)}}},pT={kernelName:ov,gradFunc:t=>({x:()=>Zx(t,"float32")})},fT={kernelName:cv,gradFunc:t=>({x:()=>HS(t)})},mT={kernelName:hv,gradFunc:t=>({x:()=>HS(t)})},gT={kernelName:dv,gradFunc:t=>({x:()=>HS(t)})},yT={kernelName:pv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,i=MC(s,0);return{x:()=>jS(i,t,UC(t,r))}}},bT={kernelName:bv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SC(t,Vk(n,1))}}},vT={kernelName:yv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SC(t,Zx(n,"float32"))}}},wT={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const e=BC(s);return jC(t,UC(HC(t,r,!0),e))}}}},_T=hx({localResponseNormalizationBackprop_:function(t,e,n,s=5,r=1,i=1,a=.5){return ex.runKernel(kv,{x:t,y:e,dy:n},{depthRadius:s,bias:r,alpha:i,beta:a})}}),xT={kernelName:xv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:i,bias:a,alpha:o,beta:l}=n;return{x:()=>_T(s,r,t,i,a,o,l)}}};function kT(t,e,n,s){return e.rank<n.rank&&(e=sC(e,nS(e.shape,s))),t.rank<n.rank&&(t=sC(t,nS(t.shape,s))),{x:()=>UC(t,Zx(AC(n,e),t.dtype))}}const CT={kernelName:Cv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,i=e[0],a=kT(t,e[1],i,_y(r,i.shape));return{x:()=>a.x()}}},ST=hx({less_:function(t,e){let n=ux(t,"a","less","string_or_numeric"),s=ux(e,"b","less","string_or_numeric");return[n,s]=q_(n,s),TC(n.shape,s.shape),ex.runKernel(fv,{a:n,b:s})}}),IT={kernelName:Sv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>UC(t,Zx(PC(n,s),"float32")),b:()=>UC(t,Zx(ST(n,s),"float32"))}}},ET=hx({maxPool3dGrad_:function(t,e,n,s,r,i,a){const o=ux(t,"dy","maxPool3dGrad"),l=ux(e,"input","maxPool3dGrad"),u=ux(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=sC(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=sC(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=sC(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),cy(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),cy(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),cy(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),null!=a&&cy(gy(i),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`);const f=ex.runKernel(Tv,{dy:c,input:h,output:d},{filterSize:s,strides:r,pad:i,dimRoundingMode:a});return p?sC(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),NT={kernelName:Nv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=n;return{x:()=>ET(t,s,r,i,a,o,l)}}},TT=hx({maxPoolGrad_:function(t,e,n,s,r,i,a){const o=ux(t,"dy","maxPoolGrad"),l=ux(e,"input","maxPoolGrad"),u=ux(n,"output","maxPoolGrad");return cy(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),cy(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),cy(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),null!=a&&cy(gy(i),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`),ex.runKernel(Ev,{dy:o,input:l,output:u},{filterSize:s,strides:r,pad:i,dimRoundingMode:a})}}),AT={kernelName:Iv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o}=n;return{x:()=>TT(t,s,r,i,a,o)}}},$T={kernelName:$v,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,i=_y(r,s.shape),a=fy(eS(s.shape,i)[1]);return{x:()=>{const e=s.shape.slice();i.forEach(t=>{e[t]=1});const n=sC(t,e);return SC(UC(n,pS(s.shape,"float32")),a)}}}},RT={kernelName:Rv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[i,a]=e,o=kT(t,a,i,_y(r,i.shape));return{x:()=>o.x()}}},OT={kernelName:Ov,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>UC(t,Zx(PI(n,s),"float32")),b:()=>UC(t,Zx(MC(n,s),"float32"))}}},FT={kernelName:Fv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(t=>t[0]);return{x:()=>ES(t,i,s.shape)}}},DT={kernelName:Dv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=TC(n.shape,s.shape);return{a:()=>{const e=NC(n.shape,r);return e.length>0?sC(HC(t,e),n.shape):t},b:()=>{const e=UC(t,uS(DC(SC(n,s)))),i=NC(s.shape,r);return i.length>0?sC(HC(e,i),s.shape):e}}}},LT={kernelName:Mv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=TC(n.shape,s.shape);return{a:()=>{const e=UC(t,Zx(s,"float32")),i=NC(n.shape,r);return i.length>0?sC(HC(e,i),n.shape):e},b:()=>{const e=UC(t,Zx(n,"float32")),i=NC(s.shape,r);return i.length>0?sC(HC(e,i),s.shape):e}}}},MT={kernelName:Pv,gradFunc:t=>({x:()=>uS(t)})},PT={kernelName:jv,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>dS(n.shape,"float32")}}},zT={kernelName:Uv,gradFunc:t=>({x:()=>HS(t)})},VT={kernelName:Hv,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return WS(t,s).map(t=>()=>t)}},BT={kernelName:Gv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(t=>t[0]);return{x:()=>ES(t,i,s.shape)}}},WT={kernelName:qv,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,i=n,a=s,o=TC(i.shape,a.shape);return{a:()=>{const e=Zx(a,"float32");let n=UC(t,UC(e,HI(i,jC(e,Mk(1)))));const s=NC(i.shape,o);return s.length>0&&(n=HC(n,s)),sC(n,i.shape)},b:()=>{const e=MC(i,0),n=jS(e,VC(i),HS(i));let s=UC(t,UC(r,n));const l=NC(a.shape,o);return l.length>0&&(s=HC(s,l)),sC(s,a.shape)}}}},UT={kernelName:Kv,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=MC(n,0);return{x:()=>jS(r,t,UC(t,s)),alpha:()=>{let e=jS(r,HS(t),UC(t,n));const i=NC(s.shape,t.shape);return i.length>0&&(e=HC(e,i)),sC(e,s.shape)}}}},jT={kernelName:Wb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=TC(n.shape,s.shape);return{a:()=>{const e=SC(t,Zx(s,"float32")),i=NC(n.shape,r);return i.length>0?sC(HC(e,i),n.shape):e},b:()=>{let e=UC(t,Zx(n,"float32"));const i=NC(s.shape,r);i.length>0&&(e=sC(HC(e,i),s.shape));const a=oS(s);return uS(SC(e,Zx(a,"float32")))}}}},HT={kernelName:Qv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SC(t,uS(oS(n)))}}},GT={kernelName:iw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=UC(PI(n,6),nI(n));return{x:()=>UC(t,Zx(s,"float32"))}}},qT={kernelName:Jv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(t,Zx(nI(n),"float32"))}}},KT={kernelName:tw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sC(t,n.shape)}}},XT={kernelName:sw,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ex.runKernel(rw,r,n)}}},ZT={kernelName:ew,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ex.runKernel(nw,r,n)}}},YT={kernelName:aw,gradFunc:(t,e,n)=>{const{dims:s}=n,r=_y(s,t.shape);return{x:()=>kS(t,r)}}},QT={kernelName:ow,gradFunc:t=>({x:()=>HS(t)})},JT={kernelName:lw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>uS(SC(t,UC(HI(n,1.5),2)))}}},tA=hx({logicalNot_:function(t){const e=ux(t,"x","logicalNot","bool");return ex.runKernel(wv,{x:e})}}),eA={kernelName:cw,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Zx(HS(n),"float32"),t:()=>UC(t,Zx(n,t.dtype)),e:()=>UC(t,Zx(tA(n),t.dtype))}}},nA={kernelName:hw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=MC(n,Mk(0)),s=Mk(PE),r=Mk(zE),i=UC(t,r),a=UC(UC(t,s),BC(Zx(n,"float32")));return jS(e,i,a)}}}},sA={kernelName:gw,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(t,UC(n,jC(Mk(1),n)))}}},rA={kernelName:mw,gradFunc:t=>({x:()=>HS(t)})},iA=hx({cos_:function(t){const e=ux(t,"x","cos");return ex.runKernel(Tb,{x:e})}}),aA={kernelName:pw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(iA(Zx(n,"float32")),t)}}},oA=hx({cosh_:function(t){const e=ux(t,"x","cosh");return ex.runKernel(Ab,{x:e})}}),lA={kernelName:fw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(oA(Zx(n,"float32")),t)}}},uA={kernelName:dw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:i}=n,a=s.shape,[o,l]=Sk(s,r,i),u=[];for(let c=0;c<t.rank;c++)u.push([o[c],a[c]-o[c]-l[c]]);return{x:()=>mS(t,u)}}},cA={kernelName:xw,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,i=UC(t,s);return{logits:()=>jC(i,UC(HC(i,[r],!0),s))}}},hA={kernelName:yw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(t,IS(n))}}},dA=hx({batchToSpaceND_:function(t,e,n){const s=ux(t,"x","batchToSpaceND"),r=e.reduce((t,e)=>t*e);return cy(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),cy(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),cy(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`),ex.runKernel(mb,{x:s},{blockShape:e,crops:n})}}),pA={kernelName:ww,gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>dA(t,s,r)}}},fA={kernelName:_w,gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>hC(t,s)}}},mA=[gN,yN,bN,vN,wN,_N,xN,kN,CN,SN,IN,EN,TN,$N,RN,FN,DN,LN,MN,PN,zN,VN,WN,BN,jN,GN,KN,ZN,YN,QN,jT,JN,tT,eT,nT,sT,iT,rT,oT,uT,dT,pT,fT,mT,gT,yT,bT,vT,wT,xT,CT,CT,IT,NT,AT,$T,RT,OT,FT,DT,LT,MT,PT,zT,VT,BT,BT,WT,UT,HT,GT,qT,KT,XT,ZT,YT,QT,JT,eA,nA,sA,rA,aA,lA,uA,cA,hA,pA,pA,fA,fA,{kernelName:bw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SC(t,UC(DS(Zx(n,"float32")),2))}}},{kernelName:Nw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Mk(2);return{a:()=>UC(t,UC(r,jC(n,s))),b:()=>UC(t,UC(r,jC(s,n)))}}},{kernelName:Tw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(t,UC(Zx(n,"float32"),2))}}},{kernelName:Hw,gradFunc:t=>({x:()=>HS(t)})},{kernelName:Fw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=TC(n.shape,s.shape);return{a:()=>{let e=t;const s=NC(n.shape,r);return s.length>0&&(e=HC(e,s)),sC(e,n.shape)},b:()=>{let e=t;const n=NC(s.shape,r);return n.length>0&&(e=HC(e,n)),sC(uS(e),s.shape)}}}},{kernelName:vw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:i}=n;_y(i,s.shape).forEach(t=>{r[t]=1});const a=sC(t,r),o=UC(a,pS(s.shape,"float32"));return{x:()=>o}}},{kernelName:Dw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SC(t,oS(iA(n)))}}},{kernelName:Lw,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(jC(Mk(1),oS(n)),t)}}},{kernelName:Mw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let e=HS(s);if(1===s.rank)for(let n=0;n<r[0];++n)e=Vk(e,ES(t,[n*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)e=Vk(e,ES(t,[n*s.shape[0],i*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let a=0;a<r[2];++a)e=Vk(e,ES(t,[n*s.shape[0],i*s.shape[1],a*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let a=0;a<r[2];++a)for(let o=0;o<r[3];++o)e=Vk(e,ES(t,[n*s.shape[0],i*s.shape[1],a*s.shape[2],o*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return e}}}},{kernelName:Vw,gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,i=iS(r);return{x:()=>GS(t,i)}}},{kernelName:Ww,gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>MS(t,r)}}},{kernelName:Uw,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=ZC(e,HS(e)),s=LC(t,n);let r=PC(e,Mk(0,"int32"));const i=s.rank-r.rank;for(let o=0;o<i;++o)r=$C(r,o+1);r=qC(r,pS(s.shape,"bool"));const a=HS(s);return jS(r,s,a)}(t,n)}}},{kernelName:jw,gradFunc:t=>({x:()=>HS(t)})}];for(const M7 of mA)s_(M7);M_().prototype.abs=function(){return this.throwIfDisposed(),zk(this)};const gA=hx({acos_:function(t){const e=ux(t,"x","acos");return ex.runKernel(Yy,{x:e})}});M_().prototype.acos=function(){return this.throwIfDisposed(),gA(this)};const yA=hx({acosh_:function(t){const e=ux(t,"x","acosh");return ex.runKernel(Qy,{x:e})}});M_().prototype.acosh=function(){return this.throwIfDisposed(),yA(this)},M_().prototype.add=function(t){return this.throwIfDisposed(),Vk(this,t)},M_().prototype.all=function(t,e){return this.throwIfDisposed(),Bk(this,t,e)},M_().prototype.any=function(t,e){return this.throwIfDisposed(),Wk(this,t,e)},M_().prototype.argMax=function(t){return this.throwIfDisposed(),Uk(this,t)};const bA=hx({argMin_:function(t,e=0){const n=ux(t,"x","argMin");return ex.runKernel(rb,{x:n},{axis:e})}});M_().prototype.argMin=function(t){return this.throwIfDisposed(),bA(this,t)},M_().prototype.asScalar=function(){return this.throwIfDisposed(),cy(1===this.size,()=>"The array must have only 1 element."),sC(this,[])},M_().prototype.asType=function(t){return this.throwIfDisposed(),Zx(this,t)},M_().prototype.as1D=function(){return this.throwIfDisposed(),sC(this,[this.size])},M_().prototype.as2D=function(t,e){return this.throwIfDisposed(),sC(this,[t,e])},M_().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),sC(this,[t,e,n])},M_().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),sC(this,[t,e,n,s])},M_().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),sC(this,[t,e,n,s,r])};const vA=hx({asin_:function(t){const e=ux(t,"x","asin");return ex.runKernel(ib,{x:e})}});M_().prototype.asin=function(){return this.throwIfDisposed(),vA(this)};const wA=hx({asinh_:function(t){const e=ux(t,"x","asinh");return ex.runKernel(ab,{x:e})}});M_().prototype.asinh=function(){return this.throwIfDisposed(),wA(this)};const _A=hx({atan_:function(t){const e=ux(t,"x","atan");return ex.runKernel(ob,{x:e})}});M_().prototype.atan=function(){return this.throwIfDisposed(),_A(this)};const xA=hx({atan2_:function(t,e){let n=ux(t,"a","atan2"),s=ux(e,"b","atan2");return[n,s]=q_(n,s),ex.runKernel(ub,{a:n,b:s})}});M_().prototype.atan2=function(t){return this.throwIfDisposed(),xA(this,t)};const kA=hx({atanh_:function(t){const e=ux(t,"x","atanh");return ex.runKernel(lb,{x:e})}});M_().prototype.atanh=function(){return this.throwIfDisposed(),kA(this)},M_().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),rC(this,t,e,n,s)},M_().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),dA(this,t,e)},M_().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),aC(this,t,e,n,s,r)},M_().prototype.broadcastTo=function(t){return this.throwIfDisposed(),US(this,t)},M_().prototype.cast=function(t){return this.throwIfDisposed(),Zx(this,t)};const CA=hx({ceil_:function(t){const e=ux(t,"x","ceil");return ex.runKernel(bb,{x:e})}});M_().prototype.ceil=function(){return this.throwIfDisposed(),CA(this)},M_().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),cC(this,t,e)},M_().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof L_&&(t=[t]),hC([this,...t],e)},M_().prototype.conv1d=function(t,e,n,s,r,i){return this.throwIfDisposed(),yC(this,t,e,n,s,r,i)},M_().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),vC(this,t,e,n,s,r)},M_().prototype.conv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),gC(this,t,e,n,s,r,i)},M_().prototype.cos=function(){return this.throwIfDisposed(),iA(this)},M_().prototype.cosh=function(){return this.throwIfDisposed(),oA(this)},M_().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),XN(this,t,e,n)};const SA=hx({depthToSpace_:function(t,e,n="NHWC"){const s=ux(t,"x","depthToSpace"),r="NHWC"===n?s.shape[1]:s.shape[2],i="NHWC"===n?s.shape[2]:s.shape[3],a="NHWC"===n?s.shape[3]:s.shape[1];return cy(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${e}  for depthToSpace with input shape\n    ${s.shape}`),cy(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e} for depthToSpace with input shape\n        ${s.shape}`),cy(a%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`),ex.runKernel(Fb,{x:s},{blockSize:e,dataFormat:n})}});M_().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),SA(this,t,e)},M_().prototype.depthwiseConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),kC(this,t,e,n,s,r,i)};const IA=hx({dilation2d_:function(t,e,n,s,r=[1,1],i="NHWC"){const a=ux(t,"x","dilation2d"),o=ux(e,"filter","dilation2d");cy(3===a.rank||4===a.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),cy(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),cy("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=a,u=!1;3===a.rank&&(l=sC(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);const c=ex.runKernel(zb,{x:l,filter:o},{strides:n,pad:s,dilations:r});return u?sC(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});M_().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),IA(this,t,e,n,s,r)};const EA=hx({divNoNan_:function(t,e){let n=ux(t,"a","div"),s=ux(e,"b","div");[n,s]=q_(n,s);const r=SC(n,s),i=HS(r),a=AC(s,i);return jS(a,i,r)}});M_().prototype.divNoNan=function(t){return this.throwIfDisposed(),EA(this,t)},M_().prototype.div=function(t){return this.throwIfDisposed(),SC(this,t)};const NA=hx({dot_:function(t,e){const n=ux(t,"t1","dot"),s=ux(e,"t2","dot");cy(!(1!==n.rank&&2!==n.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=1===n.rank?n.size:n.shape[1],i=1===s.rank?s.size:s.shape[0];if(cy(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),1===n.rank&&1===s.rank){const t=sC(n,[1,-1]),e=sC(s,[-1,1]),r=hI(t,e);return sC(r,[])}if(1===n.rank&&2===s.rank){const t=sC(n,[1,-1]),e=sC(s,[s.shape[0],s.shape[1]]),r=hI(t,e);return sC(r,[r.size])}if(2===n.rank&&1===s.rank){const t=sC(s,[-1,1]),e=hI(n,t);return sC(e,[e.size])}{const t=sC(s,[s.shape[0],s.shape[1]]);return hI(n,t)}}});M_().prototype.dot=function(t){return this.throwIfDisposed(),NA(this,t)},M_().prototype.elu=function(){return this.throwIfDisposed(),IC(this)},M_().prototype.equal=function(t){return this.throwIfDisposed(),AC(this,t)};const TA=hx({erf_:function(t){let e=ux(t,"x","erf");return cy("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=Zx(e,"float32")),ex.runKernel(Gb,{x:e})}});M_().prototype.erf=function(){return this.throwIfDisposed(),TA(this)},M_().prototype.exp=function(){return this.throwIfDisposed(),BC(this)},M_().prototype.expandDims=function(t){return this.throwIfDisposed(),$C(this,t)};const AA=hx({expm1_:function(t){const e=ux(t,"x","expm1");return ex.runKernel(Zb,{x:e})}});M_().prototype.expm1=function(){return this.throwIfDisposed(),AA(this)},M_().prototype.fft=function(){return this.throwIfDisposed(),ZS(this)},M_().prototype.flatten=function(){return this.throwIfDisposed(),sC(this,[this.size])},M_().prototype.floor=function(){return this.throwIfDisposed(),DC(this)},M_().prototype.floorDiv=function(t){return this.throwIfDisposed(),CC(this,t)},M_().prototype.gather=function(t,e){return this.throwIfDisposed(),LC(this,t,e)},M_().prototype.greaterEqual=function(t){return this.throwIfDisposed(),PC(this,t)},M_().prototype.greater=function(t){return this.throwIfDisposed(),MC(this,t)},M_().prototype.ifft=function(){return this.throwIfDisposed(),QS(this)},M_().prototype.irfft=function(){return this.throwIfDisposed(),JS(this)};const $A=hx({isFinite_:function(t){const e=ux(t,"x","isFinite");return ex.runKernel(cv,{x:e})}});M_().prototype.isFinite=function(){return this.throwIfDisposed(),$A(this)};const RA=hx({isInf_:function(t){const e=ux(t,"x","isInf");return ex.runKernel(hv,{x:e})}});M_().prototype.isInf=function(){return this.throwIfDisposed(),RA(this)};const OA=hx({isNaN_:function(t){const e=ux(t,"x","isNaN");return ex.runKernel(dv,{x:e})}});M_().prototype.isNaN=function(){return this.throwIfDisposed(),OA(this)},M_().prototype.leakyRelu=function(t){return this.throwIfDisposed(),zC(this,t)},M_().prototype.lessEqual=function(t){return this.throwIfDisposed(),PI(this,t)},M_().prototype.less=function(t){return this.throwIfDisposed(),ST(this,t)};const FA=hx({localResponseNormalization_:function(t,e=5,n=1,s=1,r=.5){const i=ux(t,"x","localResponseNormalization");cy(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),cy(gy(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=i,o=!1;3===i.rank&&(o=!0,a=sC(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l=ex.runKernel(xv,{x:a},{depthRadius:e,bias:n,alpha:s,beta:r});return o?sC(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});M_().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),FA(this,t,e,n,s)};const DA=hx({logSigmoid_:function(t){const e=ux(t,"x","logSigmoid");return Lk(t=>({value:uS(OS(uS(t))),gradFunc:e=>UC(e,IS(uS(t)))}))(e)}});M_().prototype.logSigmoid=function(){return this.throwIfDisposed(),DA(this)},M_().prototype.logSoftmax=function(t){return this.throwIfDisposed(),GC(this,t)},M_().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),eE(this,t,e)},M_().prototype.log=function(){return this.throwIfDisposed(),VC(this)},M_().prototype.log1p=function(){return this.throwIfDisposed(),tE(this)},M_().prototype.logicalAnd=function(t){return this.throwIfDisposed(),qC(this,t)},M_().prototype.logicalNot=function(){return this.throwIfDisposed(),tA(this)};const LA=hx({logicalOr_:function(t,e){const n=ux(t,"a","logicalOr","bool"),s=ux(e,"b","logicalOr","bool");return TC(n.shape,s.shape),ex.runKernel(_v,{a:n,b:s})}});M_().prototype.logicalOr=function(t){return this.throwIfDisposed(),LA(this,t)};const MA=hx({logicalXor_:function(t,e){const n=ux(t,"a","logicalXor","bool"),s=ux(e,"b","logicalXor","bool");return TC(n.shape,s.shape),qC(LA(t,e),tA(qC(t,e)))}});M_().prototype.logicalXor=function(t){return this.throwIfDisposed(),MA(this,t)},M_().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),hI(this,t,e,n)},M_().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),KC(this,t,e,n,s)},M_().prototype.max=function(t,e){return this.throwIfDisposed(),WC(this,t,e)},M_().prototype.maximum=function(t){return this.throwIfDisposed(),ZC(this,t)},M_().prototype.mean=function(t,e){return this.throwIfDisposed(),YC(this,t,e)},M_().prototype.min=function(t,e){return this.throwIfDisposed(),jI(this,t,e)},M_().prototype.minimum=function(t){return this.throwIfDisposed(),QC(this,t)};const PA=hx({mirrorPad_:function(t,e,n){cy("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=ux(t,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");cy(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r="reflect"===n?1:0;for(let i=0;i<s.rank;i++)cy(2===e[i].length,()=>"Invalid number of paddings. Must be length of 2 each."),cy(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);return ex.runKernel(Fv,{x:s},{paddings:e,mode:n})}});M_().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),PA(this,t,e)};const zA=hx({mod_:function(t,e){let n=ux(t,"a","mod"),s=ux(e,"b","mod");return[n,s]=q_(n,s),ex.runKernel(Dv,{a:n,b:s})}});M_().prototype.mod=function(t){return this.throwIfDisposed(),zA(this,t)},M_().prototype.mul=function(t){return this.throwIfDisposed(),UC(this,t)},M_().prototype.neg=function(){return this.throwIfDisposed(),uS(this)},M_().prototype.norm=function(t,e,n){return this.throwIfDisposed(),qI(this,t,e,n)},M_().prototype.notEqual=function(t){return this.throwIfDisposed(),cS(this,t)},M_().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),hS(this,t,e,n)},M_().prototype.onesLike=function(){return this.throwIfDisposed(),fS(this)},M_().prototype.pad=function(t,e){return this.throwIfDisposed(),mS(this,t,e)};const VA=hx({pool_:function(t,e,n,s,r,i){null==r&&(r=[1,1]),null==i&&(i=1),0===s&&(s="valid");const a=ux(t,"x","maxPool");let o=a,l=!1;3===a.rank&&(l=!0,o=sC(a,[1,a.shape[0],a.shape[1],a.shape[2]])),cy(eC(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const u=Hk(o.shape,e,i,r,s),c=[u.dilationHeight,u.dilationWidth];let h;h="same"===s?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),s=n.map(t=>Math.floor(t/2)),r=n.map((t,e)=>t-s[e]);return n.map((t,e)=>[s[e],r[e]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(t,e,n){const s=n.map(t=>t[0]),r=n.map(t=>t[1]),i=t.concat(s,r),a=e.map((t,e)=>(t-i[e]%t)%t),o=r.map((t,e)=>t+a[e]);return[e.map((t,e)=>[s[e],o[e]]),e.map((t,e)=>[0,a[e]])]}([u.inHeight,u.inWidth],c,h),m=d?s:"valid",g=d?o:ON(o,c,p),y=("avg"===n?()=>rC(g,e,i,m):()=>KC(g,e,i,m))(),b=d?y:dA(y,c,f);return l?sC(b,[b.shape[1],b.shape[2],b.shape[3]]):b}});M_().prototype.pool=function(t,e,n,s,r){return this.throwIfDisposed(),VA(this,t,e,n,s,r)},M_().prototype.pow=function(t){return this.throwIfDisposed(),HI(this,t)},M_().prototype.prelu=function(t){return this.throwIfDisposed(),gS(this,t)};const BA=hx({prod_:function(t,e=null,n=!1){let s=ux(t,"x","prod");return"bool"===s.dtype&&(s=Zx(s,"int32")),ex.runKernel(Xv,{x:s},{axis:e,keepDims:n})}});M_().prototype.prod=function(t,e){return this.throwIfDisposed(),BA(this,t,e)};const WA=hx({reciprocal_:function(t){const e=ux(t,"x","reciprocal");return ex.runKernel(Qv,{x:e})}});M_().prototype.reciprocal=function(){return this.throwIfDisposed(),WA(this)},M_().prototype.relu=function(){return this.throwIfDisposed(),xS(this)},M_().prototype.relu6=function(){return this.throwIfDisposed(),eI(this)},M_().prototype.reshapeAs=function(t){return this.throwIfDisposed(),sC(this,t.shape)},M_().prototype.reshape=function(t){return this.throwIfDisposed(),sC(this,t)},M_().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),DI(this,t,e,n)},M_().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),LI(this,t,e,n)},M_().prototype.reverse=function(t){return this.throwIfDisposed(),kS(this,t)},M_().prototype.rfft=function(){return this.throwIfDisposed(),YS(this)},M_().prototype.round=function(){return this.throwIfDisposed(),zI(this)},M_().prototype.rsqrt=function(){return this.throwIfDisposed(),aT(this)},M_().prototype.selu=function(){return this.throwIfDisposed(),CS(this)},M_().prototype.separableConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),SS(this,t,e,n,s,r,i)},M_().prototype.sigmoid=function(){return this.throwIfDisposed(),IS(this)};const UA=hx({sign_:function(t){const e=ux(t,"x","sign");return ex.runKernel(mw,{x:e})}});M_().prototype.sign=function(){return this.throwIfDisposed(),UA(this)},M_().prototype.sin=function(){return this.throwIfDisposed(),HN(this)},M_().prototype.sinh=function(){return this.throwIfDisposed(),qN(this)},M_().prototype.slice=function(t,e){return this.throwIfDisposed(),ES(this,t,e)},M_().prototype.softmax=function(t){return this.throwIfDisposed(),RS(this,t)},M_().prototype.softplus=function(){return this.throwIfDisposed(),OS(this)},M_().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),ON(this,t,e)},M_().prototype.split=function(t,e){return this.throwIfDisposed(),FS(this,t,e)},M_().prototype.sqrt=function(){return this.throwIfDisposed(),DS(this)},M_().prototype.square=function(){return this.throwIfDisposed(),oS(this)},M_().prototype.squaredDifference=function(t){return this.throwIfDisposed(),JI(this,t)},M_().prototype.squeeze=function(t){return this.throwIfDisposed(),LS(this,t)},M_().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof L_?[this,t]:[this,...t];return MS(n,e)},M_().prototype.step=function(t){return this.throwIfDisposed(),nI(this,t)};const jA=hx({stridedSlice_:function(t,e,n,s,r=0,i=0,a=0,o=0,l=0){const u=ux(t,"x","stridedSlice","string_or_numeric");return ex.runKernel(Aw,{x:u},{begin:e,end:n,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l})}});M_().prototype.stridedSlice=function(t,e,n,s,r,i,a,o){return this.throwIfDisposed(),jA(this,t,e,n,s,r,i,a,o)},M_().prototype.sub=function(t){return this.throwIfDisposed(),jC(this,t)},M_().prototype.sum=function(t,e){return this.throwIfDisposed(),HC(this,t,e)};const HA=hx({tan_:function(t){const e=ux(t,"x","tan");return ex.runKernel(Dw,{x:e})}});M_().prototype.tan=function(){return this.throwIfDisposed(),HA(this)},M_().prototype.tanh=function(){return this.throwIfDisposed(),PS(this)},M_().prototype.tile=function(t){return this.throwIfDisposed(),RC(this,t)},M_().prototype.toBool=function(){return this.throwIfDisposed(),Zx(this,"bool")},M_().prototype.toFloat=function(){return this.throwIfDisposed(),Zx(this,"float32")},M_().prototype.toInt=function(){return this.throwIfDisposed(),Zx(this,"int32")};const GA=hx({topk_:function(t,e=1,n=!0){const s=ux(t,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},a={k:e,sorted:n},[o,l]=ex.runKernel(Pw,i,a);return{values:o,indices:l}}});M_().prototype.topk=function(t,e){return this.throwIfDisposed(),GA(this,t,e)},M_().prototype.transpose=function(t){return this.throwIfDisposed(),GS(this,t)};const qA=hx({unique_:function(t,e=0){const n=ux(t,"x","unique","string_or_numeric");cy(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[i,a]=ex.runKernel(Bw,s,r);return{values:i,indices:a}}});let KA;function XA(){return null==KA&&(KA=ex.backend.epsilon()),KA}M_().prototype.unique=function(t){return this.throwIfDisposed(),qA(this,t)},M_().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),lT(this,t,e)},M_().prototype.unstack=function(t){return this.throwIfDisposed(),WS(this,t)},M_().prototype.where=function(t,e){return this.throwIfDisposed(),jS(t,this,e)},M_().prototype.zerosLike=function(){return this.throwIfDisposed(),HS(this)};class ZA extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ZA.prototype)}}class YA extends Error{constructor(t){super(t),Object.setPrototypeOf(this,YA.prototype)}}class QA extends Error{constructor(t){super(t),Object.setPrototypeOf(this,QA.prototype)}}class JA extends Error{constructor(t){super(t),Object.setPrototypeOf(this,JA.prototype)}}class t$ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,t$.prototype)}}function e$(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function n$(t,e){if(!t)throw new t$(e)}function s$(t,e){let n=0;for(const s of t)s===e&&n++;return n}function r$(t){return 1===t.length?t[0]:t}function i$(t){return Array.isArray(t)?t:[t]}function a$(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function o$(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let l$={};function u$(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function c$(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(t=>c$(t));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?c$(e):t[n]=e.value)}}}function h$(t,e={},n={},s="object",r=!1){if("string"==typeof t){const r=t;let i;if(r in n)i=n[r];else if(r in l$)i=l$[r];else if(i=e[r],null==i)throw new QA(`Unknown ${s}: ${t}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=t;if(null==i.className||null==i.config)throw new QA(`${s}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const a=i.className;let o,l;if(a in n?[o,l]=n[a]:a in l$?[o,l]=l$.className:a in e&&([o,l]=e[a]),null==o)throw new QA(`Unknown ${s}: ${a}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const n of Object.keys(l$))t[n]=l$[n];for(const r of Object.keys(n))t[r]=n[r];i.config.customObjects=t;const e=Object.assign({},l$);for(const r of Object.keys(n))l$[r]=n[r];c$(i.config);const s=l(o,i.config,n,r);return l$=Object.assign({},e),s}{const t=Object.assign({},l$);for(const s of Object.keys(n))l$[s]=n[s];const e=new o(i.config);return l$=Object.assign({},t),e}}}function d$(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function p$(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function f$(t){if(null==t)throw new QA(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function m$(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new QA(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function g$(t,e,n=0,s=1/0){return n$(n>=0),n$(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(t=>typeof t===e)}function y$(t,e){Array.isArray(t)?(cy(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((t,n)=>y$(t,`element ${n+1} of ${e}`))):cy(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${b$(t)}.`)}function b$(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>b$(t)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function v$(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function w$(t,e){return Rk(()=>DS(HC(UC(t,t),e,!0)))}class _$ extends Ek{getConfig(){return{}}}class x$ extends _${constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Rk(()=>{const e=w$(t,this.axis),n=cC(e,0,this.maxValue);return UC(t,SC(n,Vk(XA(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}x$.className="MaxNorm",Tk(x$);class k$ extends _${constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Rk(()=>SC(t,Vk(XA(),w$(t,this.axis))))}getConfig(){return{axis:this.axis}}}k$.className="UnitNorm",Tk(k$);class C$ extends _${apply(t){return xS(t)}}C$.className="NonNeg",Tk(C$);class S$ extends _${constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Rk(()=>{const e=w$(t,this.axis),n=Vk(UC(this.rate,cC(e,this.minValue,this.maxValue)),UC(1-this.rate,e));return UC(t,SC(n,Vk(XA(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}S$.className="MinMaxNorm",Tk(S$);const I$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function E$(t){return u$(t)}function N$(t,e={}){return h$(t,Nk.getMap().classNameMap,e,"constraint")}function T$(t){return null==t?null:"string"==typeof t?N$({className:t in I$?I$[t]:t,config:{}}):t instanceof _$?t:N$(t)}const A$=["channelsFirst","channelsLast"],$$=["nearest","bilinear"],R$=["valid","same","causal"],O$=["max","avg"],F$=["sum","mul","concat","ave"],D$=new Map;function L$(t){m$(A$,"DataFormat",t)}function M$(t){m$(R$,"PaddingMode",t)}function P$(t){m$(O$,"PoolMode",t)}const z$=[];function V$(t,e){z$.push(t);try{const t=e();return z$.pop(),t}catch(n){throw z$.pop(),n}}function B$(t){if(!j$(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===z$.length?"":z$.join("/")+"/")+t}function W$(t){if(!j$(t))throw new Error("Not a valid tensor name: '"+t+"'");D$.has(t)||D$.set(t,0);const e=D$.get(t);if(D$.set(t,D$.get(t)+1),e>0){const n=`${t}_${e}`;return D$.set(n,1),n}return t}const U$=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function j$(t){return!!t.match(U$)}function H$(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function G$(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s<e&&(e=s)}return e}function q$(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s>e&&(e=s)}return e}function K$(t,e){if(e<t)throw new QA(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}function X$(t,e){return t.asType(e)}function Z$(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),t.reshape(n)}function Y$(t,e,n){return Rk(()=>{switch(t.rank){case 1:return NS(t,e,n);case 2:return TS(t,[e,0],[n,t.shape[1]]);case 3:return AS(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return $S(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return ES(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return ES(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new QA(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Q$(t,e,n){return Rk(()=>{switch(t.rank){case 1:return NS(t,e,n);case 2:return TS(t,[0,e],[t.shape[0],n]);case 3:return AS(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return $S(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new QA(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function J$(t,e,n,s){return Rk(()=>{switch(t.rank){case 1:return NS(t,e,n);case 2:switch(s){case 1:return Y$(t,e,n);case 2:return Q$(t,e,n);default:throw new QA(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Y$(t,e,n);case 2:return AS(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return Q$(t,e,n);default:throw new QA(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Y$(t,e,n);case 2:return $S(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return $S(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return Q$(t,e,n);default:throw new QA(`The axis is not within the rank of the tensor ${s}`)}default:throw new QA(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function tR(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),hC(t,e)}function eR(t,e){switch(t.rank){case 1:return dC([t,e]);case 2:return pC([t,e],0);case 3:return fC([t,e],0);case 4:return mC([t,e],0);default:throw new QA(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function nR(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new QA(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return RC(t,e)}function sR(t,e=0,n=1,s,r){return wS(t,e,n,s,r)}function rR(t,e,n,s){if(t.rank<2||e.rank<2)throw new JA(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new JA(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);if(2===t.rank&&2===e.rank)return dI({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?oR(t.rank,s,"channelsLast"):null,activation:n});{const r=t.shape.slice(),i=r.pop();t=t.reshape([-1,i]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],c=Array.from({length:e.rank},(t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n);e=e.transpose(c).reshape([l,-1]);const h=[...r,...u];return dI({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?oR(t.rank,s,"channelsLast"):null,activation:n}).reshape(h)}}function iR(t,e,n){return Rk(()=>(e=Array.isArray(e)?zS(e,"int32"):e.toInt(),LC(t,e,n)))}function aR(t){return UC(t,t)}function oR(t,e,n){const s=e.shape;if(1!==e.rank&&e.rank!==t)throw new QA(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,s[0]]:[1].concat(s))}else if(t<3)return e;throw new QA(`Unsupported input rank by biasAdd: ${e.rank}`)}function lR(t,e,n){return Rk(()=>(null==n&&(n="channelsLast"),L$(n),t.add(oR(t.rank,e,n))))}function uR(t,e,n,s){return Rk(()=>qS(t,e,n,s))}function cR(t,e,n=!1){return n?t():e()}const hR=["fanIn","fanOut","fanAvg"],dR=["normal","uniform","truncatedNormal"];class pR extends Ek{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class fR extends pR{apply(t,e){return dS(t,e)}}fR.className="Zeros",Tk(fR);class mR extends pR{apply(t,e){return pS(t,e)}}mR.className="Ones",Tk(mR);class gR extends pR{constructor(t){if(super(),"object"!=typeof t)throw new QA(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new QA(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return Rk(()=>UC(Mk(this.value),pS(t,e)))}getConfig(){return{value:this.value}}}gR.className="Constant",Tk(gR);class yR extends pR{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return _S(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}yR.className="RandomUniform",Tk(yR);class bR extends pR{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new JA(`randomNormal does not support dType ${e}.`);return sR(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}bR.className="RandomNormal",Tk(bR);class vR extends pR{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new JA(`truncatedNormal does not support dType ${e}.`);return BS(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}vR.className="TruncatedNormal",Tk(vR);class wR extends pR{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return Rk(()=>{if(2!==t.length||t[0]!==t[1])throw new QA("Identity matrix initializer can only be used for 2D square matrices.");return UC(this.gain,OC(t[0]))})}getConfig(){return{gain:this.gain}}}wR.className="Identity",Tk(wR);class _R extends pR{constructor(t){if(super(),t.scale<0)throw new QA(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,m$(hR,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,m$(dR,"Distribution",this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,s;if(L$(e),2===t.length)n=t[0],s=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=H$(t,2);n=t[1]*e,s=t[0]*e}else if("channelsLast"===e){const e=H$(t,0,t.length-2);n=t[t.length-2]*e,s=t[t.length-1]*e}}else{const e=H$(t);n=Math.sqrt(e),s=Math.sqrt(e)}return[n,s]}(t),s=n[0],r=n[1];let i=this.scale;if(i/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,r):Math.max(1,(s+r)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new JA(`${this.getClassName()} does not support dType ${e}.`);return BS(t,0,n,e,this.seed)}{const n=Math.sqrt(3*i);return _S(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}_R.className="VarianceScaling",Tk(_R);class xR extends _R{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return _R.className}}xR.className="GlorotUniform",Tk(xR);class kR extends _R{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return _R.className}}kR.className="GlorotNormal",Tk(kR);class CR extends _R{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return _R.className}}CR.className="HeNormal",Tk(CR);class SR extends _R{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return _R.className}}SR.className="HeUniform",Tk(SR);class IR extends _R{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return _R.className}}IR.className="LeCunNormal",Tk(IR);class ER extends _R{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return _R.className}}ER.className="LeCunNormal",Tk(ER);class NR extends pR{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new JA("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return Rk(()=>{if(t.length<2)throw new JA("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=sR(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=cE.gramSchmidt(e);return t[0]>t[1]&&(n=n.transpose()),UC(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}NR.className="Orthogonal",Tk(NR);const TR={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function AR(t,e={}){return h$(t,Nk.getMap().classNameMap,e,"initializer")}function $R(t){return u$(t)}function RR(t){if("string"==typeof t){const e=t in TR?TR[t]:t;if("GlorotNormal"===e)return new kR;if("GlorotUniform"===e)return new xR;if("HeNormal"===e)return new CR;if("HeUniform"===e)return new SR;if("LeCunNormal"===e)return new IR;if("LeCunUniform"===e)return new ER;{const t={};return t.className=e,t.config={},AR(t)}}return t instanceof pR?t:AR(t)}let OR=0;function FR(){return OR++}const DR={};function LR(t=""){return t in DR||(DR[t]=0),DR[t]+=1,t+DR[t].toString()}function MR(t){return Array.isArray(t)&&Array.isArray(t[0])}function PR(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function zR(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new QA(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function VR(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new QA(`Expected exactly 1 Shape; got ${t.length}`)}return t}function BR(t){let e=0;for(const n of t)e+=0===n.shape.length?1:n.shape.reduce((t,e)=>t*e);return e}class WR{constructor(t,e="float32",n="Variable",s=!0,r=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=FR(),this.originalName=B$(n=null==n?"Variable":n),this.name=W$(this.originalName),this.trainable_=s,this.constraint=r,this.val=function(t,e=!0,n,s){return ex.makeVariable(t,e,n,s)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function UR(t){return t.map(t=>t.read())}function jR(t){t.forEach(t=>{t[0].write(t[1])})}class HR{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class GR{constructor(t,e,n,s,r,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=s,this.callArgs=r,this.outputTensorIndex=a,this.id=FR(),null!=i&&(this.originalName=B$(i),this.name=W$(this.originalName)),this.rank=e.length}}let qR=0;class KR{constructor(t,e){this.callArgs=e,this.id=qR++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let XR=0;class ZR extends Ek{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=XR++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=a$(t)+"_"+LR(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new YA(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new QA(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return r$(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return r$(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ZA(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new ZA(`Layer ${this.name} is not connected, no input to return.`);return r$(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new ZA(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ZA(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return r$(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=i$(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=i$(this.inputSpec);if(t.length!==e.length)throw new QA(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){const s=t[n],r=e[n];if(null==r)continue;const i=s.rank;if(null!=r.ndim&&i!==r.ndim)throw new QA(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${i}`);if(null!=r.maxNDim&&i>r.maxNDim)throw new QA(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${i}`);if(null!=r.minNDim&&i<r.minNDim)throw new QA(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${i}.`);if(null!=r.dtype&&s.dtype!==r.dtype)throw new QA(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${s.dtype}.`);if(r.axes){const t=s.shape;for(const e in r.axes){const s=Number(e),i=r.axes[e],a=s>=0?t[s]:t[t.length+s];if(null!=i&&-1===[i,null].indexOf(a))throw new QA(`Input ${n} is incompatible with layer ${this.name}: expected axis ${s} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const e=r.shape[t],i=s.shape[t];if(null!=e&&null!=i&&e!==i)throw new QA(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=i$(t);let s=!0;for(const i of n)if(!(i instanceof GR)){s=!1;break}let r=!0;for(const i of n)if(i instanceof GR){r=!1;break}if(s===r)throw new QA("Arguments to apply() must be all SymbolicTensors or all Tensors");return V$(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of i$(t))e.push(n.shape);this.build(r$(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(t),r){let s=this.call(t,e);const r=i$(s),i=[];for(let t of r)-1!==n.indexOf(t)&&(t=t.clone()),i.push(t);if(s=r$(i),null!=this.activityRegularizer)throw new JA("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}{const n=function(t){t=i$(t);const e=[];for(const n of t)e.push(n.shape);return r$(e)}(t),s=this.computeOutputShape(n);let r;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),r=null!=s&&s.length>0&&Array.isArray(s[0])?s.map((n,s)=>new GR(i,n,this,i$(t),e,this.name,s)):new GR(i,s,this,i$(t),e,this.name),this.addInboundNode(t,r,null,null,n,s,e),this._refCount++,null!=this.activityRegularizer)throw new JA("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,s)=>{null!=n&&null!=t[s]&&t[s]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new ZA(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new ZA(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new YA(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return BR(this.weights)}build(t){this.built=!0}getWeights(t=!1){return UR(t?this.trainableWeights:this.weights)}setWeights(t){Rk(()=>{const e=this.weights;if(e.length!==t.length)throw new QA(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],s=UR(e);for(let r=0;r<s.length;++r){const i=s[r],a=e[r],o=t[r];if(!my(i.shape,o.shape))throw new QA(`Layer weight shape ${i.shape} not compatible with provided weight shape ${o.shape}`);n.push([a,o])}jR(n)})}addWeight(t,e,n,s,r,i,a){if(-1!==this._addedWeightNames.indexOf(t))throw new QA(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(s=RR("zeros"));const o=s.apply(e,n),l=new WR(o,n,t,i,a);return o.dispose(),null!=r&&this.addLoss(()=>r.apply(l.read())),null==i&&(i=!0),i?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=i$(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,n,s,r,i,a=null){const o=i$(t);e=i$(e),n=i$(n),s=i$(s),r=PR(r),i=PR(i);const l=[],u=[],c=[];for(const h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new KR({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:e,inputMasks:n,outputMasks:s,inputShapes:r,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function YR(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const s=YR(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of s)-1===e.indexOf(t)&&e.push(t)}return e}}}class QR extends ZR{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:LR("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new QA("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new QA("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new QA("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const s=new GR(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new KR({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new QA(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function JR(t){return tO.apply(this,arguments)}function tO(){return(tO=ny(function*(t){if(null==t)return;const e=[],n=[],s=[];for(const r in t){const i=t[r];if("number"!=typeof i){const t=i;e.push(t.data()),n.push(r),s.push(t)}}if(e.length>0){const r=yield Promise.all(e);for(let e=0;e<r.length;++e)t[n[e]]=r[e][0];Ok(s)}})).apply(this,arguments)}function eO(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var nO;QR.className="InputLayer",Tk(QR),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(nO||(nO={}));class sO{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return ny(function*(){})()}onEpochEnd(t,e){return ny(function*(){})()}onBatchBegin(t,e){return ny(function*(){})()}onBatchEnd(t,e){return ny(function*(){})()}onTrainBegin(t){return ny(function*(){})()}onTrainEnd(t){return ny(function*(){})()}setModel(t){}}class rO{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var n=this;return ny(function*(){null==e&&(e={});for(const s of n.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var n=this;return ny(function*(){null==e&&(e={});for(const s of n.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var n=this;return ny(function*(){null==e&&(e={});for(const s of n.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var n=this;return ny(function*(){null==e&&(e={});for(const s of n.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return ny(function*(){null==t&&(t={});for(const n of e.callbacks)yield n.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return ny(function*(){null==t&&(t={});for(const n of e.callbacks)yield n.onTrainEnd(t)})()}}class iO extends sO{constructor(){super()}onEpochBegin(t){var e=this;return ny(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var n=this;return ny(function*(){null==e&&(e={});const t=null==e.size?0:e.size;n.seen+=t;for(const s in e){const r=e[s];if("number"==typeof r)n.totals.hasOwnProperty(s)||(n.totals[s]=0),n.totals[s]=n.totals[s]+r*t;else{let e;s in n.totals?e=n.totals[s]:n.totals[s]=0;const i=Rk(()=>Vk(n.totals[s],UC(r,t)));n.totals[s]=i,null!=e&&e.dispose()}}})()}onEpochEnd(t,e){var n=this;return ny(function*(){if(null!=e)for(const t of n.params.metrics)null!=n.totals[t]&&("number"==typeof n.totals[t]?e[t]=n.totals[t]/n.seen:Rk(()=>{const s=UC(SC(1,n.seen),n.totals[t]);e[t]=s,n.totals[t].dispose(),Fk(e[t])}))})()}}class aO extends sO{onTrainBegin(t){var e=this;return ny(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var n=this;return ny(function*(){null==e&&(e={}),n.epoch.push(t);for(const t in e)null==n.history[t]&&(n.history[t]=[]),n.history[t].push(e[t])})()}syncData(){var t=this;return ny(function*(){const e=[],n=[],s=[];for(const i in t.history){const r=t.history[i];for(let t=0;t<r.length;++t)"number"!=typeof r[t]&&(e.push(r[t].data()),n.push(i),s.push(t))}const r=yield Promise.all(e);for(let i=0;i<r.length;++i)t.history[n[i]][s[i]].dispose(),t.history[n[i]][s[i]]=r[i][0]})()}}class oO extends sO{constructor(t,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Ty(this.yieldEvery)&&(this.maybeWait=function(t,e){let n,s=__();return(...r)=>{const i=__();return i-s<e||(s=i,n=t(...r)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,n){var s=this;return ny(function*(){const r=[];null!=s.yield&&(yield JR(n),r.push(s.yield(t,e,n))),r.push(kE()),yield Promise.all(r)})()}onEpochBegin(t,e){var n=this;return ny(function*(){n.currentEpoch=t,null!=n.epochBegin&&(yield JR(e),yield n.epochBegin(t,e))})()}onEpochEnd(t,e){var n=this;return ny(function*(){const s=[];null!=n.epochEnd&&(yield JR(e),s.push(n.epochEnd(t,e))),"epoch"===n.yieldEvery&&s.push(kE()),yield Promise.all(s)})()}onBatchBegin(t,e){var n=this;return ny(function*(){null!=n.batchBegin&&(yield JR(e),yield n.batchBegin(t,e))})()}onBatchEnd(t,e){var n=this;return ny(function*(){const s=[];null!=n.batchEnd&&(yield JR(e),s.push(n.batchEnd(t,e))),"batch"===n.yieldEvery?s.push(kE()):Ty(n.yieldEvery)&&s.push(n.maybeWait(n.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return ny(function*(){null!=e.trainBegin&&(yield JR(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return ny(function*(){null!=e.trainEnd&&(yield JR(t),yield e.trainEnd(t))})()}}function lO(t,e){return null==t&&(t={}),t instanceof sO?[t]:Array.isArray(t)&&t[0]instanceof sO?t:i$(t).map(t=>new oO(t,e))}class uO{constructor(){}static registerCallbackConstructor(t,e){cy(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),uO.checkForDuplicate(e),null==uO.constructors[t]&&(uO.constructors[t]=[]),uO.constructors[t].push(e)}static checkForDuplicate(t){for(const e in uO.constructors)uO.constructors[+e].forEach(e=>{if(e===t)throw new QA("Duplicate callback constructor.")})}static clear(){uO.constructors={}}static createCallbacks(t){const e=[];for(const n in uO.constructors){const s=+n;t>=s&&e.push(...uO.constructors[s])}return e.map(t=>new t)}}function cO(t,e,n,s,r,i,a,o,l){const u=new aO,c=[new iO,...uO.createCallbacks(e)];null!=t&&c.push(...t),c.push(u);const h=new rO(c);return h.setParams({epochs:n,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:h,history:u}}function hO(t,e={},n=!1){return h$(t,Nk.getMap().classNameMap,e,"layer",n)}function dO(t,e){return Rk(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const n=HC(aR(t),e,!0),s=FC(n.shape,XA()),r=DS(ZC(n,s));return SC(t,r)})}function pO(t,e){return Rk(()=>YC(aR(jC(e,t)),-1))}function fO(t,e){return Rk(()=>YC(zk(jC(e,t)),-1))}function mO(t,e){return Rk(()=>{const n=jC(t,e),s=cC(zk(t),XA(),Number.MAX_VALUE),r=zk(SC(n,s));return UC(100,YC(r,-1))})}function gO(t,e,n=!1){return Rk(()=>{if(n)e=RS(e);else{const t=HC(e,e.shape.length-1,!0);e=SC(e,t)}return e=cC(e,XA(),1-XA()),uS(HC(UC(t.toFloat(),VC(e)),e.shape.length-1))})}function yO(t,e,n=!1){return Rk(()=>{const s=DC(function(t){const e=[H$(t.shape)];return t.reshape(e)}(t)).toInt(),r=(e=cC(e,XA(),1-XA())).shape;return gO(hS(s,r[r.length-1]).reshape(r),e,n)})}function bO(t,e){return Rk(()=>{let n;return n=cC(e,XA(),1-XA()),n=VC(SC(n,jC(1,n))),YC(function(t,e){if(!my(t.shape,e.shape))throw new QA(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return Rk(()=>{const n=e.relu(),s=e.abs().neg();return n.sub(e.mul(t)).add(s.exp().log1p())})}(t,n),-1)})}function vO(t,e){return Rk(()=>{const n=dO(t,-1),s=dO(e,-1),r=UC(n,s);return uS(HC(r,-1))})}uO.constructors={};const wO={meanSquaredError:pO,meanAbsoluteError:fO,meanAbsolutePercentageError:mO,meanSquaredLogarithmicError:function(t,e){return Rk(()=>{const n=cC(e,XA(),Number.MAX_VALUE),s=VC(Vk(1,n)),r=cC(t,XA(),Number.MAX_VALUE),i=VC(Vk(1,r));return YC(aR(jC(s,i)),-1)})},squaredHinge:function(t,e){return Rk(()=>{const n=ZC(0,jC(1,UC(t,e)));return YC(aR(n),-1)})},hinge:function(t,e){return Rk(()=>{const n=ZC(0,jC(1,UC(t,e)));return YC(n,-1)})},categoricalHinge:function(t,e){return Rk(()=>{const n=HC(UC(t,e),-1),s=WC(UC(jC(1,t),e),-1);return ZC(0,Vk(1,jC(s,n)))})},logcosh:function(t,e){return Rk(()=>{const n=Math.log(2),s=jC(e,t),r=jC(Vk(s,OS(UC(-2,s))),n);return YC(r,-1)})},categoricalCrossentropy:gO,sparseCategoricalCrossentropy:yO,binaryCrossentropy:bO,kullbackLeiblerDivergence:function(t,e){return Rk(()=>{const n=cC(t,XA(),1),s=cC(e,XA(),1);return HC(UC(t,VC(SC(n,s))),-1)})},poisson:function(t,e){return Rk(()=>{const n=VC(Vk(XA(),e));return YC(jC(e,UC(t,n)),-1)})},cosineProximity:vO};function _O(t){if("string"==typeof t){if(t in wO)return wO[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new QA(e)}return t}function xO(t,e){return Rk(()=>{const n=UC(.5,fS(e)),s=X$(MC(e,n),t.dtype);return YC(AC(t,s),-1)})}function kO(t,e){return Rk(()=>X$(AC(Uk(t,-1),Uk(e,-1)),"float32"))}function CO(t,e){return bO(t,e)}function SO(t,e){return t.rank===e.rank&&(t=t.squeeze([t.rank-1])),(e=e.argMax(-1)).dtype!==t.dtype&&(e=e.asType(t.dtype)),AC(t,e).asType("float32")}const IO=gO,EO=yO,NO={binaryAccuracy:xO,categoricalAccuracy:kO,precision:function(t,e){return Rk(()=>{const n=function(t,e){return Rk(()=>qC(t.equal(1),e.equal(1)).sum().cast("float32"))}(t,e),s=function(t,e){return Rk(()=>qC(t.equal(0),e.equal(1)).sum().cast("float32"))}(t,e),r=n.add(s);return jS(MC(r,0),n.div(r),0).cast("float32")})},categoricalCrossentropy:IO,sparseCategoricalCrossentropy:EO,mse:pO,MSE:pO,mae:fO,MAE:fO,mape:mO,MAPE:mO,cosine:vO};function TO(t){if("string"==typeof t&&t in NO)return NO[t];if("string"!=typeof t&&null!=t)return t;throw new QA(`Unknown metric ${t}`)}function AO(t){if(n$(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(wO))if(wO[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(NO))if(NO[n]===t){e=n;break}return void 0!==e?e:t.name}}function $O(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!RO(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function RO(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!RO(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!RO(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function OO(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function FO(t,e,n){let s;try{s=JSON.stringify(t.outputShape)}catch(D7){s="multiple"}OO([`${t.name} (${t.getClassName()})`,s,t.countParams().toString()],e,n)}function DO(t,e,n,s){let r;try{r=JSON.stringify(t.outputShape)}catch(D7){r="multiple"}const i=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t)i.push(`${u.inboundLayers[t].name}[${u.nodeIndices[t]}][${u.tensorIndices[t]}]`);const a=t.name,o=t.getClassName(),l=0===i.length?"":i[0];OO([`${a} (${o})`,r,t.countParams().toString(),l],e,s);for(let u=1;u<i.length;++u)OO(["","","",i[u]],e,s)}function LO(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function MO(t,e){if(null===t)return null;if("string"==typeof t)return o$(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const s=t[r];LO(e,r,s)?n.push(s):n.push(MO(s,e))}return n}{const e={};for(const n of Object.keys(t)){const s=t[n];if("name"===n&&"string"==typeof s)e[n]=s;else{const t=o$(n);e[t]=MO(s,t)}}return e}}function PO(t,e){if(null==t)return null;if("string"==typeof t)return a$(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const s=t[r];LO(e,r,s)?n.push(s):n.push(PO(s,e))}return n}{const e={};for(const n of Object.keys(t)){const s=t[n];e[a$(n)]="name"!==n&&"className"!==n||"string"!=typeof s?PO(s,n):s}return e}}class zO{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof zO)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new QA(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return Zx(e,t.dtype)}catch(D7){throw new QA(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof GR){if(null==this.id2Value[t.id])throw new QA(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new QA(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof GR){if(null==this.id2Value[t.id])throw new QA(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new QA(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&Ok(this.id2Mask)}}const VO={},BO={};function WO(t,e,n,s){const r=null!=n&&n.training,i=Array.isArray(t),a=i?t:[t],o=a.map(t=>t.name),l=[],u=e.names();for(const f of o)-1!==u.indexOf(f)?l.push(e.getValue(f)):l.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=o.join(",")+"|"+e.names().join(",");let h,d;if(null==VO[c]){const t=function(t,e){cy(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(1===t.length){const r=jO(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of t){const{sorted:t,recipientMap:a}=jO(i,e);for(const e of t)r.has(e.name)||(n.push(e),r.add(e.name));for(const e in a)null==s[e]&&(s[e]=new Set),a[e].forEach(t=>s[e].add(t))}}return{sorted:n,recipientCounts:UO(s)}}(a,e);h=t.sorted,d=t.recipientCounts,VO[c]=h,BO[c]=d}h=VO[c],d={},r||Object.assign(d,BO[c]);const p=new zO(e);for(let f=0;f<h.length;++f){if(null!=s){const t=$k().numTensors;t>s.maxNumTensors&&(s.maxNumTensors=t),t<s.minNumTensors&&(s.minNumTensors=t)}const t=h[f],i=t.sourceLayer;if(i instanceof QR)continue;const a=[],u=[],c=[];let m=!1;for(const n of t.inputs){const t=p.getValue(n),s=p.getMask(n);a.push(t),u.push(s),null!=s&&(m=!0),r||(d[n.name]--,0!==d[n.name]||e.hasKey(n)||-1!==o.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||c.push(t))}m&&((n=n||{}).mask=u[0]);const g=i$(i.apply(a,n));let y=null;i.supportsMasking&&(y=i.computeMask(a,u));const b=HO(t),v=Array.isArray(b)?b:[b];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],g[e],Array.isArray(y)?y[0]:y);const t=o.indexOf(v[e].name);-1!==t&&(l[t]=g[e])}r||Ok(c)}return p.disposeMasks(),i?l:l[0]}function UO(t){const e={};for(const n in t)e[n]=t[n].size;return e}function jO(t,e){const n=new Set,s=[],r={};for(const o of e.names())n.add(o);const i=[],a=[];for(i.push(t);i.length>0;){const t=i[i.length-1];if(n.has(t.name)){i.pop();continue}const e=a[a.length-1]===i.length-1;if(0===t.inputs.length||e)i.pop(),s.push(t),n.add(t.name),e&&a.pop();else{a.push(i.length-1);for(const e of t.inputs)null==r[e.name]&&(r[e.name]=new Set),r[e.name].add(t.name),n.has(e.name)||i.push(e)}}return{sorted:s,recipientMap:r}}function HO(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const s of t.sourceLayer.inboundNodes[e].outputTensors)if(s.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}class GO extends ZR{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=LR(t)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],p$(this.inputs).length!==this.inputs.length)throw new QA(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(t=>t.name)}`);p$(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(t=>t.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const t=y.nodeIndex,e=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(e)}for(const y of this.inputs){const t=y.sourceLayer,e=y.nodeIndex,n=y.tensorIndex;n$(0===e,"input layer has >1 nodes"),n$(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const e=this.inputLayers[y];if(!(e instanceof QR))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const e={},n={},s={},r={},i={},a=[],o=(t,e,n,s,r,l)=>{null!=s&&null!=r&&null!=l||(s=t.sourceLayer,r=t.nodeIndex,l=t.tensorIndex);const u=s.inboundNodes[r];if(-1!==n.indexOf(u))throw new YA(`The tensor ${t.name} at layer "${s.name}" is part of a cycle.`);if(-1!==e.indexOf(u))return;this.containerNodes.add(GO.nodeKey(s,r)),s.id in i||(i[s.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let i=0;i<c;i++)o(u.inputTensors[i],e,n,u.inboundLayers[i],u.nodeIndices[i],u.tensorIndices[i]);for(e.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);a.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=a.slice().reverse();for(const y of c){n[y.id]=y,y.id in e||(e[y.id]=0);let t=e[y.id];t=Math.max(t,null==s[y.outboundLayer.id]?0:s[y.outboundLayer.id]),s[y.outboundLayer.id]=t,r[y.outboundLayer.id]=y.outboundLayer,e[y.id]=t;for(let s=0;s<y.inboundLayers.length;s++){const r=y.inboundLayers[s].inboundNodes[y.nodeIndices[s]];e[r.id]=Math.max(t+1,null==e[r.id]?0:e[r.id]),n[r.id]=r}}const h={};for(const y in e){const t=e[y];t in h||(h[t]=[]),h[t].push(n[y])}const d={};for(const y in s){const t=s[y];t in d||(d[t]=[]),d[t].push(r[y])}let p=Object.keys(d).map(t=>parseInt(t,10)).sort(d$);this.layers=[];for(const y of p){const t=d[y];t.sort((t,e)=>{const n=i[t.id],s=i[e.id];return n<s?-1:n>s?1:0});for(const e of t)e instanceof GO&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(t=>parseInt(t,10)).sort(d$);const f=this.inputs.slice(),m=[];for(const y of p)for(const t of h[y]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new YA(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(t=>t.name);for(const y of g){const t=g.filter(t=>t===y).length;if(1!==t)throw new YA(`The name "${y}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new KR({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new QA("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let s=0;for(const i of this.layers)for(const t of i.weights){if(null!=n[t.originalName])throw new QA(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,s++}const r=[];for(const i in t){let s=i;if(null==n[i]){const t=i.split("/");s=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[s])r.push([n[s],t[i]]);else if(e)throw new QA(`Provided weight data has no target variable: ${i}`);delete n[s]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new QA(`${t.length} of ${s} weights are not set: ${t}`)}jR(r)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.7.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=PO(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return Rk(()=>{t=i$(t);const n=new zO;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return WO(this.outputs,n,e)})}computeMask(t,e){return Rk(()=>{let n;return t=i$(t),n=null==e?e$(null,t.length):i$(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=PR(t);if(e.length!==this.inputLayers.length)throw new QA(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let a=0;a<e.length;a++)n[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(d$);if(s.length>1)for(const a of s){const t=this.nodesByDepth[a];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const s=[];for(let a=0;a<e.inboundLayers.length;a++)s.push(n[`${e.inboundLayers[a].name}_${e.nodeIndices[a]}_${e.tensorIndices[a]}`]);const r=PR(t.computeOutputShape(r$(s))),i=t.inboundNodes.indexOf(e);for(let e=0;e<r.length;e++)n[`${t.name}_${i}_${e}`]=r[e]}}const r=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const t=i[a];n$(t in n),r.push(n[t])}return r$(r)}runInternalGraph(t,e){null==e&&(e=e$(null,t.length));const n={};for(let o=0;o<this.inputs.length;++o)n[this.inputs[o].id]=[t[o],e[o]];const s=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(d$);for(const o of s){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer,s=e.inputTensors,r=e.outputTensors,i=new Array;for(const e of s)e.id in n&&i.push(n[e.id]);if(i.length===s.length){let s,a,o,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===i.length){const[e,n]=i[0];null==u.mask&&(u.mask=n),o=i$(t.call(e,u)),l=i$(t.computeMask(e,n)),s=[e],a=[n]}else s=i.map(t=>t[0]),a=i.map(t=>t[1]),null==u.mask&&(u.mask=a),o=i$(t.call(s,u)),l=i$(t.computeMask(s,a));if(t.activityRegularizer)throw new JA("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<r.length;++t)n[r[t].id]=[o[t],l[t]]}}}const r=[],i=[],a=[];for(const o of this.outputs){n$(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[t,e]=n[o.id];a.push(t.shape),r.push(t),i.push(e)}return[r,i,a]}buildNodeConversionMap(t){const e={};let n;for(const s of this.layers){n=s instanceof GO?1:0;for(let t=0;t<s.inboundNodes.length;t++){const r=GO.nodeKey(s,t);this.containerNodes.has(r)&&(e[r]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new QA(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new QA("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new QA(`No such layer: ${t}`)}calculateLosses(){return Rk(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const s=GO.nodeKey(e,n);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const t=i.getClassName(),s=i.getConfig(),r=[];for(let n=0;n<i.inboundNodes.length;n++){const t=i.inboundNodes[n],s=GO.nodeKey(i,n);let a={};if(this.containerNodes.has(s)){if(t.callArgs)try{JSON.stringify(t.callArgs),a=t.callArgs}catch(D7){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),a={}}if(t.inboundLayers.length>0){const n=[];for(let s=0;s<t.inboundLayers.length;s++){const r=t.inboundLayers[s],i=t.tensorIndices[s];let o=e[GO.nodeKey(r,t.nodeIndices[s])];null==o&&(o=0),n.push([r.name,o,i,a])}r.push(n)}}}const a={};a.name=i.name,a.className=t,a.config=s,a.inboundNodes=r,n.push(a)}t.layers=n;const s=[];for(let i=0;i<this.inputLayers.length;i++){const t=this.inputLayers[i],n=GO.nodeKey(t,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let r=e[n];null==r&&(r=0),s.push([t.name,r,this.inputLayersTensorIndices[i]])}t.inputLayers=s;const r=[];for(let i=0;i<this.outputLayers.length;i++){const t=this.outputLayers[i],n=GO.nodeKey(t,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let s=e[n];null==s&&(s=0),r.push([t.name,s,this.outputLayersTensorIndices[i]])}return t.outputLayers=r,t}static fromConfig(t,e,n={},s=!1){const r={},i={};function a(t,e){t.name in i?i[t.name].push(e):i[t.name]=[e]}function o(t,e){const n=[];let s;for(const i of e){const o=i[0],l=i[1],u=i[2];if(s=null==i[3]?{}:i[3],!(o in r))return void a(t,e);const c=r[o];if(c.inboundNodes.length<=l)return void a(t,e);n.push(c.inboundNodes[l].outputTensors[u])}n.length>0&&t.apply(r$(n),s)}function l(t){const n=t.name,i=hO(t,null!=e.customObjects?e.customObjects:{});i.setFastWeightInitDuringBuild(s),r[n]=i,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new QA(`Corrupted configuration, expected array for nodeData: ${t}`);a(i,t)})}const u=e.name,c=e.layers;for(const m of c)l(m);for(;!f$(i);)for(const t of c){const e=r[t.name];if(e.name in i){const t=i[e.name];delete i[e.name];for(const n of t)o(e,n)}}const h=[],d=[],p=e.inputLayers;for(const m of p){const t=m[0],e=m[1],n=m[2];n$(t in r),h.push(r[t].inboundNodes[e].outputTensors[n])}const f=e.outputLayers;for(const m of f){const t=m[0],e=m[1],n=m[2];n$(t in r),d.push(r[t].inboundNodes[e].outputTensors[n])}return new t({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new QA("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Rk(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function qO(t,e){return function(t,e,n){const s=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>null);if(1===s)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided classWeight is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach(e=>{n.push(e in t?t[e]:null)}),n}throw new Error(`The model has multiple (${s}) outputs, so classWeight must be either an array with ${s} elements or an object with ${e} keys. Provided classWeight not understood: ${JSON.stringify(t)}`)}(t,e)}function KO(t,e,n,s){return XO.apply(this,arguments)}function XO(){return(XO=ny(function*(t,e,n,s){if(null!=e||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=Rk(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield e.data());Ok(e);const r=[];return s.forEach(t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);r.push(n[t])}),zS(r,"float32")}return null})).apply(this,arguments)}function ZO(t,e){return UC(t,e)}function YO(t,e){let n,s;n=e.xs,s=e.ys,cy(null!=n&&null!=s,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const r=QO("input",t.inputNames,n),i=QO("output",t.outputNames,s),a=r[0].shape[0];cy(r.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),cy(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let o=0;o<r.length;o++)cy(r[o].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[o]} has ${r[o].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let o=0;o<i.length;o++)cy(i[o].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[o]} has ${i[o].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:r,ys:i}}function QO(t,e,n){if(n instanceof L_)return[n];if(Array.isArray(n))return cy(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(null==n[r])throw new QA(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function JO(t){if(3===t.length)throw new JA("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}function tF(){return(tF=ny(function*(t,e,n){const s=null!=n.batchesPerEpoch;if(cy(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),cy(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),cy(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),cy(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),cy(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const r=null!=n.validationData;let i,a;if(r)if(nF(n.validationData))cy(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const t=JO(n.validationData);i=t.xs,a=t.ys}const o=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=r?l.slice().concat(l.map(t=>"val_"+t)):l.slice();const c=lO(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=cO(c,h,n.epochs,null,null,eF(e,n),null,r,u);d.setModel(t),t.history=p,yield d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=yield e.iterator();for(;f<n.epochs;){const u={};yield d.onEpochBegin(f);let c=0,h=0;for(s||(m=yield e.iterator());!s||c<n.batchesPerEpoch;){const e=yield m.next();if(s&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:s,ys:r}=YO(t,e.value),i={};i.batch=h,i.size=s[0].shape[0],yield d.onBatchBegin(h,i);const a=[];if(null!=n.classWeight){const e=qO(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)a.push(yield KO(r[t],null,e[t]))}const u=s.concat(r).concat(a),p=o(u);Ok(u);for(let t=0;t<l.length;++t){const e=p[t];i[l[t]]=e,Fk(e)}yield d.onBatchEnd(h,i),eO(i),h++,c++}if(s?c>=n.batchesPerEpoch:e.done){if(r){let e;e=nF(n.validationData)?i$(yield t.evaluateDataset(n.validationData,{batches:n.validationBatches})):i$(t.evaluate(i,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)u[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(yield d.onEpochEnd(f,u),f++,t.stopTraining_)break}return yield d.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})).apply(this,arguments)}function eF(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function nF(t){return"function"==typeof t.iterator}function sF(t){return"function"==typeof t.next}function rF(){return(rF=ny(function*(t,e,n){const s=null!=(n=n||{}).batches,r=t.testFunction;let i=[];if(n.verbose>0)throw new JA("Verbose mode is not implemented yet.");cy(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const a=sF(e)?e:yield e.iterator();let o=0,l=0;for(;!s||l<n.batches;){const e=yield a.next();if(i=Rk(()=>{if(e.value){const{xs:n,ys:s}=YO(t,e.value),a=n.concat(s),u=Rk(()=>r(a));if(Ok(a),0===l)for(let t=0;t<u.length;++t)i.push(Mk(0));const c=a[0].shape[0];for(let t=0;t<u.length;++t){const e=u[t],n=i[t];i[t]=Rk(()=>Vk(i[t],UC(c,e))),l>0&&Ok(n)}Ok(u),o+=c,++l}return i}),e.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const t=i[u];i[u]=SC(i[u],o),Ok(t)}return r$(i)})).apply(this,arguments)}function iF(t){cy(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function aF(t,e,n){return null==t?[null]:Array.isArray(t)?t.map(t=>Y$(t,e,n-e)):Y$(t,e,n-e)}function oF(t,e){return Rk(()=>null==t?null:Array.isArray(t)?t.map(t=>oF(t,e)):iR(t,"int32"===e.dtype?e:e.toInt()))}function lF(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function uF(t,e,n,s,r,i,a,o,l,u,c,h,d,p,f){return cF.apply(this,arguments)}function cF(){return(cF=ny(function*(t,e,n,s,r,i,a,o,l,u,c,h,d,p,f){null==r&&(r=32),null==i&&(i=1),null==c&&(c=!0),null==d&&(d=0);let m=!1;if(null!=l&&null!=u&&(m=!0),null!=f&&(m=!0,null==p))throw new QA("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=t.checkNumSamples(n,r,p,"steps_per_epoch");let y;null!=g&&(y=K$(0,g)),null==a&&(a=1);const{callbackList:b,history:v}=cO(o,a,i,d,g,p,r,m,h);b.setModel(t),t.history=v,yield b.onTrainBegin(),t.stopTraining_=!1;for(let w=d;w<i;++w){yield b.onEpochBegin(w);const i={};if(null!=p)throw new JA("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new JA("batch shuffling is not implemneted yet");c&&oy(y);const a=zS(y),o=lF(g,r);for(let c=0;c<o.length;++c){const h={};if(yield b.onBatchBegin(c,h),Rk(()=>{const d=o[c][0],p=o[c][1],f=Y$(a,d,p-d);h.batch=c,h.size=p-d;const g=oF(n,f),y=e(g);for(let t=0;t<s.length;++t){const e=y[t];h[s[t]]=e,Fk(e)}if(c===o.length-1&&m){const e=t.testLoop(l,u,r);for(let t=0;t<s.length;++t){const n=s[t],r=e[t];Fk(r),i["val_"+n]=r}}}),yield b.onBatchEnd(c,h),eO(h),t.stopTraining_)break}a.dispose()}if(yield b.onEpochEnd(w,i),t.stopTraining_)break}return yield b.onTrainEnd(),yield t.history.syncData(),t.history})).apply(this,arguments)}function hF(){return(hF=ny(function*(t,e,n,s={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,i,a,o,l,u,c;t.isTraining=!0;try{const h=null==s.batchSize?32:s.batchSize;iF(h);const d=!1,p=yield t.standardizeUserData(e,n,s.sampleWeight,s.classWeight,d,h);r=p[0],i=p[1],c=p[2];let f,m=!1;if(null!=s.validationData&&s.validationData.length>0){if(m=!0,2!==s.validationData.length)throw 3===s.validationData.length?new JA("validationData including sample weights is not supported yet."):new QA(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);a=s.validationData[0],o=s.validationData[1];const e=!0,n=yield t.standardizeUserData(a,o,null,null,e,h);l=n[0],u=n[1],f=l.concat(u)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){m=!0;const t=Math.floor(r[0].shape[0]*(1-s.validationSplit)),e=r[0].shape[0];l=aF(r,t,e),r=aF(r,0,t),u=aF(i,t,e),i=aF(i,0,t),f=l.concat(u)}else null!=s.validationSteps&&(m=!0);const g=r.concat(i).concat(c);t.checkTrainableWeightsConsistency();const y=t.makeTrainFunction(),b=t.getDedupedMetricsNames();let v,w;m?(t.makeTestFunction(),v=t.testFunction,w=b.slice().concat(b.map(t=>"val_"+t))):(v=null,f=[],w=b.slice());const _=lO(s.callbacks,s.yieldEvery);return yield uF(t,y,g,b,h,s.epochs,s.verbose,_,v,f,s.shuffle,w,s.initialEpoch,null,null)}finally{t.isTraining=!1,pF(r,e),pF(i,n),pF(l,a),pF(u,o),null!=c&&Ok(c)}})).apply(this,arguments)}function dF(t){const e=[];t instanceof L_&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(1===s.rank)e.push(Z$(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function pF(t,e){if(null==t)return;const n=[];if(e instanceof L_)n.push(e.id);else if(Array.isArray(e))e.forEach(t=>n.push(t.id));else if(null!=e)for(const r in e)n.push(e[r].id);const s=[];if(t instanceof L_)-1===n.indexOf(t.id)&&s.push(t);else if(Array.isArray(t))t.forEach(t=>{-1===n.indexOf(t.id)&&s.push(t)});else if(null!=t)for(const r in t){const e=t[r];-1===n.indexOf(e.id)&&s.push(e)}s.forEach(t=>{t.isDisposed||t.dispose()})}function fF(t){return Array.isArray(t)}function mF(t){return!function(t){return t instanceof L_}(t)&&!fF(t)}function gF(t,e,n,s=!0,r=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(fF(t)&&t.length>0)e=!0;else if(mF(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new QA(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(null==t)return e.map(t=>null);let i;if(mF(t)){t=t,i=[];for(const n of e){if(null==t[n])throw new QA(`No data provided for "${n}". Need data for each key in: ${e}`);i.push(t[n])}}else if(fF(t)){if((t=t).length!==e.length)throw new QA(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);i=t}else{if(t=t,e.length>1)throw new QA(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);i=[t]}if(i=dF(i),null!=n)for(let a=0;a<e.length;++a){if(null==n[a])continue;const t=i[a];if(t.shape.length!==n[a].length)throw new QA(`Error when checking ${r}: expected ${e[a]} to have ${n[a].length} dimension(s). but got array with shape ${t.shape}`);for(let i=0;i<n[a].length;++i){if(0===i&&!s)continue;const o=t.shape[i],l=n[a][i];if(null!=l&&l>=0&&o!==l)throw new QA(`Error when checking ${r}: expected ${e[a]} to have shape [${n[a]}], but got array with shape [${t.shape}].`)}}return i}function yF(t,e,n,s=!0,r=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new QA(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new QA(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);i=[t]}if(null!=n)for(let a=0;a<e.length;++a){if(null==n[a])continue;const t=i[a];if(t.shape.length!==n[a].length)throw new QA(`Error when checking ${r}: expected ${e[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(t.shape)}`);for(let i=0;i<n[a].length;++i){if(0===i&&!s)continue;const o=t.shape[i],l=n[a][i];if(null!=l&&l!==o)throw new QA(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(t.shape)}.`)}}}class bF extends GO{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new QA("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,s=console.log){const r=function(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let t=!1;for(const n of r.inboundNodes)if(-1!==s.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),i=["Layer (type)","Output shape","Param #"];let a;if(r?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(t=>Math.floor(e*t))),!r){i.push("Receives inputs"),a=[];for(const e in t.nodesByDepth)a.push(...t.nodesByDepth[e])}s("_".repeat(e)),OO(i,n,s),s("=".repeat(e));const o=t.layers;for(let c=0;c<o.length;++c)r?FO(o[c],n,s):DO(o[c],n,a,s),s((c===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=BR(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),e}(t),u=BR(t.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>_E.adagrad(.01),Adadelta:()=>_E.adadelta(1,.95,XA()),Adam:()=>_E.adam(.001,.9,.999,XA()),Adamax:()=>_E.adamax(.002,.9,.999,XA(),0),RMSProp:()=>_E.rmsprop(.001,.9,0,XA()),SGD:()=>_E.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new QA(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Pk))throw new QA("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new QA(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(t=>_O(t))}else{const n=_O(t.loss);this.outputs.forEach(t=>{e.push(n)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new QA(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(_O(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const t=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[i])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],V$("loss",()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}});const s=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>[]);let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map(t=>n);{const t=[];for(const s of e){let e=n.hasOwnProperty(s)?n[s]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),r=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};V$("metric",()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,s,i;for(const a of e){if("string"==typeof a&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(a)){const e=this.internalOutputShapes[t];let r;1===e[e.length-1]||this.lossFunctions[t]===bO?-1!==["accuracy","acc"].indexOf(a)?s=xO:-1!==["crossentropy","ce"].indexOf(a)&&(s=CO):this.lossFunctions[t]===yO?-1!==["accuracy","acc"].indexOf(a)?s=SO:-1!==["crossentropy","ce"].indexOf(a)&&(s=EO):-1!==["accuracy","acc"].indexOf(a)?s=kO:-1!==["crossentropy","ce"].indexOf(a)&&(s=IO),-1!==["accuracy","acc"].indexOf(a)?r="acc":-1!==["crossentropy","ce"].indexOf(a)&&(r="ce"),i=s,n=""+r}else{const t=TO(a);i=t,n=""+AO(a)}let e;V$(n,()=>{e=i}),r(t,n,e)}})(s[t])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const s=null==n.batchSize?32:n.batchSize;iF(s);const r=this.standardizeUserDataXY(t,e,!0,s);try{const i=r[0].concat(r[1]);return this.makeTestFunction(),r$(this.testLoop(this.testFunction,i,s,n.verbose,n.steps))}finally{pF(r[0],t),pF(r[1],e)}}evaluateDataset(t,e){var n=this;return ny(function*(){return n.makeTestFunction(),function(t,e,n){return rF.apply(this,arguments)}(n,t,e)})()}checkNumSamples(t,e,n,s="steps"){let r;if(null!=n){if(r=null,null!=e)throw new QA(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new QA(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new QA("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),s=this.retrieveSymbolicTensors(n?e:[e]),r=new zO;if(t instanceof L_&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new QA(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)r.add(this.inputs[e],t[e])}else for(const a of this.inputs){const e=t[a.name];if(null==e)throw new QA(`No value is provided for the model's input ${a.name}`);r.add(a,e)}const i=WO(s,r);return n?i:i[0]}retrieveSymbolicTensors(t){const e=e$(null,t.length);let n=t.length;for(const s of this.layers){const r=Array.isArray(s.output)?s.output:[s.output],i=r.map(t=>t.name);for(let s=0;s<t.length;++s){const a=i.indexOf(t[s]);if(-1!==a&&(e[s]=r[a],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach((e,s)=>{null==e&&n.push(t[s])}),new QA(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return Rk(()=>{const s=this.checkNumSamples(t);if(n)throw new JA("Verbose predictLoop() is not implemented yet.");const r=lF(s,e),i=this.outputs.map(t=>[]);for(let e=0;e<r.length;++e)Rk(()=>{const n=aF(t,r[e][0],r[e][1]),s=[];if(Array.isArray(n))for(let t=0;t<n.length;++t)s.push({key:this.inputs[t],value:n[t]});else s.push({key:this.inputs[0],value:n});const i=new zO(s);return WO(this.outputs,i)}).forEach((t,e)=>i[e].push(t));return r$(i.map(t=>hC(t,0)))})}predict(t,e={}){const n=dF(t);yF(n,this.inputNames,this.feedInputShapes,!1);try{const s=null==e.batchSize?32:e.batchSize;return iF(s),this.predictLoop(n,s)}finally{pF(n,t)}}predictOnBatch(t){yF(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,s){if(null==this.optimizer_)throw new YA("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let i=0;i<this.feedOutputShapes.length;++i){const t=this.feedOutputShapes[i];r.push(this.feedLossFns[i]===yO?t.slice(0,t.length-1).concat([1]):t)}if(function(t,e,n){const s=p$(t.map(t=>t.shape[0]));s.sort();const r=p$(e.map(t=>t.shape[0]));if(r.sort(),s.length>1)throw new QA(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(t=>t.shape))}`);if(r.length>1)throw new QA(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(t=>t.shape))}`);if(s.length>0&&r.length>0&&!my(s,r))throw new QA(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}(t=gF(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=gF(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const s=[pO,bO,gO];for(let r=0;r<t.length;++r){const i=t[r],a=e[r],o=n[r];if(null!=a){if(a===gO&&1===i.shape[i.shape.length-1])throw new QA(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(a)){const t=i.shape.slice(1),e=o.slice(1);for(let n=0;n<t.length;++n){const s=t[n],r=e[n];if(null!=r&&s!==r)throw new QA(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&t[0].shape[0]%s!=0)throw new QA(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}standardizeUserData(t,e,n,s,r=!0,i){var a=this;return ny(function*(){const[o,l]=a.standardizeUserDataXY(t,e,r,i);if(null!=n)throw new Error("sample weight is not supported yet.");let u=null;if(null!=s){const t=qO(s,a.outputNames);u=[];for(let e=0;e<t.length;++e)u.push(yield KO(l[e],null,t[e]))}return[o,l,u]})()}testLoop(t,e,n,s=0,r){return Rk(()=>{const i=this.checkNumSamples(e,n,r,"steps"),a=[];if(s>0)throw new JA("Verbose mode is not implemented yet.");if(null!=r)throw new JA("steps mode in testLoop() is not implemented yet");{const s=lF(i,n),r=zS(K$(0,i));for(let n=0;n<s.length;++n){const i=s[n][0],o=s[n][1],l=Y$(r,i,o-i),u=oF(e,l),c=t(u);if(0===n)for(let t=0;t<c.length;++t)a.push(Mk(0));for(let t=0;t<c.length;++t)a[t]=Vk(a[t],UC(o-i,c[t]))}for(let t=0;t<a.length;++t)a[t]=SC(a[t],i)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const s=t[n];let r=s;s$(t,s)>1&&(r+=`_${s$(t.slice(0,n),s)}`),e.push(r)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],a=this.collectedTrainableWeights.map(t=>t.read());return[this.optimizer_.minimize(()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const a=new zO(t),o=WO(this.outputs,a,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(s[n],o[n]);null!=r[n]&&(t=ZO(t,r[n]));const i=YC(t);e.push(i),l=0===n?t:Vk(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][1];t=YC((0,this.metricsTensors[n][0])(s[e],o[e]))}Fk(t),i.push(t)}return l=YC(l),this.calculateLosses().forEach(t=>{l=Vk(l,t)}),l},!0,a)].concat(i)}}makeTestFunction(){this.testFunction=t=>Rk(()=>{const e=[];let n;const s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let t=0;t<this.inputs.length;++t)i.push({key:this.inputs[t],value:s[t]});const a=new zO(i),o=WO(this.outputs,a);for(let t=0;t<this.lossFunctions.length;++t){const s=YC((0,this.lossFunctions[t])(r[t],o[t]));n=0===t?s:Vk(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][1],s=YC((0,this.metricsTensors[t][0])(r[n],o[n]));e.push(s)}return e})}fit(t,e,n={}){var s=this;return ny(function*(){return function(t,e,n){return hF.apply(this,arguments)}(s,t,e,n)})()}fitDataset(t,e){var n=this;return ny(function*(){return function(t,e,n){return tF.apply(this,arguments)}(n,t,e)})()}trainOnBatch(t,e){var n=this;return ny(function*(){const s=yield n.standardizeUserData(t,e),r=s[0],i=s[1],a=n.makeTrainFunction()(r.concat(i)),o=[];for(const t of a){const e=yield t.data();o.push(e[0])}return Ok(a),r$(o)})()}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,s=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let i=0;i<s.length;++i)n&&!s[i].trainable||e.push({name:s[i].originalName,tensor:r[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=$k().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-$k().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=a$(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(t=>a$(t))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const s of e){if("string"!=typeof n[s])throw new Error("Serialization of non-string loss is not supported.");t[s]=a$(n[s])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[a$(AO(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>a$(AO(t)));{const t={};for(const e in this.metrics)t[e]=a$(AO(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=hO(MO(t.optimizer_config));let n,s;if("string"==typeof t.loss)n=o$(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(t=>o$(t));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=o$(t.loss[e])}if(Array.isArray(t.metrics))s=t.metrics.map(t=>o$(t));else if(null!=t.metrics){s={};for(const e in t.metrics)s[e]=o$(t.metrics[e])}this.compile({loss:n,metrics:s,optimizer:e})}save(t,e){var n=this;return ny(function*(){if("string"==typeof t){const e=Sx(t);if(0===e.length)throw new QA(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new QA(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new QA("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=yield gx(n.getNamedWeights(e)),r={modelTopology:n.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.7.0",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=n.optimizer){r.trainingConfig=n.getTrainingConfig();const t="optimizer",{data:e,specs:i}=yield gx(yield n.optimizer.getWeights(),t);s.specs.push(...i),s.data=_x([s.data,e])}return null!=n.userDefinedMetadata&&($O(n.userDefinedMetadata,n.name,!0),r.userDefinedMetadata=n.userDefinedMetadata),r.weightData=s.data,r.weightSpecs=s.specs,t.save(r)})()}setUserDefinedMetadata(t){$O(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}bF.className="Model",Tk(bF);class vF extends bF{}vF.className="Functional",Tk(vF);class wF extends bF{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:LR("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new QA(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof wF||t instanceof bF;let n;if(e){if(n=t,1!==n.outputs.length)throw new QA("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new QA("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new QA("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new QA("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new QR({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new QA(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new QA("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=YR(this.outputs[0])}this.inboundNodes=[],new KR({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:e$(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(VR(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new bF({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new YA("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}evaluateDataset(t,e){var n=this;return ny(function*(){if(!n.built)throw new YA("The model needs to be compiled before being used.");return n.model.evaluateDataset(t,e)})()}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}fit(t,e,n={}){var s=this;return ny(function*(){if(!s.built)throw new YA("The model needs to be compiled before being used.");return s.model.fit(t,e,n)})()}fitDataset(t,e){var n=this;return ny(function*(){if(!n.built)throw new YA("The model needs to be compiled before being used.");return n.model.fitDataset(t,e)})()}trainOnBatch(t,e){var n=this;return ny(function*(){return n.model.trainOnBatch(t,e)})()}static fromConfig(t,e,n={},s=!1){let r,i={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new QA("Legacy serialization format not supported yet.");r=e}else cy(null!=e.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=e.layers,delete e.layers,i=e;const a=new t(i);if(!(a instanceof wF))throw new JA(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const o of r){const t=hO(o,void 0,s);s&&t.setFastWeightInitDuringBuild(!0),a.add(t)}return a}set stopTraining(t){if(null==this.model)throw new QA("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new QA("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}wF.className="Sequential",Tk(wF);class _F extends Ek{getConfig(){return{}}}class xF extends _F{apply(t,e=1){return function(t,e=1){if(1!==e)throw new JA(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return IC(t)}(t,e)}}xF.className="elu",Tk(xF);class kF extends _F{apply(t){return CS(t)}}kF.className="selu",Tk(kF);class CF extends _F{apply(t){return xS(t)}}CF.className="relu",Tk(CF);class SF extends _F{apply(t){return Rk(()=>QC(6,xS(t)))}}SF.className="relu6",Tk(SF);class IF extends _F{apply(t){return t}}IF.className="linear",Tk(IF);class EF extends _F{apply(t){return IS(t)}}EF.className="sigmoid",Tk(EF);class NF extends _F{apply(t){return function(t){return Rk(()=>{const e=Vk(.5,UC(.2,t));return cC(e,0,1)})}(t)}}NF.className="hardSigmoid",Tk(NF);class TF extends _F{apply(t){return OS(t)}}TF.className="softplus",Tk(TF);class AF extends _F{apply(t){return function(t){return Rk(()=>SC(t,zk(t).add(1)))}(t)}}AF.className="softsign",Tk(AF);class $F extends _F{apply(t){return PS(t)}}$F.className="tanh",Tk($F);class RF extends _F{apply(t,e=-1){return RS(t,e)}}RF.className="softmax",Tk(RF);class OF extends _F{apply(t,e=-1){return GC(t,e)}}OF.className="logSoftmax",Tk(OF);class FF extends _F{apply(t,e=1){return Rk(()=>IS(t.mul(e)).mul(t))}}FF.className="swish",Tk(FF);class DF extends _F{apply(t){return Rk(()=>UC(t,PS(OS(t))))}}function LF(t){return t.getClassName()}function MF(t,e={}){return h$(t,Nk.getMap().classNameMap,e,"activation")}function PF(t){if(null==t)return MF({className:"linear",config:{}});if("string"==typeof t){const e={};return e.className=t,e.config={},MF(e)}return t instanceof _F?t:MF(t)}DF.className="mish",Tk(DF);class zF extends Ek{}class VF extends zF{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return Rk(()=>{let e=dS([1]);return this.hasL1&&(e=Vk(e,HC(UC(this.l1,zk(t))))),this.hasL2&&(e=Vk(e,HC(UC(this.l2,aR(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}VF.className="L1L2",Tk(VF);const BF={l1l2:"L1L2"};function WF(t){return u$(t)}function UF(t,e={}){return h$(t,Nk.getMap().classNameMap,e,"regularizer")}function jF(t){return null==t?null:"string"==typeof t?UF({className:t in BF?BF[t]:t,config:{}}):t instanceof zF?t:UF(t)}class HF extends ZR{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=zR(t);let n=xS(t);return null!=this.maxValue&&(n=cC(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}HF.className="ReLU",Tk(HF);class GF extends ZR{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=zR(t);return zC(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}GF.className="LeakyReLU",Tk(GF);class qF extends ZR{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=RR(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=jF(t.alphaRegularizer),this.alphaConstraint=T$(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new QA(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=VR(t)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)e[s-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let s=1;s<t.length;++s)n[s]=t[s];this.inputSpec=[new HR({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=zR(t),gS(t,this.alpha.read())}getConfig(){const t={alphaInitializer:$R(this.alphaInitializer),alphaRegularizer:WF(this.alphaRegularizer),alphaConstraint:E$(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}qF.className="PReLU",Tk(qF);class KF extends ZR{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new JA(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=zR(t);return IC(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}KF.className="ELU",Tk(KF);class XF extends ZR{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=zR(t);return n.mul(X$(n.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}XF.className="ThresholdedReLU",Tk(XF);class ZF extends ZR{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new RF).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=zR(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function YF(t,e,n){if("number"==typeof t)return e$(t,e);if(t.length!==e)throw new QA(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let r=0;r<e;++r){const i=t[r];if((s=i)!==parseInt(s.toString(),10))throw new QA(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`)}return t;var s}function QF(t,e,n,s,r=1){if(null==t)return t;let i;return i="same"===n?t:t-(e+(e-1)*(r-1))+1,Math.floor((i+s-1)/s)}function JF(t,e,n,s){if(null==t)return null;if("valid"===s)t=t*e+q$([n-e,0]);else{if("same"!==s)throw new QA(`Unsupport padding mode: ${s}.`);t*=e}return t}function tD(t,e){return Rk(()=>(L$(e),"channelsFirst"===e?GS(t,[0,2,3,1]):t))}function eD(t,e){return Rk(()=>(L$(e),"channelsFirst"===e?GS(t,[0,2,3,4,1]):t))}function nD(t,e,n,s=[1,1],r="valid",i,a,o=null){return Rk(()=>{if(null==i&&(i="channelsLast"),L$(i),3!==t.rank&&4!==t.rank)throw new QA(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new QA(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=tD(t,i);if("causal"===r)throw new JA("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=oI({x:l,filter:e,strides:s,pad:"same"===r?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===i&&(l=GS(l,[0,3,1,2])),l})}ZF.className="Softmax",Tk(ZF);class sD extends ZR{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",sD.verifyArgs(e),this.rank=t,y$(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new JA(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=YF(e.kernelSize,t,"kernelSize"),this.strides=YF(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,M$(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,L$(this.dataFormat),this.activation=PF(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=RR(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=T$(e.biasConstraint),this.biasRegularizer=jF(e.biasRegularizer),this.activityRegularizer=jF(e.activityRegularizer),this.dilationRate=YF(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new QA(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new QA(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new QA(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(n$("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!g$(t.kernelSize,"number",1,3))throw new QA(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:LF(this.activation),useBias:this.useBias,biasInitializer:$R(this.biasInitializer),biasRegularizer:WF(this.biasRegularizer),activityRegularizer:WF(this.activityRegularizer),biasConstraint:E$(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class rD extends sD{constructor(t,e){super(t,e),this.kernel=null,rD.verifyArgs(e),this.filters=e.filters,y$(this.filters,"filters"),this.kernelInitializer=RR(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=T$(e.kernelConstraint),this.kernelRegularizer=jF(e.kernelRegularizer)}build(t){t=VR(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new QA(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],s=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return Rk(()=>{let e;t=zR(t);const n=null==this.bias?null:this.bias.read(),s=v$(this.activation.getClassName());if(null!=s&&2===this.rank)e=nD(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)e=function(t,e,n,s=1,r="valid",i,a=1){return Rk(()=>{if(null==i&&(i="channelsLast"),L$(i),3!==t.shape.length)throw new QA(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new QA(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new QA(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===i&&(t=GS(t,[0,2,1])),"causal"===r)throw new JA("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=yC(t,e,s,"same"===r?"same":"valid","NWC",a);return null!=n&&(o=lR(o,n)),o})}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=nD(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new JA("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,s=[1,1,1],r="valid",i,a){return Rk(()=>{if(null==i&&(i="channelsLast"),L$(i),4!==t.rank&&5!==t.rank)throw new QA(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new QA(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=eD(t,i);if("causal"===r)throw new JA("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=wC(o,e,s,"same"===r?"same":"valid","NDHWC",a),null!=n&&(o=lR(o,n)),"channelsFirst"===i&&(o=GS(o,[0,4,1,2,3])),o})}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(t){t=VR(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let r=0;r<n.length;++r){const t=QF(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);e.push(t)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:$R(this.kernelInitializer),kernelRegularizer:WF(this.kernelRegularizer),kernelConstraint:E$(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new QA(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class iD extends rD{constructor(t){super(2,t),iD.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!g$(t.kernelSize,"number",1,2))throw new QA(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}iD.className="Conv2D",Tk(iD);class aD extends rD{constructor(t){super(3,t),aD.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new QA(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}aD.className="Conv3D",Tk(aD);class oD extends iD{constructor(t){if(super(t),this.inputSpec=[new HR({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new QA(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=VR(t)).length)throw new QA("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new QA("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new HR({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return Rk(()=>{let e=zR(t);if(4!==e.shape.length)throw new QA(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let s,r;"channelsFirst"===this.dataFormat?(s=2,r=3):(s=1,r=2);const i=n[r],a=this.kernelSize[1],o=this.strides[1],l=[n[0],JF(n[s],this.strides[0],this.kernelSize[0],this.padding),JF(i,o,a,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=GS(e,[0,2,3,1]));let u=vC(e,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(u=GS(u,[0,3,1,2])),null!=this.bias&&(u=lR(u,this.bias.read(),this.dataFormat)),null!=this.activation&&(u=this.activation.apply(u)),u})}computeOutputShape(t){const e=(t=VR(t)).slice();let n,s,r;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3):(n=3,s=1,r=2);const i=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[s]=JF(e[s],o,i,this.padding),e[r]=JF(e[r],l,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}oD.className="Conv2DTranspose",Tk(oD);class lD extends aD{constructor(t){if(super(t),this.inputSpec=[new HR({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new QA(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=VR(t)).length)throw new QA("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new QA("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new HR({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return Rk(()=>{let e=zR(t);if(5!==e.shape.length)throw new QA(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let s,r,i;"channelsFirst"===this.dataFormat?(i=2,s=3,r=4):(i=1,s=2,r=3);const a=n[s],o=n[r],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[1],h=this.strides[2],d=[n[0],JF(n[i],this.strides[0],this.kernelSize[0],this.padding),JF(a,c,l,this.padding),JF(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=GS(e,[0,2,3,4,1]));let p=xC(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=GS(p,[0,4,1,2,3])),null!==this.bias&&(p=lR(p,this.bias.read(),this.dataFormat)),null!==this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(t){const e=(t=VR(t)).slice();let n,s,r,i;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3,i=4):(n=4,s=1,r=2,i=3);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[s]=JF(e[s],u,a,this.padding),e[r]=JF(e[r],c,o,this.padding),e[i]=JF(e[i],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}lD.className="Conv3DTranspose",Tk(lD);class uD extends rD{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new QA("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new QA("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new QA(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=RR(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=jF(e.depthwiseRegularizer),this.depthwiseConstraint=T$(e.depthwiseConstraint),this.pointwiseInitializer=RR(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=jF(e.pointwiseRegularizer),this.pointwiseConstraint=T$(e.pointwiseConstraint)}build(t){if((t=VR(t)).length<this.rank+2)throw new QA(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new QA(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],s=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let a=0;a<this.rank;++a)r.push(1);r.push(n*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):null,this.inputSpec=[new HR({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return Rk(()=>{let e;if(t=zR(t),1===this.rank)throw new JA("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=GS(t,[0,2,3,1])),e=SS(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=lR(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=GS(e,[0,3,1,2])),e})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=$R(this.depthwiseInitializer),t.pointwiseInitializer=$R(this.pointwiseInitializer),t.depthwiseRegularizer=WF(this.depthwiseRegularizer),t.pointwiseRegularizer=WF(this.pointwiseRegularizer),t.depthwiseConstraint=E$(this.depthwiseConstraint),t.pointwiseConstraint=E$(this.pointwiseConstraint),t}}uD.className="SeparableConv";class cD extends uD{constructor(t){super(2,t)}}cD.className="SeparableConv2D",Tk(cD);class hD extends rD{constructor(t){super(1,t),hD.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!g$(t.kernelSize,"number",1,1))throw new QA(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}hD.className="Conv1D",Tk(hD);class dD extends ZR{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return Rk(()=>{if(t=zR(t),"channelsLast"===this.dataFormat){const e=J$(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return J$(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=J$(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return J$(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}dD.className="Cropping2D",Tk(dD);class pD extends ZR{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,L$(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,m$($$,"InterpolationFormat",this.interpolation)}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,e){return Rk(()=>{let e=zR(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=GS(e,[0,2,3,1]);const t=this.size[0]*n[2],s=this.size[1]*n[3],r="nearest"===this.interpolation?e.resizeNearestNeighbor([t,s]):e.resizeBilinear([t,s]);return GS(r,[0,3,1,2])}{const t=this.size[0]*n[1],s=this.size[1]*n[2];return"nearest"===this.interpolation?e.resizeNearestNeighbor([t,s]):e.resizeBilinear([t,s])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}pD.className="UpSampling2D",Tk(pD);class fD extends sD{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=RR(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=T$(t.depthwiseConstraint),this.depthwiseRegularizer=jF(t.depthwiseRegularizer)}build(t){if((t=VR(t)).length<4)throw new QA(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new QA(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return Rk(()=>{let e=function(t,e,n=[1,1],s="valid",r,i){return Rk(()=>{null==r&&(r="channelsLast"),L$(r);let a=tD(t,r);if(4!==t.rank)throw new QA(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new QA(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=kC(a,e,n,"same"===s?"same":"valid","NHWC",i),"channelsFirst"===r&&(a=GS(a,[0,3,1,2])),a})}(t=zR(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=lR(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(t){t=VR(t);const e="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=QF("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),r=QF(e,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,s,r]:[t[0],s,r,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=$R(this.depthwiseInitializer),t.depthwiseRegularizer=WF(this.depthwiseRegularizer),t.depthwiseConstraint=E$(this.depthwiseRegularizer),t}}function mD(t,e,n,s){if(Array.isArray(t)){if(null!=e||null!=n)throw new QA("When inputs is an array, neither initialState or constants should be provided");null!=s&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=r(e),constants:n=r(n)}}function gD(t,e,n,s=!1,r,i,a=!1,o=!1){return Rk(()=>{const l=e.shape.length;if(l<3)throw new QA(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(K$(2,l));if(e=GS(e,u),null!=i)throw new JA("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=r.asType("bool").asType("float32")).rank===l-1&&(r=$C(r,-1)),r=GS(r,u)),s&&(e=kS(e,0),null!=r&&(r=kS(r,0)));const c=[];let h,d=n;const p=e.shape[0],f=WS(e);let m,g;null!=r&&(m=WS(r));for(let e=0;e<p;++e){const n=f[e],s=Rk(()=>t(n,d));if(null==r)h=s[0],d=s[1];else{const t=Rk(()=>{const t=m[e],n=fS(t).sub(t);return{output:s[0].mul(t).add(d[0].mul(n)),newStates:d.map((e,r)=>s[1][r].mul(t).add(e.mul(n)))}});h=t.output,d=t.newStates}o&&c.push(h)}return o&&(g=MS(c,1)),[h,g,d]})}fD.className="DepthwiseConv2D",Tk(fD);class yD extends ZR{constructor(t){let e;if(super(t),null==t.cell)throw new QA("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new SD({cells:t.cell}):t.cell,null==e.stateSize)throw new QA("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new HR({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?K$(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){MR(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let s;if(s=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const s of e)n.push([t[0],s]);return[s].concat(n)}return s}computeMask(t,e){return Rk(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new JA("Constants support is not implemented in RNN yet.");MR(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new HR({shape:[e,null,...n]});const s=[t[0]].concat(t.slice(2));let r;if(this.cell.build(s),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!my(this.stateSpec.map(t=>t.shape[t.shape.length-1]),r))throw new QA(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(t=>new HR({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){Rk(()=>{if(!this.stateful)throw new ZA("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new QA("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>dS([n,t])):[dS([n,this.cell.stateSize])];else if(null==t)Ok(this.states_),null!=this.keptStates&&(Ok(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>dS([n,t])):this.states_[0]=dS([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new QA(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):Ok(this.states_);for(let e=0;e<this.states_.length;++e){const s=t[e],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,i=[n,r];if(!my(s.shape,i))throw new QA(`State ${e} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[e]=s}}this.states_=this.states_.map(t=>Fk(t.clone()))})}apply(t,e){let n=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=mD(t,n,s,this.numConstants);t=r.inputs,n=r.initialState,s=r.constants;let i=[],a=[];if(null!=n){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new HR({shape:t.shape}));a=a.concat(this.stateSpec)}if(null!=s&&(e.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof GR){const n=[t].concat(i),s=this.inputSpec.concat(a),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,e);return this.inputSpec=r,o}return super.apply(t,e)}call(t,e){return Rk(()=>{const n=null==e?null:e.mask,s=null==e?null:e.training;let r=null==e?null:e.initialState;t=zR(t),null==r&&(r=this.stateful?this.states_:this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==i)throw new QA(`RNN Layer has ${i} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},o=gD((t,e)=>{const n=this.cell.call([t].concat(e),a);return[n[0],n.slice(1)]},t,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,s);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h})}getInitialState(t){return Rk(()=>{let e=dS(t.shape);return e=HC(e,[1,2]),e=Z$(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?nR(e,[1,t]):e):this.cell.stateSize>1?[nR(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===yD.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){const s=hO(e.cell,n);return new t(Object.assign(e,{cell:s}))}}yD.className="RNN",Tk(yD);class bD extends ZR{}class vD extends bD{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,y$(this.units,"units"),this.activation=PF(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=RR(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=RR(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=RR(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=jF(t.kernelRegularizer),this.recurrentRegularizer=jF(t.recurrentRegularizer),this.biasRegularizer=jF(t.biasRegularizer),this.kernelConstraint=T$(t.kernelConstraint),this.recurrentConstraint=T$(t.recurrentConstraint),this.biasConstraint=T$(t.biasConstraint),this.dropout=G$([1,q$([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=G$([1,q$([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=VR(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return Rk(()=>{if(2!==(t=t).length)throw new QA(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const s=null!=e.training&&e.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ID({ones:()=>fS(t),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ID({ones:()=>fS(n),rate:this.recurrentDropout,training:s}));const i=this.dropoutMask,a=this.recurrentDropoutMask;r=rR(null!=i?UC(t,i):t,this.kernel.read()),null!=this.bias&&(r=lR(r,this.bias.read())),null!=a&&(n=UC(n,a));let o=Vk(r,rR(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:LF(this.activation),useBias:this.useBias,kernelInitializer:$R(this.kernelInitializer),recurrentInitializer:$R(this.recurrentInitializer),biasInitializer:$R(this.biasInitializer),kernelRegularizer:WF(this.kernelRegularizer),recurrentRegularizer:WF(this.recurrentRegularizer),biasRegularizer:WF(this.biasRegularizer),activityRegularizer:WF(this.activityRegularizer),kernelConstraint:E$(this.kernelConstraint),recurrentConstraint:E$(this.recurrentConstraint),biasConstraint:E$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}vD.className="SimpleRNNCell",Tk(vD);class wD extends yD{constructor(t){t.cell=new vD(t),super(t)}call(t,e){return Rk(()=>(null!=this.cell.dropoutMask&&(Ok(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ok(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return new t(e)}}wD.className="SimpleRNN",Tk(wD);class _D extends bD{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new QA("GRUCell does not support reset_after parameter set to true.");this.units=t.units,y$(this.units,"units"),this.activation=PF(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=PF(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=RR(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=RR(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=RR(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=jF(t.kernelRegularizer),this.recurrentRegularizer=jF(t.recurrentRegularizer),this.biasRegularizer=jF(t.biasRegularizer),this.kernelConstraint=T$(t.kernelConstraint),this.recurrentConstraint=T$(t.recurrentConstraint),this.biasConstraint=T$(t.biasConstraint),this.dropout=G$([1,q$([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=G$([1,q$([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=VR(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return Rk(()=>{if(2!==(t=t).length)throw new QA(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ID({ones:()=>fS(t),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ID({ones:()=>fS(s),rate:this.recurrentDropout,training:n,count:3}));const r=this.recurrentDropoutMask;let i,a,o;0<this.dropout&&this.dropout<1&&(t=UC(t,this.dropoutMask[0]));let l=rR(t,this.kernel.read());this.useBias&&(l=lR(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=UC(s,r[0]));const u=this.recurrentKernel.read(),[c,h]=FS(u,[2*this.units,this.units],u.rank-1),d=rR(s,c),[p,f,m]=FS(l,3,l.rank-1),[g,y]=FS(d,2,d.rank-1);i=this.recurrentActivation.apply(Vk(p,g)),a=this.recurrentActivation.apply(Vk(f,y));const b=rR(UC(a,s),h);o=this.activation.apply(Vk(m,b));const v=Vk(UC(i,s),UC(Vk(1,uS(i)),o));return[v,v]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:LF(this.activation),recurrentActivation:LF(this.recurrentActivation),useBias:this.useBias,kernelInitializer:$R(this.kernelInitializer),recurrentInitializer:$R(this.recurrentInitializer),biasInitializer:$R(this.biasInitializer),kernelRegularizer:WF(this.kernelRegularizer),recurrentRegularizer:WF(this.recurrentRegularizer),biasRegularizer:WF(this.biasRegularizer),activityRegularizer:WF(this.activityRegularizer),kernelConstraint:E$(this.kernelConstraint),recurrentConstraint:E$(this.recurrentConstraint),biasConstraint:E$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}_D.className="GRUCell",Tk(_D);class xD extends yD{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new _D(t),super(t)}call(t,e){return Rk(()=>(null!=this.cell.dropoutMask&&(Ok(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ok(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}xD.className="GRU",Tk(xD);class kD extends bD{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,y$(this.units,"units"),this.activation=PF(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=PF(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=RR(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=RR(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=RR(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=jF(t.kernelRegularizer),this.recurrentRegularizer=jF(t.recurrentRegularizer),this.biasRegularizer=jF(t.biasRegularizer),this.kernelConstraint=T$(t.kernelConstraint),this.recurrentConstraint=T$(t.recurrentConstraint),this.biasConstraint=T$(t.biasConstraint),this.dropout=G$([1,q$([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=G$([1,q$([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;let n;if(t=VR(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,s=this.units;n=new((e=class extends pR{apply(e,n){const r=t.apply([s]),i=(new mR).apply([s]),a=t.apply([2*s]);return eR(eR(r,i),a)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return Rk(()=>{const n=null!=e.training&&e.training;if(3!==(t=t).length)throw new QA(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ID({ones:()=>fS(t),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ID({ones:()=>fS(s),rate:this.recurrentDropout,training:n,count:4}));const i=this.recurrentDropoutMask;let a,o,l,u;0<this.dropout&&this.dropout<1&&(t=UC(t,this.dropoutMask[0]));let c=rR(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=UC(s,i[0])),c=Vk(c,rR(s,this.recurrentKernel.read())),this.useBias&&(c=lR(c,this.bias.read()));const[h,d,p,f]=FS(c,4,c.rank-1);a=this.recurrentActivation.apply(h),o=this.recurrentActivation.apply(d),l=Vk(UC(o,r),UC(a,this.activation.apply(p))),u=this.recurrentActivation.apply(f);const m=UC(u,this.activation.apply(l));return[m,m,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:LF(this.activation),recurrentActivation:LF(this.recurrentActivation),useBias:this.useBias,kernelInitializer:$R(this.kernelInitializer),recurrentInitializer:$R(this.recurrentInitializer),biasInitializer:$R(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:WF(this.kernelRegularizer),recurrentRegularizer:WF(this.recurrentRegularizer),biasRegularizer:WF(this.biasRegularizer),activityRegularizer:WF(this.activityRegularizer),kernelConstraint:E$(this.kernelConstraint),recurrentConstraint:E$(this.recurrentConstraint),biasConstraint:E$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}kD.className="LSTMCell",Tk(kD);class CD extends yD{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new kD(t),super(t)}call(t,e){return Rk(()=>(null!=this.cell.dropoutMask&&(Ok(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ok(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}CD.className="LSTM",Tk(CD);class SD extends bD{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return Rk(()=>{let n=(t=t).slice(1);const s=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?s.push(n.splice(0,t.stateSize.length)):s.push(n.splice(0,1));s.reverse();const r=[];let i;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];n=s[a],i=0===a?[t[0]].concat(n):[i[0]].concat(n),i=o.call(i,e),r.push(i.slice(1))}n=[];for(const t of r.slice().reverse())n.push(...t);return[i[0]].concat(n)})}build(t){let e;MR(t)&&(t=t[0]),t=t,this.cells.forEach((n,s)=>{V$(`RNNCell_${s}`,()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=this.cells.map(t=>({className:t.getClassName(),config:t.getConfig()}));return Object.assign({},t,{cells:e})}static fromConfig(t,e,n={}){const s=[];for(const r of e.cells)s.push(hO(r,n));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return UR(t)}setWeights(t){const e=[];for(const n of this.cells){const s=t.splice(n.weights.length);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],s[t]])}jR(e)}}function ID(t){const{ones:e,rate:n,training:s=!1,count:r=1}=t,i=()=>uR(e(),n),a=()=>cR(i,e,s);return!r||r<=1?Fk(a().clone()):Array(r).fill(void 0).map(a).map(t=>Fk(t.clone()))}var ED,ND;SD.className="StackedRNNCells",Tk(SD);class TD extends yD{constructor(t){if(t.unroll)throw new JA("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new JA("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new HR({ndim:5})]}call(t,e){return Rk(()=>{if(null!=this.cell.dropoutMask&&(Ok(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ok(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new QA("ConvRNN2D cell does not support constants");return super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return Rk(()=>{const{stateSize:e}=this.cell,n=this.computeSingleOutputShape(t.shape),s=dS([n[0],...n.slice(2)]);return Array.isArray(e)?Array(e.length).fill(s):[s]})}resetStates(t,e=!1){Rk(()=>{if(!this.stateful)throw new ZA("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,s=this.computeSingleOutputShape(n),r=[s[0],...s.slice(2)];if(null==n[0])throw new QA("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>dS(r)):[dS(r)];else if(null==t)Ok(this.states_),null!=this.keptStates&&(Ok(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>dS(r)):this.states_[0]=dS(r);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new QA(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Ok(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],s=r;if(!my(n.shape,s))throw new QA(`State ${e} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${n.shape}`);this.states_[e]=n}}this.states_=this.states_.map(t=>Fk(t.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:s,padding:r,strides:i,dilationRate:a}=this.cell,o="channelsFirst"===e,l=t[o?4:3],u=QF(t[o?3:2],s[0],r,i[0],a[0]),c=QF(l,s[1],r,i[1],a[1]);return[...t.slice(0,2),...o?[n,u,c]:[u,c,n]]}}TD.className="ConvRNN2D";class AD extends kD{constructor(t){const{filters:e,kernelSize:n,strides:s,padding:r,dataFormat:i,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,y$(this.filters,"filters"),this.kernelSize=YF(n,2,"kernelSize"),this.kernelSize.forEach(t=>y$(t,"kernelSize")),this.strides=YF(s||1,2,"strides"),this.strides.forEach(t=>y$(t,"strides")),this.padding=r||"valid",M$(this.padding),this.dataFormat=i||"channelsLast",L$(this.dataFormat),this.dilationRate=YF(a||1,2,"dilationRate"),this.dilationRate.forEach(t=>y$(t,"dilationRate"))}build(t){var e;t=VR(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new QA(`The channel dimension of the input should be defined. Found ${t[n]}`);const s=this.kernelSize.concat([t[n],4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,s=this.filters;t=new((e=class extends pR{apply(t,e){return tR([n.apply([s]),pS([s]),n.apply([2*s])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return Rk(()=>{if(3!==t.length)throw new QA(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,s=t[0],r=t[1],i=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ID({ones:()=>fS(s),rate:this.dropout,training:n,count:4}));const a=this.dropoutMask,o=(t,e,n)=>e&&e[n]?UC(e[n],t):t;let l=o(s,a,0),u=o(s,a,1),c=o(s,a,2),h=o(s,a,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ID({ones:()=>fS(r),rate:this.recurrentDropout,training:n,count:4}));const d=this.recurrentDropoutMask;let p=o(r,d,0),f=o(r,d,1),m=o(r,d,2),g=o(r,d,3);const[y,b,v,w]=FS(this.kernel.read(),4,3),[_,x,k,C]=this.useBias?FS(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,_,this.padding),u=this.inputConv(u,b,x,this.padding),c=this.inputConv(c,v,k,this.padding),h=this.inputConv(h,w,C,this.padding);const[S,I,E,N]=FS(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,S),f=this.recurrentConv(f,I),m=this.recurrentConv(m,E),g=this.recurrentConv(g,N);const T=this.recurrentActivation.apply(Vk(l,p)),A=this.recurrentActivation.apply(Vk(u,f)),$=Vk(UC(A,i),UC(T,this.activation.apply(Vk(c,m)))),R=UC(this.recurrentActivation.apply(Vk(h,g)),this.activation.apply($));return[R,R,$]})}getConfig(){const t=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]])}return n}(super.getConfig(),["units"]);return Object.assign({},t,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(t,e,n,s){const r=gC(t,e,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?lR(r,n,this.dataFormat):r}recurrentConv(t,e){return gC(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}AD.className="ConvLSTM2DCell",Tk(AD);class $D extends TD{constructor(t){const e=new AD(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}$D.className="ConvLSTM2D",Tk($D);class RD extends ZR{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(null==this.noiseShape[s]?e[s]:this.noiseShape[s]);return n}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);const n=zR(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,s=this.getNoiseShape(n);return cR(()=>uR(n,this.rate,s,this.seed),()=>n,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}RD.className="Dropout",Tk(RD);class OD extends RD{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}OD.className="SpatialDropout1D",Tk(OD);class FD extends ZR{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,y$(this.units,"units"),this.activation=PF(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=RR(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=RR(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=T$(t.kernelConstraint),this.biasConstraint=T$(t.biasConstraint),this.kernelRegularizer=jF(t.kernelRegularizer),this.biasRegularizer=jF(t.biasRegularizer),this.activityRegularizer=jF(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=VR(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=VR(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);const n=zR(t),s=v$(this.activation.getClassName());let r;return null!=s?r=rR(n,this.kernel.read(),s,this.bias?this.bias.read():null):(r=rR(n,this.kernel.read()),null!=this.bias&&(r=lR(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){const t={units:this.units,activation:LF(this.activation),useBias:this.useBias,kernelInitializer:$R(this.kernelInitializer),biasInitializer:$R(this.biasInitializer),kernelRegularizer:WF(this.kernelRegularizer),biasRegularizer:WF(this.biasRegularizer),activityRegularizer:WF(this.activityRegularizer),kernelConstraint:E$(this.kernelConstraint),biasConstraint:E$(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}FD.className="Dense",Tk(FD);class DD extends ZR{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=VR(t);for(const e of t.slice(1))if(null==e)throw new QA(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],H$(t,1)]}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);let n=zR(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=n.transpose(t)}return function(t){if(t.rank<=1)throw new QA(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],H$(t.shape,1)];return t.reshape(e)}(n)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}DD.className="Flatten",Tk(DD);class LD extends ZR{constructor(t){super(t),this.supportsMasking=!0,this.activation=PF(t.activation)}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);const n=zR(t);return this.activation.apply(n)})}getConfig(){const t={activation:LF(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}LD.className="Activation",Tk(LD);class MD extends ZR{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return Rk(()=>{return t=zR(t),e=t,n=this.n,Rk(()=>{if(2!==e.shape.length)throw new QA(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return nR(Z$(e,1),[1,n,1])});var e,n})}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}MD.className="RepeatVector",Tk(MD);class PD extends ZR{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",s=e.slice();let r=1,i=null;for(let o=0;o<s.length;++o){const t=s[o];if(this.isUnknown(t)){if(null!==i)throw new QA("Can only specifiy one unknown dimension.");i=o}else r*=t}const a=H$(t);if(null!==i){if(0===r||a%r!=0)throw new QA(n);s[i]=a/r}else if(a!==r)throw new QA(n);return s}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);const n=zR(t),s=n.shape,r=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return n.reshape(r)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}PD.className="Reshape",Tk(PD);class zD extends ZR{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=K$(1,t.dims.length+1);if(!my(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new HR({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=VR(t)).slice();return this.dims.forEach((n,s)=>{e[s+1]=t[n]}),e}call(t,e){return GS(zR(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}zD.className="Permute",Tk(zD);class VD extends ZR{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=zR(t);return Wk(cS(n,this.maskValue),-1)}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);const n=zR(t),s=Wk(cS(n,this.maskValue),-1,!0);return n.mul(s.asType(n.dtype))})}}VD.className="Masking",Tk(VD);class BD extends ZR{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=null==t.inputLength?[e,null]:[e].concat(i$(t.inputLength))}this.inputDim=t.inputDim,y$(this.inputDim,"inputDim"),this.outputDim=t.outputDim,y$(this.outputDim,"outputDim"),this.embeddingsInitializer=RR(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=jF(t.embeddingsRegularizer),this.activityRegularizer=jF(t.activityRegularizer),this.embeddingsConstraint=T$(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return Rk(()=>this.maskZero?(t=zR(t),cS(t,HS(t))):null)}computeOutputShape(t){if(t=VR(t),null==this.inputLength)return[...t,this.outputDim];const e=i$(this.inputLength);if(e.length!==t.length-1)throw new QA(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let s=0;s<e.length;++s){const r=e[s],i=t[s+1];if(null!=r&&null!=i&&r!==i)throw new QA(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==r&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);let n=zR(t);return"int32"!==n.dtype&&(n=X$(n,"int32")),iR(this.embeddings.read(),n.as1D()).reshape(VR(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:$R(this.embeddingsInitializer),embeddingsRegularizer:WF(this.embeddingsRegularizer),activityRegularizer:WF(this.activityRegularizer),embeddingsConstraint:E$(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}BD.className="Embedding",Tk(BD);class WD extends ZR{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new JA}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const r=t[t.length-e.length+s],i=e[s];if(null==r||null==i||r<0||i<0)n.push(null);else if(1===r)n.push(i);else if(1===i)n.push(r);else{if(r!==i)throw new QA("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(r)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[VR(t)]),(t=t).length<2)throw new QA(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const r of t)null!=r&&null!==r[0]&&e.push(r[0]);if(e=p$(e),e.length>1)throw new QA(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const e=null==t[r]?null:t[r].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const s=t.map(t=>t.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==p$(s).length}call(t,e){return Rk(()=>{if(t=t,this.reshapeRequired){const e=[],n=t.map(t=>t.rank);if(-1===n.indexOf(null)){const s=q$(n);for(let n of t){const t=n.rank;for(let e=0;e<s-t;++e)n=Z$(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const i of t){const t=i.rank;if(null==t){const t=i.shape,s=t[0],r=t.slice(1).concat([s]);let a=i.reshape([s].concat(H$(t.slice(1))));a=GS(a,[1,0]),a=a.reshape(r),e.push(a),n=!0}else if(t>1){const s=K$(1,t).concat([0]);e.push(GS(i,s)),n=!0}else e.push(i)}let s=this.mergeFunction(e);const r=s.rank;if(n)if(null==r){const t=s.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));s=GS(s.reshape([-1,e]),[1,0]).reshape(n)}else if(r>1){const t=[r-1].concat(K$(0,r-1));s=GS(s,t)}return s}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const n=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const s of t)null!=s&&null!==s[0]&&n.push(s[0]);return n=p$(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return Rk(()=>{if(null==e)return null;if(!Array.isArray(e))throw new QA("`mask` should be an Array");if(!Array.isArray(t))throw new QA("`inputs` should be an Array");if(e.length!==t.length)throw new QA(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(t=>null==t))return null;let n=(e=e.map(t=>null==t?t:$C(t,0)))[0];for(let t=1;t<e.length-1;++t)n=qC(n,e[t]);return n})}}class UD extends WD{constructor(t){super(t)}mergeFunction(t){return Rk(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Vk(e,t[n]);return e})}}UD.className="Add",Tk(UD);class jD extends WD{constructor(t){super(t)}mergeFunction(t){return Rk(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=UC(e,t[n]);return e})}}jD.className="Multiply",Tk(jD);class HD extends WD{constructor(t){super(t)}mergeFunction(t){return Rk(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Vk(e,t[n]);return UC(1/t.length,e)})}}HD.className="Average",Tk(HD);class GD extends WD{constructor(t){super(t)}mergeFunction(t){return Rk(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=ZC(e,t[n]);return e})}}GD.className="Maximum",Tk(GD);class qD extends WD{constructor(t){super(t)}mergeFunction(t){return Rk(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=QC(e,t[n]);return e})}}qD.className="Minimum",Tk(qD);class KD extends WD{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new QA("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const s of t)if(null!=s){e=!1;break}if(e)return;const n=[];for(let s=0;s<t.length;++s){const e=t[s].slice();e.splice(this.axis,1);let r=!1;for(const t of n)if(my(t,e)){r=!0;break}r||n.push(e)}if(n.length>1)throw new QA("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return Rk(()=>tR(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new QA("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(const r of e.slice(1)){if(null==n[s]||null==r[s]){n[s]=null;break}n[s]+=r[s]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new QA("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new QA("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new QA(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return Rk(()=>{let n=!0;if(e.forEach(t=>{null==t||(n=!1)}),n)return null;const s=[];for(let i=0;i<t.length;++i)s.push(null==e[i]?fS(t[i]).asType("bool"):e[i].rank<t[i].rank?$C(e[i],-1):e[i]);const r=hC(s,this.axis);return Bk(r,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function XD(t,e){for(;t<0;)t+=e;return t}KD.className="Concatenate",Tk(KD);class ZD extends WD{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){cy(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new JA("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,n);if(e[s[0]]!==n[s[1]])throw new QA(`Dimension incompatibility: ${e[s[0]]} !== ${n[s[1]]}`)}mergeFunction(t){if(2!==t.length)throw new QA(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],s=t[1];return e=Array.isArray(this.axes)?this.axes.map((e,n)=>XD(e,t[n].shape.length)):[XD(this.axes,n.shape.length),XD(this.axes,s.shape.length)],this.normalize&&(n=dO(n,e[0]),s=dO(s,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new JA("batchDot is not implemented for tensors of 4D or higher rank yet");if(cy(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),cy(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new JA("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;null==n&&(n=[s-1,r-2]);const i=n;return Rk(()=>{let n,a;if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else n=0;if(a=2===t.shape.length&&2===e.shape.length?i[0]===i[1]?t.mul(e).sum(i[0]):t.transpose([1,0]).mul(e).sum(i[1]):t.matMul(e,i[0]!==t.shape.length-1,i[1]===e.shape.length-1),n>0){let t;t=s>r?s+r-3:s-1;const e=[];for(let s=t;s<t+n;++s)e.push(s);a=a.squeeze(e)}return 1===a.shape.length&&(a=a.expandDims(1)),a})}(n,s,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[XD(this.axes,t.length),XD(this.axes,e.length)],n}computeOutputShape(t){cy(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new JA("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,n);e.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);const r=e.concat(n);return 1===r.length&&r.push(1),r}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}ZD.className="Dot",Tk(ZD);class YD extends ZR{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);const n=zR(t);return cR(()=>sR(n.shape,0,this.stddev).add(n),()=>n,e.training||!1)})}}YD.className="GaussianNoise",Tk(YD);class QD extends ZR{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Rk(()=>{this.invokeCallHook(t,e);const n=zR(t);return this.rate>0&&this.rate<1?cR(()=>{const t=Math.sqrt(this.rate/(1-this.rate));return n.mul(sR(n.shape,1,t))},()=>n,e.training||!1):n})}}QD.className="GaussianDropout",Tk(QD);class JD extends ZR{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||zR(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Rk(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return cR(()=>{const e=zR(t),s=-1.7580993408473766;let r=PC(_S(n),this.rate);r=X$(r,"float32");const i=((1-this.rate)*(1+this.rate*s**2))**-.5,a=-i*s*this.rate;return e.mul(r).add(r.add(-1).mul(s)).mul(i).add(a)},()=>zR(t),e.training||!1)}return t})}}function tL(t,e,n,s,r,i=.001){let a;if(2===t.rank)a=oC(t,e,n,s,r,i);else if(3===t.rank)a=lC(t,e,n,s,r,i);else{if(4!==t.rank)throw new JA(`batchNormalization is not implemented for array of rank ${t.rank} yet`);a=uC(t,e,n,s,r,i)}return a}JD.className="AlphaDropout",Tk(JD);class eL extends ZR{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=RR(t.betaInitializer||"zeros"),this.gammaInitializer=RR(t.gammaInitializer||"ones"),this.movingMeanInitializer=RR(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=RR(t.movingVarianceInitializer||"ones"),this.betaConstraint=T$(t.betaConstraint),this.gammaConstraint=T$(t.gammaConstraint),this.betaRegularizer=jF(t.betaRegularizer),this.gammaRegularizer=jF(t.gammaRegularizer)}build(t){t=VR(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new QA(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new HR({ndim:t.length,axes:{[e]:n}})];const s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return Rk(()=>{const n=null!=e.training&&e.training,s=zR(t),r=s.shape,i=r.length,a=K$(0,i),o=this.axis>=0?this.axis:this.axis+i;a.splice(o,1);const l=e$(1,i);l[o]=r[o];const u=a.slice();u.sort();const c=!my(u,K$(0,i).slice(0,i-1));if(!n)return(()=>{if(c){const t=this.movingMean.read().reshape(l),e=this.movingVariance.read().reshape(l),n=this.center?this.beta.read().reshape(l):null,r=this.scale?this.gamma.read().reshape(l):null;return tL(s,t,e,n,r,this.epsilon)}return tL(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(t,e,n,s,r=.001){return my(s.slice().sort(),K$(0,t.rank-1))?function(t,e,n,s,r=.001){return Rk(()=>{const i=lS(t,s),a=i.mean,o=i.variance;return[tL(t,a,o,n,e,r),a,o]})}(t,e,n,s,r):function(t,e,n,s,r=.001){return Rk(()=>{const i=lS(t,s),a=i.mean,o=i.variance,l=[];for(const e of K$(0,t.rank))-1!==s.indexOf(e)?l.push(1):l.push(t.shape[e]);const u=a.reshape(l),c=o.reshape(l),h=null==e?null:e.reshape(l),d=null==n?null:n.reshape(l);return[tL(t,u,c,d,h,r),a,o]})}(t,e,n,s,r)}(s,this.gamma.read(),this.beta.read(),a,this.epsilon),f=(t,e,n)=>{Rk(()=>{const s=1-n,r=t.read(),i=r.sub(e).mul(s);t.write(r.sub(i))})};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:$R(this.betaInitializer),gammaInitializer:$R(this.gammaInitializer),movingMeanInitializer:$R(this.movingMeanInitializer),movingVarianceInitializer:$R(this.movingVarianceInitializer),betaRegularizer:WF(this.betaRegularizer),gammaRegularizer:WF(this.gammaRegularizer),betaConstraint:E$(this.betaConstraint),gammaConstraint:E$(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}eL.className="BatchNormalization",Tk(eL);class nL extends ZR{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=RR(t.betaInitializer||"zeros"),this.gammaInitializer=RR(t.gammaInitializer||"ones"),this.betaRegularizer=jF(t.betaRegularizer),this.gammaRegularizer=jF(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=VR(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(const s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==p$(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(e=>t[e]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,e){const n=zR(t),s=n.shape,r=s.length;return Rk(()=>{let{mean:t,variance:e}=lS(n,this.axis,!0);const i=e$(1,r);for(const n of this.axis)i[n]=s[n];const a=t=>null!=t&&t.shape.length!==r&&this.axis!==[r-1]?t.reshape(i):t;let o=a(this.gamma.read()),l=a(this.beta.read());const u=[],c=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(u.push(s[n]),c.push(1)):(u.push(1),c.push(s[n]));return t=t.tile(u),e=e.tile(u),o=o.tile(c),l=l.tile(c),tL(n,t,e,l,o,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:$R(this.betaInitializer),gammaInitializer:$R(this.gammaInitializer),betaRegularizer:WF(this.betaRegularizer),gammaRegularizer:WF(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}nL.className="LayerNormalization",Tk(nL);class sL extends ZR{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new QA(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new QA(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new QA(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new HR({ndim:4})]}computeOutputShape(t){let e,n;return t=VR(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return Rk(()=>{return e=zR(t),n=this.padding,s=this.dataFormat,Rk(()=>{if(4!==e.rank)throw new QA(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new QA("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==s&&(s="channelsLast"),"channelsLast"!==s&&"channelsFirst"!==s)throw new QA(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===s?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],mS(e,t)});var e,n,s})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function rL(t,e,n,s,r,i){return Rk(()=>{let a;L$(r),P$(i),M$(s),null==n&&(n=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),t=tD(t,r);const o="same"===s?"same":"valid";return a="max"===i?KC(t,e,n,o):rC(t,e,n,o),"channelsFirst"===r&&(a=GS(a,[0,3,1,2])),a})}function iL(t,e,n,s,r,i){return Rk(()=>{let a;L$(r),P$(i),M$(s),null==n&&(n=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),t=eD(t,r);const o="same"===s?"same":"valid";return a="max"===i?XC(t,e,n,o):iC(t,e,n,o),"channelsFirst"===r&&(a=GS(a,[0,4,1,2,3])),a})}sL.className="ZeroPadding2D",Tk(sL);class aL extends ZR{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new QA(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(y$(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new QA(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}y$(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,M$(this.padding),this.inputSpec=[new HR({ndim:3})]}computeOutputShape(t){const e=QF((t=VR(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return Rk(()=>{this.invokeCallHook(t,e),t=Z$(zR(t),2);const n=this.poolingFunction(zR(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return LS(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class oL extends aL{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return L$(r),M$(s),rL(t,e,n,s,r,"max")}}oL.className="MaxPooling1D",Tk(oL);class lL extends aL{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return L$(r),M$(s),rL(t,e,n,s,r,"avg")}}lL.className="AveragePooling1D",Tk(lL);class uL extends ZR{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new QA(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];y$(this.poolSize,"poolSize"),y$(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,L$(this.dataFormat),M$(this.padding),this.inputSpec=[new HR({ndim:4})]}computeOutputShape(t){t=VR(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=QF(e,this.poolSize[0],this.padding,this.strides[0]),n=QF(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return Rk(()=>(this.invokeCallHook(t,e),this.poolingFunction(zR(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class cL extends uL{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return L$(r),M$(s),rL(t,e,n,s,r,"max")}}cL.className="MaxPooling2D",Tk(cL);class hL extends uL{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return L$(r),M$(s),rL(t,e,n,s,r,"avg")}}hL.className="AveragePooling2D",Tk(hL);class dL extends ZR{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new QA(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];y$(this.poolSize,"poolSize"),y$(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,L$(this.dataFormat),M$(this.padding),this.inputSpec=[new HR({ndim:5})]}computeOutputShape(t){t=VR(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=QF(e,this.poolSize[0],this.padding,this.strides[0]),n=QF(n,this.poolSize[1],this.padding,this.strides[1]),s=QF(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,s]:[t[0],e,n,s,t[4]]}call(t,e){return Rk(()=>(this.invokeCallHook(t,e),this.poolingFunction(zR(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class pL extends dL{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return L$(r),M$(s),iL(t,e,n,s,r,"max")}}pL.className="MaxPooling3D",Tk(pL);class fL extends dL{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return L$(r),M$(s),iL(t,e,n,s,r,"avg")}}fL.className="AveragePooling3D",Tk(fL);class mL extends ZR{constructor(t){super(t),this.inputSpec=[new HR({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new JA}}class gL extends mL{constructor(t){super(t||{})}call(t,e){return Rk(()=>{const e=zR(t);return YC(e,1)})}}gL.className="GlobalAveragePooling1D",Tk(gL);class yL extends mL{constructor(t){super(t||{})}call(t,e){return Rk(()=>{const e=zR(t);return WC(e,1)})}}yL.className="GlobalMaxPooling1D",Tk(yL);class bL extends ZR{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,L$(this.dataFormat),this.inputSpec=[new HR({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new JA}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class vL extends bL{call(t,e){return Rk(()=>{const e=zR(t);return YC(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}vL.className="GlobalAveragePooling2D",Tk(vL);class wL extends bL{call(t,e){return Rk(()=>{const e=zR(t);return WC(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}wL.className="GlobalMaxPooling2D",Tk(wL);class _L extends ZR{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const s=hO(e.layer,n);delete e.layer;const r={layer:s};return Object.assign(r,e),new t(r)}}class xL extends _L{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=VR(t)).length<3)throw new QA(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=VR(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e);return[n[0],t[1]].concat(n.slice(1))}call(t,e){return Rk(()=>gD((t,n)=>[zR(this.layer.call(t,e)),[]],t=zR(t),[],!1,null,null,!1,!0)[1])}}xL.className="TimeDistributed",Tk(xL);class kL extends _L{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=hO(n),e.goBackwards=!0!==e.goBackwards;const s={};if(s.className=t.layer.getClassName(),s.config=e,this.backwardLayer=hO(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,m$(F$,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new JA("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,e)),this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let e,n,s,r=this.forwardLayer.computeOutputShape(t);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState?(s=r.slice(1),e=r[0]):e=r[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(s).concat(s.slice()):[e].concat(s).concat(s.slice()):r$(n)}apply(t,e){let n=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=mD(t,n,s,this.numConstants);if(t=r.inputs,n=r.initialState,s=r.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==s)return super.apply(t,e);const i=[],a=[];if(null!=n){const t=n.length;if(t%2>0)throw new QA("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);const s=n.map(t=>new HR({shape:t.shape}));this.forwardLayer.stateSpec=s.slice(0,t/2),this.backwardLayer.stateSpec=s.slice(t/2),a.push(...s)}if(null!=s)throw new JA("Support for constants in Bidirectional layers is not implemented yet.");const o=i[0]instanceof GR;for(const l of i)if(l instanceof GR!==o)throw new QA("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[t].concat(i),s=this.inputSpec.concat(a),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,e);return this.inputSpec=r,o}return super.apply(t,e)}call(t,e){return Rk(()=>{const n=e.initialState;let s,r,i,a;if(null==n)s=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const i=n.slice(0,n.length/2),a=n.slice(n.length/2);s=this.forwardLayer.call(t,Object.assign(e,{initialState:i})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:a}))}return this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(r.slice(1))),s=s[0],r=r[0]),this.returnSequences&&(r=kS(r,1)),"concat"===this.mergeMode?a=tR([s,r]):"sum"===this.mergeMode?a=Vk(s,r):"ave"===this.mergeMode?a=UC(.5,Vk(s,r)):"mul"===this.mergeMode?a=UC(s,r):null==this.mergeMode&&(a=[s,r]),this.returnState?null==this.mergeMode?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){V$(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),V$(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map(t=>null);return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=hO(e.layer);if(delete e.layer,null!=e.numConstants)throw new JA("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=e;return s.layer=n,new t(s)}}kL.className="Bidirectional",Tk(kL),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(ED||(ED={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(ND||(ND={}));const CL={};function SL(t){return CL[t]}function IL(t,e,n,s,r){const i=e.inputParams[t];if(i&&void 0!==i.inputIndexStart){const t=i.inputIndexStart,a=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?t+1:i.inputIndexEnd;if("tensor"===i.type)return EL(e.inputNames[i.inputIndexStart],n,s,r);if("tensors"===i.type)return e.inputNames.slice(t,a).map(t=>EL(t,n,s,r));const o=EL(e.inputNames.slice(t)[0],n,s,r),l=o.dataSync();return"number"===i.type?l[0]:Dy(o.shape,l)}const a=e.attrParams[t];return a&&a.value}function EL(t,e,n,s){const[r,i]=AL(t);if(null!=s){const t=s.getHashTableHandleByName(r);if(null!=t)return t}const a=n.currentContextIds.find(t=>!!e[TL(r,t)]);return void 0!==a?e[TL(r,a)][i]:void 0}function NL(t,e){const[n,s,r]=AL(t);return[TL(n,e&&e.currentContextId),s,r]}function TL(t,e){return e?`${t}-${e}`:t}function AL(t){const e=t.split(":");if(1===e.length)return[t,0,void 0];const n=3===e.length?e[1]:void 0;return[e[0],Number(e[e.length-1]),n]}function $L(t,e,n){let s=IL("pad",t,e,n);if("explicit"===s){s=IL("explicitPaddings",t,e,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let t=0;t<4;t++)r[t][0]=s[2*t],r[t][1]=s[2*t+1];return r}return s}function RL(t){return t.kept?t:Yx(t)}const OL=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],FL=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],DL=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],LL=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],ML=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],PL=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zL=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],VL=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],BL=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],WL=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],UL=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jL=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],HL=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],GL=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],qL=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],KL=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],XL=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],ZL=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],YL=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class QL{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[a,o,l,u,c,h,d,p,f,m,g,y,b,v,w,_,x,k,C].map(t=>t.json));this.opMappers=t.reduce((t,e)=>(t[e.tfOpName]=e,t),{})}transformGraph(t,e={}){const n=[],s=[],r=[],i=t.node.reduce((t,e)=>(t[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")?n.push(t[e.name]):"Const"===e.op?s.push(t[e.name]):null!=e.input&&0!==e.input.length||r.push(t[e.name]),t),{});let a=[];const o=[];let l={},u={};null!=e&&(l=this.mapSignatureEntries(e.inputs),u=this.mapSignatureEntries(e.outputs));const c=Object.keys(i);c.forEach(t=>{const e=i[t];e.inputNames.forEach((t,n)=>{const[s,,r]=NL(t),a=i[s];if(null!=a.outputs){const t=a.outputs.indexOf(r);-1!==t&&(e.inputNames[n]=`${s}:${t}`)}e.inputs.push(a),a.children.push(e)})}),0===Object.keys(u).length?c.forEach(t=>{const e=i[t];0===e.children.length&&o.push(e)}):Object.keys(u).forEach(t=>{const[e]=NL(t),n=i[e];null!=n&&(n.signatureKey=u[t],o.push(n))}),Object.keys(l).length>0?Object.keys(l).forEach(t=>{const[e]=NL(t),n=i[e];n&&(n.signatureKey=l[t],a.push(n))}):a=n;let h={};null!=t.library&&null!=t.library.function&&(h=t.library.function.reduce((t,e)=>(t[e.signature.name]=this.mapFunction(e),t),{}));const d={nodes:i,inputs:a,outputs:o,weights:s,placeholders:n,signature:e,functions:h};return r.length>0&&(d.initNodes=r),d}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){const e=SL(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(t=>t.startsWith("^")?t.substr(1):t),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(n.inputParams=e.inputs.reduce((t,e)=>(t[e.name]={type:e.type,inputIndexStart:e.start,inputIndexEnd:e.end},t),{})),null!=e.attrs&&(n.attrParams=e.attrs.reduce((e,n)=>{const s=n.type;let r;switch(n.type){case"string":r=tM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=tM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=cM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=cM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=nM(t.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=nM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=uM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=uM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=eM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=eM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=dM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=dM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=lM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=lM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=hM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=hM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=iM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=iM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=aM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=aM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=rM(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=rM(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${t.op}`)}return e[n.name]={value:r,type:s},e},{})),n}mapFunction(t){const e=t.nodeDef,n=[];let s={};null!=e&&(s=e.reduce((t,e)=>(t[e.name]=this.mapNode(e),"Const"===e.op&&n.push(t[e.name]),t),{}));const r=[],i=[];t.signature.inputArg.forEach(t=>{const[e]=NL(t.name),n={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:sM(t.type),type:"dtype"}},children:[]};n.signatureKey=t.name,r.push(n),s[e]=n}),Object.keys(s).forEach(t=>{const e=s[t];e.inputNames.forEach((t,n)=>{const[r,,i]=NL(t),a=s[r];if(null!=a.outputs){const t=a.outputs.indexOf(i);-1!==t&&(e.inputNames[n]=`${r}:${t}`)}e.inputs.push(a),a.children.push(e)})});const a=t.ret;t.signature.outputArg.forEach(t=>{const[e,n]=NL(a[t.name]),r=s[e];null!=r&&(r.defaultOutput=n,i.push(r))});const o=this.mapArgsToSignature(t);return{nodes:s,inputs:r,outputs:i,weights:n,placeholders:[],signature:o}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((t,e)=>(t[e.name]=this.mapArgToTensorInfo(e),t),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return null!=e&&(n=e[n]),{name:n,dtype:t.type}}}function JL(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):function(t){const e=Hy().global;if(void 0!==e.atob)return e.atob(t);if("undefined"!=typeof Buffer)return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return e?n:n.toLowerCase()}function tM(t,e,n,s=!1){const r=t[e];return null!=r?JL(r.s,s):n}function eM(t,e,n){const s=t[e];return s?s.b:n}function nM(t,e,n){const s=t[e]||{},r=null!=s.i?s.i:null!=s.f?s.f:n;return"number"==typeof r?r:parseInt(r,10)}function sM(t){switch("string"==typeof t&&(t=ED[t]),t){case ED.DT_FLOAT:return"float32";case ED.DT_INT32:case ED.DT_INT64:case ED.DT_INT8:case ED.DT_UINT8:return"int32";case ED.DT_BOOL:return"bool";case ED.DT_DOUBLE:return"float32";case ED.DT_STRING:return"string";default:return null}}function rM(t,e,n){const s=t[e];return s&&s.func?s.func.name:n}function iM(t,e,n){const s=t[e];return s&&s.type?sM(s.type):n}function aM(t,e,n){const s=t[e];return s&&s.list&&s.list.type?s.list.type.map(t=>sM(t)):n}function oM(t){if(!t.unknownRank)return null!=t.dim?t.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function lM(t,e,n){const s=t[e];return s&&s.shape?oM(s.shape):n}function uM(t,e,n){const s=t[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(t=>"number"==typeof t?t:parseInt(t,10)):n}function cM(t,e,n,s=!1){const r=t[e];return r&&r.list&&r.list.s?r.list.s.map(t=>JL(t,s)):n}function hM(t,e,n){const s=t[e];return s&&s.list&&s.list.shape?s.list.shape.map(t=>oM(t)):n}function dM(t,e,n){const s=t[e];return s&&s.list&&s.list.b?s.list.b:n}class pM{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(t=>this.getInput(t)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((t,e)=>(t[e]=this.getAttr(e),t),{}))}getInput(t){return EL(t,this.tensorMap,this.context)}getAttr(t,e){const n=this.node.rawAttrs[t];if(null!=n.tensor)return EL(t,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return nM(this.node.rawAttrs,t,e);if(null!=n.s)return tM(this.node.rawAttrs,t,e);if(null!=n.b)return eM(this.node.rawAttrs,t,e);if(null!=n.shape)return lM(this.node.rawAttrs,t,e);if(null!=n.type)return iM(this.node.rawAttrs,t,e);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return uM(this.node.rawAttrs,t,e);if(null!=n.list.s)return cM(this.node.rawAttrs,t,e);if(null!=n.list.shape)return hM(this.node.rawAttrs,t,e);if(null!=n.list.b)return dM(this.node.rawAttrs,t,e);if(null!=n.list.type)return aM(this.node.rawAttrs,t,e)}return e}}const fM=hx({addN_:function(t){cy(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),cy(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((t,e)=>ux(t,`tensors${e}`,"addN")),n=e[0];return e.forEach(t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(t=>{if(!my(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),ex.runKernel(tb,e)}});function mM(t,e,n=""){if("number"!=typeof t&&"number"!=typeof e){cy(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let s=0;s<t.length;s++){const r=t[s],i=e[s];cy(r<0||i<0||r===i,()=>n+` Shapes ${t} and ${e} must match`)}}}function gM(t){return"number"!=typeof t&&!t.some(t=>t<0)}function yM(t,e,n){let s=bM(t,n);const r=!gM(s);if(r&&0===e.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(t=>{s=bM(t.shape,s)}),!gM(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function bM(t,e){if("number"==typeof t)return e;if("number"==typeof e)return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let s=0;s<t.length;++s){const r=t[s],i=e[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[s]=r>=0?r:i}return n}class vM{constructor(t,e,n,s,r,i,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=s,this.identicalElementShapes=r,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Mk(0),Fk(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{null!=t&&t.has(e.tensor.id)||e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(t=>this.read(t))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),mM(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Fk(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((t,n)=>this.write(t,e[n]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return fx([],[0].concat(this.elementShape));const n=this.readMany(t);return mM(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),MS(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return fx([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const n=this.readMany(e);return mM(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),hC(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,WS(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0;const s=t.map(t=>(n+=t,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const r=0===n?0:e.size/n,i=[];Rk(()=>{e=sC(e,[1,n,r]);for(let n=0;n<t.length;++n)i[n]=sC(ES(e,[0,0===n?0:s[n-1],0],[1,t[n],r]),this.elementShape);return i});const a=[];for(let o=0;o<t.length;o++)a[o]=o;this.writeMany(a,i)}}class wM{constructor(t,e,n,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,null!=t&&t.forEach(t=>{if(n!==t.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${t.dtype}`);mM(e,t.shape,"TensorList shape mismatch: "),Fk(t)}),this.idTensor=Mk(0),this.maxNumElements=s,Fk(this.idTensor)}get id(){return this.idTensor.id}copy(){return new wM([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{null!=t&&t.has(e.id)||e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);mM(t,this.elementShape,"TensorList shape mismatch: ");const s=yM(this.elementShape,this.tensors,t);return Rk(()=>{const t=this.tensors.map(t=>sC(t,s));return MS(t,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=yM(this.elementShape,this.tensors,t),s=this.tensors.pop();return mM(s.shape,t,"TensorList shape mismatch: "),sC(s,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(mM(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Fk(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);mM(this.tensors[t].shape,e,"TensorList shape mismatch: ");const s=yM(this.elementShape,this.tensors,e);return sC(this.tensors[t],s)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);mM(this.elementShape,e.shape,"TensorList shape mismatch: "),Fk(e),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);mM(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=yM(this.elementShape,this.tensors,n);return 0===t.length?fx([],[0].concat(s)):Rk(()=>{const e=t.map(t=>sC(this.tensors[t],s));return MS(e,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);mM(this.elementShape,e,"TensorList shape mismatch: ");const n=yM(this.elementShape,this.tensors,e);return 0===this.size()?fx([],[0].concat(n)):Rk(()=>{const t=this.tensors.map(t=>sC(t,n));return hC(t,0)})}}const _M=function(){var t=ny(function*(t,e,n){switch(t.op){case"If":case"StatelessIf":{const s=IL("thenBranch",t,e,n),r=IL("elseBranch",t,e,n),i=IL("cond",t,e,n),a=IL("args",t,e,n);return(yield i.data())[0]?n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=IL("body",t,e,n),r=IL("cond",t,e,n),i=IL("args",t,e,n),a=yield n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),o=i.map(t=>t.id);let l=yield a[0].data();a.forEach(t=>{t.kept||-1!==o.indexOf(t.id)||t.dispose()});let u=i;for(;l[0];){const t=u;u=yield n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const e=u.map(t=>t.id);t.forEach(t=>{t.kept||-1!==o.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()});const i=yield n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=yield i[0].data(),i.forEach(t=>{t.kept||-1!==o.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()})}return u}case"LoopCond":return[RL(IL("pred",t,e,n))];case"Switch":{const s=IL("pred",t,e,n);let r=IL("data",t,e,n);return r.kept||(r=RL(r)),(yield s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=t.inputNames.find(t=>void 0!==EL(t,e,n));return s?[RL(EL(s,e,n))]:void 0}case"Enter":{const s=IL("frameName",t,e,n),r=IL("tensor",t,e,n);return n.enterFrame(s),[RL(r)]}case"Exit":{const s=IL("tensor",t,e,n);return n.exitFrame(),[RL(s)]}case"NextIteration":{const s=IL("tensor",t,e,n);return n.nextIteration(),[RL(s)]}case"TensorArrayV3":{const s=IL("size",t,e,n),r=IL("dtype",t,e,n),i=IL("elementShape",t,e,n),a=IL("dynamicSize",t,e,n),o=IL("clearAfterRead",t,e,n),l=IL("identicalElementShapes",t,e,n),u=IL("name",t,e,n),c=new vM(u,r,s,i,l,a,o);return n.addTensorArray(c),[c.idTensor,Mk(1)]}case"TensorArrayWriteV3":{const s=IL("tensorArrayId",t,e,n),r=IL("index",t,e,n),i=IL("tensor",t,e,n),a=n.getTensorArray(s.id);return a.write(r,i),[a.idTensor]}case"TensorArrayReadV3":{const s=IL("tensorArrayId",t,e,n),r=IL("index",t,e,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=IL("tensorArrayId",t,e,n),r=IL("indices",t,e,n),i=IL("dtype",t,e,n);return[n.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=IL("tensorArrayId",t,e,n),r=IL("indices",t,e,n),i=IL("tensor",t,e,n),a=n.getTensorArray(s.id);return a.scatter(r,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=IL("tensorArrayId",t,e,n),r=n.getTensorArray(s.id),i=IL("dtype",t,e,n);return[r.concat(i)]}case"TensorArraySplitV3":{const s=IL("tensorArrayId",t,e,n),r=IL("tensor",t,e,n),i=IL("lengths",t,e,n),a=n.getTensorArray(s.id);return a.split(i,r),[a.idTensor]}case"TensorArraySizeV3":{const s=IL("tensorArrayId",t,e,n);return[Mk(n.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=IL("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=IL("tensorListId",t,e,n),r=IL("index",t,e,n),i=IL("tensor",t,e,n),a=n.getTensorList(s.id);return a.setItem(r,i),[a.idTensor]}case"TensorListGetItem":{const s=IL("tensorListId",t,e,n),r=IL("index",t,e,n),i=IL("elementShape",t,e,n),a=IL("elementDType",t,e,n);return[n.getTensorList(s.id).getItem(r,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=IL("indices",t,e,n),r=function(t,e,n,s){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(null!=s&&-1!==s&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new wM([],n,t.dtype,s),a=WS(t,0);return e.forEach((t,e)=>{i.setItem(t,a[e])}),i}(IL("tensor",t,e,n),s,IL("elementShape",t,e,n),IL("numElements",t,e,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=IL("elementShape",t,e,n),r=IL("elementDType",t,e,n);let i;i="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=function(t,e,n){return new wM([],t,e,n)}(s,r,IL(i,t,e,n));return n.addTensorList(a),[a.idTensor]}case"TensorListGather":{const s=IL("tensorListId",t,e,n),r=IL("indices",t,e,n),i=IL("elementShape",t,e,n),a=IL("elementDType",t,e,n);return[n.getTensorList(s.id).gather(r,a,i)]}case"TensorListStack":{const s=IL("tensorListId",t,e,n),r=IL("elementShape",t,e,n),i=IL("elementDType",t,e,n),a=IL("numElements",t,e,n);return[n.getTensorList(s.id).stack(r,i,a)]}case"TensorListFromTensor":{const s=function(t,e,n){const s=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);mM(t.shape.slice(1),e,"TensorList shape mismatch: ");const r=WS(t);return new wM(r,e,s)}(IL("tensor",t,e,n),IL("elementShape",t,e,n),IL("elementDType",t,e,n));return n.addTensorList(s),[s.idTensor]}case"TensorListConcat":{const s=IL("tensorListId",t,e,n),r=n.getTensorList(s.id),i=IL("dtype",t,e,n),a=IL("elementShape",t,e,n);return[r.concat(i,a)]}case"TensorListPushBack":{const s=IL("tensorListId",t,e,n),r=IL("tensor",t,e,n),i=n.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=IL("tensorListId",t,e,n),r=IL("elementShape",t,e,n),i=IL("elementDType",t,e,n);return[n.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=IL("tensor",t,e,n),r=IL("elementShape",t,e,n),i=function(t,e,n){let s=0;const r=e.map(t=>(s+=t,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${t.shape}`);const i=bM(t.shape.slice(1),n),a=0===s?0:t.size/s,o=Rk(()=>{const n=[];t=sC(t,[1,s,a]);for(let s=0;s<e.length;++s)n[s]=sC(ES(t,[0,0===s?0:r[s-1],0],[1,e[s],a]),i);return t.dispose(),n}),l=new wM([],n,t.dtype,e.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(s,IL("lengths",t,e,n),r);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,n,s){return t.apply(this,arguments)}}(),xM=hx({maxPoolWithArgmax_:function(t,e,n,s,r=!1){const i=ux(t,"x","maxPoolWithArgmax"),a=ex.runKernel(Av,{x:i},{filterSize:e,strides:n,pad:s,includeBatchInIndex:r});return{result:a[0],indexes:a[1]}}});function kM(t,e,n){const[s,r]=IL("fusedOps",t,e,n),i="biasadd"===s,a=!i,o="prelu"===r,l="fusedbatchnorm"===s,u=IL("numArgs",t,e,n);if(i){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=IL("strides",t,e,n),h=$L(t,e,n),d=IL("dataFormat",t,e,n).toUpperCase(),p=IL("dilations",t,e,n);let[f,m]=IL("args",t,e,n);return a&&(m=f,f=void 0),{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:IL("leakyreluAlpha",t,e,n)}}function CM(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return ex.runKernel(gv,{},{start:t,stop:e,num:n})}const SM=hx({multinomial_:function(t,e,n,s=!1){const r=ux(t,"logits","multinomial"),i=r.size,a=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();const o=1===a?sC(r,[1,-1]):r,l=ex.runKernel(Lv,{logits:o},{numSamples:e,seed:n,normalized:s});return 1===a?sC(l,[l.size]):l}});function IM(){return(IM=ny(function*(t){const e=ux(t,"condition","whereAsync","bool"),n=yield e.data(),s=mN(e.shape,n);return t!==e&&e.dispose(),s})).apply(this,arguments)}const EM=function(t){return IM.apply(this,arguments)};function NM(){return(NM=ny(function*(t,e){const n=ux(t,"x","setdiff1d"),s=ux(e,"y","setdiff1d");cy(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),cy(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),cy(1===s.rank,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=yield n.data(),i=yield s.data(),a=new Set(i);let o=0;for(let c=0;c<r.length;c++)a.has(r[c])||o++;const l=new R_([o],n.dtype),u=new R_([o],"int32");for(let c=0,h=0;c<r.length;c++)a.has(r[c])||(l.values[h]=r[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]})).apply(this,arguments)}function TM(t,e,n){return{boxes:IL("boxes",t,e,n),scores:IL("scores",t,e,n),maxOutputSize:IL("maxOutputSize",t,e,n),iouThreshold:IL("iouThreshold",t,e,n),scoreThreshold:IL("scoreThreshold",t,e,n),softNmsSigma:IL("softNmsSigma",t,e,n)}}const AM=function(){var t=ny(function*(t,e,n){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:r,maxOutputSize:i,iouThreshold:a,scoreThreshold:o,softNmsSigma:l}=TM(t,e,n),u=yield uE.nonMaxSuppressionWithScoreAsync(s,r,i,a,o,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:r,maxOutputSize:i,iouThreshold:a,scoreThreshold:o}=TM(t,e,n),l=IL("padToMaxOutputSize",t,e,n),u=yield uE.nonMaxSuppressionPaddedAsync(s,r,i,a,o,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:r,maxOutputSize:i,iouThreshold:a,scoreThreshold:o}=TM(t,e,n);return[yield uE.nonMaxSuppressionAsync(s,r,i,a,o)]}case"Where":{const s=Zx(IL("condition",t,e,n),"bool"),r=[yield EM(s)];return s.dispose(),r}case"ListDiff":return function(t,e){return NM.apply(this,arguments)}(IL("x",t,e,n),IL("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,n,s){return t.apply(this,arguments)}}();class $M{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Mk(0),this.tensorMap=new Map,Fk(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Mk(this.size(),"int32")}import(t,e){var n=this;return ny(function*(){n.checkKeyAndValueTensor(t,e);const s=yield t.data();return n.tensorMap.forEach(t=>t.dispose()),n.tensorMap.clear(),Rk(()=>{const t=WS(e),r=s.length,i=t.length;cy(r===i,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${i} elements.`);for(let e=0;e<r;e++){const r=s[e],i=t[e];Fk(i),n.tensorMap.set(r,i)}return n.handle})})()}find(t,e){var n=this;return ny(function*(){n.checkKeyAndValueTensor(t,e);const s=yield t.data();return Rk(()=>{const t=[];for(let r=0;r<s.length;r++){const i=n.findWithDefault(s[r],e);t.push(i)}return MS(t)})})()}findWithDefault(t,e){const n=this.tensorMap.get(t);return null!=n?n:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const RM=function(){var t=ny(function*(t,e,n,s){switch(t.op){case"HashTable":case"HashTableV2":{const r=IL("keyDType",t,e,n),i=IL("valueDType",t,e,n),a=new $M(r,i);return s.addHashTable(t.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=IL("tableHandle",t,e,n,s),i=IL("keys",t,e,n),a=IL("values",t,e,n),o=s.getHashTableById(r.id);return[yield o.import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=IL("tableHandle",t,e,n,s),i=IL("keys",t,e,n),a=IL("defaultValue",t,e,n),o=s.getHashTableById(r.id);return[yield o.find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=IL("tableHandle",t,e,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,n,s,r){return t.apply(this,arguments)}}(),OM=hx({einsum_:function(t,...e){const n=e.map((t,e)=>ux(t,`tensors${e}`,"einsum"));return ex.runKernel(Ub,n,{equation:t})}}),FM=hx({sparseToDense_:function(t,e,n,s=0){const r=ux(t,"sparseIndices","sparseToDense","int32"),i=ux(e,"sparseValues","sparseToDense"),a=ux(s,"defaultValue","sparseToDense",i.dtype);return function(t,e,n,s){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,i=t.rank>1?t.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);if(0!==e.rank&&(1!==e.rank||e.size!==r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,i,n,a),ex.runKernel(Ew,{sparseIndices:r,sparseValues:i,defaultValue:a},{outputShape:n})}}),DM=hx({denseBincount_:function(t,e,n,s=!1){const r=ux(t,"x","denseBincount"),i=ux(e,"weights","denseBincount");return cy("int32"===r.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),cy(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),cy(n>=0,()=>`size must be non-negative, but got ${n}.`),cy(i.size===r.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`),ex.runKernel(Ob,{x:r,weights:i},{size:n,binaryOutput:s})}}),LM=hx({scatterND_:function(t,e,n){const s=ux(t,"indices","scatterND","int32"),r=ux(e,"updates","scatterND");return LE(r,s,n),ex.runKernel(uw,{indices:s,updates:r},{shape:n})}}),MM=hx({gatherND_:function(t,e){const n=ux(e,"indices","gatherND","int32"),s=ux(t,"x","gatherND","string_or_numeric");return ex.runKernel(rv,{params:s,indices:n})}});function PM(t,e,n,s){const r=((t,e,n)=>{switch(t.category){case"arithmetic":return Rk(()=>((t,e,n)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[Vk(IL("a",t,e,n),IL("b",t,e,n))];case"AddN":return[fM(IL("tensors",t,e,n))];case"FloorMod":case"Mod":return[zA(IL("a",t,e,n),IL("b",t,e,n))];case"Mul":return[UC(IL("a",t,e,n),IL("b",t,e,n))];case"RealDiv":case"Div":return[SC(IL("a",t,e,n),IL("b",t,e,n))];case"DivNoNan":return[EA(IL("a",t,e,n),IL("b",t,e,n))];case"FloorDiv":return[CC(IL("a",t,e,n),IL("b",t,e,n))];case"Sub":return[jC(IL("a",t,e,n),IL("b",t,e,n))];case"Minimum":return[QC(IL("a",t,e,n),IL("b",t,e,n))];case"Maximum":return[ZC(IL("a",t,e,n),IL("b",t,e,n))];case"Pow":return[HI(IL("a",t,e,n),IL("b",t,e,n))];case"SquaredDifference":return[JI(IL("a",t,e,n),IL("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"basic_math":return Rk(()=>((t,e,n)=>{switch(t.op){case"Abs":case"ComplexAbs":return[zk(IL("x",t,e,n))];case"Acos":return[gA(IL("x",t,e,n))];case"Acosh":return[yA(IL("x",t,e,n))];case"Asin":return[vA(IL("x",t,e,n))];case"Asinh":return[wA(IL("x",t,e,n))];case"Atan":return[_A(IL("x",t,e,n))];case"Atan2":return[xA(IL("x",t,e,n),IL("y",t,e,n))];case"Atanh":return[kA(IL("x",t,e,n))];case"Ceil":return[CA(IL("x",t,e,n))];case"Complex":return[dx(IL("real",t,e,n),IL("imag",t,e,n))];case"Cos":return[iA(IL("x",t,e,n))];case"Cosh":return[oA(IL("x",t,e,n))];case"Elu":return[IC(IL("x",t,e,n))];case"Erf":return[TA(IL("x",t,e,n))];case"Exp":return[BC(IL("x",t,e,n))];case"Expm1":return[AA(IL("x",t,e,n))];case"Floor":return[DC(IL("x",t,e,n))];case"Log":return[VC(IL("x",t,e,n))];case"Log1p":return[tE(IL("x",t,e,n))];case"Imag":return[KS(IL("x",t,e,n))];case"Neg":return[uS(IL("x",t,e,n))];case"Reciprocal":return[WA(IL("x",t,e,n))];case"Real":return[XS(IL("x",t,e,n))];case"Relu":return[xS(IL("x",t,e,n))];case"Round":return[zI(IL("x",t,e,n))];case"Selu":return[CS(IL("x",t,e,n))];case"Sigmoid":return[IS(IL("x",t,e,n))];case"Sin":return[HN(IL("x",t,e,n))];case"Sign":return[UA(IL("x",t,e,n))];case"Sinh":return[qN(IL("x",t,e,n))];case"Softplus":return[OS(IL("x",t,e,n))];case"Sqrt":return[DS(IL("x",t,e,n))];case"Square":return[oS(IL("x",t,e,n))];case"Tanh":return[PS(IL("x",t,e,n))];case"Tan":return[HA(IL("x",t,e,n))];case"ClipByValue":return[cC(IL("x",t,e,n),IL("clipValueMin",t,e,n),IL("clipValueMax",t,e,n))];case"Relu6":return[eI(IL("x",t,e,n))];case"Rsqrt":return[aT(EL(t.inputNames[0],e,n))];case"Prod":return[BA(IL("x",t,e,n),IL("axes",t,e,n))];case"LeakyRelu":return[zC(IL("x",t,e,n),IL("alpha",t,e,n))];case"Prelu":return[gS(IL("x",t,e,n),IL("alpha",t,e,n))];case"IsNan":return[OA(EL(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"control":return _M(t,e,n);case"convolution":return Rk(()=>((t,e,n)=>{switch(t.op){case"Conv1D":{const s=IL("stride",t,e,n),r=IL("pad",t,e,n),i=IL("dataFormat",t,e,n).toUpperCase(),a=IL("dilation",t,e,n);return[yC(IL("x",t,e,n),IL("filter",t,e,n),s,r,i,a)]}case"Conv2D":{const s=IL("strides",t,e,n),r=$L(t,e,n),i=IL("dataFormat",t,e,n).toUpperCase(),a=IL("dilations",t,e,n);return[gC(IL("x",t,e,n),IL("filter",t,e,n),[s[1],s[2]],r,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:r,dataFormat:i,dilations:a,biasArg:o,preluArg:l,activationFunc:u,leakyreluAlpha:c}=kM(t,e,n);return[oI({x:IL("x",t,e,n),filter:IL("filter",t,e,n),strides:[s[1],s[2]],pad:r,dataFormat:i,dilations:[a[1],a[2]],bias:o,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:r,dataFormat:i,dilations:a,biasArg:o,preluArg:l,activationFunc:u,leakyreluAlpha:c}=kM(t,e,n);return[cI({x:IL("x",t,e,n),filter:IL("filter",t,e,n),strides:[s[1],s[2]],pad:r,dataFormat:i,dilations:[a[1],a[2]],bias:o,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=IL("outputShape",t,e,n),r=IL("strides",t,e,n),i=$L(t,e,n);return[vC(IL("x",t,e,n),IL("filter",t,e,n),s,[r[1],r[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=IL("strides",t,e,n),r=$L(t,e,n),i=IL("dilations",t,e,n),a=IL("dataFormat",t,e,n).toUpperCase();return[kC(IL("input",t,e,n),IL("filter",t,e,n),[s[1],s[2]],r,a,[i[1],i[2]])]}case"Conv3D":{const s=IL("strides",t,e,n),r=IL("pad",t,e,n),i=IL("dataFormat",t,e,n).toUpperCase(),a=IL("dilations",t,e,n);return[wC(IL("x",t,e,n),IL("filter",t,e,n),[s[1],s[2],s[3]],r,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=IL("strides",t,e,n),r=IL("pad",t,e,n),i=IL("kernelSize",t,e,n);return[rC(IL("x",t,e,n),[i[1],i[2]],[s[1],s[2]],r)]}case"MaxPool":{const s=IL("strides",t,e,n),r=IL("pad",t,e,n),i=IL("kernelSize",t,e,n);return[KC(IL("x",t,e,n),[i[1],i[2]],[s[1],s[2]],r)]}case"MaxPoolWithArgmax":{const s=IL("strides",t,e,n),r=IL("pad",t,e,n),i=IL("kernelSize",t,e,n),a=IL("includeBatchInIndex",t,e,n),{result:o,indexes:l}=xM(IL("x",t,e,n),[i[1],i[2]],[s[1],s[2]],r,a);return[o,l]}case"AvgPool3D":{const s=IL("strides",t,e,n),r=IL("pad",t,e,n),i=IL("kernelSize",t,e,n);return[iC(IL("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],r)]}case"MaxPool3D":{const s=IL("strides",t,e,n),r=IL("pad",t,e,n),i=IL("kernelSize",t,e,n);return[XC(IL("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],r)]}case"Dilation2D":{const s=IL("strides",t,e,n),r=IL("pad",t,e,n),i=IL("dilations",t,e,n),a=s[1],o=s[2],l=i[1],u=i[2];return[IA(IL("x",t,e,n),IL("filter",t,e,n),[a,o],r,[l,u],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"creation":return Rk(()=>((t,e,n)=>{switch(t.op){case"Fill":{const s=IL("shape",t,e,n),r=IL("dtype",t,e,n);return[FC(s,IL("value",t,e,n),r)]}case"LinSpace":return[CM(IL("start",t,e,n),IL("stop",t,e,n),IL("num",t,e,n))];case"Multinomial":{const s=IL("logits",t,e,n),r=IL("numSamples",t,e,n),i=IL("seed",t,e,n);return[SM(s,r,i)]}case"OneHot":{const s=IL("indices",t,e,n),r=IL("depth",t,e,n),i=IL("onValue",t,e,n),a=IL("offValue",t,e,n);return[hS(s,r,i,a)]}case"Ones":return[pS(IL("shape",t,e,n),IL("dtype",t,e,n))];case"OnesLike":return[fS(IL("x",t,e,n))];case"RandomUniform":return[_S(IL("shape",t,e,n),IL("minval",t,e,n),IL("maxval",t,e,n),IL("dtype",t,e,n))];case"Range":return[VI(IL("start",t,e,n),IL("stop",t,e,n),IL("step",t,e,n),IL("dtype",t,e,n))];case"TruncatedNormal":{const s=IL("shape",t,e,n),r=IL("mean",t,e,n),i=IL("stdDev",t,e,n),a=IL("seed",t,e,n);return[BS(s,r,i,IL("dtype",t,e,n),a)]}case"Zeros":return[dS(IL("shape",t,e,n),IL("dtype",t,e,n))];case"ZerosLike":return[HS(IL("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"dynamic":return AM(t,e,n);case"evaluation":return Rk(()=>((t,e,n)=>{switch(t.op){case"TopKV2":{const s=IL("x",t,e,n),r=IL("k",t,e,n),i=IL("sorted",t,e,n),a=GA(s,r,i);return[a.values,a.indices]}case"Unique":{const s=IL("x",t,e,n),r=qA(s);return[r.values,r.indices]}case"UniqueV2":{const s=IL("x",t,e,n),r=IL("axis",t,e,n),i=qA(s,r);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"image":return Rk(()=>((t,e,n)=>{switch(t.op){case"ResizeBilinear":{const s=IL("images",t,e,n),r=IL("size",t,e,n),i=IL("alignCorners",t,e,n),a=IL("halfPixelCenters",t,e,n);return[uE.resizeBilinear(s,[r[0],r[1]],i,a)]}case"ResizeNearestNeighbor":{const s=IL("images",t,e,n),r=IL("size",t,e,n),i=IL("alignCorners",t,e,n),a=IL("halfPixelCenters",t,e,n);return[uE.resizeNearestNeighbor(s,[r[0],r[1]],i,a)]}case"CropAndResize":{const s=IL("image",t,e,n),r=IL("boxes",t,e,n),i=IL("boxInd",t,e,n),a=IL("cropSize",t,e,n),o=IL("method",t,e,n),l=IL("extrapolationValue",t,e,n);return[uE.cropAndResize(s,r,i,a,o,l)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"graph":return Rk(()=>((t,e,n)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=IL("default",t,e,n);return[EL(t.name,e,n)||s];case"Placeholder":return[EL(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[RL(IL("x",t,e,n))];case"IdentityN":return IL("x",t,e,n).map(t=>RL(t));case"Snapshot":return[RL(IL("x",t,e,n))];case"Shape":return[zS(IL("x",t,e,n).shape,"int32")];case"ShapeN":return IL("x",t,e,n).map(t=>zS(t.shape));case"Size":return[Mk(IL("x",t,e,n).size,"int32")];case"Rank":return[Mk(IL("x",t,e,n).rank,"int32")];case"NoOp":return[Mk(1)];case"Print":const r=IL("x",t,e,n),i=IL("data",t,e,n),a=IL("message",t,e,n),o=IL("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let t=0;t<i.length;t++)console.log(Array.prototype.slice.call(i[t].dataSync()).slice(0,o));return[r];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"logical":return Rk(()=>((t,e,n)=>{switch(t.op){case"Equal":return[AC(IL("a",t,e,n),IL("b",t,e,n))];case"NotEqual":return[cS(IL("a",t,e,n),IL("b",t,e,n))];case"Greater":return[MC(IL("a",t,e,n),IL("b",t,e,n))];case"GreaterEqual":return[PC(IL("a",t,e,n),IL("b",t,e,n))];case"Less":return[ST(IL("a",t,e,n),IL("b",t,e,n))];case"LessEqual":return[PI(IL("a",t,e,n),IL("b",t,e,n))];case"LogicalAnd":return[qC(IL("a",t,e,n),IL("b",t,e,n))];case"LogicalNot":return[tA(IL("a",t,e,n))];case"LogicalOr":return[LA(IL("a",t,e,n),IL("b",t,e,n))];case"Select":case"SelectV2":return[jS(IL("condition",t,e,n),IL("a",t,e,n),IL("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"matrices":return Rk(()=>((t,e,n)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[hI(IL("a",t,e,n),IL("b",t,e,n),IL("transposeA",t,e,n),IL("transposeB",t,e,n))];case"Einsum":return[OM(IL("equation",t,e,n),...IL("tensors",t,e,n))];case"Transpose":return[GS(IL("x",t,e,n),IL("perm",t,e,n))];case"_FusedMatMul":const[s,r]=IL("fusedOps",t,e,n),i="biasadd"===s,a="prelu"===r,o=IL("numArgs",t,e,n),l=IL("leakyreluAlpha",t,e,n);if(i){if(a&&2!==o)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==o)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,c]=IL("args",t,e,n);return[dI({a:IL("a",t,e,n),b:IL("b",t,e,n),transposeA:IL("transposeA",t,e,n),transposeB:IL("transposeB",t,e,n),bias:u,activation:r,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"normalization":return Rk(()=>((t,e,n)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[aC(IL("x",t,e,n),IL("mean",t,e,n),IL("variance",t,e,n),IL("offset",t,e,n),IL("scale",t,e,n),IL("epsilon",t,e,n))];case"LRN":return[FA(IL("x",t,e,n),IL("radius",t,e,n),IL("bias",t,e,n),IL("alpha",t,e,n),IL("beta",t,e,n))];case"Softmax":return[RS(IL("x",t,e,n))];case"LogSoftmax":return[GC(IL("x",t,e,n))];case"SparseToDense":return[FM(IL("sparseIndices",t,e,n),IL("outputShape",t,e,n),IL("sparseValues",t,e,n),IL("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"reduction":return Rk(()=>((t,e,n)=>{switch(t.op){case"Max":{const s=IL("axis",t,e,n),r=IL("keepDims",t,e,n);return[WC(IL("x",t,e,n),s,r)]}case"Mean":{const s=IL("axis",t,e,n),r=IL("keepDims",t,e,n);return[YC(IL("x",t,e,n),s,r)]}case"Min":{const s=IL("axis",t,e,n),r=IL("keepDims",t,e,n);return[jI(IL("x",t,e,n),s,r)]}case"Sum":{const s=IL("axis",t,e,n),r=IL("keepDims",t,e,n);return[HC(IL("x",t,e,n),s,r)]}case"All":{const s=IL("axis",t,e,n),r=IL("keepDims",t,e,n);return[Bk(IL("x",t,e,n),s,r)]}case"Any":{const s=IL("axis",t,e,n),r=IL("keepDims",t,e,n);return[Wk(IL("x",t,e,n),s,r)]}case"ArgMax":{const s=IL("axis",t,e,n);return[Uk(IL("x",t,e,n),s)]}case"ArgMin":{const s=IL("axis",t,e,n);return[bA(IL("x",t,e,n),s)]}case"Prod":{const s=IL("axis",t,e,n),r=IL("keepDims",t,e,n);return[BA(IL("x",t,e,n),s,r)]}case"Cumsum":{const s=IL("axis",t,e,n),r=IL("exclusive",t,e,n),i=IL("reverse",t,e,n);return[XN(IL("x",t,e,n),s,r,i)]}case"Bincount":const s=IL("x",t,e,n),r=IL("weights",t,e,n),i=IL("size",t,e,n);return[MI(s,r,i)];case"DenseBincount":{const s=IL("x",t,e,n),r=IL("weights",t,e,n),i=IL("size",t,e,n),a=IL("binaryOutput",t,e,n);return[DM(s,r,i,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"slice_join":return Rk(()=>((t,e,n)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=IL("n",t,e,n),r=IL("axis",t,e,n);let i=IL("tensors",t,e,n);return i=i.slice(0,s),[hC(i,r)]}case"Gather":{const s=IL("x",t,e,n),r=IL("indices",t,e,n);return[LC(s,Zx(r,"int32"),0)]}case"GatherV2":{const s=IL("axis",t,e,n),r=IL("batchDims",t,e,n),i=IL("x",t,e,n),a=IL("indices",t,e,n);return[LC(i,Zx(a,"int32"),s,r)]}case"Reverse":{const s=IL("dims",t,e,n),r=[];for(let t=0;t<s.length;t++)s[t]&&r.push(t);const i=IL("x",t,e,n);return[kS(i,r)]}case"ReverseV2":{const s=IL("axis",t,e,n),r=IL("x",t,e,n);return[kS(r,s)]}case"Slice":{const s=IL("begin",t,e,n),r=IL("size",t,e,n);return[ES(IL("x",t,e,n),s,r)]}case"StridedSlice":{const s=IL("begin",t,e,n),r=IL("end",t,e,n),i=IL("strides",t,e,n),a=IL("beginMask",t,e,n),o=IL("endMask",t,e,n),l=IL("ellipsisMask",t,e,n),u=IL("newAxisMask",t,e,n),c=IL("shrinkAxisMask",t,e,n),h=IL("x",t,e,n);return[jA(h,s,r,i,a,o,l,u,c)]}case"Pack":return Rk(()=>{const s=IL("axis",t,e,n),r=IL("tensors",t,e,n),i=r[0].shape,a=LS(r[0]).shape,o=r.map(t=>{const e=my(t.shape,i);if(!e&&!my(LS(t).shape,a))throw new Error("the input tensors shape does not match");return e?t:sC(t,i)});return[MS(o,s)]});case"Unpack":{const s=IL("axis",t,e,n),r=IL("tensor",t,e,n);return WS(r,s)}case"Tile":{const s=IL("reps",t,e,n);return[RC(IL("x",t,e,n),s)]}case"Split":case"SplitV":{const s=IL("axis",t,e,n),r=IL("numOrSizeSplits",t,e,n),i=IL("x",t,e,n);return FS(i,r,s)}case"ScatterNd":{const s=IL("indices",t,e,n),r=IL("values",t,e,n),i=IL("shape",t,e,n);return[LM(s,r,i)]}case"GatherNd":{const s=IL("x",t,e,n),r=IL("indices",t,e,n);return[MM(s,r)]}case"SparseToDense":{const s=IL("sparseIndices",t,e,n),r=IL("outputShape",t,e,n),i=IL("sparseValues",t,e,n),a=IL("defaultValue",t,e,n);return[FM(s,i,r,i.dtype===a.dtype?a:Zx(a,i.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"sparse":return Rk(()=>((t,e,n)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:r,emptyRowIndicator:i,reverseIndexMap:a}=hE.sparseFillEmptyRows(IL("indices",t,e,n),IL("values",t,e,n),IL("denseShape",t,e,n),IL("defaultValue",t,e,n));return[s,r,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:r}=hE.sparseReshape(IL("inputIndices",t,e,n),IL("inputShape",t,e,n),IL("newShape",t,e,n));return[s,r]}case"SparseSegmentMean":return[hE.sparseSegmentMean(IL("data",t,e,n),IL("indices",t,e,n),IL("segmentIds",t,e,n))];case"SparseSegmentSum":return[hE.sparseSegmentSum(IL("data",t,e,n),IL("indices",t,e,n),IL("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"spectral":return Rk(()=>((t,e,n)=>{switch(t.op){case"FFT":return[ZS(IL("x",t,e,n))];case"IFFT":return[QS(IL("x",t,e,n))];case"RFFT":return[YS(IL("x",t,e,n))];case"IRFFT":return[JS(IL("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"string":return Rk(()=>((t,e,n)=>{switch(t.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:r}=dE.stringNGrams(IL("data",t,e,n),IL("dataSplits",t,e,n),IL("separator",t,e,n),IL("nGramWidths",t,e,n),IL("leftPad",t,e,n),IL("rightPad",t,e,n),IL("padWidth",t,e,n),IL("preserveShortSequences",t,e,n));return[s,r]}case"StringSplit":{const{indices:s,values:r,shape:i}=dE.stringSplit(IL("input",t,e,n),IL("delimiter",t,e,n),IL("skipEmpty",t,e,n));return[s,r,i]}case"StringToHashBucketFast":return[dE.stringToHashBucketFast(IL("input",t,e,n),IL("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"transformation":return Rk(()=>((t,e,n)=>{switch(t.op){case"Cast":return[Zx(IL("x",t,e,n),IL("dtype",t,e,n))];case"ExpandDims":{const s=IL("axis",t,e,n);return[$C(IL("x",t,e,n),s)]}case"Squeeze":{const s=IL("axis",t,e,n);return[LS(IL("x",t,e,n),s)]}case"Reshape":return[sC(IL("x",t,e,n),IL("shape",t,e,n))];case"MirrorPad":return[PA(IL("x",t,e,n),IL("padding",t,e,n),IL("mode",t,e,n))];case"PadV2":case"Pad":return[mS(IL("x",t,e,n),IL("padding",t,e,n),IL("constantValue",t,e,n))];case"SpaceToBatchND":{const s=IL("blockShape",t,e,n),r=IL("paddings",t,e,n);return[ON(IL("x",t,e,n),s,r)]}case"BatchToSpaceND":{const s=IL("blockShape",t,e,n),r=IL("crops",t,e,n);return[dA(IL("x",t,e,n),s,r)]}case"DepthToSpace":{const s=IL("blockSize",t,e,n),r=IL("dataFormat",t,e,n).toUpperCase();return[SA(IL("x",t,e,n),s,r)]}case"BroadcastTo":return[US(IL("x",t,e,n),IL("shape",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"hash_table":return RM(t,e,n,s);case"custom":const r=SL(t.op);if(r&&r.customExecutor)return r.customExecutor(new pM(t,e,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Wy(r)?r.then(t=>[].concat(t)):[].concat(r)}class zM{constructor(t={},e={},n={},s={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function VM(t,e,n,s){const r=new Set,i=[];let a=null,o=null;const l=new Set,u=Object.keys(t).map(t=>AL(t)[0]);let c=[];null!=s&&(c=s.map(t=>AL(t.name)[0]));const h=[...e];for(;h.length>0;){const t=h.pop();(jM(t)||HM(t)||GM(t))&&null==a&&(a=t,o=a.children.map(t=>t.name).filter(t=>r.has(t))),r.add(t.name),null==n[t.name]&&-1===u.indexOf(t.name)&&-1===c.indexOf(t.name)&&(0!==t.inputs.length?t.inputs.forEach(t=>{l.has(t.name)||(l.add(t.name),h.push(t))}):i.push(t.name))}return{inputs:t,outputs:e,usedNodes:r,missingInputs:i,dynamicNode:a,syncInputs:o}}const BM=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],WM=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],UM=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function jM(t){return BM.indexOf(t.op)>=0}function HM(t){return WM.indexOf(t.op)>=0}function GM(t){return UM.indexOf(t.op)>=0}class qM{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(e=>{this._functionExecutorMap[e]=new qM(t.functions[e],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(e=>t[e].map(t=>t.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){const n=t.map(t=>t.name).sort(),s=e.map(t=>t.name).sort();return n.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(t,e){const n=VM(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:r,syncInputs:i}=n;if(null!=r)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const n=e.map(t=>t.name),r=Object.keys(t);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${r}]. Missing the following inputs: [${s}]`)}return function(t,e,n){const{usedNodes:s,inputs:r}=n,i=[],a=Object.keys(r).map(t=>AL(t)[0]).map(e=>t.nodes[e]),o=t.initNodes;a.forEach(t=>{s.has(t.name)&&i.push(t)}),t.weights.forEach(t=>{s.has(t.name)&&i.push(t)}),null!=o&&o.forEach(t=>{s.has(t.name)&&i.push(t)});const l=new Set,u=[];for(;i.length>0;){const t=i.pop();l.add(t.name),e[t.name]||u.push(t),t.children.forEach(t=>{!l.has(t.name)&&s.has(t.name)&&t.inputs.every(t=>l.has(t.name))&&i.push(t)})}return u}(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const s=n.map(t=>this.graph.nodes[AL(t)[0]]),r=e.map(t=>AL(t)[0]);let i=r.map(t=>this.graph.nodes[t]);0===i.length&&(i=this._outputs);const a=this.getCompilationKey(s,i);let o=this.compiledMap.get(a);null==o&&(o=this.compile(t,i),this.compiledMap.set(a,o));const l={},u={};return Rk(()=>{const n=new zM(this.weightMap,l,u,this.functionExecutorMap),s=Object.assign({},this.weightMap);Object.keys(t).forEach(e=>{const[n,r]=AL(e),i=[];i[r]=t[e],s[n]=i});const i=this.getFrozenTensorIds(s),a={};for(let t=0;t<o.length;t++){const e=o[t];if(!s[e.name]){const t=PM(e,s,n,this._resourceManager);if(Wy(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);s[e.name]=t,this.checkTensorForDisposal(e.name,e,s,n,i,r,a)}}return null==this.parent&&n.dispose(i),e.map(t=>EL(t,s,n))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(e=>t[e]).map(t=>t.map(t=>t.id)));return new Set(e)}checkTensorForDisposal(t,e,n,s,r,i,a){"control"!==e.category&&-1===i.indexOf(t)&&(n[t].forEach(t=>{null!=t&&(a[t.id]=(a[t.id]||0)+e.children.length)}),e.inputs.forEach(t=>{if("control"!==t.category){const e=function(t,e,n){return e[TL(t,n.currentContextId)]}(t.name,n,s);null!=e&&e.forEach(t=>{if(t&&!t.kept&&!r.has(t.id)){const e=a[t.id];1===e?(t.dispose(),delete a[t.id]):null!=e&&a[t.id]--}})}}))}executeAsync(t,e){var n=this;return ny(function*(){return n._executeAsync(t,e)})()}_executeAsync(t,e,n=!1,s={},r={}){var i=this;return ny(function*(){n||(t=i.mapInputs(t),i.checkInputs(t),i.checkInputShapeAndType(t),e=i.mapOutputs(e),i.checkOutputs(e));const a=new zM(i.weightMap,s,r,i.functionExecutorMap),o=yield i.executeWithControlFlow(t,a,e,n),l=e.map(t=>EL(t,o,a)),u=l.map(t=>t.id),c=Object.keys(t).map(e=>t[e].id),h=new Set([...u,...c,...i.weightIds]);return Object.keys(o).forEach(t=>{o[t].forEach(t=>{!t||t.kept||t.isDisposed||h.has(t.id)||t.dispose()})}),null==i.parent&&a.dispose(h),l})()}executeFunctionAsync(t,e,n){var s=this;return ny(function*(){const r=t.reduce((t,e,n)=>(t[s.inputs[n].name]=e,t),{});return s._executeAsync(r,s.outputNodes,!0,e,n)})()}executeWithControlFlow(t,e,n,s){var r=this;return ny(function*(){const i=Object.keys(t),a=i.map(t=>r.graph.nodes[AL(t)[0]]),o=n.map(t=>AL(t)[0]);let l=o.map(t=>r.graph.nodes[t]);0===l.length&&(l=r._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:h,syncInputs:d}=VM(t,l,r.weightMap,r._initNodes),p=[...a,...r.graph.weights,...r._initNodes||[]].map(t=>({node:t,contexts:e.currentContext})),f=Object.assign({},r.weightMap);Object.keys(t).forEach(e=>{const[n,s]=AL(e),r=[];r[s]=t[e],f[n]=r});const m={},g=r.getFrozenTensorIds(f),y={};for(;p.length>0;){const t=r.processStack(a,p,e,f,y,g,o,m,u);yield Promise.all(t)}null!=h||s||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter(t=>!jM(t)&&!EL(t.name,f,e)).map(t=>t.name);if(b.length>0){let t="";throw null!=h&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${i}]. Consider providing the following inputs: [${c}]. ${t}`)}return f})()}processStack(t,e,n,s,r,i,a,o,l){const u=[];for(;e.length>0;){const t=e.pop();n.currentContext=t.contexts;let c="";if("Enter"===t.node.op&&IL("isConstant",t.node,s,n)&&([c]=NL(t.node.name,n)),null==s[t.node.name]){const h=PM(t.node,s,n,this._resourceManager);c||([c]=NL(t.node.name,n));const d=n.currentContext;Wy(h)?u.push(h.then(u=>(s[c]=u,n.currentContext=d,this.checkTensorForDisposal(c,t.node,s,n,i,a,o),this.processChildNodes(t.node,e,n,s,r,l),u))):(s[c]=h,this.checkTensorForDisposal(c,t.node,s,n,i,a,o),this.processChildNodes(t.node,e,n,s,r,l))}else this.processChildNodes(t.node,e,n,s,r,l)}return u}processChildNodes(t,e,n,s,r,i){t.children.forEach(t=>{const[a]=NL(t.name,n);!r[a]&&i.has(t.name)&&("Merge"===t.op?t.inputNames.some(t=>!!EL(t,s,n))&&(r[a]=!0,e.push({contexts:n.currentContext,node:t})):t.inputNames.every(t=>!!EL(t,s,n))&&(r[a]=!0,e.push({contexts:n.currentContext,node:t})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(t=>t.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const n=t[e],[s]=AL(e),r=this.graph.nodes[s];if(r.attrParams.shape&&r.attrParams.shape.value){const t=r.attrParams.shape.value;cy(t.length===n.shape.length&&n.shape.every((e,n)=>-1===t[n]||t[n]===e),()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&cy(n.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){const e={};for(const n in t)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?e[this._signature.inputs[n].name]=t[n]:e[n]=t[n];return e}checkInputs(t){const e=Object.keys(t).filter(t=>{const[e]=AL(t);return null==this.graph.nodes[e]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(t=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[t]?this._signature.outputs[t].name:t,{})}checkOutputs(t){t.forEach(t=>{const[e]=AL(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)})}}class KM{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class XM{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={}),this.resourceManager=new KM}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=ok(t,this.loadOptions);else{const e=Cx.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(ok(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){var t=this;return ny(function*(){if(t.findIOHandler(),null==t.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=yield t.handler.load();return t.loadSync(e)})()}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const s=function(t,e){const n={};let s,r=0;for(const i of e){const e=i.name,a=i.dtype,o=i.shape,l=fy(o);let u;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${a}.`)}const o=mx[n.dtype],c=t.slice(r,r+l*o),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===a)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(h.length);for(let t=0;t<h.length;t++)u[t]=h[t]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===s&&(s=kx()),u=s(h)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let t=0;t<h.length;t++)u[t]=Math.round(h[t]*n.scale+n.min)}r+=l*o}else if("string"===a){const e=fy(i.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(r,r+4))[0];r+=4;const n=new Uint8Array(t.slice(r,r+e));u.push(n),r+=e}}else{const s=mx[a],i=t.slice(r,r+l*s);if("float32"===a)u=new Float32Array(i);else if("int32"===a)u=new Int32Array(i);else if("bool"===a)u=new Uint8Array(i);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);{u=new Float32Array(i);const t=new Float32Array(u.length/2),s=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],s[e]=u[2*e+1];const r=fx(t,o,"float32"),a=fx(s,o,"float32");n[e]=dx(r,a),r.dispose(),a.dispose()}}r+=l*s}"complex64"!==a&&(n[e]=fx(u,o,a))}return n}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new qM(QL.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const e=QL.Instance.transformGraph(t.modelInitializer);this.initializer=new qM(e),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(t,e){var n=this;return ny(function*(){if("string"==typeof t){const e=Sx(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(n.artifacts)})()}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof L_||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,n,s)=>(e[n]=t[s],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=this.executor.execute(t,e);return n.length>1?n:n[0]}executeAsync(t,e){var n=this;return ny(function*(){t=n.normalizeInputs(t),e=n.normalizeOutputs(e);const s=yield n.executor.executeAsync(t,e);return s.length>1?s:s[0]})()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function ZM(t){return YM.apply(this,arguments)}function YM(){return(YM=ny(function*(t,e={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t=`${t}model.json?tfjs-format=file`);const n=new XM(t,e);return yield n.load(),n})).apply(this,arguments)}function QM(t,e,n=new Map,s=new Set){if(null==t)return null;if(s.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(nP(t)){const r=Array.isArray(t)?[]:{};s.add(t);for(const i in t){const a=QM(t[i],e,n,s);r[i]=a}return s.delete(t),r}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,r.value),r.value}function JM(t,e=eP){return tP(t,e)}function tP(t,e,n=new Set){const s=t[0];if(n.has(s))throw new Error("Circular references are not supported.");const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(nP(s)){const r=Array.isArray(s)?[]:{};n.add(s);for(const i in s){const s=tP(t.map(t=>t[i]),e,n);r[i]=s}return n.delete(s),r}throw new Error(`Can't recurse into non-iterable type: ${s}`)}return r.value}function eP(t){return null===t?null:nP(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function nP(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof L_))}function sP(t){return QM(t,rP)}function rP(t){return t instanceof L_?{value:t.clone(),recurse:!1}:nP(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class iP{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class aP extends iP{constructor(){super(aP.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let s=0;s<n;s++)e[s]=this.get(this.wrap(this.begin+s));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}aP.INITIAL_CAPACITY=32;class oP{toArray(){var t=this;return ny(function*(){const e=[];let n=yield t.next();for(;!n.done;)e.push(n.value),n=yield t.next();return e})()}toArrayForTest(){var t=this;return ny(function*(){const e=t.prefetch(100),n=[];let s=yield e.next();for(;!s.done;)n.push(s.value),s=yield e.next();return n})()}resolveFully(){var t=this;return ny(function*(){let e=yield t.next();for(;!e.done;)e=yield t.next()})()}resolveWhile(t){var e=this;return ny(function*(){let n=yield e.next(),s=t(n.value);for(;!n.done&&s;)n=yield e.next(),s=t(n.value)})()}handleErrors(t){return new gP(this,t)}filter(t){return new fP(this,t)}map(t){return new mP(this,t)}mapAsync(t){return new yP(this,t)}serialMapAsync(t){return new yP(this,t).serial()}flatmap(t){return new vP(this,t)}forEachAsync(t){var e=this;return ny(function*(){return e.map(t).resolveFully()})()}serialForEach(t){var e=this;return ny(function*(){return e.serialMapAsync(t).resolveWhile(t=>!0===t)})()}rowMajorBatch(t,e=!0){return new pP(this,t,e)}columnMajorBatch(t,e=!0,n=eP){return this.rowMajorBatch(t,e).map(t=>JM(t,n))}concatenate(t,e){return new wP(new lP([this,t]),e)}take(t){return t<0||null==t?this:new dP(this,t)}skip(t){return t<0||null==t?this:new hP(this,t)}prefetch(t){return new kP(this,t)}shuffle(t,e){return new CP(this,t,e)}serial(){return new cP(this)}}class lP extends oP{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var t=this;return ny(function*(){if(t.trav>=t.items.length)return{value:null,done:!0};const e=t.items[t.trav];return t.trav++,{value:sP(e),done:!1}})()}}class uP extends oP{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}next(){var t=this;return ny(function*(){try{return t.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}})()}}class cP extends oP{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var t=this;return ny(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return ny(function*(){return t.upstream.next()})()}}class hP extends oP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var t=this;return ny(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return ny(function*(){for(;t.count++<t.maxCount;){const e=yield t.upstream.next();if(e.done)return e;Ok(e.value)}return t.upstream.next()})()}}class dP extends oP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var t=this;return ny(function*(){return t.count++>=t.maxCount?{value:null,done:!0}:t.upstream.next()})()}}class pP extends oP{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var t=this;return ny(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return ny(function*(){const e=[];for(;e.length<t.batchSize;){const n=yield t.upstream.next();if(n.done)return t.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(n.value)}return{value:e,done:!1}})()}}class fP extends oP{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var t=this;return ny(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return ny(function*(){for(;;){const e=yield t.upstream.next();if(e.done||t.predicate(e.value))return e;Ok(e.value)}})()}}class mP extends oP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}next(){var t=this;return ny(function*(){const e=yield t.upstream.next();if(e.done)return{value:null,done:!0};const n=X_(e.value),s=t.transform(e.value),r=X_(s);for(const t of n)K_(t,r)||t.dispose();return{value:s,done:!1}})()}}class gP extends oP{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var t=this;return ny(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return ny(function*(){for(;;)try{return yield t.upstream.next()}catch(e){if(!t.handler(e))return{value:null,done:!0}}})()}}class yP extends oP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var t=this;return ny(function*(){const e=yield t.upstream.next();if(e.done)return{value:null,done:!0};const n=X_(e.value),s=yield t.transform(e.value),r=X_(s);for(const t of n)K_(t,r)||t.dispose();return{value:s,done:!1}})()}}class bP extends oP{constructor(){super(),this.outputQueue=new aP,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var t=this;return ny(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return ny(function*(){for(;0===t.outputQueue.length();)if(!(yield t.pump()))return{value:null,done:!0};return{value:t.outputQueue.shift(),done:!1}})()}}class vP extends bP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var t=this;return ny(function*(){const e=yield t.upstream.next();if(e.done)return!1;const n=X_(e.value),s=t.transform(e.value),r=X_(s);t.outputQueue.pushAll(s);for(const t of n)K_(t,r)||t.dispose();return!0})()}}class wP extends oP{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var t=this;return ny(function*(){return t.lastRead=t.readFromChain(t.lastRead),t.lastRead})()}readFromChain(t){var e=this;return ny(function*(){if(yield t,null==e.iterator){const t=yield e.moreIterators.next();if(t.done)return{value:null,done:!0};e.iterator=t.value,null!=e.baseErrorHandler&&(e.iterator=e.iterator.handleErrors(e.baseErrorHandler))}const n=yield e.iterator.next();return n.done?(e.iterator=null,e.readFromChain(t)):n})()}}var _P,xP;(xP=_P||(_P={}))[xP.FAIL=0]="FAIL",xP[xP.SHORTEST=1]="SHORTEST",xP[xP.LONGEST=2]="LONGEST";class kP extends oP{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new iP(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class CP extends kP{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=yS.alea(n||__().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var t=this;return ny(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var t=this;return ny(function*(){for(t.upstreamExhausted||t.refill();!t.buffer.isEmpty();){const e=t.chooseIndex(),n=yield t.buffer.shuffleExcise(e);if(!n.done)return t.refill(),n;t.upstreamExhausted=!0}return{value:null,done:!0}})()}}class SP{constructor(){this.size=null}batch(t,e=!0){const n=this;let s;return cy(t>0,()=>`batchSize needs to be positive, but it is\n      ${t}`),s=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),IP(ny(function*(){return(yield n.iterator()).columnMajorBatch(t,e,EP)}),s)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,IP(ny(function*(){return(yield e.iterator()).concatenate(yield t.iterator())}),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,IP(ny(function*(){return(yield e.iterator()).filter(e=>Rk(()=>t(e)))}),n)}forEachAsync(t){var e=this;return ny(function*(){return(yield e.iterator()).forEachAsync(t)})()}map(t){const e=this;return IP(ny(function*(){return(yield e.iterator()).map(e=>Rk(()=>t(e)))}),this.size)}mapAsync(t){const e=this;return IP(ny(function*(){return(yield e.iterator()).mapAsync(t)}),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return IP(ny(function*(){return(yield e.iterator()).prefetch(t)}),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,IP(ny(function*(){return n=(s=ny(function*(){return{value:yield e.iterator(),done:!1}}),new uP(s)).take(t),new wP(n,undefined);var n,s}),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,IP(ny(function*(){return(yield e.iterator()).skip(t)}),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,r=yS.alea(e||__().toString());return IP(ny(function*(){let e=r.int32();return n&&(e+=r.int32()),(yield s.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,IP(ny(function*(){return(yield e.iterator()).take(t)}),n)}toArray(){var t=this;return ny(function*(){if(t.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield t.iterator()).toArray()})()}toArrayForTest(){var t=this;return ny(function*(){if(t.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield t.iterator()).toArrayForTest()})()}}function IP(t,e=null){return new class extends SP{constructor(){super(...arguments),this.size=e}iterator(){return ny(function*(){return t()})()}}}function EP(t){return null===t?null:null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof L_||Iy(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof L_?MS(t):fx(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function NP(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&cy("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the CPU backend.`)})}SP.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const TP=mN;class AP extends iy{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ry(this,Ak())}nextDataId(){return AP.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,Hy().get("IS_NODE")&&GE("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:n,refCount:1}),s}makeTensorInfo(t,e,n){let s;if("string"===e&&null!=n&&n.length>0&&Ny(n[0])){const r=n.map(t=>x_(t));s=this.write(r,t,e)}else s=this.write(n,t,e);return{dataId:s,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,e,n,s,r){this.data.set(t,{values:e,dtype:s,refCount:r})}numDataIds(){return this.data.numDataIds()}read(t){var e=this;return ny(function*(){return e.readSync(t)})()}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);return"complex64"===e?KE(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>k_(t))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return Xx(t.shape,t.dtype,n)}makeOutput(t,e,n){const s=this.write(t,e,n);return Ak().makeTensorFromDataId(s,e,n,this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}time(t){return ny(function*(){const e=__();return t(),{kernelMs:__()-e}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){NP([t],"where");const e=this.readSync(t.dataId);return TP(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function $P(t,e,n){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;if(NP(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=i,l=o.data.get(a.dataId).values,u=fy(a.shape),c=n||a.dtype,h=Cy(c,u);for(let t=0;t<u;++t)h[t]=e(l[t],r);return o.makeTensorInfo(a.shape,c,h)}}function RP(t,e,n){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;if(NP(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=i,l=o.data.get(a.dataId).values,u=n||a.dtype,c=e(l,u,r);return o.makeTensorInfo(a.shape,u,c)}}AP.nextDataId=0,Dk("cpu",()=>new AP,1);const OP=$P(jb,t=>t>=0?t:Math.exp(t)-1),FP={kernelName:jb,backendName:"cpu",kernelFunc:OP};function DP(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const LP={kernelName:ov,backendName:"cpu",kernelFunc:DP};function MP(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:i}=s;NP([r],"leakyRelu");const a=fy(r.shape),o=n.data.get(r.dataId).values,l=ky("float32",a);for(let u=0;u<o.length;u++)l[u]=o[u]<0?i*o[u]:o[u];return n.makeTensorInfo(r.shape,"float32",l)}const PP={kernelName:pv,backendName:"cpu",kernelFunc:MP};function zP(t){return(e,n,s,r,i)=>{const a=TC(e,n),o=a.length,l=Oy(a),u=ky(i,fy(a)),c=e.length,h=n.length,d=Oy(e),p=Oy(n),f=EC(e,a),m=EC(n,a);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=t(s[g%s.length],r[g%r.length]);else for(let g=0;g<u.length;++g){const e=By(g,o,l),n=e.slice(-c);f.forEach(t=>n[t]=0);const i=Vy(n,c,d),a=e.slice(-h);m.forEach(t=>a[t]=0);const y=Vy(a,h,p);u[g]=t(s[i],r[y])}return[u,a]}}const VP=zP((t,e)=>t<0?e*t:t);function BP(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;NP([s,r],"prelu");const i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,[o,l]=VP(s.shape,r.shape,i,a,s.dtype);return n.makeTensorInfo(l,s.dtype,o)}const WP={kernelName:Kv,backendName:"cpu",kernelFunc:BP},UP=$P(Jv,t=>Math.max(0,t)),jP={kernelName:Jv,backendName:"cpu",kernelFunc:UP},HP=$P(iw,t=>Math.min(Math.max(0,t),6)),GP={kernelName:iw,backendName:"cpu",kernelFunc:HP},qP=$P(gw,t=>1/(1+Math.exp(-t))),KP={kernelName:gw,backendName:"cpu",kernelFunc:qP};function XP(t,e,n,s,r){if("linear"===n)return DP({inputs:{x:e},backend:t});if("relu"===n)return UP({inputs:{x:e},backend:t});if("elu"===n)return OP({inputs:{x:e},backend:t});if("relu6"===n)return HP({inputs:{x:e},backend:t});if("prelu"===n)return BP({inputs:{x:e,alpha:s},backend:t});if("leakyrelu"===n)return MP({inputs:{x:e},backend:t,attrs:{alpha:r}});if("sigmoid"===n)return qP({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function ZP(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,o=n.makeTensorInfo(s.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",i),imag:n.makeTensorInfo(r.shape,"float32",a)},o}const YP={kernelName:wb,backendName:"cpu",kernelFunc:ZP};function QP(t,e,n="float32"){if("complex64"===n)return ZP({inputs:{real:QP(t,e,"float32"),imag:QP(t,e,"float32")},backend:t});const s=My(fy(e),n);return t.makeTensorInfo(e,n,s)}function JP(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const tz={kernelName:Yv,backendName:"cpu",kernelFunc:JP};function ez(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return DP({inputs:{x:r},backend:n});const t=QP(n,r.shape,r.dtype),e=ez({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),s=ZP({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),s}if("complex64"===r.dtype){const t=JP({inputs:{input:r},backend:n}),e=ez({inputs:{x:t},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(t),e}if(!Sy(r.dtype,i)){const t=DP({inputs:{x:r},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:i}}if("int32"===i){const t=n.data.get(r.dataId).values,e=Int32Array.from(t);return n.makeTensorInfo(r.shape,"int32",e)}if("bool"===i){const t=n.data.get(r.dataId).values,e=w_([0],r.dtype),[s,i]=zP((t,e)=>t!==e?1:0)(r.shape,[],t,e,"bool");return n.makeTensorInfo(i,"bool",s)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const nz={kernelName:yb,backendName:"cpu",kernelFunc:ez};function sz(t,e,n,s){return null==n?({inputs:n,backend:r})=>{const{a:i,b:a}=n,o=r;NP([i,a],t);const l=o.data.get(i.dataId).values,u=o.data.get(a.dataId).values,c="string"===i.dtype?pN(l):l,h="string"===i.dtype?pN(u):u,d=s||i.dtype,[p,f]=e(i.shape,a.shape,c,h,d);return o.makeTensorInfo(f,d,p)}:({inputs:t,backend:r})=>{const{a:i,b:a}=t,o=r;if("complex64"===i.dtype||"complex64"===a.dtype){const t=ez({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),e=o.data.get(t.dataId),s=e.complexTensorInfos.imag,r=o.data.get(e.complexTensorInfos.real.dataId).values,l=o.data.get(s.dataId).values,u=ez({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),c=o.data.get(u.dataId),h=c.complexTensorInfos.imag,d=o.data.get(c.complexTensorInfos.real.dataId).values,p=o.data.get(h.dataId).values,[f,m,g]=n(i.shape,a.shape,r,l,d,p),y=o.makeTensorInfo(g,"float32",f),b=o.makeTensorInfo(g,"float32",m),v=ZP({inputs:{real:y,imag:b},backend:o});return o.disposeIntermediateTensorInfo(t),o.disposeIntermediateTensorInfo(u),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(b),v}{const t=o.data.get(i.dataId).values,n=o.data.get(a.dataId).values,r=s||i.dtype,[l,u]=e(i.shape,a.shape,t,n,r);return o.makeTensorInfo(u,r,l)}}}function rz(t){return(e,n,s,r,i,a)=>{const o=TC(e,n),l=fy(o),u=o.length,c=Oy(o),h=ky("float32",l),d=ky("float32",l),p=EC(e,o),f=EC(n,o),m=KE(s,r),g=KE(i,a),y=e.length,b=Oy(e),v=n.length,w=Oy(n);if(p.length+f.length===0)for(let _=0;_<h.length;_++){const e=_%m.length,n=_%g.length,s=t(m[2*e],m[2*e+1],g[2*n],g[2*n+1]);h[_]=s.real,d[_]=s.imag}else for(let _=0;_<h.length;_++){const e=By(_,u,c),n=e.slice(-y);p.forEach(t=>n[t]=0);const s=Vy(n,y,b),r=e.slice(-v);f.forEach(t=>r[t]=0);const i=Vy(r,v,w),a=t(m[2*s],m[2*s+1],g[2*i],g[2*i+1]);h[_]=a.real,d[_]=a.imag}return[h,d,o]}}const iz=zP((t,e)=>t+e),az=rz((t,e,n,s)=>({real:t+n,imag:e+s})),oz=sz(Jy,iz,az),lz={kernelName:Jy,backendName:"cpu",kernelFunc:oz};function uz(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:i}=s,a=fy(r.shape),o=wy(i,a),l=fy(o);cy(a===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(null!=u.complexTensorInfos){const t=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=o,t.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const cz={kernelName:tw,backendName:"cpu",kernelFunc:uz};function hz(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;NP([r,i],"matMul");const l=r.shape.length,u=i.shape.length,c=a?r.shape[l-2]:r.shape[l-1],h=o?i.shape[u-1]:i.shape[u-2],d=a?r.shape[l-1]:r.shape[l-2],p=o?i.shape[u-2]:i.shape[u-1],f=r.shape.slice(0,-2),m=i.shape.slice(0,-2),g=fy(f),y=fy(m);cy(l>=2&&u>=2&&(g===y||1===g||1===y),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`);const b=(g>y?r.shape.slice(0,-2):i.shape.slice(0,-2)).concat([d,p]);cy(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`);const v=o?[y,p,h]:[y,h,p],w=uz({inputs:{x:r},backend:n,attrs:{shape:a?[g,c,d]:[g,d,c]}}),_=uz({inputs:{x:i},backend:n,attrs:{shape:v}}),x=a?w.shape[1]:w.shape[2],k=a?w.shape[2]:w.shape[1],C=o?_.shape[1]:_.shape[2],S=Math.max(g,y),I=n.data.get(w.dataId).values,E=n.data.get(_.dataId).values,N=Oy(w.shape),T=Oy(_.shape),[A,$,R]=a?[N[0],1,N[1]]:[N[0],N[1],1],[O,F,D]=o?[1,T[1],T[0]]:[T[1],1,T[0]],L=k*C,M=Xx([S,k,C],w.dtype),P=M.values,z=n.blockSize;for(let V=0;V<S;V++)for(let t=0;t<k;t+=z)for(let e=0;e<C;e+=z)for(let n=0;n<x;n+=z){const s=Math.min(t+z,k),r=Math.min(e+z,C),i=Math.min(n+z,x);for(let a=t;a<s;a++)for(let t=e;t<r;t++){let e=0;for(let s=n;s<i;s++){const n=Math.min(V,g-1)*A,r=Math.min(V,y-1)*D;e+=I[n+a*$+s*R]*E[s*O+t*F+r]}P[V*L+(a*C+t)]+=e}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(_),n.makeTensorInfo(b,M.dtype,M.values)}const dz={kernelName:fb,backendName:"cpu",kernelFunc:hz},pz={kernelName:Kw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,p,f;const m=[];d=hz({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(p=oz({inputs:{a:d,b:a},backend:n}),m.push(d),d=p),c&&(f=XP(n,d,c,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function fz(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const mz={kernelName:Zy,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;NP(e,"abs");let s=new Float32Array(fy(e.shape));return s=fz(n.data.get(e.dataId).values),n.makeOutput(s,e.shape,"float32")}},gz=$P(Yy,t=>Math.acos(t)),yz={kernelName:Yy,backendName:"cpu",kernelFunc:gz},bz=$P(Qy,t=>Math.acosh(t)),vz={kernelName:Qy,backendName:"cpu",kernelFunc:bz},wz={kernelName:tb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,s=e;NP(e,"addN");const r=s.map(t=>n.data.get(t.dataId).values),i=Xx(s[0].shape,s[0].dtype),a=i.values;for(let o=0;o<s.length;o++){const t=r[o];for(let e=0;e<a.length;e++)a[e]+=t[e]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function _z(t,e,n,s,r){const i=e.length,a=fy(e),o=Oy(e),l=Oy(r),u=ky(n,fy(r));for(let c=0;c<a;++c){const e=By(c,i,o),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[s[t]];u[Vy(n,i,l)]=t[c]}return u}function xz(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:i}=n;NP(r,"transpose");const a=new Array(r.shape.length);for(let l=0;l<a.length;l++)a[l]=r.shape[i[l]];const o=_z(s.data.get(r.dataId).values,r.shape,r.dtype,i,a);return{dataId:s.write(o,a,r.dtype),shape:a,dtype:r.dtype}}const kz={kernelName:Vw,backendName:"cpu",kernelFunc:xz},Cz={kernelName:eb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s;NP(r,"all");const o=_y(i,r.shape);let l=o;const u=rS(l,r.shape.length);let c=r;null!=u&&(c=xz({inputs:{x:r},backend:n,attrs:{perm:u}}),l=aS(l.length,r.shape.length)),sS("all",l,c.shape.length);const[h,d]=eS(c.shape,l),p=fy(d),f=My(fy(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const t=y*p;let e=m[t];for(let n=0;n<p;++n){const s=m[t+n];e=e&&s}f[y]=e}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=uz({inputs:{x:g},backend:n,attrs:{shape:nS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},Sz={kernelName:nb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s;NP(r,"any");const o=_y(i,r.shape);let l=o;const u=rS(l,r.shape.length);let c=r;null!=u&&(c=xz({inputs:{x:r},backend:n,attrs:{perm:u}}),l=aS(l.length,r.shape.length)),sS("any",l,c.shape.length);const[h,d]=eS(c.shape,l),p=fy(d),f=My(fy(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const t=y*p;let e=m[t];for(let n=0;n<p;++n){const s=m[t+n];e=e||s}f[y]=e}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=uz({inputs:{x:g},backend:n,attrs:{shape:nS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},Iz={kernelName:sb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;NP(r,"argMax");let a=_y(i,r.shape);const o=rS(a,r.shape.length);let l=r;const u=[];null!=o&&(l=xz({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),a=aS(a.length,l.shape.length)),a=[a[0]],sS("argMax",a,l.shape.length);const[c,h]=eS(l.shape,a),d=My(fy(c),"int32"),p=fy(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const t=m*p;let e=f[t],n=0;for(let s=0;s<p;++s){const r=f[t+s];r>e&&(e=r,n=s)}d[m]=n}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(c,"int32",d)}},Ez={kernelName:rb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;NP(r,"argMin");let a=_y(i,r.shape);const o=rS(a,r.shape.length);let l=r;const u=[];null!=o&&(l=xz({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),a=aS(a.length,l.shape.length)),a=[a[0]],sS("argMin",a,l.shape.length);const[c,h]=eS(l.shape,a),d=My(fy(c),"int32"),p=fy(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const t=m*p;let e=f[t],n=0;for(let s=0;s<p;++s){const r=f[t+s];r<e&&(e=r,n=s)}d[m]=n}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(c,"int32",d)}},Nz=$P(ib,t=>Math.asin(t)),Tz={kernelName:ib,backendName:"cpu",kernelFunc:Nz},Az=$P(ab,t=>Math.asinh(t)),$z={kernelName:ab,backendName:"cpu",kernelFunc:Az},Rz=$P(ob,t=>Math.atan(t)),Oz={kernelName:ob,backendName:"cpu",kernelFunc:Rz},Fz=zP((t,e)=>Math.atan2(t,e)),Dz=sz(ub,Fz),Lz={kernelName:ub,backendName:"cpu",kernelFunc:Dz},Mz=$P(lb,t=>Math.atanh(t)),Pz={kernelName:lb,backendName:"cpu",kernelFunc:Mz};function zz(t,e,n,s,r,i){const a=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Xx(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let w=0;w<r.batchSize;++w){const e=w*y,n=w*s[0];for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outHeight;++y){const w=y*a-d,_=Math.max(0,w),x=Math.min(r.inHeight,c+w),k=e+y*b;for(let e=0;e<r.outWidth;++e){const a=e*o-p,c=Math.max(0,a),d=Math.min(r.inWidth,h+a);let y=f,b=0,w=0;for(let e=_;e<x;e+=l){const r=n+e*s[1];for(let e=c;e<d;e+=u){const n=t[r+e*s[2]+m];"max"===i&&n>y?y=n:"avg"===i&&(b+=n,w++)}if(isNaN(y))break}g[k+e*v+m]="avg"===i?b/w:y}}}return m}function Vz(t,e,n,s,r=!1,i=!1){const a=Xx(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=Xx(e,n,t);for(let g=0;g<s.batchSize;++g)for(let t=0;t<s.inChannels;++t)for(let e=0;e<s.outHeight;++e){const n=e*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(s.inHeight,h+n);for(let o=0;o<s.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const v=Math.min(s.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,_=-1;for(let e=y;e<b;e+=u){const a=e-n;for(let n=p;n<v;n+=c){const o=n-h,l=m.get(g,e,n,t);l>w&&(w=l,_=r?i?((g*s.inHeight+e)*s.inWidth+n)*s.inChannels+t:(e*s.inWidth+n)*s.inChannels+t:a*d+o)}}a.set(_,g,e,o,t)}}return a}function Bz(t,e,n,s,r,i){const a=r.strideDepth,o=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Xx(r.outShape,n),w=v.values,_=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],x=r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[3]*r.outShape[4],C=r.outShape[4];for(let S=0;S<r.batchSize;++S){const e=S*_,n=S*s[0];for(let v=0;v<r.inChannels;++v)for(let _=0;_<r.outDepth;++_){const S=_*a-m;let I=S;for(;I<0;)I+=u;const E=Math.min(r.inDepth,d+S),N=e+_*x;for(let e=0;e<r.outHeight;++e){const a=e*o-g;let d=a;for(;d<0;)d+=c;const m=Math.min(r.inHeight,p+a),_=N+e*k;for(let e=0;e<r.outWidth;++e){const a=e*l-y;let o=a;for(;o<0;)o+=h;const p=Math.min(r.inWidth,f+a),g=_+e*C;let x=b,k=0,S=0;for(let e=I;e<E;e+=u){const r=n+e*s[1];for(let e=d;e<m;e+=c){const n=r+e*s[2];for(let e=o;e<p;e+=h){const r=t[n+e*s[3]+v];if("max"===i&&r>x?x=r:"avg"===i&&(k+=r,S++),isNaN(x))break}if(isNaN(x))break}if(isNaN(x))break}w[g+v]="avg"===i?k/S:x}}}}return v}const Wz={kernelName:cb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;NP(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s;cy(eC(a,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const u=Hk(r.shape,i,a,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&my(u.inShape,u.outShape))c=DP({inputs:{x:r},backend:n});else{const t=n.data.get(r.dataId).values,e=Oy(r.shape),s=zz(t,0,r.dtype,e,u,"avg");c=n.makeTensorInfo(u.outShape,r.dtype,s.values)}return c}},Uz={kernelName:db,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=s;NP(r,"avgPool3d");const c=Gk(r.shape,i,a,1,o,l,u),h=Bz(n.data.get(r.dataId).values,0,r.dtype,Oy(r.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},jz={kernelName:pb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=s;NP([r,i],"avgPool3DGrad");const c=Gk(i.shape,a,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,_=c.effectiveFilterHeight,x=c.effectiveFilterWidth,k=w-1-c.padInfo.front,C=x-1-c.padInfo.left,S=_-1-c.padInfo.top,I=Xx(i.shape,"float32"),E=1/(f*m*g),N=n.bufferSync(r);for(let T=0;T<c.batchSize;++T)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inDepth;++e)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=e-k,i=n-S,a=s-C;let o=0;for(let e=0;e<w;e+=y){const n=(r+e)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let e=0;e<_;e+=b){const s=(i+e)/d;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let e=0;e<x;e+=v){const r=(a+e)/p;r<0||r>=c.outWidth||Math.floor(r)!==r||(o+=N.get(T,n,s,r,t))}}}I.set(o*E,T,e,n,s,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},Hz={kernelName:hb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i;NP([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=s,c=Hk(a.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,w=y-1-c.padInfo.top,_=Xx(a.shape,"float32"),x=1/(p*f),k=n.data.get(r.dataId).values,C=Xx(r.shape,"float32",k);for(let S=0;S<c.batchSize;++S)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inHeight;++e)for(let n=0;n<c.inWidth;++n){const s=e-w,r=n-v;let i=0;for(let e=0;e<y;e+=m){const n=(s+e)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let e=0;e<b;e+=g){const s=(r+e)/d;s<0||s>=c.outWidth||Math.floor(s)!==s||(i+=C.get(S,n,s,t))}}_.set(i*x,S,e,n,t)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}},Gz={kernelName:nv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,scale:i,offset:a,mean:o,variance:l}=e;cy(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),cy(null==a||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),cy(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),NP([r,o,l,i,a],"batchNorm");let{varianceEpsilon:u}=s;null==u&&(u=.001);const c=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=i?n.data.get(i.dataId).values:new Float32Array([1]),f=a?n.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=d.length,v=h.length;let w=0,_=0,x=0,k=0;for(let C=0;C<c.length;++C)m[C]=f[w++]+(c[C]-h[_++])*p[x++]/Math.sqrt(d[k++]+u),w>=g&&(w=0),_>=v&&(_=0),x>=y&&(x=0),k>=b&&(k=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function qz(t,e,n,s,r){const i=kk(s,e,n),a=fy(n),o=Oy(s);if(i){const n=Ck(e,o);return"string"===r?t.slice(n,n+a):t.subarray(n,n+a)}const l=Xx(s,r,"string"===r?pN(t):t),u=Xx(n,r);for(let c=0;c<u.size;++c){const t=u.indexToLoc(c),n=t.map((t,n)=>t+e[n]);u.set(l.get(...n),...t)}return"string"===r?fN(u.values):u.values}function Kz(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:a}=s;NP(r,"slice");const[o,l]=Sk(r,i,a);hk(r,o,l);const u=qz(n.data.get(r.dataId).values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,u)}const Xz={kernelName:dw,backendName:"cpu",kernelFunc:Kz},Zz={kernelName:mb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:a}=s;NP([r],"batchToSpaceND");const o=i.reduce((t,e)=>t*e),l=TE(r.shape,i,o),u=AE(l.length,i.length),c=$E(r.shape,i,o),h=RE(a,i.length),d=OE(c,a,i.length),p=uz({inputs:{x:r},backend:n,attrs:{shape:l}}),f=xz({inputs:{x:p},backend:n,attrs:{perm:u}}),m=uz({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Kz({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function Yz(t,e,n,s,r){const i=fy(s),a=My(r,n);for(let o=0;o<t.length;o++){const n=t[o];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(a[n]+=i>0?e[o]:1)}return a}function Qz(t,e,n,s=!1){const r=t.shape[0],i=t.shape[1],a=Xx([r,n],e.dtype);for(let o=0;o<r;o++)for(let r=0;r<i;r++){const i=t.get(o,r);if(i<0)throw new Error("Input x must be non-negative!");i>=n||a.set(s?1:e.size>0?a.get(o,i)+e.get(o,r):a.get(o,i)+1,o,i)}return a}const Jz={kernelName:gb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a}=s,o=Yz(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,o)}};function tV(t){return(e,n,s)=>{const r=ky(n,e.length);for(let i=0;i<e.length;++i)r[i]=t(e[i],s);return r}}const eV=tV(t=>Math.ceil(t)),nV=RP(bb,eV),sV={kernelName:bb,backendName:"cpu",kernelFunc:nV},rV=$P(vb,(t,e)=>t>e.clipValueMax?e.clipValueMax:t<e.clipValueMin?e.clipValueMin:t),iV={kernelName:vb,backendName:"cpu",kernelFunc:rV},aV={kernelName:_b,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,s=new Float32Array(fy(e.shape)),r=n.data.get(e.dataId),i=r.complexTensorInfos.imag,a=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(i.dataId).values;for(let l=0;l<a.length;l++)s[l]=Math.hypot(a[l],o[l]);return n.makeOutput(s,e.shape,"float32")}};function oV(t,e,n,s){const r=Cy(n,fy(e));if(s&&"string"!==n){let e=0;t.forEach(t=>{const n=fy(t.shape);r.set(t.vals,e),e+=n})}else{let s=0;t.forEach(t=>{const i="string"===n?pN(t.vals):t.vals;let a=0;for(let n=0;n<t.shape[0];++n){const o=n*e[1]+s;for(let e=0;e<t.shape[1];++e)r[o+e]=i[a++]}s+=t.shape[1]})}return r}function lV(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const uV={kernelName:uv,backendName:"cpu",kernelFunc:lV};function cV(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,i=_y(r,e[0].shape)[0];let a=SE(e.map(t=>t.shape),i);if(0===fy(a))return n.makeTensorInfo(a,e[0].dtype,[]);const o=e.filter(t=>fy(t.shape)>0);if(1===o.length)return DP({inputs:{x:o[0]},backend:n});if(CE(o.map(t=>t.shape),i),"complex64"===o[0].dtype){const t=o.map(t=>JP({inputs:{input:t},backend:n})),e=o.map(t=>lV({inputs:{input:t},backend:n})),s=cV({inputs:t,backend:n,attrs:{axis:i}}),r=cV({inputs:e,backend:n,attrs:{axis:i}}),a=ZP({inputs:{real:s,imag:r},backend:n});return t.forEach(t=>n.disposeIntermediateTensorInfo(t)),e.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),a}const l=o.map(t=>{const e=fy(t.shape.slice(i));return uz({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})}),u=l.map(t=>({vals:n.data.get(t.dataId).values,shape:t.shape}));a=SE(l.map(t=>t.shape),1);const c=oV(u,a,e[0].dtype,1===l[0].shape[0]),h=SE(o.map(t=>t.shape),i),d=n.makeTensorInfo(h,e[0].dtype,c);return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),d}const hV={kernelName:xb,backendName:"cpu",kernelFunc:cV};function dV(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=s;NP([r,i],"conv2d");const h=nC(l),d=qk(r.shape,i.shape,a,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v="channelsLast"===d.dataFormat,w=new R_(d.outShape,r.dtype),_=Oy(r.shape),x=Oy(i.shape),k=_[0],C=v?_[1]:_[2],S=v?_[2]:1,I=v?1:_[1],E=w.strides[0],N=v?w.strides[1]:w.strides[2],T=v?w.strides[2]:1,A=v?1:w.strides[1],$=n.data.get(r.dataId).values,R=n.data.get(i.dataId).values,O=w.values;for(let F=0;F<d.batchSize;++F){const t=F*k,e=F*E;for(let n=0;n<d.outHeight;++n){const s=e+n*N,r=n*d.strideHeight-b;for(let e=0;e<p;++e){const n=r+e*m;if(n<0||n>=d.inHeight)continue;const i=e*x[0],a=t+n*C;for(let t=0;t<d.outWidth;++t){const e=s+t*T,n=t*d.strideWidth-y;for(let t=0;t<f;++t){const s=n+t*g;if(s<0||s>=d.inWidth)continue;const r=a+s*S;let o=i+t*x[1];for(let t=0;t<d.inChannels;++t){const n=$[r+t*I];for(let t=0;t<d.outChannels;++t)O[e+t*A]+=n*R[o+t];o+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,O)}const pV={kernelName:kb,backendName:"cpu",kernelFunc:dV},fV={kernelName:Cb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;NP([r,i],"conv2dBackpropFilter");const h=nC(l),d=qk(r.shape,c,a,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new R_(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,_=n.data.get(r.dataId).values,x=n.data.get(i.dataId).values,k=new R_(r.shape,r.dtype,_),C=new R_(i.shape,i.dtype,x);for(let S=0;S<m;++S){const t=Math.max(0,Math.ceil((w-S)/p)),e=Math.min(d.outHeight,(d.inHeight+w-S)/p);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let i=0;i<d.inChannels;++i)for(let a=0;a<d.outChannels;++a){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=t;u<e;++u){const t=S+u*p-w;for(let e=s;e<r;++e){const s=n+e*f-v;o+=y?k.get(l,t,s,i)*C.get(l,u,e,a):k.get(l,i,t,s)*C.get(l,a,u,e)}}b.set(o,S,n,i,a)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},mV={kernelName:Sb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=s;NP([r,i],"conv2dBackpropInput");const h=Oy(i.shape),d=Oy(r.shape);let p=nC(u);const f=qk(a,i.shape,o,1,l,c,!1,p),m=new R_(f.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,b=n.data.get(i.dataId).values,[v,w,_]=h,{batchSize:x,filterHeight:k,filterWidth:C,inChannels:S,inHeight:I,inWidth:E,outChannels:N,outHeight:T,outWidth:A,strideHeight:$,strideWidth:R}=f;p=f.dataFormat;const O=k-1-f.padInfo.top,F=C-1-f.padInfo.left,D="channelsLast"===p,L=m.strides[0],M=D?m.strides[1]:m.strides[2],P=D?m.strides[2]:1,z=D?1:m.strides[1],V=d[0],B=D?d[1]:d[2],W=D?d[2]:1,U=D?1:d[1];for(let j=0;j<x;++j)for(let t=0;t<S;++t)for(let e=0;e<I;++e){const n=e-O,s=Math.max(0,Math.ceil(n/$)),r=Math.min(T,(k+n)/$);for(let i=0;i<E;++i){const a=i-F,o=Math.max(0,Math.ceil(a/R)),l=Math.min(A,(C+a)/R);let u=0;for(let e=s;e<r;++e){const s=e*$-n;for(let n=o;n<l;++n){const r=V*j+B*e+W*n,i=v*(k-1-s)+w*(C-1-(n*R-a))+_*t;for(let t=0;t<N;++t)u+=y[r+U*t]*b[i+t]}}g[L*j+M*e+P*i+z*t]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},gV={kernelName:Ib,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s;NP([r,i],"conv3d");const u=Kk(r.shape,i.shape,a,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,w=new R_(u.outShape,r.dtype),_=n.data.get(r.dataId).values,x=n.data.get(i.dataId).values,k=w.values,C=Oy(r.shape),S=Oy(i.shape);for(let I=0;I<u.batchSize;++I){const t=I*C[0],e=I*w.strides[0];for(let n=0;n<u.outDepth;++n){const s=e+n*w.strides[1],r=n*u.strideDepth-y;for(let e=0;e<c;++e){const n=r+e*p;if(n<0||n>=u.inDepth)continue;const i=e*S[0],a=t+n*C[1];for(let t=0;t<u.outHeight;++t){const e=s+t*w.strides[2],n=t*u.strideHeight-v;for(let t=0;t<h;++t){const s=n+t*f;if(s<0||s>=u.inHeight)continue;const r=i+t*S[1],o=a+s*C[2];for(let t=0;t<u.outWidth;++t){const n=e+t*u.outChannels,s=t*u.strideWidth-b;for(let t=0;t<d;++t){const e=s+t*m;if(e<0||e>=u.inWidth)continue;const i=o+e*u.inChannels;let a=r+t*S[2];for(let t=0;t<u.inChannels;++t){const e=_[i+t];for(let t=0;t<u.outChannels;++t)k[n+t]+=e*x[a+t];a+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},yV={kernelName:Eb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s;NP([r,i],"conv3dBackpropFilterV2");const u=Oy(r.shape),c=Oy(i.shape),h=Kk(r.shape,l,a,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new R_(h.filterShape,"float32"),v=b.values,[w,_,x,k]=b.strides,C=n.data.get(i.dataId).values,[S,I,E,N]=c,T=n.data.get(r.dataId).values,[A,$,R,O]=u,F=h.padInfo.front,D=h.padInfo.left,L=h.padInfo.top;for(let M=0;M<m;++M){const t=Math.max(0,Math.ceil((F-M)/d)),e=Math.min(h.outDepth,(h.inDepth+F-M)/d),n=M*w;for(let s=0;s<g;++s){const r=Math.max(0,Math.ceil((L-s)/p)),i=Math.min(h.outHeight,(h.inHeight+L-s)/p),a=s*_+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((D-n)/f)),l=Math.min(h.outWidth,(h.inWidth+D-n)/f),u=n*x+a;for(let a=0;a<h.inChannels;++a){const c=a*k+u;for(let u=0;u<h.outChannels;++u){let m=0;for(let c=0;c<h.batchSize;++c){const h=c*A,g=c*S;for(let c=t;c<e;++c){const t=(M+c*d-F)*$+h,e=c*I+g;for(let c=r;c<i;++c){const r=(s+c*p-L)*R+t,i=c*E+e;for(let t=o;t<l;++t)m+=T[(n+t*f-D)*O+r+a]*C[t*N+i+u]}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},bV={kernelName:Nb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:l}=s;NP([r],"conv3dBackpropInputV2");const u=Oy(r.shape),c=Oy(i.shape),h=Kk(l,i.shape,o,1,a),d=new R_(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(r.dataId).values,[v,w,_,x]=u,k=n.data.get(i.dataId).values,[C,S,I,E]=c,{batchSize:N,filterDepth:T,filterHeight:A,filterWidth:$,inChannels:R,inDepth:O,inHeight:F,inWidth:D,outChannels:L,outDepth:M,outHeight:P,outWidth:z,strideDepth:V,strideHeight:B,strideWidth:W}=h,U=T-1-h.padInfo.front,j=A-1-h.padInfo.top,H=$-1-h.padInfo.left;for(let G=0;G<N;++G)for(let t=0;t<R;++t)for(let e=0;e<O;++e){const n=e-U,s=Math.max(0,Math.ceil(n/V)),r=Math.min(M,(T+n)/V);for(let i=0;i<F;++i){const a=i-j,o=Math.max(0,Math.ceil(a/B)),l=Math.min(P,(A+a)/B);for(let u=0;u<D;++u){const c=u-H,h=Math.max(0,Math.ceil(c/W)),d=Math.min(z,($+c)/W);let N=0;for(let e=s;e<r;++e){const s=e*V-n;for(let n=o;n<l;++n){const r=n*B-a;for(let i=h;i<d;++i){const a=v*G+w*e+_*n+x*i,o=C*(T-1-s)+S*(A-1-r)+I*($-1-(i*W-c))+E*t;for(let t=0;t<L;++t)N+=b[a+t]*k[o+t]}}}p[f*G+m*e+g*i+y*u+t]=N}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},vV=$P(Tb,t=>Math.cos(t)),wV={kernelName:Tb,backendName:"cpu",kernelFunc:vV},_V=$P(Ab,t=>Math.cosh(t)),xV={kernelName:Ab,backendName:"cpu",kernelFunc:_V},kV={kernelName:Rb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=s,[c,h,d,p]=r.shape,f=i.shape[0],[m,g]=o,y=Xx([f,m,g,p],"float32"),b=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,w=n.data.get(r.dataId).values,_=Oy(r.shape),x=Oy(y.shape);for(let k=0;k<f;k++){const t=4*k,e=b[t],n=b[t+1],s=b[t+2],r=b[t+3],i=v[k];if(i>=c)continue;const a=m>1?(s-e)*(h-1)/(m-1):0,o=g>1?(r-n)*(d-1)/(g-1):0;for(let c=0;c<m;c++){const t=m>1?e*(h-1)+c*a:.5*(e+s)*(h-1);if(t<0||t>h-1)for(let e=0;e<g;e++)for(let t=0;t<p;t++)y.values[t+e*x[2]+c*x[1]+k*x[0]]=u;else if("bilinear"===l){const e=Math.floor(t),s=Math.ceil(t),a=t-e;for(let t=0;t<g;t++){const l=g>1?n*(d-1)+t*o:.5*(n+r)*(d-1);if(l<0||l>d-1){for(let e=0;e<p;e++)y.values[e+t*x[2]+c*x[1]+k*x[0]]=u;continue}const h=Math.floor(l),f=Math.ceil(l),m=l-h;for(let n=0;n<p;n++){let r=n+h*_[2]+e*_[1]+i*_[0];const o=w[r];r=n+f*_[2]+e*_[1]+i*_[0];const l=w[r];r=n+h*_[2]+s*_[1]+i*_[0];const u=w[r];r=n+f*_[2]+s*_[1]+i*_[0];const d=w[r],p=o+(l-o)*m;r=n+t*x[2]+c*x[1]+k*x[0],y.values[r]=p+(u+(d-u)*m-p)*a}}}else for(let e=0;e<g;++e){const s=g>1?n*(d-1)+e*o:.5*(n+r)*(d-1);if(s<0||s>d-1){for(let t=0;t<p;t++)y.values[t+e*x[2]+c*x[1]+k*x[0]]=u;continue}const a=Math.round(s),l=Math.round(t);for(let t=0;t<p;t++)y.values[t+e*x[2]+c*x[1]+k*x[0]]=w[t+a*_[2]+l*_[1]+i*_[0]]}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},CV={kernelName:$b,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;NP(r,"cumsum");const l=rS([i],r.shape.length);let u=r;null!=l&&(u=xz({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=aS(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=H_(u.dtype,"int32"),d=My(fy(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let y=0;y<p.length;y+=f)for(let t=0;t<f;t++){const e=m(y,t);if(0===t)d[e]=a?0:p[e];else{const n=m(y,t-1);d[e]=a?p[n]+d[n]:p[e]+d[n]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const t=xz({inputs:{x:g},backend:n,attrs:{perm:iS(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}},SV={kernelName:Ob,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(1===r.shape.length){const t=Yz(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,t)}if(2===r.shape.length){const t=Qz(n.bufferSync(r),n.bufferSync(i),a,o);return n.makeTensorInfo(t.shape,i.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},IV={kernelName:Fb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:i,dataFormat:a}=s;cy("NHWC"===a,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`),cy(i>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${i}`);const o=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*i,d=u*i,p=c/(i*i),f=n.data.get(r.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let y=0;y<o;++y)for(let t=0;t<h;++t){const e=Math.floor(t/i),n=t%i;for(let t=0;t<d;++t){const s=Math.floor(t/i),r=(n*i+t%i)*p;for(let t=0;t<p;++t)m[g++]=f[t+r+c*(s+u*(e+l*y))]}}return n.makeTensorInfo([o,h,d,p],r.dtype,m)}};function EV(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=s;NP([r,i],"depthwiseConv2DNative");const c=Oy(r.shape),h=Oy(i.shape);let d=l;null==d&&(d=[1,1]),cy(eC(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=qk(r.shape,i.shape,a,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,w=b.top,_=p.outChannels/p.inChannels,x=new R_(p.outShape,r.dtype),k=n.data.get(r.dataId).values,C=n.data.get(i.dataId).values,S=x.values;for(let I=0;I<p.batchSize;++I){const t=I*c[0],e=I*x.strides[0];for(let n=0;n<p.outHeight;++n){const s=e+n*x.strides[1],r=n*p.strideHeight-w;for(let e=0;e<f;++e){const n=r+e*g;if(n<0||n>=p.inHeight)continue;const i=e*h[0],a=t+n*c[1];for(let t=0;t<p.outWidth;++t){const e=s+t*x.strides[2],n=t*p.strideWidth-v;for(let t=0;t<m;++t){const s=n+t*y;if(s<0||s>=p.inWidth)continue;const r=a+s*p.inChannels;let o=e,l=i+t*h[1];for(let t=0;t<p.inChannels;++t){const e=k[r+t];for(let t=0;t<_;++t)S[o+t]+=e*C[l+t];o+=_,l+=_}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const NV={kernelName:Db,backendName:"cpu",kernelFunc:EV},TV={kernelName:Lb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=s;NP([r,i],"depthwiseConv2dNativeBackpropFilter");const h=qk(r.shape,c,a,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new R_(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(r.dataId).values,_=new R_(r.shape,r.dtype,w),x=n.data.get(i.dataId).values,k=new R_(i.shape,i.dtype,x);for(let C=0;C<f;++C){const t=Math.max(0,Math.ceil((b-C)/d)),e=Math.min(h.outHeight,(h.inHeight+b-C)/d);for(let n=0;n<m;++n){const s=Math.max(0,Math.ceil((y-n)/p)),r=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let i=0;i<h.outChannels;++i){const a=Math.trunc(i/v),o=i%v;let l=0;for(let u=0;u<h.batchSize;++u)for(let o=t;o<e;++o){const t=C+o*d-b;for(let e=s;e<r;++e)l+=_.get(u,t,n+e*p-y,a)*k.get(u,o,e,i)}g.set(l,C,n,a,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},AV={kernelName:Mb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=s;NP([r,i],"depthwiseConv2DNativeBackpropInput");const h=Oy(r.shape),d=Oy(i.shape),p=qk(c,i.shape,a,o,l,u,!0),f=new R_(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(r.dataId).values,[w,_,x]=h,k=n.data.get(i.dataId).values,[C,S,I]=d,{batchSize:E,filterHeight:N,filterWidth:T,inChannels:A,inHeight:$,inWidth:R,outChannels:O,outHeight:F,outWidth:D,strideHeight:L,strideWidth:M}=p,P=N-1-p.padInfo.top,z=T-1-p.padInfo.left,V=O/A;for(let B=0;B<E;++B)for(let t=0;t<A;++t)for(let e=0;e<$;++e){const n=e-P,s=Math.max(0,Math.ceil(n/L)),r=Math.min(F,(N+n)/L);for(let i=0;i<R;++i){const a=i-z,o=Math.max(0,Math.ceil(a/M)),l=Math.min(D,(T+a)/M);let u=0;for(let e=s;e<r;++e){const s=e*L-n;for(let n=o;n<l;++n){const r=w*B+_*e+x*n,i=C*(N-1-s)+S*(T-1-(n*M-a))+I*t;for(let e=0;e<V;++e)u+=v[r+(t*V+e)]*k[i+e]}}m[g*B+y*e+b*i+t]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},$V={kernelName:Pb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,r=fy(s.shape),i=n.data.get(s.dataId).values,a=Xx([r,r],s.dtype),o=a.values;for(let u=0;u<i.length;u++)o[u*r+u]=i[u];const l=[...s.shape,...s.shape];return n.makeTensorInfo(l,a.dtype,a.values)}},RV={kernelName:zb,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r}=t,{strides:i,pad:a,dilations:o}=n,l=e,u=l.data.get(s.dataId).values,c=s.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:w,strideWidth:_,filterHeight:x,filterWidth:k,dilationHeight:C,dilationWidth:S,outShape:I}=jk(s.shape,r.shape,i,a,"NHWC",o),E=fy(I),N=I.length,T=Cy(s.dtype,E);for(let A=0;A<p;++A)for(let t=0;t<y;++t){const e=t*w-v.top;for(let n=0;n<b;++n){const i=n*_-v.left;for(let a=0;a<g;++a){let o=Number.MIN_SAFE_INTEGER;for(let t=0;t<x;++t){const n=e+t*C;if(n>=0&&n<f)for(let e=0;e<k;++e){const l=i+e*S;if(l>=0&&l<m){const i=Vy([A,n,l,a],c,Oy(s.shape)),p=Vy([t,e,a],d,Oy(r.shape)),f=u[i]+h[p];f>o&&(o=f)}}}T[Vy([A,t,n,a],N,Oy(I))]=o}}}return{dataId:l.write(w_(T,s.dtype),I,s.dtype),shape:I,dtype:s.dtype}}},OV={kernelName:Bb,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:i}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=Dy(s.shape,u.data.get(s.dataId).values),h=Dy(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:w,filterHeight:_,filterWidth:x,dilationHeight:k,dilationWidth:C,outShape:S}=jk(s.shape,r.shape,a,o,"NHWC",l);cy(i.rank===S.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${S.length}, but got ${i.rank}`);const I=Dy(S,u.data.get(i.dataId).values),E=Py(r.shape,r.dtype);for(let N=0;N<d;++N)for(let t=0;t<g;++t){const e=t*v-b.top;for(let n=0;n<y;++n){const s=n*w-b.left;for(let r=0;r<m;++r){let i=Number.MIN_SAFE_INTEGER,a=0,o=0;for(let t=0;t<_;++t){const n=e+t*k;if(n>=0&&n<p)for(let e=0;e<x;++e){const l=s+e*C;if(l>=0&&l<f){const s=c[N][n][l][r]+h[t][e][r];s>i&&(i=s,a=t,o=e)}}}E[a][o][r]+=I[N][t][n][r]}}}return{dataId:u.write(w_(E,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},FV={kernelName:Vb,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:i}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=Dy(s.shape,u.data.get(s.dataId).values),h=Dy(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:w,filterHeight:_,filterWidth:x,dilationHeight:k,dilationWidth:C,outShape:S}=jk(s.shape,r.shape,a,o,"NHWC",l);cy(i.rank===S.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${S.length}, but got ${i.rank}`);const I=Dy(S,u.data.get(i.dataId).values),E=Py(s.shape,s.dtype);for(let N=0;N<d;++N)for(let t=0;t<g;++t){const e=t*v-b.top;for(let n=0;n<y;++n){const s=n*w-b.left;for(let r=0;r<m;++r){let i=Number.MIN_SAFE_INTEGER,a=e<0?0:e,o=s<0?0:s;for(let t=0;t<_;++t){const n=e+t*k;if(n>=0&&n<p)for(let e=0;e<x;++e){const l=s+e*C;if(l>=0&&l<f){const s=c[N][n][l][r]+h[t][e][r];s>i&&(i=s,a=n,o=l)}}}E[N][a][o][r]+=I[N][t][n][r]}}}return{dataId:u.write(w_(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},DV=zP((t,e)=>t*e),LV=rz((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),MV=sz(Mv,DV,LV),PV={kernelName:Mv,backendName:"cpu",kernelFunc:MV};function zV(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s;let o;NP(r,"sum"),o="bool"===r.dtype?ez({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):DP({inputs:{x:r},backend:n});const l=o.shape.length,u=_y(i,o.shape),c=rS(u,l);let h=u,d=o;null!=c&&(d=xz({inputs:{x:o},backend:n,attrs:{perm:c}}),h=aS(h.length,l)),sS("sum",h,d.shape.length);const[p,f]=eS(d.shape,h);let m=QP(n,p,H_(d.dtype,"int32"));const g=fy(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let v=0;v<y.length;++v){const t=v*g;let e=0;for(let n=0;n<g;++n)e+=b[t+n];y[v]=e}if(a){const t=m;m=uz({inputs:{x:m},backend:n,attrs:{shape:nS(m.shape,u)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const VV={kernelName:vw,backendName:"cpu",kernelFunc:zV},BV={kernelName:Ub,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:l}=sN(r,i.length);iN(a.length,l,i);const{path:u,steps:c}=aN(o,l),h=c.length;let d=null,p=a.length;const f=[];for(let m=0;m<h;++m){for(const t of c[m]){const{permutationIndices:e,expandDims:s}=rN(p,l[t]);let r;oN(e)?r=i[t]:(r=xz({inputs:{x:i[t]},backend:n,attrs:{perm:e}}),f.push(r));const a=r.shape.slice();for(let t=0;t<s.length;++t)a.splice(s[t],0,1);my(r.shape,a)||(r=uz({inputs:{x:r},backend:n,attrs:{shape:a}}),f.push(r)),null===d?d=r:(d=MV({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=zV({inputs:{x:d},backend:n,attrs:{axis:u[m]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},WV={kernelName:Hb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:s,y:r}=e;NP([s,r],"eluGrad");const i=new Float32Array(fy(r.shape)),a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values;for(let l=0;l<a.length;++l){const t=a[l];i[l]=t>=1?o[l]:o[l]*(t+1)}return n.makeTensorInfo(r.shape,"float32",i)}},UV=zP((t,e)=>t===e?1:0),jV=sz(qb,UV,null,"bool"),HV={kernelName:qb,backendName:"cpu",kernelFunc:jV},GV=VE,qV=BE,KV=WE,XV=UE,ZV=jE,YV=HE,QV=$P(Gb,t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+GV*n);return e*(1-((((YV*s+ZV)*s+XV)*s+KV)*s+qV)*s*Math.exp(-n*n))}),JV={kernelName:Gb,backendName:"cpu",kernelFunc:QV},tB=tV(t=>Math.exp(t)),eB=RP(Kb,tB),nB={kernelName:Kb,backendName:"cpu",kernelFunc:eB};function sB(t){const{inputs:e,backend:n,attrs:s}=t,{input:r}=e,{dim:i}=s,a=r.shape.length,o=r.shape.slice();let l=i;return i<0&&(cy(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+i+1),o.splice(l,0,1),uz({inputs:{x:r},backend:n,attrs:{shape:o}})}const rB={kernelName:Xb,backendName:"cpu",kernelFunc:sB},iB=tV(t=>Math.expm1(t)),aB=RP(Zb,iB),oB={kernelName:Zb,backendName:"cpu",kernelFunc:aB},lB=zP((t,e)=>t/e),uB=sz(Wb,lB),cB={kernelName:Wb,backendName:"cpu",kernelFunc:uB},hB=zP((t,e)=>t-e),dB=rz((t,e,n,s)=>({real:t-n,imag:e-s})),pB=sz(Fw,hB,dB),fB={kernelName:Fw,backendName:"cpu",kernelFunc:pB};function mB(t,e,n){const s=t.shape,r=s[0],i=s[1],a=n.data.get(t.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[r,i],c=fy(u),h=ky("float32",c),d=ky("float32",c);for(let g=0;g<r;g++){const t=Kz({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,i]}}),s=Kz({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,i]}}),r=ZP({inputs:{real:t,imag:s},backend:n}),{real:a,imag:u}=gB(r,e,n),c=KE(a,u);for(let e=0;e<i;e++){const t=QE(c,e);h[g*i+e]=t.real,d[g*i+e]=t.imag}n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=ZP({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function gB(t,e,n){const s=fy(t.shape),r=n.data.get(t.dataId),i=n.data.get(r.complexTensorInfos.real.dataId).values,a=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0==((o=s)&o-1)){const r=yB(i,a,s,e,n),o=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(o,"float32",r.real),e=n.makeTensorInfo(o,"float32",r.imag),i=n.makeTensorInfo([],"float32",v_(s,"float32")),a=DP({inputs:{x:i},backend:n}),l=cB.kernelFunc({inputs:{a:t,b:i},backend:n}),u=cB.kernelFunc({inputs:{a:e,b:a},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return r}return XE(function(t,e,n){const s=new Float32Array(2*e);for(let r=0;r<e;r++){let i=0,a=0;for(let s=0;s<e;s++){const o=eN(r*s,e,n),l=QE(t,s);i+=l.real*o.real-l.imag*o.imag,a+=l.real*o.imag+l.imag*o.real}n&&(i/=e,a/=e),JE(s,i,a,r)}return s}(KE(i,a),s,e));var o}function yB(t,e,n,s,r){if(1===n)return{real:t,imag:e};const i=KE(t,e),a=n/2,o=ZE(i),l=o.real,u=o.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),d=r.makeTensorInfo(c,"float32",u),p=ZP({inputs:{real:h,imag:d},backend:r}),f=YE(i),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),v=r.makeTensorInfo(y,"float32",g),w=ZP({inputs:{real:b,imag:v},backend:r}),_=yB(l,u,a,s,r),x=_.real,k=_.imag,C=[x.length],S=r.makeTensorInfo(C,"float32",x),I=r.makeTensorInfo(C,"float32",k),E=ZP({inputs:{real:S,imag:I},backend:r}),N=yB(m,g,a,s,r),T=N.real,A=N.imag,$=[T.length],R=r.makeTensorInfo($,"float32",T),O=r.makeTensorInfo($,"float32",A),F=ZP({inputs:{real:R,imag:O},backend:r}),D=tN(n,s),L=[D.real.length],M=r.makeTensorInfo(L,"float32",D.real),P=r.makeTensorInfo(L,"float32",D.imag),z=ZP({inputs:{real:M,imag:P},backend:r}),V=MV({inputs:{a:z,b:F},backend:r}),B=oz({inputs:{a:E,b:V},backend:r}),W=pB({inputs:{a:E,b:V},backend:r}),U=JP({inputs:{input:B},backend:r}),j=JP({inputs:{input:W},backend:r}),H=lV({inputs:{input:B},backend:r}),G=lV({inputs:{input:W},backend:r}),q=cV({inputs:[U,j],backend:r,attrs:{axis:0}}),K=cV({inputs:[H,G],backend:r,attrs:{axis:0}}),X=r.data.get(q.dataId).values,Z=r.data.get(K.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(K),{real:X,imag:Z}}const bB={kernelName:Yb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e,r=fy(s.shape),i=s.shape[s.shape.length-1],a=uz({inputs:{x:s},backend:n,attrs:{shape:[r/i,i]}}),o=mB(a,!1,n),l=uz({inputs:{x:o},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}};function vB(t){const{backend:e,attrs:n}=t,{shape:s,value:r,dtype:i}=n,a=i||Ay(r),o=Cy(a,fy(s));return function(t,e,n){t.fill(e)}(o,r),e.makeTensorInfo(s,a,o)}const wB={kernelName:Qb,backendName:"cpu",kernelFunc:vB},_B={kernelName:Jb,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=ky(n.dtype,fy(n.shape)),[i,a,o,l]=n.shape,u=s.data.get(n.dataId).values;for(let c=0;c<i;c++){const t=c*o*a*l;for(let e=0;e<a;e++){const n=e*(o*l);for(let s=0;s<o;s++){const a=s*l;for(let c=0;c<l;c++){const h=Math.round(o-[i,e,s,c][2]),d=t+n+a+c;let p=u[d];h>=0&&h<o&&(p=u[t+n+h*l+c]),r[d]=p}}}}return{dataId:s.write(r,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},xB=tV(t=>Math.floor(t)),kB=RP(tv,xB),CB={kernelName:tv,backendName:"cpu",kernelFunc:kB},SB=zP((t,e)=>Math.floor(t/e)),IB=sz(ev,SB,null,"int32"),EB={kernelName:ev,backendName:"cpu",kernelFunc:IB},NB={kernelName:Xw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=dV({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;m=oz({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=XP(n,m,p,o,f),n.disposeIntermediateTensorInfo(t)}return m}},TB={kernelName:Zw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=EV({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;m=oz({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=XP(n,m,p,o,f),n.disposeIntermediateTensorInfo(t)}return m}};function AB(t,e,n,s,r,i,a,o,l){const u=Xx([s,i],n);for(let c=0;c<s;c++){const n=[];let s=0;for(let e=0;e<r;e++){const i=t[c*r+e];s+=i*a[e],n.push(i)}if(s<0||s>=l/i)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let t=0;t<i;t++)u.values[c*i+t]=e.get(...e.indexToLoc(s*i+t))}return u}const $B={kernelName:rv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,i=fy(s.shape),a=r.shape,o=a[a.length-1],[l,u,c,h]=FE(s,r);if(0===u)return n.makeTensorInfo(l,s.dtype,[]);const d=AB(n.data.get(r.dataId).values,n.bufferSync(s),s.dtype,u,o,c,h,s.shape,i);return n.makeTensorInfo(l,s.dtype,d.values)}};function RB(t,e,n){const s=Xx(n,t.dtype);for(let r=0;r<s.size;++r){const n=s.indexToLoc(r).slice(),i=e.locToIndex([n[0],n[2]]);n[2]=e.values[i];const a=t.locToIndex(n);s.values[r]=t.values[a]}return s}const OB={kernelName:sv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:i}=e,{axis:a,batchDims:o}=s;NP([r,i],"gatherV2");let l=o;null==o&&(l=0);const u=fy(i.shape),c=dN(r,i,_y(a,r.shape)[0],l),h=uz({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=uz({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}}),p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize],f=n.bufferSync(d),m=RB(n.bufferSync(h),f,p);return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.makeTensorInfo(c.outputShape,m.dtype,m.values)}},FB=zP((t,e)=>t>e?1:0),DB=sz(iv,FB,null,"bool"),LB={kernelName:iv,backendName:"cpu",kernelFunc:DB},MB=zP((t,e)=>t>=e?1:0),PB=sz(av,MB,null,"bool"),zB={kernelName:av,backendName:"cpu",kernelFunc:PB},VB={kernelName:lv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e,r=fy(s.shape),i=s.shape[s.shape.length-1],a=uz({inputs:{x:s},backend:n,attrs:{shape:[r/i,i]}}),o=mB(a,!0,n),l=uz({inputs:{x:o},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}},BB=$P(cv,t=>Number.isFinite(t)?1:0,"bool"),WB={kernelName:cv,backendName:"cpu",kernelFunc:BB},UB=$P(hv,t=>Math.abs(t)===1/0?1:0,"bool"),jB={kernelName:hv,backendName:"cpu",kernelFunc:UB},HB=$P(dv,t=>Number.isNaN(t)?1:0,"bool"),GB={kernelName:dv,backendName:"cpu",kernelFunc:HB},qB=zP((t,e)=>t<e?1:0),KB=sz(fv,qB,null,"bool"),XB={kernelName:fv,backendName:"cpu",kernelFunc:KB},ZB=zP((t,e)=>t<=e?1:0),YB=sz(mv,ZB,null,"bool"),QB={kernelName:mv,backendName:"cpu",kernelFunc:YB};function JB(t,e,n){const s=(e-t)/(n-1),r=My(n,"float32");r[0]=t;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const tW={kernelName:gv,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,a=JB(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}},eW=tV(t=>Math.log(t)),nW=RP(yv,eW),sW={kernelName:yv,backendName:"cpu",kernelFunc:nW},rW=$P(bv,t=>Math.log1p(t)),iW={kernelName:bv,backendName:"cpu",kernelFunc:rW},aW=zP((t,e)=>t&&e),oW=sz(vv,aW,null,"bool"),lW={kernelName:vv,backendName:"cpu",kernelFunc:oW},uW=$P(wv,t=>t?0:1,"bool"),cW={kernelName:wv,backendName:"cpu",kernelFunc:uW},hW=zP((t,e)=>t||e),dW=sz(_v,hW,null,"bool"),pW={kernelName:_v,backendName:"cpu",kernelFunc:dW},fW={kernelName:xv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s;NP(r,"LRN");const u=r.shape[3],c=u-1,h=n.data.get(r.dataId).values,d=fy(r.shape),p=new Float32Array(d);function f(t){const e=t%u;let n=t-e+Math.max(0,e-i);const s=t-e+Math.min(e+i,c);let r=0;for(;n<=s;n++){const t=h[n];r+=t*t}return r}for(let m=0;m<d;m++){const t=f(m),e=h[m]*Math.pow(a+o*t,-l);p[m]=e}return n.makeTensorInfo(r.shape,r.dtype,p)}},mW={kernelName:kv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=s;NP(a,"LRNGrad");const h=fy(a.shape),d=a.shape[3],p=n.data.get(a.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(i.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const t=b%d,e=b-t+Math.max(0,t-o),n=b-t+Math.min(d,t+o+1);let s=0;for(let r=e;r<n;r++)s+=Math.pow(f[r],2);s=u*s+l;for(let r=e;r<n;r++){let t=-2*u*c*f[r]*m[b]/s;b===r&&(t+=Math.pow(s,-c)),t*=p[b],g[r]+=t}}return n.makeTensorInfo(a.shape,r.dtype,g)}};function gW(t,e,n,s){const r=ky(s,fy(n));for(let i=0;i<r.length;++i){const n=i*e;let s=t[n];for(let r=0;r<e;++r){const e=t[n+r];(Number.isNaN(e)||e>s)&&(s=e)}r[i]=s}return r}function yW(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=n;let l=r.shape;const u=l.length,c=_y(i,l);let h=c;const d=rS(h,u);let p=o.data.get(r.dataId).values;if(null!=d){const t=new Array(u);for(let e=0;e<t.length;e++)t[e]=l[d[e]];p=_z(p,l,r.dtype,d,t),h=aS(h.length,u),l=t}NP(r,"max"),sS("max",h,u);const[f,m]=eS(l,h),g=gW(p,fy(m),f,r.dtype),y=o.write(g,f,r.dtype);let b=f;return a&&(b=nS(f,c)),{dataId:y,shape:b,dtype:r.dtype}}const bW={kernelName:Cv,backendName:"cpu",kernelFunc:yW},vW=zP((t,e)=>Math.max(t,e)),wW=sz(Sv,vW),_W={kernelName:Sv,backendName:"cpu",kernelFunc:wW},xW={kernelName:Iv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;NP(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s;cy(eC(a,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const u=Hk(r.shape,i,a,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&my(u.inShape,u.outShape))c=DP({inputs:{x:r},backend:n});else{const t=n.data.get(r.dataId).values,e=Oy(r.shape),s=zz(t,0,r.dtype,e,u,"max");c=n.makeTensorInfo(u.outShape,r.dtype,s.values)}return c}},kW={kernelName:Nv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=s;NP(r,"maxPool3d");const c=Gk(r.shape,i,a,1,o,l,u),h=Bz(n.data.get(r.dataId).values,0,r.dtype,Oy(r.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},CW={kernelName:Tv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=s;NP([r,i],"maxPool3DGrad");const c=Gk(i.shape,a,o,1,l,u),h=function(t,e){const n=Xx(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*s-d;let v=b;for(;v<0;)v+=a;const w=Math.min(e.inDepth,u+b);for(let s=0;s<e.outHeight;++s){const u=s*r-p;let d=u;for(;d<0;)d+=o;const _=Math.min(e.inHeight,c+u);for(let r=0;r<e.outWidth;++r){const p=r*i-f;let x=p;for(;x<0;)x+=l;const k=Math.min(e.inWidth,h+p);let C=Number.NEGATIVE_INFINITY,S=-1;for(let e=v;e<w;e+=a){const n=e-b;for(let s=d;s<_;s+=o){const r=s-u;for(let i=x;i<k;i+=l){const a=i-p,o=t.get(m,e,s,i,g);o>=C&&(C=o,S=n*c*h+r*c+a)}}}n.set(S,m,y,s,r,g)}}}return n}(n.bufferSync(i),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,_=b-1-c.padInfo.front,x=w-1-c.padInfo.left,k=v-1-c.padInfo.top,C=Xx(i.shape,"float32"),S=n.bufferSync(r);for(let I=0;I<c.batchSize;++I)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inDepth;++e)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=e-_,i=n-k,a=s-x;let o=0;for(let e=0;e<b;e+=m){const n=(r+e)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let s=0;s<v;s+=g){const r=(i+s)/p;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let i=0;i<w;i+=y){const l=(a+i)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*v*w-1-h.get(I,n,r,l,t)===e*v*w+s*w+i?1:0;0!==u&&(o+=S.get(I,n,r,l,t)*u)}}}C.set(o,I,e,n,s,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},SW={kernelName:Ev,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:a}=e,o=i;NP([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=Hk(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=Xx(d.outShape,o.dtype,Vz(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,_=w-1-d.padInfo.left,x=v-1-d.padInfo.top,k=Xx(o.shape,"float32"),C=n.data.get(r.dataId).values,S=Xx(r.shape,"float32",C);for(let I=0;I<d.batchSize;++I)for(let t=0;t<d.inChannels;++t)for(let e=0;e<d.inHeight;++e)for(let n=0;n<d.inWidth;++n){const s=e-x,r=n-_;let i=0;for(let e=0;e<v;e+=y){const n=(s+e)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let s=0;s<w;s+=b){const a=(r+s)/g;if(a<0||a>=d.outWidth||Math.floor(a)!==a)continue;const o=v*w-1-f.get(I,n,a,t)===e*w+s?1:0;0!==o&&(i+=S.get(I,n,a,t)*o)}}k.set(i,I,e,n,t)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},IW={kernelName:Av,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,l=n;NP(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=Hk(s.shape,r,i,[1,1],a),[h,d]=function(t,e,n,s,r){const i=zz(t,0,n,Oy(e),r,"max"),a=Vz(t,e,n,r,!0,s);return[i.values,a.values]}(u,s.shape,s.dtype,o,c),p=l.write(h,c.outShape,s.dtype),f=l.write(d,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},EW={kernelName:$v,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s,o=_y(i,r.shape),l=fy(eS(r.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=ez({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=uB({inputs:{a:h,b:c},backend:n});u.push(d);const p=zV({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:a}});return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),p}},NW={kernelName:Rv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s;NP(r,"min");const o=_y(i,r.shape);let l=o;const u=rS(l,r.shape.length);let c=r;null!=u&&(c=xz({inputs:{x:r},backend:n,attrs:{perm:u}}),l=aS(l.length,r.shape.length)),sS("min",l,c.shape.length);const[h,d]=eS(c.shape,l),p=fy(d),f=My(fy(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const t=y*p;let e=m[t];for(let n=0;n<p;++n){const s=m[t+n];(Number.isNaN(s)||s<e)&&(e=s)}f[y]=e}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=uz({inputs:{x:g},backend:n,attrs:{shape:nS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},TW=zP((t,e)=>Math.min(t,e)),AW=sz(Ov,TW),$W={kernelName:Ov,backendName:"cpu",kernelFunc:AW},RW={kernelName:Fv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,mode:a}=s;NP(r,"mirrorPad");const o=i.map((t,e)=>t[0]+r.shape[e]+t[1]),l=i.map(t=>t[0]),u=i.map((t,e)=>t[0]+r.shape[e]),c="reflect"===a?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,p=Oy(r.shape),f=fy(o),m=o.length,g=Oy(o),y=ky(r.dtype,f);for(let b=0;b<f;b++){let t=By(b,m,g);for(let n=0;n<m;n++)t[n]<l[n]?t[n]=2*l[n]-t[n]-c:t[n]>=u[n]&&(t[n]=2*(u[n]-1)-t[n]+c);t=t.map((t,e)=>t-l[e]);const e=Vy(t,d,p);y[b]=h[e]}return{dataId:n.write(y,o,r.dtype),shape:o,dtype:r.dtype}}},OW=zP((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),FW=sz(Dv,OW),DW={kernelName:Dv,backendName:"cpu",kernelFunc:FW};function LW(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:i}=s,a=r.shape.length;let o=i;if(-1===o&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=_y([o],r.shape),u=yW({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=nS(u.shape,l),h=uz({inputs:{x:u},backend:n,attrs:{shape:c}}),d=pB({inputs:{a:r,b:h},backend:n}),p=eB({inputs:{x:d},backend:n}),f=zV({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=uz({inputs:{x:f},backend:n,attrs:{shape:c}}),g=uB({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const MW={kernelName:xw,backendName:"cpu",kernelFunc:LW},PW={kernelName:Lv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s;NP(r,"multinomial");const l=o?r:LW({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,i],p=My(fy(d),"int32");for(let f=0;f<u;++f){const t=f*c,e=new Float32Array(c-1);e[0]=h[t];for(let r=1;r<e.length;++r)e[r]=e[r-1]+h[t+r];const n=yS.alea(a.toString()),s=f*i;for(let r=0;r<i;++r){const t=n();p[s+r]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){p[s+r]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function zW(t,e,n){const s=v_(-1,n);return DV([],e,s,t,n)}const VW={kernelName:Pv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;NP(s,"neg");const r=n.data.get(s.dataId).values,[i,a]=zW(r,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,i)}},BW=kI,WW={kernelName:Vv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s;NP(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=BW(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},UW=CI,jW={kernelName:Bv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=s;NP(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=UW(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},HW=SI,GW={kernelName:Wv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=s;NP(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=a,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=HW(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},qW=zP((t,e)=>t!==e?1:0),KW=sz(zv,qW,null,"bool"),XW={kernelName:zv,backendName:"cpu",kernelFunc:KW},ZW={kernelName:jv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{depth:i,onValue:a,offValue:o}=s;NP(r,"oneHot");const l=fy(r.shape),u=new Float32Array(l*i);u.fill(o);const c=n.data.get(r.dataId).values;for(let h=0;h<l;++h)c[h]>=0&&c[h]<i&&(u[h*i+c[h]]=a);return n.makeTensorInfo([...r.shape,i],"int32",u)}};function YW(t){const{inputs:e,backend:n}=t,{x:s}=e;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const t=JP({inputs:{input:s},backend:n}),e=YW({inputs:{x:t},backend:n}),r=lV({inputs:{input:s},backend:n}),i=YW({inputs:{x:r},backend:n}),a=ZP({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}return vB({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const QW={kernelName:jw,backendName:"cpu",kernelFunc:YW},JW={kernelName:Uv,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:s}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const e=JP({inputs:{input:r},backend:s}),n=t({inputs:{x:e},backend:s}),i=lV({inputs:{input:r},backend:s}),a=YW({inputs:{x:i},backend:s}),o=ZP({inputs:{real:n,imag:a},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}return vB({backend:s,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function tU(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(1===e.length)return sB({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(t=>{hy(i,t.shape,"All tensors passed to stack must have matching shapes"),cy(a===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=cV({inputs:e.map(t=>{const e=sB({inputs:{input:t},backend:n,attrs:{dim:r}});return o.push(e),e}),backend:n,attrs:{axis:r}});return o.forEach(t=>n.disposeIntermediateTensorInfo(t)),l}const eU={kernelName:Hv,backendName:"cpu",kernelFunc:tU},nU={kernelName:Gv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:a}=s;NP(r,"pad");const o=i.map((t,e)=>t[0]+r.shape[e]+t[1]),l=i.map(t=>t[0]),u=n.data.get(r.dataId).values,c=fy(r.shape),h=r.shape.length,d=Oy(r.shape),p=fy(o),f=o.length,m=Oy(o),g=ky(r.dtype,p);0!==a&&g.fill(a);for(let y=0;y<c;y++)g[Vy(By(y,h,d).map((t,e)=>t+l[e]),f,m)]=u[y];return{dataId:n.write(g,o,r.dtype),shape:o,dtype:r.dtype}}},sU=zP((t,e)=>Math.pow(t,e)),rU=sz(qv,sU),iU={kernelName:qv,backendName:"cpu",kernelFunc:rU};function aU(t,e,n,s){const[r,i]=eS(t,s),a=H_(e,"int32"),o=My(fy(r),a),l=fy(i);for(let u=0;u<o.length;++u){const t=u*l;let e=1;for(let s=0;s<l;++s)e*=n[t+s];o[u]=e}return{outVals:o,outShape:r,outDtype:a}}const oU={kernelName:Xv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s;NP(r,"prod");const o=r.shape.length,l=_y(i,r.shape),u=rS(l,o);let c=l,h=r;const d=[];null!=u&&(h=xz({inputs:{x:r},backend:n,attrs:{perm:u}}),d.push(h),c=aS(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=aU(h.shape,h.dtype,p,c);let y=m;return a&&(y=nS(m,l)),d.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(y,g,f)}};function lU(t,e,n,s){if(t===e||t<e&&n<0||e<t&&n>1)return My(0,s);const r=My(Math.abs(Math.ceil((e-t)/n)),s);e<t&&1===n&&(n=-1),r[0]=t;for(let i=1;i<r.length;i++)r[i]=r[i-1]+n;return r}const uU={kernelName:Zv,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:i,step:a}=n,o=lU(s,r,a,i);return e.makeTensorInfo([o.length],i,o)}},cU=$P(Qv,t=>1/t),hU={kernelName:Qv,backendName:"cpu",kernelFunc:cU},dU={kernelName:sw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;NP(r,"resizeBilinear");const l=Oy(r.shape),[u,c]=o,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(fy([h,u,c,f])),y=[i&&u>1?d-1:d,i&&c>1?p-1:p],b=[i&&u>1?u-1:u,i&&c>1?c-1:c];let v=0;const w=y[0]/b[0],_=y[1]/b[1];for(let x=0;x<h;x++)for(let t=0;t<u;t++){let e;e=a?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),s=e-n,r=Math.min(d-1,Math.ceil(e)),i=x*l[0]+n*l[1],o=x*l[0]+r*l[1];for(let t=0;t<c;t++){let e;e=a?_*(t+.5)-.5:_*t;const n=Math.max(0,Math.floor(e)),r=e-n,u=Math.min(p-1,Math.ceil(e)),c=i+n*l[2],h=o+n*l[2],d=i+u*l[2],y=o+u*l[2];for(let t=0;t<f;t++){const e=m[c+t],n=m[h+t],i=e+(m[d+t]-e)*r;g[v++]=i+(n+(m[y+t]-n)*r-i)*s}}}return n.makeTensorInfo([h,u,c,f],"float32",g)}},pU={kernelName:rw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:a}=s;NP([i,r],"resizeBilinearGrad");const o=Oy(r.shape),[l,u,c,h]=r.shape,[,d,p]=i.shape,f=new Float32Array(l*u*c*h),m=[a&&d>1?u-1:u,a&&p>1?c-1:c],g=[a&&d>1?d-1:d,a&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(i.dataId).values;let w=0;for(let _=0;_<l;_++){const t=_*o[0];for(let e=0;e<d;e++){const n=e*y,s=Math.floor(n),r=Math.min(Math.ceil(n),u-1),i=t+s*o[1],a=t+r*o[1],l=n-s,d=1-l;for(let t=0;t<p;t++){const e=t*b,n=Math.floor(e),s=Math.min(Math.ceil(e),c-1),r=e-n,u=1-r,p=i+n*o[2],m=i+s*o[2],g=a+n*o[2],y=a+s*o[2],_=d*u,x=d*r,k=l*u,C=l*r;for(let t=0;t<h;t++){const e=v[w++];f[p+t]+=e*_,f[m+t]+=e*x,f[g+t]+=e*k,f[y+t]+=e*C}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}},fU={kernelName:ew,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;NP(r,"resizeNearestNeighbor");const l=Oy(r.shape),[u,c]=o,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(h*u*c*f),y=[i&&u>1?d-1:d,i&&c>1?p-1:p],b=[i&&u>1?u-1:u,i&&c>1?c-1:c],v=y[0]/b[0],w=y[1]/b[1];let _=0;for(let x=0;x<h;x++){const t=x*l[0];for(let e=0;e<u;e++){const n=a?v*(e+.5):v*e;let s=Math.min(d-1,i?Math.round(n):Math.floor(n));a&&(s=Math.max(0,s));const r=t+s*l[1];for(let t=0;t<c;t++){const e=a?w*(t+.5):w*t;let n=Math.min(p-1,i?Math.round(e):Math.floor(e));a&&(n=Math.max(0,n));const s=r+n*l[2];for(let t=0;t<f;t++)g[_++]=m[s+t]}}}return n.makeTensorInfo([h,u,c,f],r.dtype,g)}},mU={kernelName:nw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:a}=s;NP([i,r],"resizeNearestNeighborGrad");const o=Oy(r.shape),l=Oy(i.shape),[u,c,h,d]=r.shape,[,p,f]=i.shape,m=new Float32Array(u*c*h*d),g=n.data.get(i.dataId).values,y=[a&&p>1?c-1:c,a&&f>1?h-1:h],b=[a&&p>1?p-1:p,a&&f>1?f-1:f],v=y[0]/b[0],w=y[1]/b[1],_=1/v,x=1/w,k=2*Math.ceil(_)+2,C=2*Math.ceil(x)+2;for(let S=0;S<u;S++){const t=S*o[0];for(let e=0;e<c;e++){const n=t+e*o[1],s=Math.floor(e*_),r=Math.floor(s-k/2);for(let i=0;i<h;i++){const s=n+i*o[2],u=Math.floor(i*x),y=Math.floor(u-C/2);for(let n=0;n<d;n++){let o=0;for(let s=0;s<k;s++){const u=s+r;if(u<0||u>=p)continue;const d=t+u*l[1],m=u*v;if(e===Math.min(c-1,a?Math.round(m):Math.floor(m)))for(let t=0;t<C;t++){const e=t+y;if(e<0||e>=f)continue;const s=d+e*l[2],r=e*w;i===Math.min(h-1,a?Math.round(r):Math.floor(r))&&(o+=g[s+n])}}m[s+n]=o}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}},gU={kernelName:aw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:i}=s;NP(r,"reverse");const a=r.shape.length,o=_y(i,r.shape);if(0===a)return DP({inputs:{x:r},backend:n});const l=new R_(r.shape,r.dtype),u=n.bufferSync(r);for(let c=0;c<l.size;c++){const t=l.indexToLoc(c),e=t.slice();o.forEach(t=>e[t]=r.shape[t]-1-e[t]),l.set(u.get(...e),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},yU={kernelName:qw,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:a}=e,o=n,l=ky(s.dtype,fy(s.shape)),[u,c,h,d]=s.shape,[p,f]=NE(a,c,h),m=Math.sin(r),g=Math.cos(r),y=o.data.get(s.dataId).values;for(let b=0;b<u;b++){const t=b*h*c*d;for(let e=0;e<c;e++){const n=e*(h*d);for(let s=0;s<h;s++){const r=s*d;for(let a=0;a<d;a++){const o=[u,e,s,a],b=o[2],v=o[1];let w=(b-p)*g-(v-f)*m,_=(b-p)*m+(v-f)*g;w=Math.round(w+p),_=Math.round(_+f);let x=i;"number"!=typeof i&&(x=3===a?255:i[a]),w>=0&&w<h&&_>=0&&_<c&&(x=y[t+_*(h*d)+w*d+a]),l[t+n+r+a]=x}}}}return{dataId:o.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},bU=$P(ow,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1}),vU={kernelName:ow,backendName:"cpu",kernelFunc:bU},wU=tV(t=>1/Math.sqrt(t)),_U=RP(lw,wU),xU={kernelName:lw,backendName:"cpu",kernelFunc:_U};function kU(t,e,n,s,r,i,a,o,l,u){const c=[s/r,r],h=t.values,d=e.values;if(0===s)return Xx(n,e.dtype);const p=Xx(c,e.dtype);p.values.fill(l);for(let f=0;f<i;f++){const t=[];let i=0;for(let e=0;e<a;e++){const n=h[f*a+e];t.push(n),i+=n*o[e]}if(i<0||i>=s/r)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<r;n++)u?p.values[i*r+n]+=d[f*r+n]:p.values[i*r+n]=0===e.rank?d[0]:d[f*r+n]}return p}const CU={kernelName:uw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ME(0,r,a),d=kU(n.bufferSync(r),n.bufferSync(i),a,h,u,l,o,c,0,!0);return n.makeTensorInfo(a,d.dtype,d.values)}},SU={kernelName:cw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e;NP([s,r,i],"select");const a=s.shape.length,o=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=H_(r.dtype,i.dtype),h=My(fy(r.shape),c);let d=0;const p=0===a||a>1||1===r.shape.length?1:fy(r.shape.slice(1));for(let f=0;f<o.length;f++)for(let t=0;t<p;t++)h[d++]=1===o[f]?l[f]:u[f];return n.makeTensorInfo(r.shape,c,h)}},IU=PE,EU=zE,NU=$P(hw,t=>t>=0?EU*t:IU*(Math.exp(t)-1)),TU={kernelName:hw,backendName:"cpu",kernelFunc:NU},AU=$P(mw,t=>t<0?-1:t>0?1:0),$U={kernelName:mw,backendName:"cpu",kernelFunc:AU},RU=$P(pw,t=>Math.sin(t)),OU={kernelName:pw,backendName:"cpu",kernelFunc:RU},FU=$P(fw,t=>Math.sinh(t)),DU={kernelName:fw,backendName:"cpu",kernelFunc:FU},LU=Math.log(1.1920928955078125e-7)+2,MU=$P(yw,t=>{const e=t>-LU,n=t<LU,s=Math.exp(t);let r;return r=n?s:e?t:Math.log(1+s),r}),PU={kernelName:yw,backendName:"cpu",kernelFunc:MU},zU={kernelName:ww,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,paddings:a}=s;NP([r],"spaceToBatchND");const o=fy(i),l=[[0,0]];l.push(...a);for(let g=1+i.length;g<r.shape.length;++g)l.push([0,0]);const u=nU.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=TE(u.shape,i,o,!1),h=AE(c.length,i.length,!1),d=$E(u.shape,i,o,!1),p=uz({inputs:{x:u},backend:n,attrs:{shape:c}}),f=xz({inputs:{x:p},backend:n,attrs:{perm:h}}),m=uz({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function VU(t,e,n,s,r,i,a){const o=e[0],l=i[0],u=new Array(l),c=new Array(o),h=e[1];if(0===l){if(0!==o)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${o}`);return[Cy(n,0),[0,h],Cy(r,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const e=t[g*h];if(e<0)throw new Error(`indices(${g}, 0) is invalid: ${e} < 0`);if(e>=l)throw new Error(`indices(${g}, 0) is invalid: ${e} >= ${l}`);++f[e],d=d&&e>=p,p=e}let m=!0;for(let g=0;g<l;++g){const t=0===f[g];u[g]=t,m=m&&!t,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const e=t,n=s;for(let t=0;t<o;++t)c[t]=t;return[e,[o,h],n,u,c]}{const e=f[l-1],i=Cy(n,e*h),d=Cy(r,e),p=new Array(l).fill(0);for(let n=0;n<o;++n){const e=t[n*h],r=(0===e?0:f[e-1])+p[e];p[e]++;for(let s=0;s<h;++s)i[r*h+s]=t[n*h+s];d[r]=s[n],c[n]=r}for(let t=0;t<l;++t)if(0===p[t]){const e=0===t?0:f[t-1];i[e*h+0]=t;for(let t=1;t<h;++t)i[e*h+t]=0;d[e]=a}return[i,[e,h],d,u,c]}}const BU={kernelName:kw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values[0],[h,d,p,f,m]=VU(o,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(t=>Number(t)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}};function WU(t,e,n,s,r){const i=fy(s),a=e[0],o=r.length,l=[];let u=1,c=-1;for(let g=0;g<o;++g){const t=r[g];if(-1===t){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,l.push(1)}else{if(t<0)throw new Error(`size ${g} must be non-negative, not ${t}`);u*=t,l.push(t)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(i/u);if(u*t!==i)throw new Error(`Input to reshape is a SparseTensor with ${i}\n          dense values, but the requested shape requires a multiple of ${u}. inputShape=${s} outputShape= ${l}`);l[c]=t}const h=fy(l);if(h!==i)throw new Error(`Input to reshape is a tensor with ${i} dense values, but the requested shape has ${h}. inputShape=${s} outputShape=${l}`);const d=s.length,p=[];if(d>0){p[d-1]=1;for(let t=d-2;t>=0;--t)p[t]=p[t+1]*s[t+1]}const f=[];if(o>0){f[o-1]=1;for(let t=o-2;t>=0;--t)f[t]=f[t+1]*l[t+1]}const m=Cy(n,a*o);for(let g=0;g<a;++g){let e=0;for(let n=0;n<d;++n)e+=t[g*d+n]*p[n];for(let t=0;t<o;++t)m[g*o+t]=Math.trunc(e/f[t]),e%=f[t]}return[m,[a,o],l]}const UU={kernelName:Cw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:i}=e;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.data.get(r.dataId).values),o=n.data.get(s.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,c,h]=WU(o,s.shape,s.dtype,a,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}};function jU(t,e,n,s,r,i=!1,a=0){const o=s.length;if(o!==r.length)throw new Error("segmentIds and indices should have same size.");const l=[e[0],t.length/e[0]],u=l[1],c=o>0?r[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=e.slice();h[0]=c;const d=Cy(n,h.reduce((t,e)=>t*e,1));if(0===o)return c>0&&d.fill(a),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let e=0;if(f<o){if(e=r[f],g===e){++f;continue}if(g>=e)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(`Segment id ${g} out of range [0, ${c}), possibly because segmentIds input is not sorted.`);g>m&&d.fill(a,m*u,g*u);for(let n=p;n<f;++n){const e=s[n];if(e<0||e>=l[0])throw new Error(`Bad: indices[${n}] == ${s[n]} out of range [0, ${l[0]})`);for(let n=0;n<u;n++)d[g*u+n]+=t[e*u+n]}if(i)for(let t=0;t<u;t++)d[g*u+t]/=f-p;if(p=f,++f,m=g+1,g=e,f>o)break}return m<c&&d.fill(a,m*u,c*u),[d,h]}const HU={kernelName:Sw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);const a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=jU(a,s.shape,s.dtype,o,l,!0);return n.makeTensorInfo(c,s.dtype,u)}},GU={kernelName:Iw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);const a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=jU(a,s.shape,s.dtype,o,l);return n.makeTensorInfo(c,s.dtype,u)}},qU={kernelName:Ew,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=ME(0,r,o),p=kU(n.bufferSync(r),n.bufferSync(i),o,d,c,u,l,h,n.data.get(a.dataId).values[0],!1);return n.makeTensorInfo(o,p.dtype,p.values)}},KU={kernelName:_w,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=_y(a,r.shape)[0],l=uN(r,i,o),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(t=>{const e=[...c];e[o]=t;const s=Kz({inputs:{x:r},backend:n,attrs:{begin:u,size:e}});return u[o]+=t,s})}},XU=$P(bw,t=>Math.sqrt(t)),ZU={kernelName:bw,backendName:"cpu",kernelFunc:XU},YU={kernelName:Tw,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;NP(n,"square");const r=s.data.get(n.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const t=r[a];i[a]=t*t}return{dataId:s.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},QU=zP((t,e)=>{const n=t-e;return n*n}),JU=sz(Nw,QU),tj={kernelName:Nw,backendName:"cpu",kernelFunc:JU},ej=$P(Hw,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),nj={kernelName:Hw,backendName:"cpu",kernelFunc:ej};function sj(t,e,n,s){const r=Xx(t,e.dtype);for(let i=0;i<r.size;i++){const t=r.indexToLoc(i),a=new Array(t.length);for(let e=0;e<a.length;e++)a[e]=t[e]*n[e]+s[e];r.set(e.get(...a),...t)}return r}const rj={kernelName:Aw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;NP(r,"stridedSlice");const{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=Ik(r.shape,i,a,o,l,u,c,h,d),v=uz({inputs:{x:r},backend:n,attrs:{shape:y}});let w;if(p){const t=Kz({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});w=uz({inputs:{x:t},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(t)}else if(b.some(t=>0===t))w=n.makeTensorInfo(b,r.dtype,[]);else{const t=sj(b,n.bufferSync(v),m,f);w=n.makeTensorInfo(t.shape,t.dtype,t.values)}const _=uz({inputs:{x:w},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),_}};class ij{constructor(t,e,n,s,r,i){this.separator=x_(t),this.nGramWidths=e,this.leftPad=x_(n),this.rightPad=x_(s),this.padWidth=r,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,s,r,i){for(let a=0;a<r;++a){const o=this.getPadWidth(i),l=Math.max(0,o-a),u=Math.max(0,o-(r-(a+1))),c=i-(l+u),h=e+(l>0?0:a-o);let d=0;d+=l*this.leftPad.length;for(let e=0;e<c;++e)d+=t[h+e].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[s+a]=new Uint8Array(d);const p=n[s+a];let f=0;const m=t=>t.forEach(t=>p[f++]=t);for(let t=0;t<l;++t)m(this.leftPad),m(this.separator);for(let e=0;e<c-1;++e)m(t[h+e]),m(this.separator);if(c>0){m(t[h+c-1]);for(let t=0;t<u;++t)m(this.separator),m(this.rightPad)}else{for(let t=0;t<u-1;++t)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(t,e){const n=t.length,s=e.length;if(s>0){let t=e[0];if(0!==t)throw new Error(`First split value must be 0, got ${t}`);for(let r=1;r<s;++r){let s=e[r]>=t;if(s=s&&e[r]<=n,!s)throw new Error(`Invalid split value ${e[r]}, must be in [${t}, ${n}]`);t=e[r]}if(t!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${t}`)}const r=s-1,i=Cy("int32",s);if(0===n||0===s){const t=new Array(n);for(let e=0;e<=r;++e)i[e]=0;return[t,i]}i[0]=0;for(let o=1;o<=r;++o){const t=e[o]-e[o-1];let n=0;this.nGramWidths.forEach(e=>{n+=this.getNumNGrams(t,e)}),this.preserveShort&&t>0&&0===n&&(n=1),i[o]=i[o-1]+n}const a=new Array(i[r]);for(let o=0;o<r;++o){const n=e[o];let s=i[o];if(this.nGramWidths.forEach(r=>{const i=this.getNumNGrams(e[o+1]-e[o],r);this.createNGrams(t,n,a,s,i,r),s+=i}),this.preserveShort&&s===i[o]){const r=e[o+1]-e[o];if(0===r)continue;this.createNGrams(t,n,a,s,1,r+2*this.padWidth)}}return[a,i]}}function aj(t,e,n,s,r,i,a,o){return new ij(n,s,r,i,a,o).compute(t,e)}const oj={kernelName:$w,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=aj(d,p,r,i,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function lj(t,e,n){if(!t.length)return[];if(0===e.length){const e=new Array(t.length);for(let n=0;n<t.length;++n)e[n]=t.subarray(n,n+1);return e}if(1===e.length){const s=e[0],r=[];let i=t.indexOf(s);for(;-1!==i;){const e=t.subarray(0,i);n&&0===e.length||r.push(e),i=(t=t.subarray(i+1)).indexOf(s)}return n&&0===t.length||r.push(t),r}const s=[];let r=0;for(let i=0;i<t.length+1;i++)if(i===t.length||-1!==e.indexOf(t[i])){const e=t.subarray(r,i);n&&0===e.length||s.push(e),r=i+1}return s}function uj(t,e,n){const s=t.length,r=[];let i=0,a=0;const o=new Array(s);for(let d=0;d<s;++d){const s=lj(t[d],e,n),l=s.length;o[d]=l,i+=l,a=Math.max(a,l),r.push(...s)}const l=Cy("int32",2*i),u=new Array(i),c=[s,a];let h=0;for(let d=0;d<s;++d)for(let t=0;t<o[d];++t)l[2*h]=d,l[2*h+1]=t,u[h]=r[h],++h;return[l,u,c]}const cj={kernelName:Rw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values[0],[u,c,h]=uj(o,l,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function hj(t,e){const n=Cy("int32",t.length);for(let s=0;s<t.length;++s)n[s]=b_(t[s]).modulo(e).getLowBitsUnsigned();return n}const dj={kernelName:Ow,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:i}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=hj(n.data.get(i.dataId).values,r);return n.makeTensorInfo(i.shape,"int32",a)}},pj=$P(Dw,t=>Math.tan(t)),fj={kernelName:Dw,backendName:"cpu",kernelFunc:pj},mj=$P(Lw,t=>Math.tanh(t));function gj(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=Xx(n,t.dtype);for(let r=0;r<s.values.length;++r){const e=s.indexToLoc(r),n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=e[s]%t.shape[s];const i=t.locToIndex(n);s.values[r]=t.values[i]}return s}function yj(t,e,n,s,r){const i=e[e.length-1],[a,o]=[t.length/i,i],l=ky(n,a*s),u=ky("int32",a*s);for(let h=0;h<a;h++){const e=h*o,n=t.subarray(e,e+o),r=[];for(let t=0;t<n.length;t++)r.push({value:n[t],index:t});r.sort((t,e)=>e.value-t.value);const i=h*s,a=l.subarray(i,i+s),c=u.subarray(i,i+s);for(let t=0;t<s;t++)a[t]=r[t].value,c[t]=r[t].index}const c=e.slice();return c[c.length-1]=s,[Xx(c,n,l),Xx(c,"int32",u)]}function bj(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return ly(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;return n<0?e<=1?n=0:n+=e*(Math.trunc(-n/(e-1))+1):n>e-1&&(e<=1?n=0:n-=e*Math.trunc(n/(e-1))),ly(0,n,e-1)}(t,e);case"nearest":return function(t,e){return ly(0,t,e-1)}(t,e);case"constant":default:return function(t,e){return t}(t)}}function vj(t,e,n,s,r,i,a,o,l,u,c){return 0<=o&&o<e&&0<=l&&l<n?t[a*s+o*r+l*i+u]:c}function wj(t,e,n,s,r,i,a,o,l,u,c){return vj(t,e,n,s,r,i,a,Math.round(o),Math.round(l),u,c)}function _j(t,e,n,s,r,i,a,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*vj(t,e,n,s,r,i,a,h,d,u,c)+(l-d)*vj(t,e,n,s,r,i,a,h,f,u,c))+(o-h)*((f-l)*vj(t,e,n,s,r,i,a,p,d,u,c)+(l-d)*vj(t,e,n,s,r,i,a,p,f,u,c))}function xj(t,e,n,s){const r=_y(e,n)[0],i=[1,n[0],1];for(let f=0;f<r;f++)i[0]*=n[f];i[1]=n[r];for(let f=r+1;f<n.length;f++)i[2]*=n[f];const a={},o=new Int32Array(n[r]),l=new R_(i,s,t),u=[],c=1===i[0]&&1===i[2];for(let f=0;f<n[r];f++){let e;if(c)e=t[f].toString();else{const t=[];for(let e=0;e<i[0];e++)for(let n=0;n<i[2];n++)t.push(l.get(e,f,n));e=t.join(",")}if(void 0!==a[e])o[f]=a[e];else{const t=Object.keys(a).length;a[e]=t,o[f]=t,u.push(f)}}const h=i.slice();h[1]=Object.keys(a).length;const d=new R_(h,s);u.forEach((t,e)=>{for(let n=0;n<i[0];n++)for(let s=0;s<i[2];s++)d.set(l.get(n,t,s),n,e,s)});const p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const kj=[pz,mz,yz,vz,lz,wz,Cz,Sz,Iz,Ez,Tz,$z,Oz,Lz,Pz,Wz,Uz,jz,Hz,dz,Gz,Zz,Jz,nz,sV,iV,YP,aV,hV,fV,mV,pV,yV,bV,gV,wV,xV,kV,CV,SV,IV,NV,TV,AV,$V,RV,FV,OV,cB,BV,FP,WV,HV,JV,nB,rB,oB,bB,wB,_B,CB,EB,NB,TB,$B,OB,LB,zB,LP,VB,uV,WB,jB,GB,PP,XB,QB,tW,sW,iW,lW,cW,pW,fW,mW,_W,xW,kW,CW,SW,IW,bW,EW,NW,$W,RW,DW,PW,PV,VW,WW,jW,GW,XW,ZW,JW,eU,nU,iU,WP,oU,uU,tz,hU,jP,GP,cz,dU,pU,fU,mU,gU,yU,vU,xU,CU,SU,TU,KP,$U,OU,DU,Xz,MW,PU,zU,BU,UU,HU,GU,qU,KU,ZU,YU,tj,nj,rj,oj,cj,dj,fB,VV,fj,{kernelName:Lw,backendName:"cpu",kernelFunc:mj},{kernelName:Mw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;NP(r,"tile");const a=gj(n.bufferSync(r),i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}},{kernelName:Pw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i}=s;NP(r,"topk");const a=n.data.get(r.dataId).values,[o,l]=yj(a,r.shape,r.dtype,i);return[n.makeTensorInfo(o.shape,o.dtype,o.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},kz,{kernelName:zw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=r.shape,[f,m]=null!=u?u:[h,d],g=[c,f,m,p],y=Oy(r.shape),b=y[0],v=y[1],w=y[2],_=ky(r.dtype,fy(g));_.fill(l);const x=s.data.get(r.dataId).values,k=s.data.get(i.dataId).values;for(let C=0;C<c;++C){const t=1===i.shape[0]?k:k.subarray(8*C,8*C+8);for(let e=0;e<f;++e)for(let n=0;n<m;++n)for(let s=0;s<p;++s){let r;const i=t[6]*n+t[7]*e+1;if(0===i)continue;const u=(t[3]*n+t[4]*e+t[5])/i,c=bj((t[0]*n+t[1]*e+t[2])/i,d,o),p=bj(u,h,o);switch(a){case"nearest":r=wj(x,h,d,b,v,w,C,p,c,s,l);break;case"bilinear":r=_j(x,h,d,b,v,w,C,p,c,s,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}_[C*b+e*v+n*w+s]=r}return s.makeTensorInfo(g,r.dtype,_)}return{dataId:s.write(_,g,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:Bw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;NP(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:u}=xj(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([u.length],"int32",u)]}},{kernelName:Ww,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,o=r.shape[i],l=new Array(a-1);let u=0;for(let p=0;p<a;p++)p!==i&&(l[u++]=r.shape[p]);const c=new Array(a).fill(0),h=r.shape.slice();h[i]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[i]=p;const t=Kz({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});d[p]=uz({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}},{kernelName:Uw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:i}=e,{numSegments:a}=s;NP(r,"unsortedSegmentSum");const o=[],l=[],u=r.shape.length-i.shape.length;let c=i;for(let d=0;d<u;++d){const t=sB({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=t,l.push(t)}for(let d=0;d<a;++d){const t=v_(d,"int32"),e=n.makeTensorInfo([],"int32",t),s=jV({inputs:{a:e,b:c},backend:n}),i=ez({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),a=MV({inputs:{a:i,b:r},backend:n}),u=zV({inputs:{x:a},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(e),l.push(s),l.push(i),l.push(a),l.push(u)}const h=tU({inputs:o,backend:n,attrs:{axis:0}});return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),h}},QW];for(const M7 of kj)n_(M7);const Cj={},Sj={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ij(t){if(!(t in Cj)){const e=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete Cj[t]},!1),1===t?e.getContext("webgl",Sj)||e.getContext("experimental-webgl",Sj):e.getContext("webgl2",Sj)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;Cj[t]=e}const e=Cj[t];return e.isContextLost()?(delete Cj[t],Ij(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Cj[t])}var Ej,Nj,Tj;function Aj(t,e){return[e,t]}function $j(t){const e=fy(t);return yy(Math.ceil(e/4))}function Rj(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Oj(t,e){const n=t;let s,r,i,a,o,l,u,c,h,d;return 2===Hy().getNumber("WEBGL_VERSION")?(s=n.R32F,r=n.R16F,i=n.RGBA16F,a=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(s=t.RGBA,r=t.RGBA,i=t.RGBA,a=n.RGBA,o=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function Fj(t,e){const n=e();return Hy().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}function Dj(t){return!!(Hy().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function Lj(t,e){return Uj(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(Ej||(Ej={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(Nj||(Nj={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Tj||(Tj={}));const Mj=/ERROR: [0-9]+:([0-9]+):/g;function Pj(t,e){if(Fj(t,()=>t.validateProgram(e)),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function zj(t,e,n,s,r,i,a){const o=t.getAttribLocation(e,n);return-1!==o&&(Fj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),Fj(t,()=>t.vertexAttribPointer(o,r,t.FLOAT,!1,i,a)),Fj(t,()=>t.enableVertexAttribArray(o)),!0)}function Vj(t,e,n){Fj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Fj(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function Bj(t,e){Fj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Fj(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Wj(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function Uj(t,e,n){const s=Fj(t,()=>e());if(null==s)throw new Error(n);return s}function jj(t,e=2){return fy(t.slice(0,t.length-e))}function Hj(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Gj(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[jj(t),...Hj(t)]),e}function qj(t){return t%2==0}function Kj(t,e){if(my(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],s=e.slice(-1)[0];if(n===s)return!0;if(qj(n)&&qj(s)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&qj(t[0])&&qj(e[0])}let Xj,Zj;function Yj(t,e){return null!=t.getExtension(e)}function Qj(t){try{if(null!=Ij(t))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Jj(t){const e=Oj(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const r=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(s),r}function tH(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&cy("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const eH=Hy();function nH(){let t,e,n,s,r,i,a,o,l,u;return 2===Hy().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function sH(t,e,n="index"){const s=Oy(e);return s.map((e,r)=>`int ${t[r]} = ${n} / ${e}; ${r===s.length-1?`int ${t[r+1]} = ${n} - ${t[r]} * ${e}`:`index -= ${t[r]} * ${e}`};`).join("")}function rH(t){const e=Oy(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}eH.registerFlag("HAS_WEBGL",()=>eH.getNumber("WEBGL_VERSION")>0),eH.registerFlag("WEBGL_VERSION",()=>Qj(2)?2:Qj(1)?1:0),eH.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),eH.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===eH.get("WEBGL_VERSION")),eH.registerFlag("WEBGL_CPU_FORWARD",()=>!0),eH.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),eH.registerFlag("WEBGL_PACK",()=>eH.getBool("HAS_WEBGL")),eH.registerFlag("WEBGL_PACK_NORMALIZATION",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_PACK_CLIP",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_PACK_REDUCE",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_LAZILY_UNPACK",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_CONV_IM2COL",()=>eH.getBool("WEBGL_PACK")),eH.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==Xj){const e=Ij(t);Xj=e.getParameter(e.MAX_TEXTURE_SIZE)}return Xj}(eH.getNumber("WEBGL_VERSION"))),eH.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==Zj){const e=Ij(t);Zj=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Zj)}(eH.getNumber("WEBGL_VERSION"))),eH.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=eH.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=Ij(t);return e=Yj(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:Yj(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),eH.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>eH.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!sx()),eH.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=Ij(t);if(1===t){if(!Yj(e,"OES_texture_float"))return!1}else if(!Yj(e,"EXT_color_buffer_float"))return!1;return Jj(e)}(eH.getNumber("WEBGL_VERSION"))),eH.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!eH.getBool("WEBGL_FORCE_F16_TEXTURES")&&eH.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),eH.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(t){if(0===t)return!1;const e=Ij(t);if(1!==t){if(Yj(e,"EXT_color_buffer_float"))return Jj(e);const t="EXT_color_buffer_half_float";if(Yj(e,t)){const n=e.getExtension(t);return function(t,e){const n=Oj(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(r),i}(e,n)}return!1}return!!Yj(e,"OES_texture_float")&&!!Yj(e,"WEBGL_color_buffer_float")&&Jj(e)}(eH.getNumber("WEBGL_VERSION"))),eH.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=eH.getNumber("WEBGL_VERSION"))&&null!=Ij(t).fenceSync;var t}),eH.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>eH.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),eH.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),eH.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>sx()&&eH.getBool("IS_CHROME")?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}),eH.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);const iH="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class aH{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ej.DENSE;const e=$j(t),n=nH();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${sH(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class oH{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ej.DENSE;const e=$j(t),n=nH();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${sH(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class lH{constructor(t){this.variableNames=["A"],this.outTexUsage=Nj.DOWNLOAD;const e=nH();this.outputShape=t,this.userCode=`\n      ${iH}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class uH{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Nj.DOWNLOAD;const e=nH();this.outputShape=t,this.userCode=`\n      ${iH}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class cH{constructor(t,e,n=!1){this.variableNames=["A"];const s=nH(),[r,i]=e;this.outputShape=t;let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${rH(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${r}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class hH{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const s=nH(),[r,i]=e;this.outputShape=t;let a="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let e=0;e<=1;e++){const n=2*l+e;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${l} < ${t[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${r}.0);\n              values = ${s.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${rH(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${s.output} = ${o};\n      }\n    `}}function dH(t,e,n,s,r,i){!function(t,e){const n=Hy().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const a=function(t){return Uj(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),o=t.TEXTURE_2D;return Fj(t,()=>t.bindTexture(o,a)),Fj(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Fj(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Fj(t,()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST)),Fj(t,()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST)),Fj(t,()=>t.texImage2D(o,0,s,e,n,0,r,i,null)),Fj(t,()=>t.bindTexture(t.TEXTURE_2D,null)),a}function pH(t){return t.internalFormatFloat}function fH(t){return t.internalFormatHalfFloat}function mH(t){return t.downloadTextureFormat}function gH(t){return t.internalFormatPackedFloat}function yH(t){return t.internalFormatPackedHalfFloat}class bH{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Hy().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){Cj[t]=e}(e,t)):this.gl=Ij(e);let n="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(1===Hy().getNumber("WEBGL_VERSION")){const t="OES_texture_half_float";if(this.textureFloatExtension=Lj(this.gl,"OES_texture_float"),Yj(this.gl,t))this.textureHalfFloatExtension=Lj(this.gl,t);else if(Hy().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Yj(this.gl,s))this.colorBufferHalfFloatExtension=Lj(this.gl,s);else if(Hy().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Yj(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Yj(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function(t){return function(t,e){const n=Uj(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Fj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Fj(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=Uj(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Fj(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),Fj(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return Uj(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=Oj(this.gl,this.textureHalfFloatExtension)}get debug(){return Hy().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Fj(t,()=>t.finish()),Fj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Fj(t,()=>t.deleteFramebuffer(this.framebuffer)),Fj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Fj(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Fj(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=Aj(e,n);return dH(t,r,i,pH(s),s.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=Aj(e,n);return dH(t,r,i,fH(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=Aj(e,n);return dH(t,r,i,mH(s),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){Fj(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?Fj(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):Fj(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),Fj(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,s){this.throwIfDisposed(),function(t,e,n,s,r,i){let a,o,l;Fj(t,()=>t.bindTexture(t.TEXTURE_2D,e)),r instanceof Uint8Array?(a=new Uint8Array(n*s*4),o=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*s*4),o=t.FLOAT,l=i.internalFormatPackedFloat),a.set(r),Fj(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,s,0,t.RGBA,o,a)),Fj(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=Rj(e,n);return dH(t,r,i,yH(s),t.RGBA,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=Rj(e,n);return dH(t,r,i,gH(s),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(Bj(this.gl,this.framebuffer),this.outputTexture=null),Fj(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,s){const[r,i]=Aj(e,n),a=new Uint8Array(e*n*4);return Fj(t,()=>t.readPixels(0,0,r,i,s.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,s,r,i){return function(t,e,n,s,r,i,a,o){const l=t,u=new Float32Array(function(t,e){const[n,s]=Rj(t,e);return n*s*4}(i,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,r,i)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const s=function(t,e,n,s){const r=t.createBuffer();Fj(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const i=16*e*n;return Fj(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)),Fj(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),Fj(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,n);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Hy().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,r=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=s.clientWaitSync(r,0,0);return t===s.ALREADY_SIGNALED||t===s.CONDITION_SATISFIED},e=r}else Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n){const s=new Float32Array(e*n*4);return Fj(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e){const n=Uj(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Fj(t,()=>t.shaderSource(n,e)),Fj(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=Mj.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const s=+n[1],r=t.split("\n"),i=r.length.toString().length+2,a=r.map((t,e)=>by((e+1).toString(),i)+t);let o=0;for(let h=0;h<a.length;h++)o=Math.max(a[h].length,o);const l=a.slice(0,s-1),u=a.slice(s-1,s),c=a.slice(s);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${by(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e,t);null==this.vertexShader&&(this.vertexShader=function(t){const e=nH();return function(t,e){const n=Uj(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Fj(t,()=>t.shaderSource(n,e)),Fj(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const s=function(t){return Uj(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return Fj(e,()=>e.attachShader(s,this.vertexShader)),Fj(e,()=>e.attachShader(s,n)),function(t,e){if(Fj(t,()=>t.linkProgram(e)),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,s),this.debug&&Pj(e,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(t,e,n){return Fj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),zj(t,e,"clipSpacePos",n,3,20,0)&&zj(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Fj(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Pj(this.gl,this.program),Fj(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return Uj(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Fj(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,s){Fj(t,()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),Fj(t,()=>t.activeTexture(t.TEXTURE0+n)),Fj(t,()=>t.bindTexture(t.TEXTURE_2D,e))}(t,e,s)),Fj(t,()=>t.uniform1i(n,s))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[s,r]=Rj(e,n);this.setOutputMatrixTextureDriver(t,s,r)}setOutputMatrixWriteRegion(t,e,n,s){this.setOutputMatrixWriteRegionDriver(n,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Pj(this.gl,this.program),Wj(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),Fj(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Fj(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Lj(this.gl,2===Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return ny(function*(){return yield vy(()=>e.disposed||e.isQueryAvailable(t,Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||vy(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Vj(this.gl,t,this.framebuffer),this.debug&&Wj(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Vj(this.gl,this.outputTexture,this.framebuffer),this.debug&&Wj(this.gl)):Bj(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const s=this.gl;Vj(s,t,this.framebuffer),this.debug&&Wj(s),this.outputTexture=t,Fj(s,()=>s.viewport(0,0,e,n)),Fj(s,()=>s.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,s){this.throwIfDisposed(),Fj(this.gl,()=>this.gl.scissor(t,e,n,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:vH}=i;function wH(t,e,n,s){const r=[];t.forEach(t=>{const e=fy(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?r.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(r.push(`uniform sampler2D ${t.name};`),r.push(`uniform int offset${t.name};`))});const i=r.join("\n"),a=t.map(t=>function(t,e,n=!1){let s="";return s+=n?xH(t):_H(t),t.shapeInfo.logicalShape.length<=e.logicalShape.length&&(s+=n?function(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=vH(t.shapeInfo.logicalShape,e.logicalShape),l=TH(a),u=a-i;let c;const h=["x","y","z","w","u","v"];c=0===i?"":a<2&&o.length>=1?"coords = 0;":o.map(t=>`coords.${h[t+u]} = 0;`).join("\n");let d="";d=a<2&&i>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${h[e+u]}`).join(", ");let p="return outputValue;";const f=1===fy(t.shapeInfo.logicalShape),m=1===fy(e.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const t=i-2,e=i-1;o.indexOf(t)>-1&&o.indexOf(e)>-1?p="return vec4(outputValue.x);":o.indexOf(t)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(e)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${s}(${d});\n      ${p}\n    }\n  `}(t,e):function(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=t.shapeInfo.logicalShape.length,a=e.logicalShape.length;if(!t.shapeInfo.isUniform&&i===a&&null==t.shapeInfo.flatOffset&&my(t.shapeInfo.texShape,e.texShape))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const o=TH(a),l=vH(t.shapeInfo.logicalShape,e.logicalShape),u=a-i;let c;const h=["x","y","z","w","u","v"];c=0===i?"":a<2&&l.length>=1?"coords = 0;":l.map(t=>`coords.${h[t+u]} = 0;`).join("\n");let d="";return d=a<2&&i>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${h[e+u]}`).join(", "),`\n    float ${r}() {\n      ${o} coords = getOutputCoords();\n      ${c}\n      return get${s}(${d});\n    }\n  `}(t,e)),s}(t,e,s)).join("\n"),o=e.texShape,l=nH(),u=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let c,h,d=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${kH}\n    ${CH}\n    ${SH}\n  `}(l);return e.isPacked?(c=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(my(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),r=s*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),r=s*Math.ceil(t[t.length-2]/2);let i=r,a="",o="b, r, c";for(let l=2;l<t.length-1;l++)i*=t[t.length-l-1],a=`\n      int b${l} = index / ${i};\n      index -= b${l} * ${i};\n    `+a,o=`b${l}, `+o;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${t.length}(${o});\n    }\n  `}(t,e)}}(e.logicalShape,o),h=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(l)):(c=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=e)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(t,e){return my(t,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=sH(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=sH(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=sH(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=sH(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}var n}(e.logicalShape,o),h=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),s&&(d+=IH),[d,u,h,i,c,a,n].join("\n")}function _H(t){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[s,r]=t.shapeInfo.texShape;if(1===s&&1===r)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[i,a]=t.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${i}, ${a}, ${EH(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${NH(t)}\n      }\n    `;const s=t.shapeInfo.texShape,r=s[0],i=s[1];if(1===i&&1===r)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=EH(e);return 1===i?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===r?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape;if(null!=r&&my(e,r))return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=xy(e);if(i.length<e.length){const e=["row","col"];return`\n      ${_H(AH(t,i))}\n      float ${s}(int row, int col) {\n        return ${s}(${$H(e,a)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${NH(t)}\n      }\n    `;const o=r[0],l=r[1],u=EH(n);return 1===l?`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${o}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===o?`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${u};\n    vec2 uv = uvFromFlat(${o}, ${l}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[1]*e[2],i=e[2],{newShape:a,keptDims:o}=xy(e);if(a.length<e.length){const e=["row","col","depth"];return`\n        ${_H(AH(t,a))}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${$H(e,o)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${i}, 1)));\n        ${NH(t)}\n      }\n    `;const l=t.shapeInfo.texShape,u=l[0],c=l[1],h=t.shapeInfo.flatOffset;return c===r&&null==h?`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${u}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:c===i&&null==h?`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${u}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${i} + depth + ${EH(n)};\n        vec2 uv = uvFromFlat(${u}, ${c}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(t);case 4:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[3],i=e[2]*r,a=e[1]*i,{newShape:o,keptDims:l}=xy(e);if(o.length<e.length){const e=["row","col","depth","depth2"];return`\n      ${_H(AH(t,o))}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${$H(e,l)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${r}, 1)));\n        ${NH(t)}\n      }\n    `;const u=t.shapeInfo.flatOffset,c=t.shapeInfo.texShape,h=c[0],d=c[1];return d===a&&null==u?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:d===r&&null==u?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${EH(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[4],i=e[3]*r,a=e[2]*i,o=e[1]*a,{newShape:l,keptDims:u}=xy(e);if(l.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${_H(AH(t,l))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${$H(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${a}, ${i}, ${r})) +\n          depth3;\n        ${NH(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];return p===o&&null==c?`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===r&&null==c?`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} + depth * ${i} +\n          depth2 * ${r} + depth3 + ${EH(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:i}=xy(e);if(r.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${_H(AH(t,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${$H(e,i)});\n      }\n    `}const a=e[5],o=e[4]*a,l=e[3]*o,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${NH(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];return f===c&&null==h?`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===a&&null==h?`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${a} + depth4 + ${EH(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function xH(t){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${nH().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,r=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],i=nH();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,i=r[0],a=r[1],o=nH();if(null!=r&&my(e,r))return`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${o.texture2D}(${n}, uv);\n      }\n    `;const l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${l[0]}, ${l[1]}, row, col);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===e[0]){const n=[1,2],r=["b","row","col"];return`\n        ${xH(AH(t,e.slice(1)))}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${$H(r,n)});\n        }\n      `}const a=i[0],o=i[1],l=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${o}, ${l*Math.ceil(e[1]/2)}, ${l}, b, row, col);\n      return ${nH().texture2D}(${n}, uv);\n    }\n  `}(t);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],o=a[0],l=a[1],u=Math.ceil(e[n-1]/2);let c=u*Math.ceil(e[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=e[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${r}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${o});\n      return ${nH().texture2D}(${s}, uv);\n    }\n  `}(t)}}const kH="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",CH="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SH="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",IH="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function EH(t){return`offset${t}`}function NH(t){const e=t.name,n=fy(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function TH(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function AH(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function $H(t,e){return e.map(e=>t[e]).join(", ")}function RH(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const s=t.logicalShape,r=e[n],i=r.shape;if(!my(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(t.isUniform&&r.isUniform)return;const a=t.texShape,o=r.isUniform?null:r.texData.texShape;if(!my(a,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${o} must match`)})}const{addImpl:OH,bincountImpl:FH,bincountReduceImpl:DH,ceilImpl:LH,concatImpl:MH,equalImpl:PH,expImpl:zH,expm1Impl:VH,floorImpl:BH,gatherNdImpl:WH,gatherV2Impl:UH,greaterImpl:jH,greaterEqualImpl:HH,lessImpl:GH,lessEqualImpl:qH,linSpaceImpl:KH,logImpl:XH,maxImpl:ZH,maximumImpl:YH,minimumImpl:QH,multiplyImpl:JH,negImpl:tG,notEqualImpl:eG,prodImpl:nG,rangeImpl:sG,rsqrtImpl:rG,simpleAbsImpl:iG,sliceImpl:aG,sparseFillEmptyRowsImpl:oG,sparseReshapeImpl:lG,sparseSegmentReductionImpl:uG,stridedSliceImpl:cG,stringNGramsImpl:hG,stringSplitImpl:dG,stringToHashBucketFastImpl:pG,subImpl:fG,tileImpl:mG,topKImpl:gG,transposeImpl:yG,uniqueImpl:bG}=S;function vG(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function wG(t,e){return 1===e?[t]:vG(t,e)}class _G{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=wG("rc",e),s=TH(e),r=function(t,e,n){if(1===t)return`rc > ${e[0]}`;let s="";for(let r=t-2;r<t;r++)s+=`${n[r]} >= ${e[r]}`,r<t-1&&(s+="||");return s}(e,t,n),i=function(t,e,n,s){if(1===t)return"";const r=s.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),a=function(t,e){const n=t.length,s=function(t,e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<t;n++)i=`${e[e.length-1-n]},`+i;n.push(i)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${s[0]}),\n          cEdge ? 0. : getA(${s[1]}),\n          rEdge ? 0. : getA(${s[2]}),\n          rEdge || cEdge ? 0. : getA(${s[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class xG{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let r=0;r<4;r++){let t="thisRC = rc;";r%2==1&&(t+="thisRC.z += 1;"),r>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}var s;this.userCode=`\n      ${s=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${sH(["r","c","d"],s)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${rH(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class kG{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const s=SG(e,n),r=IG(t,s,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const i=CG(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const t=this.freeTextures[r].shift();return this.usedTextures[r].push(t),t}let a;return s===Tj.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Tj.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Tj.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Tj.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Tj.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[r].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,s){if(null==this.freeTextures)return;const r=SG(n,s),i=IG(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=CG(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s),o=Hy().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[i],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function CG(t,e,n,s,r){const i=function(t,e){switch(t){case Tj.PACKED_2X2_FLOAT32:return gH(e);case Tj.PACKED_2X2_FLOAT16:return yH(e);case Tj.UNPACKED_FLOAT32:return pH(e);case Tj.UNPACKED_FLOAT16:return fH(e);case Tj.PACKED_4X1_UNSIGNED_BYTE:return mH(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,s);let a;if(r){const[e,n]=Rj(t[0],t[1]);a=e*n}else{const[e,n]=Aj(t[0],t[1]);a=e*n}return a*function(t,e){if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}(n,i)}function SG(t,e){if(t===Nj.UPLOAD)return Tj.PACKED_2X2_FLOAT32;if(t===Nj.RENDER||null==t)return function(t){return Hy().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Tj.PACKED_2X2_FLOAT32:Tj.UNPACKED_FLOAT32:t?Tj.PACKED_2X2_FLOAT16:Tj.UNPACKED_FLOAT16}(e);if(t===Nj.DOWNLOAD||t===Nj.PIXELS)return Tj.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function IG(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class EG{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const NG="return abs(x);",TG="return x;";class AG{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class $G{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=wG("rc",e),s=TH(e),r=function(t,e){if(1===t)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const RG=mN,OG={},FG=Hy().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class DG extends iy{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Hy().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=Ij(Hy().getNumber("WEBGL_VERSION"));this.binaryCache=((e=Hy().getNumber("WEBGL_VERSION"))in OG||(OG[e]={}),OG[e]),this.gpgpu=new bH(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new kG(this.gpgpu),this.numMBBeforeWarning=null==Hy().global.screen?1024:Hy().global.screen.height*Hy().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new ry(this,Ak())}nextDataId(){return DG.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((Hy().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Hy().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:e,dtype:n,values:t,usage:Nj.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,e,n,s,r){if(Hy().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:s,values:e,usage:Nj.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:s,complexTensorInfos:r,slice:i,shape:a,isPacked:o}=e;if(null!=i){let e;e=o?new AG(a,TG):new EG(a,TG);const n=this.runWebGLProgram(e,[{dataId:t,shape:a,dtype:s}],s),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===s)return n;const l=null!=this.activeTimers;let u,c;return l&&(u=__()),c="complex64"===s?KE(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):this.getValuesFromTexture(t),l&&(this.downloadWaitMs+=__()-u),this.convertAndCacheOnCPU(t,c)}read(t){var e=this;return ny(function*(){if(e.pendingRead.has(t)){const n=e.pendingRead.get(t);return new Promise(t=>n.push(t))}const n=e.texData.get(t),{values:s,shape:r,slice:i,dtype:a,complexTensorInfos:o,isPacked:l}=n;if(null!=i){let n;n=l?new AG(r,TG):new EG(r,TG);const s=e.runWebGLProgram(n,[{dataId:t,shape:r,dtype:a}],a),i=e.read(s.dataId);return e.disposeIntermediateTensorInfo(s),i}if(null!=s)return e.convertAndCacheOnCPU(t);if(!Hy().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Hy().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,h=null;if("complex64"!==a&&Hy().get("WEBGL_BUFFER_SUPPORTED")){u=e.decode(t);const n=e.texData.get(u.dataId);h=e.gpgpu.createBufferFromTexture(n.texture,...$j(r))}if(e.pendingRead.set(t,[]),"complex64"!==a&&(yield e.gpgpu.createAndWaitForFence()),"complex64"===a){const t=yield Promise.all([e.read(o.real.dataId),e.read(o.imag.dataId)]);c=KE(t[0],t[1])}else if(null==h)c=e.getValuesFromTexture(t);else{const t=fy(r);c=e.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}null!=u&&e.disposeIntermediateTensorInfo(u);const d=e.convertAndCacheOnCPU(t,c),p=e.pendingRead.get(t);return e.pendingRead.delete(t),p.forEach(t=>t(d)),e.pendingDisposal.has(t)&&(e.pendingDisposal.delete(t),e.disposeData(t)&&Ak().removeDataId(t,e),e.pendingDeletes--),d})()}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>k_(t))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return Xx(t.shape,t.dtype,n)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!Dj(n)){if(Hy().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:s}=this.texData.get(t),r=fy(e);if(Hy().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),s=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(s.texture,...$j(e)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),i}const i=Hy().getBool("WEBGL_PACK")&&!0===s,a=i?Gj(e):e,o=i?new uH(a):new lH(a),l=this.runWebGLProgram(o,[{shape:a,dtype:n,dataId:t}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){var e=this;return ny(function*(){const n=e.activeTimers,s=[];let r=!1;null==e.programTimersStack?(e.programTimersStack=s,r=!0):e.activeTimers.push(s),e.activeTimers=s,t();const i=py(e.activeTimers.map(t=>t.query)).filter(t=>null!=t),a=py(e.activeTimers.map(t=>t.name)).filter(t=>null!=t);e.activeTimers=n,r&&(e.programTimersStack=null);const o={uploadWaitMs:e.uploadWaitMs,downloadWaitMs:e.downloadWaitMs,kernelMs:null,wallMs:null};if(Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=yield Promise.all(i);o.kernelMs=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}(t),o.getExtraProfileInfo=()=>t.map((t,e)=>({name:a[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return e.uploadWaitMs=0,e.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:__(),endMs:null}}endTimer(t){return Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=__(),t)}getQueryTime(t){var e=this;return ny(function*(){return Hy().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?e.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs})()}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:s,usage:r,isPacked:i,slice:a}=this.texData.get(t),o=a&&a.origDataId||t,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=e&&(this.numBytesInGPU-=this.computeBytes(s,n),this.textureManager.releaseTexture(e,s,r,i)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=FG){return Hy().getBool("WEBGL_CPU_FORWARD")&&t.every(t=>null==this.texData.get(t.dataId).texture&&fy(t.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){GE("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return RG(t.shape,e)}packedUnaryOp(t,e,n){const s=new AG(t.shape,e),r=this.compileAndRun(s,[t],n);return Ak().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=iG(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Hy().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,NG,t.dtype);const e=new EG(t.shape,NG),n=this.compileAndRun(e,[t]);return Ak().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(t,e,n){let s;if("string"===e&&null!=n&&n.length>0&&Ny(n[0])){const r=n.map(t=>x_(t));s=this.write(r,t,e)}else s=this.write(n,t,e);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:e}}makeOutput(t,e,n){const{dataId:s}=this.makeTensorInfo(t,e,n);return Ak().makeTensorFromDataId(s,t,e,this)}unpackTensor(t){const e=new $G(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new _G(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[jj(t.shape),...Hj(t.shape)],s={dtype:t.dtype,shape:n,dataId:t.dataId},r=[jj(e),...Hj(e)],i=new xG(r,n),a=this.runWebGLProgram(i,[s],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:s,dtype:r}=e,i=Gj(s);let a;return a=n?new oH(i):new aH(i),{dtype:r,shape:s,dataId:this.runWebGLProgram(a,[{shape:i,dtype:r,dataId:t}],r,null,!0).dataId}}runWebGLProgram(t,e,n,s,r=!1){const i=this.makeTensorInfo(t.outputShape,n),a=this.texData.get(i.dataId);if(t.packedOutput&&(a.isPacked=!0),t.outPackingScheme===Ej.DENSE){const e=$j(t.outputShape);a.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(a.usage=t.outTexUsage),0===fy(i.shape))return a.values=ky(i.dtype,0),i;const o=[],l=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&fy(e.shape)<=Hy().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),o.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!Kj(n.shape,e.shape)){const t=e,s=e.shape;e.shape=n.shape,e=this.packedReshape(e,s),o.push(e),n=this.texData.get(e.dataId),t.shape=s}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(i.dataId);const u={shape:i.shape,texData:a,isUniform:!1},c=function(t,e,n){let s="";e.concat(n).forEach(t=>{s+=`${t.shape}_${t.isUniform?"uniform":t.texData.texShape}_${null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0}`});let r=t.constructor.name;return r+="_"+s+"_"+t.userCode,r}(t,l,u),h=this.getAndSaveBinary(c,()=>function(t,e,n,s){const r=e.userCode,i=n.map((t,n)=>{const s={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(s.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:s}}),a=i.map(t=>t.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=wH(i,o,r,e.packedInputs),u=t.createProgram(l);let c=null;const h=t.getUniformLocation(u,"NAN",!1);1===Hy().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(u,"INFINITY",!1));const d={};for(let p=0;p<e.variableNames.length;p++){const n=e.variableNames[p],s=!1;d[n]=t.getUniformLocation(u,n,s),d[`offset${n}`]=t.getUniformLocation(u,`offset${n}`,s)}return{program:e,source:l,webGLProgram:u,uniformLocations:d,inShapeInfos:a,outShapeInfo:o,infLoc:c,nanLoc:h}}(this.gpgpu,t,l,u)),d=null!=this.activeTimers;let p;d&&(p=this.startTimer()),function(t,e,n,s,r){RH(e.inShapeInfos,n),RH([e.outShapeInfo],[s]);const i=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(i,a[0],a[1]):t.setOutputMatrixTexture(i,a[0],a[1]),t.setProgram(e.webGLProgram),1===Hy().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,s)=>{const r=e.program.variableNames[s],i=e.uniformLocations[r],a=e.uniformLocations[`offset${r}`];if(null!=i)if(n.isUniform)if(fy(n.shape)<2)t.gl.uniform1f(i,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(i,e)}else null!=n.texData.slice&&null!=a&&t.gl.uniform1i(a,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,i,s)}),null!=r&&r(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,h,l,u,s),o.forEach(t=>this.disposeIntermediateTensorInfo(t)),d&&(p=this.endTimer(p),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(p)}));const f=Hy().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const t=__();t-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Hy().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&!1===r){const t=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),t}return i}compileAndRun(t,e,n,s,r=!1){return this.runWebGLProgram(t,e,n=n||e[0].dtype,s,r)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Hy().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Rk(()=>{if(!Hy().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Hy().getBool("DEBUG");Hy().set("DEBUG",!1);const e=this.abs(Mk(1e-8)).dataSync()[0];if(Hy().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:s,values:r,texture:i,usage:a,isPacked:o}=e;if(null!=i)return;const l=null!=this.activeTimers;let u;l&&(u=__());let c=e.texShape;if(null==c&&(c=function(t,e=!1){let n=Hy().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?uy(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=xy(t);t=e.newShape}let s=fy(t);if(t.length<=1&&s<=n)return[1,s];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=jj(t);let n=2,r=2;return t.length&&([n,r]=Hj(t)),s=e*(n/2)*(r/2),yy(s).map(t=>2*t)}return yy(s)}(n,o),e.texShape=c),null!=r){const t=Gj(n);let i,a=c[1],h=c[0];const d=r instanceof Uint8Array;o?([a,h]=Rj(c[0],c[1]),i=new hH(t,[h,a],d)):i=new cH(t,[h,a],d);const p=this.makeTensorInfo([h,a],s);this.texData.get(p.dataId).usage=d?Nj.PIXELS:Nj.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),a,h,r);const f=this.runWebGLProgram(i,[p],s,null,!0),m=this.texData.get(f.dataId);e.texture=m.texture,e.texShape=m.texShape,e.isPacked=m.isPacked,e.usage=m.usage,this.disposeIntermediateTensorInfo(p),this.texData.delete(f.dataId),e.values=null,l&&(this.uploadWaitMs+=__()-u)}else{const t=this.acquireTexture(c,a,s,o);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:s}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,s)),n.values}acquireTexture(t,e,n,s){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,s)}computeBytes(t,e){return t[0]*t[1]*Ey(e)}}DG.nextDataId=0,rx()&&Dk("webgl",()=>new DG,2);class LG{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=TC(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class MG{constructor(t,e,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=TC(e,n);const r=this.outputShape.length;let i="";if(s)if(0===r||1===fy(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${TH(r)} coords = getOutputCoords();\n        `,1===r)i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=wG("coords",r);i+=`\n            bool nextRowOutOfBounds =\n              (${t[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${t[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function PG(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const zG={kernelName:ov,backendName:"webgl",kernelFunc:PG};function VG(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.makeTensorInfo(s.shape,"complex64"),a=n.texData.get(i.dataId),o=PG({inputs:{x:s},backend:n}),l=PG({inputs:{x:r},backend:n});return a.complexTensorInfos={real:o,imag:l},i}const BG={kernelName:wb,backendName:"webgl",kernelFunc:VG},WG="return (a < 0.) ? b * a : a;",UG="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",jG={kernelName:pv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:i}=s,a=n.makeTensorInfo([],"float32",v_(i,"float32")),o=Hy().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new MG(UG,r.shape,a.shape):new LG(WG,r.shape,a.shape),l=n.runWebGLProgram(o,[r,a],r.dtype);return n.disposeIntermediateTensorInfo(a),l}},HG="return (a < 0.) ? b * a : a;",GG="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",qG={kernelName:Kv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,i=Hy().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new MG(GG,s.shape,r.shape):new LG(HG,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}};function KG({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,o=i,l=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&null!=n){const t=o.texData.get(a.dataId),e=n(t.values,l);return o.makeTensorInfo(a.shape,l,e)}let u;return u=Hy().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=e?new AG(a.shape,e):new EG(a.shape,t),o.runWebGLProgram(u,[a],l)}}function XG({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:o})=>{const{a:l,b:u}=a,c=o;if(s&&"complex64"===l.dtype){const e=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[s,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,s]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},i={dataId:s.dataId,dtype:s.dtype,shape:u.shape},a=new LG(t,l.shape,u.shape);return c.runWebGLProgram(a,[r,i],H_(n.dtype,s.dtype))}),i=VG({inputs:{real:s,imag:r},backend:c});return c.disposeIntermediateTensorInfo(s),c.disposeIntermediateTensorInfo(r),i}const h=i||H_(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=r){const t=c.texData.get(l.dataId).values,e=c.texData.get(u.dataId).values,n="string"===l.dtype?pN(t):t,s="string"===l.dtype?pN(e):e,[i,a]=r(l.shape,u.shape,n,s,h),o=c.makeTensorInfo(a,h);return c.texData.get(o.dataId).values=i,o}let d;return d=Hy().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new MG(e,l.shape,u.shape,n):new LG(t,l.shape,u.shape),c.runWebGLProgram(d,[l,u],h)}}function ZG(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===t)return e?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return e?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===t)return e?GG:HG;if("leakyrelu"===t)return e?UG:WG;if("sigmoid"===t)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class YG{constructor(t,e,n,s=!1,r=!1,i=!1,a=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const u=Math.ceil((s?t[1]:t[2])/2),c=s?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",d=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";a&&(f=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,m="result = activation(result);");const g=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",b="rc.x";t[0]<e[0]?y=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(b=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          int batchA = ${y};\n          int batchB = ${b};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class QG{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=TC(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const JG="return a * b;";function tq(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,i=H_(s.dtype,r.dtype);if("complex64"===s.dtype){const t=n.texData.get(s.dataId),e=n.texData.get(r.dataId),i=new QG("return areal * breal - aimag * bimag;",s.shape,r.shape),a=new QG("return areal * bimag + aimag * breal;",s.shape,r.shape),o=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(i,o,"float32"),u=n.runWebGLProgram(a,o,"float32"),c=VG({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([s,r])){const t=n.texData.get(s.dataId),e=n.texData.get(r.dataId),[a,o]=JH(s.shape,r.shape,t.values,e.values,i),l=n.makeTensorInfo(o,i);return n.texData.get(l.dataId).values=a,l}let a;return a=Hy().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new MG(JG,s.shape,r.shape):new LG(JG,s.shape,r.shape),n.runWebGLProgram(a,[s,r],i)}const eq={kernelName:Mv,backendName:"webgl",kernelFunc:tq};function nq(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:i}=s,a=n,o=fy(r.shape),l=wy(i,o),u=fy(l);cy(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=a.texData.get(r.dataId);return!c.isPacked||Kj(r.shape,l)||null!==c.texture&&Kj(c.shape,l)?(a.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function(t,e,n){const s=[jj(t.shape),...Hj(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[jj(e),...Hj(e)],a=new xG(i,s),o=n.runWebGLProgram(a,[r],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}(r,l,a)}const sq={kernelName:tw,backendName:"webgl",kernelFunc:nq};class rq{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:i}=t;this.outputShape=[s,i];const a=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=e){const t=1/e;l=`sumValue += dot(values * ${gy(t)?t.toPrecision(2):t}, ones);`}let u="";r%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class iq{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:i}=t;this.outputShape=[s,i];let a="0.0",o="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",o="min"):"max"===e&&(a="-1.0 / 1e-20",o="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function aq(t,e,n,s){const r=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],s=EE(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}(t.shape);let i=t;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:l,outSize:u}=r[a];let c,h;c="mean"===n?0===a?new rq({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},o):new rq({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u}):new iq({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},n),h=i,i=s.runWebGLProgram(c,[i],e),h.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(h)}return i}class oq{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;const s=TH(this.rank),r=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class lq{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let u=0;u<n.length;u++)n[u]=t[e[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=TH(this.rank),r=vG("rc",this.rank),i=new Array(this.rank);for(let u=0;u<e.length;u++)i[e[u]]=r[u];const a=`vec2(${i.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function uq(t,e,n){const s=Hy().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lq(t.shape,e):new oq(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}function cq(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s;return function(t,e,n,s){const r=t.shape.length,i=_y(e,t.shape);let a=i;const o=rS(a,r),l=null!=o;let u=t;l&&(u=uq(t,o,s),a=aS(a.length,r)),sS("sum",a,r);const[c,h]=eS(u.shape,a);let d=c;n&&(d=nS(c,i));const p=fy(h),f=nq({inputs:{x:u},attrs:{shape:[fy(t.shape)/p,p]},backend:s}),m=aq(f,G_(t.dtype),"sum",s),g=nq({inputs:{x:m},attrs:{shape:d},backend:s});return s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(m),l&&s.disposeIntermediateTensorInfo(u),g}(r,i,a,n)}const hq={kernelName:vw,backendName:"webgl",kernelFunc:cq};function dq(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:i}=s,a=n,o=new Array(r.shape.length);for(let u=0;u<o.length;u++)o[u]=r.shape[i[u]];let l;if(a.shouldExecuteOnCPU([r])){const t=a.texData.get(r.dataId),e=yG(t.values,r.shape,r.dtype,i,o);l=a.makeTensorInfo(o,r.dtype),a.texData.get(l.dataId).values=e}else l=uq(r,i,a);return l}const pq={kernelName:Vw,backendName:"webgl",kernelFunc:dq};function fq({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,h=n?t.shape[u-2]:t.shape[u-1],d=s?e.shape[c-1]:e.shape[c-2],p=n?t.shape[u-1]:t.shape[u-2],f=s?e.shape[c-2]:e.shape[c-1],m=t.shape.slice(0,-2),g=e.shape.slice(0,-2),y=fy(m),b=fy(g);cy(u>=2&&c>=2&&(y===b||1===y||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const v=(y>b?t.shape.slice(0,-2):e.shape.slice(0,-2)).concat([p,f]);cy(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const w=n?[y,h,p]:[y,p,h],_=s?[b,f,d]:[b,d,f],x=nq({inputs:{x:t},backend:r,attrs:{shape:w}}),k=nq({inputs:{x:e},backend:r,attrs:{shape:_}}),C=[x,k],S=Math.max(y,b),I=n?x.shape[1]:x.shape[2],E=null!=i,N=null!=a,T="leakyrelu"===l,A=null!=l?ZG(l,!0):null;let $;if((1===p||1===f)&&I>1e3&&!1===(E||N||T||null!=A)){let t=x,e=k;n&&(t=dq({inputs:{x:x},backend:r,attrs:{perm:[0,2,1]}}),C.push(t)),s&&(e=dq({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),C.push(e));const i=1===f;let a=t;1!==f&&(a=nq({inputs:{x:t},backend:r,attrs:{shape:[S,I,1]}}),C.push(a));const o=1===f?2:1;let l=e;i&&(l=nq({inputs:{x:e},backend:r,attrs:{shape:[S,1,I]}}),C.push(l));const u=tq({inputs:{a:a,b:l},backend:r});$=cq({inputs:{x:u},backend:r,attrs:{axis:o,keepDims:!0}}),C.push(u)}else{const l=H_(t.dtype,e.dtype),u=new YG(w,_,[S,p,f],n,s,E,A,N,T),c=[x,k];if(null!=i&&c.push(i),N&&c.push(a),T){const t=r.makeTensorInfo([],"float32",v_(o,"float32"));c.push(t),C.push(t)}$=r.runWebGLProgram(u,c,l)}const R=nq({inputs:{x:$},backend:r,attrs:{shape:v}});C.push($);for(const O of C)r.disposeIntermediateTensorInfo(O);return R}const mq={kernelName:Kw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return fq({a:r,b:i,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},gq="return abs(x);",yq={kernelName:Zy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const t=n.texData.get(s.dataId),e=iG(t.values);return n.makeTensorInfo(s.shape,s.dtype,e)}let r;return r=Hy().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new AG(s.shape,gq):new EG(s.shape,gq),n.runWebGLProgram(r,[s],s.dtype)}},bq=KG({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),vq={kernelName:Yy,backendName:"webgl",kernelFunc:bq},wq=KG({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),_q={kernelName:Qy,backendName:"webgl",kernelFunc:wq},xq="return a + b;",kq=XG({opSnippet:xq,packedOpSnippet:xq,supportsComplex:!0,cpuKernelImpl:OH}),Cq={kernelName:Jy,backendName:"webgl",kernelFunc:kq};class Sq{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const s=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class Iq{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const s=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const Eq={kernelName:tb,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s}=e,r=n;if(1===r.length)return PG({inputs:{x:r[0]},backend:s});if(r.length>Hy().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(r.length/2),n=t({inputs:r.slice(0,e),backend:s}),i=t({inputs:r.slice(e),backend:s});return t({inputs:[n,i],backend:s})}const i=r.map(t=>t.dtype).reduce((t,e)=>H_(t,e)),a=r.map(t=>t.shape),o=Hy().getBool("WEBGL_PACK")?new Iq(r[0].shape,a):new Sq(r[0].shape,a);return s.runWebGLProgram(o,r,i)}},Nq={kernelName:eb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=_y(i,r.shape);let u=l;const c=rS(u,o);let h=r;null!=c&&(h=dq({inputs:{x:r},backend:n,attrs:{perm:c}}),u=aS(u.length,o)),sS("all",u,o);const[d,p]=eS(h.shape,u),f=nq({inputs:{x:h},backend:n,attrs:{shape:[-1,fy(p)]}}),m=aq(f,f.dtype,"all",n);let g;return g=nq(a?{inputs:{x:m},backend:n,attrs:{shape:nS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},Tq={kernelName:nb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=_y(i,r.shape);let u=l;const c=rS(u,o);let h=r;null!=c&&(h=dq({inputs:{x:r},backend:n,attrs:{perm:c}}),u=aS(u.length,o)),sS("any",u,o);const[d,p]=eS(h.shape,u),f=nq({inputs:{x:h},backend:n,attrs:{shape:[-1,fy(p)]}}),m=aq(f,f.dtype,"any",n);let g;return g=nq(a?{inputs:{x:m},backend:n,attrs:{shape:nS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class Aq{constructor(t,e,n){this.variableNames=["A"];const{windowSize:s,batchSize:r,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class $q{constructor(t,e,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,cy(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const r=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),r>1&&this.outputShape.push(r),s||this.variableNames.push("bestIndicesA");const i=this.outputShape,a=i.length,o=TH(a),l=wG("coords",a);let u,c;if(1===r){c=a+1;const t=TH(c);u=`\n        ${t} sourceLocR = ${t}(${l.join()}, 0);\n        ++${l[a-1]};\n        ${t} sourceLocG = ${t}(${l.join()}, 0);\n        ++${l[a-2]};\n        ${t} sourceLocA = ${t}(${l.join()}, 0);\n        --${l[a-1]};\n        ${t} sourceLocB = ${t}(${l.join()}, 0);\n        --${l[a-2]};`}else c=a,u=`\n        ${o} sourceLocR = coords;\n        ++${l[a-1]};\n        ${o} sourceLocG = coords;\n        ++${l[a-2]};\n        ${o} sourceLocA = coords;\n        --${l[a-1]};\n        ${o} sourceLocB = coords;\n        --${l[a-2]};`;const h=["x","y","z","w","u","v"].slice(0,c),d="."+h[c-1],p=h.map(t=>"int "+t),f=wG("sourceLocR",c-1).concat("inIdx.r"),m=wG("sourceLocG",c-1).concat("inIdx.g"),g=wG("sourceLocB",c-1).concat("inIdx.b"),y=wG("sourceLocA",c-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",v=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,_=s?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${_}\n      void main() {\n        ${o} coords = getOutputCoords();\n        bool hasNextCol = ${l[a-1]} < ${i[a-1]-1};\n        bool hasNextRow = ${l[a-2]} < ${i[a-2]-1};\n        ${u}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Rq(t,e,n,s=null){let r=e.shape[0],i=e.shape[1];null!=s&&(r=s.shape[0],i=s.shape[1]);const a=EE(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},l=new Aq(o,n,null==s),u=[e];null!=s&&u.push(s);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=Rq(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function Oq(t,e,n,s=null){const r=null!=s?s.shape:e.shape,i=EE(r[r.length-1]),a=new $q(r,i,n,null==s),o=t.runWebGLProgram(a,null==s?[e]:[e,s],"int32");if(o.shape.length===e.shape.length){const s=Oq(t,e,n,o);return t.disposeIntermediateTensorInfo(o),s}return o}function Fq(t,e,n,s){const r=[n];if(sS("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!Hy().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],[i,a]=eS(e.shape,r),o=fy(a),l=nq({inputs:{x:e},backend:t,attrs:{shape:[-1,o]}});n.push(l);const u=Rq(t,l,s);n.push(u);const c=nq({inputs:{x:u},backend:t,attrs:{shape:i}});return n.forEach(e=>t.disposeIntermediateTensorInfo(e)),c}return Oq(t,e,s)}const Dq={kernelName:sb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;let a=_y(i,r.shape);const o=rS(a,r.shape.length);let l=r;const u=[];null!=o&&(l=dq({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),a=aS(a.length,l.shape.length)),sS("argMax",[a[0]],l.shape.length);const c=Fq(n,l,a[0],"max");return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),c}},Lq={kernelName:rb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i}=s;let a=_y(i,r.shape);const o=rS(a,r.shape.length);let l=r;const u=[];null!=o&&(l=dq({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),a=aS(a.length,l.shape.length)),sS("argMin",[a[0]],l.shape.length);const c=Fq(n,l,a[0],"min");return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),c}},Mq=KG({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Pq={kernelName:ib,backendName:"webgl",kernelFunc:Mq},zq=KG({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),Vq={kernelName:ab,backendName:"webgl",kernelFunc:zq},Bq=KG({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Wq={kernelName:ob,backendName:"webgl",kernelFunc:Bq},Uq=XG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),jq={kernelName:ub,backendName:"webgl",kernelFunc:Uq},Hq=KG({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Gq={kernelName:lb,backendName:"webgl",kernelFunc:Hq};class qq{constructor(t,e,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideHeight,o=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?r?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(g="avgValue / count");const y=4*Math.floor(i/4),b=i%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class Kq{constructor(t,e,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const b="avg"===e;let v="0.0";if(b||(v="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?r?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(w="avgValue / count");const _=4*Math.floor(i/4),x=i%4,k=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${_}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${_};\n            if (${1===x}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===x}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===x}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n          setOutput(${w});\n        }\n      }\n    `}}const Xq={kernelName:cb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;tH(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s;cy(eC(a,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const u=Hk(r.shape,i,a,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&my(u.inShape,u.outShape))return PG({inputs:{x:r},backend:n});const c=new qq(u,"avg",!1);return n.runWebGLProgram(c,[r],"float32")}},Zq={kernelName:db,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=s,c=Gk(r.shape,i,a,[1,1,1],o,l,u),h=new Kq(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class Yq{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Qq{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Jq={kernelName:pb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=s,h=Gk(a.shape,o,l,[1,1,1],u,c),d=new Qq(h);return n.runWebGLProgram(d,[r],a.dtype)}},tK={kernelName:hb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i;tH([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=s,c=Hk(a.shape,o,l,1,u),h=new Yq(c);return n.runWebGLProgram(h,[r],a.dtype)}},eK={kernelName:fb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return fq({a:r,b:i,transposeA:a,transposeB:o,backend:n})}};class nK{constructor(t,e,n,s,r,i){this.outputShape=[],this.variableNames=["x","mean","variance"],TC(t,e),TC(t,n);let a="0.0";null!=s&&(TC(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";null!=r&&(TC(t,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class sK{constructor(t,e,n,s,r,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],TC(t,e),TC(t,n);let a="vec4(0.0)";null!=s&&(TC(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=r&&(TC(t,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const rK={kernelName:nv,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,mean:r,variance:i,offset:a,scale:o}=t;cy(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),cy(null==a||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),cy(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[s,r,i];let c=null;null!=a&&(c=a.shape,u.push(a));let h=null;null!=o&&(h=o.shape,u.push(o));const d=Hy().getBool("WEBGL_PACK_NORMALIZATION")?new sK(s.shape,r.shape,i.shape,c,h,l):new nK(s.shape,r.shape,i.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)}};class iK{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=TH(this.rank),n=`uniform int start[${this.rank}];`,s=function(t){if(1===t)return"sourceLoc";if(t<=6)return aK.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${aK[e]} = start[${e}] + coords.${aK[e]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const aK=["x","y","z","w","u","v"];class oK{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=TH(this.rank),n=wG("coords",this.rank),s=wG("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${r})`,a=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${s[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${a}\n        ${o}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}function lK(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:a}=s,[o,l]=Sk(r,i,a);if(hk(r,o,l),0===fy(l))return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const t=n.texData.get(r.dataId),e=aG(t.values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,e)}const{isPacked:u}=n.texData.get(r.dataId),c=kk(r.shape,o,l);if(u||!c){const t=Hy().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new oK(l):new iK(l),e=t.getCustomSetupFunc(o);return n.runWebGLProgram(t,[r],r.dtype,e)}return n.uploadToGPU(r.dataId),function(t,e,n,s){const r=s.texData.get(t.dataId),i=s.makeTensorInfo(n,t.dtype),a=s.texData.get(i.dataId);Object.assign(a,r),a.refCount=1,a.shape=n,a.dtype=t.dtype;let o=Ck(e,Oy(t.shape));r.slice&&(o+=r.slice.flatOffset),a.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),i}(r,o,l,n)}const uK={kernelName:dw,backendName:"webgl",kernelFunc:lK},cK={kernelName:mb,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:a}=s;cy(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((t,e)=>t*e),l=TE(r.shape,i,o),u=AE(l.length,i.length),c=$E(r.shape,i,o),h=RE(a,i.length),d=OE(c,a,i.length),p=[],f=nq({inputs:{x:r},backend:n,attrs:{shape:l}}),m=dq({inputs:{x:f},backend:n,attrs:{perm:u}}),g=nq({inputs:{x:m},backend:n,attrs:{shape:c}}),y=lK({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(t=>n.disposeIntermediateTensorInfo(t)),y}},hK={kernelName:gb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a}=s,o=n.readSync(r.dataId),l=n.readSync(i.dataId),u=FH(o,l,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,u)}},dK=XG({opSnippet:"return float(a != b);",cpuKernelImpl:eG,dtype:"bool"}),pK={kernelName:zv,backendName:"webgl",kernelFunc:dK};function fK(t){const{inputs:e,backend:n}=t,{input:s}=e;return PG({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.real},backend:n})}const mK={kernelName:Yv,backendName:"webgl",kernelFunc:fK},gK={kernelName:yb,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s,attrs:r}=e,{x:i}=n,{dtype:a}=r;if("complex64"===a){if("complex64"===i.dtype)return PG({inputs:{x:i},backend:s});const e=dS(i.shape),n=t({inputs:{x:i},backend:s,attrs:{dtype:"float32"}}),r=VG({inputs:{real:n,imag:e},backend:s});return e.dispose(),s.disposeIntermediateTensorInfo(n),r}if("complex64"===i.dtype){const e=fK({inputs:{input:i},backend:s}),n=t({inputs:{x:e},backend:s,attrs:{dtype:a}});return s.disposeIntermediateTensorInfo(e),n}if(!Sy(i.dtype,a)){const t=PG({inputs:{x:i},backend:s});return{dataId:t.dataId,shape:t.shape,dtype:a}}if("int32"===a)return function(t,e){const n=new EG(t.shape,"return float(int(x));"),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(i,s);if("bool"===a){const t=s.makeTensorInfo([],"bool",ky("bool",1)),e=dK({inputs:{a:i,b:t},backend:s});return s.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}},yK="return ceil(x);",bK=KG({opSnippet:yK,packedOpSnippet:yK,cpuKernelImpl:LH}),vK={kernelName:bb,backendName:"webgl",kernelFunc:bK};class wK{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class _K{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}const xK={kernelName:vb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;o=Hy().getBool("WEBGL_PACK_CLIP")?new _K(r.shape):new wK(r.shape);const l=o.getCustomSetupFunc(i,a);return n.runWebGLProgram(o,[r],r.dtype,l)}};class kK{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function CK(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const SK={kernelName:_b,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),i=new kK(s.shape),a=[CK(s,r.complexTensorInfos.real),CK(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(i,a,a[0].dtype)}};class IK{constructor(t){this.outputShape=[],this.outputShape=SE(t,1),this.variableNames=t.map((t,e)=>`T${e}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<e.length;s++)n.push(`else if (yC < ${e[s]}) setOutput(getT${s}(yR, yC-${e[s-1]}));`);n.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class EK{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=SE(t,e);const n=this.outputShape,s=n.length,r=TH(s),i=wG("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((t,e)=>`T${e}`);const o=new Array(t.length-1);o[0]=t[0][e];for(let p=1;p<o.length;p++)o[p]=o[p-1]+t[p][e];const l=a[e],u=a.slice(-2),c=a.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let p=1;p<o.length;p++){const t=o[p-1];h+=`\n        if (${l} < ${o[p]}  && ${l} >= ${o[p-1]}) {\n          return getChannel(\n            getT${p}(${NK(a,l,t)}),\n            vec2(${NK(u,l,t)}));\n        }`}const d=o[o.length-1];h+=`\n        return getChannel(\n          getT${o.length}(${NK(a,l,d)}),\n          vec2(${NK(u,l,d)}));`,this.userCode=`\n      float getValue(${a.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${n[s-2]} &&\n            ${i[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function NK(t,e,n){const s=t.indexOf(e);return t.map((t,e)=>e===s?`${t} - ${n}`:t).join()}function TK(t){const{inputs:e,backend:n}=t,{input:s}=e;return PG({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.imag},backend:n})}const AK={kernelName:uv,backendName:"webgl",kernelFunc:TK};function $K(t,e,n){const s=t[0].dtype;if("complex64"===s){const s=t.map(t=>fK({inputs:{input:t},backend:n})),r=t.map(t=>TK({inputs:{input:t},backend:n})),i=$K(s,e,n),a=$K(r,e,n),o=VG({inputs:{real:i,imag:a},backend:n});return s.forEach(t=>n.disposeIntermediateTensorInfo(t)),r.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}let r=n.shouldExecuteOnCPU(t);if("string"===s&&(r=!0),r){const r=t.map(t=>{const s=fy(t.shape.slice(e));return nq({inputs:{x:t},backend:n,attrs:{shape:[-1,s]}})}),i=r.map(t=>({vals:n.readSync(t.dataId),shape:t.shape})),a=SE(r.map(t=>t.shape),1),o=MH(i,a,s,1===r[0].shape[0]),l=SE(t.map(t=>t.shape),e),u=n.makeTensorInfo(l,s,o);return r.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}if(t.length>Hy().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const s=Math.floor(t.length/2),r=$K(t.slice(0,s),e,n),i=$K(t.slice(s),e,n),a=$K([r,i],e,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}if(Hy().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const r=new EK(t.map(t=>t.shape),e);return n.runWebGLProgram(r,t,s)}const{tensors2D:i,outShape:a}=function(t,e,n){const s=SE(t.map(t=>t.shape),e);return{tensors2D:t.map(t=>nq({inputs:{x:t},attrs:{shape:[-1,fy(t.shape.slice(e))]},backend:n})),outShape:s}}(t,e,n),o=new IK(i.map(t=>t.shape)),l=n.runWebGLProgram(o,i,s);i.forEach(t=>n.disposeIntermediateTensorInfo(t));const u=nq({inputs:{x:l},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(l),u}function RK(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,i=_y(r,e[0].shape)[0],a=SE(e.map(t=>t.shape),i);if(0===fy(a))return n.makeTensorInfo(a,e[0].dtype,[]);const o=e.filter(t=>fy(t.shape)>0);return 1===o.length?PG({inputs:{x:o[0]},backend:n}):(CE(o.map(t=>t.shape),i),$K(o,i,n))}const OK={kernelName:xb,backendName:"webgl",kernelFunc:RK};class FK{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,a=t.padInfo.left,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,m="channelsLast"===t.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",w="";n&&(v=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const _=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${_}\n        ${w}\n        setOutput(result);\n      }\n    `}}class DK{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,s=t.padInfo.left,r=t.strideDepth,i=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class LK{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:s,inChannels:r,strideWidth:i,strideHeight:a,padInfo:o,outWidth:l,dilationWidth:u,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=o,f=r*s,m=nH(),g="channelsLast"===h,y=g?0:1,b=g?1:2;let v="";for(let w=0;w<=1;w++)for(let n=0;n<=1;n++)v+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${w};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${a} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${i}. - ${d}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${r}.));\n\n              if(d1 < ${e[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*w+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*w+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${m.output} = result;\n      }\n    `}}function MK({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const l=t.shape,u=s.texData.get(t.dataId),c="channelsLast"===n.dataFormat;let h;const d=[],p=l[2]%2!=0&&!!u.isPacked;if((1!=l[0]*l[1]*l[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&Hy().getBool("WEBGL_LAZILY_UNPACK")&&Hy().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&p){const p={dataId:t.dataId,shape:[1,c?l[0]*l[1]*(l[2]+1):l[0]*l[2]*(l[3]+1),n.inChannels],dtype:t.dtype},f=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,cy(Kj(u.shape,p.shape),()=>`packed reshape ${u.shape} to ${p.shape} isn't free`);const m=nq({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});d.push(m);const g=fq({a:p,b:m,backend:s,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),y=s.texData.get(g.dataId);cy(y.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=f,y.shape=n.outShape,h=PG({inputs:{x:g},backend:s}),h.shape=n.outShape,d.push(g)}else{const u=nq({inputs:{x:t},backend:s,attrs:{shape:[1,c?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],n.inChannels]}}),p=nq({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=fq({a:u,b:p,transposeA:!1,transposeB:!1,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});h=nq({inputs:{x:f},backend:s,attrs:{shape:n.outShape}}),d.push(u),d.push(p),d.push(f)}for(const f of d)s.disposeIntermediateTensorInfo(f);return h}function PK({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,g=d*h,y=[m,g],b=[],v=nq({inputs:{x:t},backend:s,attrs:{shape:t.shape.slice(1)}}),w=nq({inputs:{x:e},backend:s,attrs:{shape:[1,m,fy(e.shape)/m]}});b.push(v),b.push(w);const _=new LK(y,v.shape,n),x=s.runWebGLProgram(_,[v],"float32"),k=nq({inputs:{x:x},backend:s,attrs:{shape:[1,y[0],y[1]]}});b.push(x),b.push(k);const C=null!=r,S=null!=i,I="leakyrelu"===o,E=o?ZG(o,!0):null,N=new YG(k.shape,w.shape,[1,g,n.outChannels],!0,!1,C,E,S,I),T=[k,w];if(r&&T.push(r),S&&T.push(i),I){const t=s.makeTensorInfo([],"float32",v_(a,"float32"));T.push(t),b.push(t)}const A=s.runWebGLProgram(N,T,"float32"),$=nq({inputs:{x:A},backend:s,attrs:{shape:f?[1,d,h,n.outChannels]:[1,n.outChannels,d,h]}});b.push(A);for(const R of b)s.disposeIntermediateTensorInfo(R);return $}const zK={kernelName:kb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=nC(l),d=qk(r.shape,i.shape,a,u,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(Hy().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])p=PK({x:r,filter:i,convInfo:d,backend:n});else{const t=new FK(d);p=n.runWebGLProgram(t,[r,i],"float32")}else p=MK({x:r,filter:i,convInfo:d,backend:n});const f=nq({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class VK{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class BK{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,s="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${s?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class WK{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class UK{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const jK={kernelName:Cb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=nC(l),d=qk(r.shape,c,a,1,o,u,!1,h),p=new VK(d);return n.runWebGLProgram(p,[r,i],"float32")}},HK={kernelName:Sb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=nC(u),d=qk(a,i.shape,o,1,l,c,!1,h),p=new BK(d);return n.runWebGLProgram(p,[r,i],"float32")}},GK={kernelName:Ib,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,u=Kk(r.shape,i.shape,a,l,o),c=new DK(u);return n.runWebGLProgram(c,[r,i],"float32")}},qK={kernelName:Eb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s,u=Kk(r.shape,l,a,1,o),c=new WK(u);return n.runWebGLProgram(c,[r,i],"float32")}},KK={kernelName:Nb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:l}=s,u=Kk(l,i.shape,o,1,a),c=new UK(u);return n.runWebGLProgram(c,[r,i],"float32")}},XK=KG({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),ZK={kernelName:Tb,backendName:"webgl",kernelFunc:XK},YK=KG({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),QK={kernelName:Ab,backendName:"webgl",kernelFunc:YK};class JK{constructor(t,e,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,o,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===s?1:0,[p,f]=[a-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,w]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const tX={kernelName:Rb,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=s,c=new JK(r.shape,i.shape,o,l,u);return n.runWebGLProgram(c,[r,i,a],"float32")}};class eX{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const s=t.length,r=e?"0.0":`getX(${nX(s,"coords")})`,i=t[t.length-1];let a="",o="";e?(a=n?"end != "+(i-1):"end != 0",o=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",o=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${TH(s)} coords = getOutputCoords();\n        int end = ${sX(s,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${o};\n          ${sX(s,"coords")} = idx;\n          val += getX(${nX(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function nX(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function sX(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}const rX={kernelName:$b,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s,l=r.shape.length,u=rS([i],l);let c=r;null!=u&&(c=dq({inputs:{x:r},backend:n,attrs:{perm:u}}));const h=aS(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${i}`);const d=c.shape[h];let p=PG({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){const t=new eX(c.shape,!1,o),e=t.getCustomSetupFunc(f),s=p;p=n.runWebGLProgram(t,[p],p.dtype,e),n.disposeIntermediateTensorInfo(s)}if(a){const t=new eX(c.shape,a,o),e=p;p=n.runWebGLProgram(t,[p],p.dtype),n.disposeIntermediateTensorInfo(e)}if(null!=u){const t=dq({inputs:{x:p},backend:n,attrs:{perm:iS(u)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),t}return p}},iX={kernelName:Ob,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(1===r.shape.length){const t=n.readSync(r.dataId),e=n.readSync(i.dataId),s=FH(t,e,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,s)}if(2===r.shape.length){const t=n.bufferSync(r),e=n.bufferSync(i),s=DH(t,e,a,o);return n.makeTensorInfo(s.shape,i.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class aX{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const oX={kernelName:Fb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:i,dataFormat:a}=s;cy(i>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${i}`);const o=r.shape[0],l=("NHWC"===a?r.shape[1]:r.shape[2])*i,u=("NHWC"===a?r.shape[2]:r.shape[3])*i,c=("NHWC"===a?r.shape[3]:r.shape[1])/(i*i),h=new aX("NHWC"===a?[o,l,u,c]:[o,c,l,u],i,a);return n.runWebGLProgram(h,[r],r.dtype)}};class lX{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.inHeight,a=t.inWidth,o=t.padInfo.top,l=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=t.outChannels/t.inChannels;let g="",y="";n&&(g=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${o}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${a}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${y}\n        setOutput(result);\n      }\n    `}}class uX{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const i=t.outChannels/t.inChannels,a=t.inHeight,o=t.inWidth,l=t.padInfo.top,u=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,f=t.filterHeight,m=t.filterWidth,g=m;let y="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let _=0;_<m;_++)y+=`\n          vec4 xTexelC${2*_};\n          int xTexelC${2*_}Ready;\n          vec4 xC${_};`;for(let _=0;_<f;_++){for(let t=0;t<m;t++)y+=`\n          xTexelC${2*t} = vec4(0.0);\n          xTexelC${2*t}Ready = 0;\n          xC${t} = vec4(0.0);`;y+=`\n        xR = xRCorner + ${_*d};\n        if (xR >=0 && xR < ${a}) {\n      `;for(let t=0;t<(g+1)/2;t++){const e=2*t,n=e*p;if(y+=`\n          xC = xCCorner + ${n};\n          `,1===h){if(e<m&&(u%2==1?(y+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,y+=1===p&&n>0?`\n                xC${e} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${o}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${o}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):y+=`\n                if (xC >= 0 && xC < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${e} = xTexelC${n};\n                `,n+1<m)){const t=u%2==0?uy(p):p;p%2==0&&u%2==1||p%2!=0&&u%2!=1?(y+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${o}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,p>1&&(y+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),y+=`\n                  xC${e+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):y+=1===t?`\n                    xC${e+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${o}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${n+2};\n                    `}}else n<m&&(u%2==1?(y+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${o}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<m&&(y+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<m&&(y+=`\n                  xC${e+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));e<m&&(y+=`\n            wTexel = getW(${_}, ${n}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<m&&(y+=`\n              wTexel = getW(${_}, ${n+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}y+="\n        }\n      "}let b="",v="";n&&(b=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,v="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${y}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}const cX={kernelName:Db,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=s;let c=l;null==c&&(c=[1,1]),cy(eC(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=qk(r.shape,i.shape,a,c,o,u,!0);let d;return d=Hy().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new uX(h):new lX(h),n.runWebGLProgram(d,[r,i],"float32")}};class hX{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class dX{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,s=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const pX={kernelName:Lb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=s,h=qk(r.shape,c,a,o,l,u,!0),d=new hX(h);return n.runWebGLProgram(d,[r,i],"float32")}},fX={kernelName:Mb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=s,h=qk(c,i.shape,a,o,l,u,!0),d=new dX(h);return n.runWebGLProgram(d,[r,i],"float32")}};class mX{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const gX={kernelName:Pb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],i=fy(s.shape),a=nq({inputs:{x:s},backend:n,attrs:{shape:[i]}}),o=new mX(i),l=n.runWebGLProgram(o,[a],a.dtype),u=nq({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}};class yX{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:s,strideHeight:r,strideWidth:i,filterHeight:a,filterWidth:o,dilationHeight:l,dilationWidth:u}=t,{top:c,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${i});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const bX={kernelName:zb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,u=jk(r.shape,i.shape,a,o,"NHWC",l);let c;const h=new yX(u);c=n.runWebGLProgram(h,[r,i],"float32");const d=nq({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}},vX={kernelName:Ub,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:l}=sN(r,i.length);iN(a.length,l,i);const{path:u,steps:c}=aN(o,l),h=c.length;let d=null,p=a.length;const f=[];for(let m=0;m<h;++m){for(const t of c[m]){const{permutationIndices:e,expandDims:s}=rN(p,l[t]);let r;oN(e)?r=i[t]:(r=dq({inputs:{x:i[t]},backend:n,attrs:{perm:e}}),f.push(r));const a=r.shape.slice();for(let t=0;t<s.length;++t)a.splice(s[t],0,1);my(r.shape,a)||(r=nq({inputs:{x:r},backend:n,attrs:{shape:a}}),f.push(r)),null===d?d=r:(d=tq({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=cq({inputs:{x:d},backend:n,attrs:{axis:u[m]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},wX=KG({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),_X={kernelName:jb,backendName:"webgl",kernelFunc:wX},xX={kernelName:Hb,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,i=Hy().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new MG("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new LG("return (b >= 1.0) ? a : a * (b + 1.0);",s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}},kX=XG({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:PH}),CX={kernelName:qb,backendName:"webgl",kernelFunc:kX},SX=KG({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${VE};\n  float a1 = ${BE};\n  float a2 = ${WE};\n  float a3 = ${UE};\n  float a4 = ${jE};\n  float a5 = ${HE};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),IX={kernelName:Gb,backendName:"webgl",kernelFunc:SX},EX="return exp(x);",NX=KG({opSnippet:EX,packedOpSnippet:EX,cpuKernelImpl:zH}),TX={kernelName:Kb,backendName:"webgl",kernelFunc:NX};function AX(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:i}=e,a=i.shape.length,o=i.shape.slice();let l=r;return r<0&&(cy(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),o.splice(l,0,1),nq({inputs:{x:i},backend:s,attrs:{shape:o}})}const $X={kernelName:Xb,backendName:"webgl",kernelFunc:AX},RX="return exp(x) - 1.0;",OX=KG({opSnippet:RX,packedOpSnippet:RX,cpuKernelImpl:VH}),FX={kernelName:Zb,backendName:"webgl",kernelFunc:OX};class DX{constructor(t,e,n){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function LX(t,e,n){const s=n.texData.get(t.dataId),r=fy(t.shape),i=t.shape[t.shape.length-1],a=nq({inputs:{x:t},backend:n,attrs:{shape:[r/i,i]}}),o=a.shape,l=new DX("real",o,e),u=new DX("imag",o,e),c=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:o},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=VG({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=nq({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(p),f}const MX={kernelName:Yb,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e;return LX(s,!1,n)}};class PX{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}function zX(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:i}=n;if(i=i||Ay(r),"string"===i){const t=Cy(i,fy(s));return t.fill(r),e.makeTensorInfo(s,i,t)}{const t=new PX(s,r),n=t.getCustomSetupFunc(r);return e.runWebGLProgram(t,[],i,n)}}const VX={kernelName:Qb,backendName:"webgl",kernelFunc:zX};class BX{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const WX={kernelName:Jb,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new BX(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}},UX="return floor(x);",jX=KG({opSnippet:UX,packedOpSnippet:UX,cpuKernelImpl:BH}),HX={kernelName:tv,backendName:"webgl",kernelFunc:jX},GX=XG({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),qX={kernelName:ev,backendName:"webgl",kernelFunc:GX};class KX{constructor(t){this.variableNames=["A"];const e=nH(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class XX{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=nH(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const ZX={kernelName:Gw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:i}=s,a="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,u]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,i];(o||a)&&(null==YX&&(YX=document.createElement("canvas").getContext("2d")),YX.canvas.width=l,YX.canvas.height=u,YX.drawImage(r,0,0,l,u),r=YX.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=Nj.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=Hy().getBool("WEBGL_PACK")?new XX(h):new KX(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let YX;const QX={kernelName:Xw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=nC(c),g=qk(r.shape,i.shape,l,h,u,d,!1,m);let y;const b=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(Hy().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])y=PK({x:r,filter:i,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const t=null!=a,e=null!=o,s="leakyrelu"===p,l=p?ZG(p,!1):null,u=new FK(g,t,l,e,s),c=[r,i];if(a&&c.push(a),o&&c.push(o),s){const t=n.makeTensorInfo([],"float32",v_(f,"float32"));c.push(t),b.push(t)}y=n.runWebGLProgram(u,c,"float32")}else y=MK({x:r,filter:i,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const v=nq({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(t=>n.disposeIntermediateTensorInfo(t)),v}},JX={kernelName:Zw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let m=c;null==m&&(m=[1,1]),cy(eC(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=qk(r.shape,i.shape,l,m,u,h,!0),y=Hy().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=d?ZG(d,y):null,v=[r,i],w=null!=a,_=null!=o,x="leakyrelu"===d;if(w&&v.push(a),_&&v.push(o),x){const t=n.makeTensorInfo([],"float32",v_(p,"float32"));v.push(t),f.push(t)}let k;k=y?new uX(g,w,b,_,x):new lX(g,w,b,_,x);const C=n.runWebGLProgram(k,v,"float32");return f.forEach(t=>n.disposeIntermediateTensorInfo(t)),C}};class tZ{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const s=TH(e.length),r=TH(n.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const eZ={kernelName:rv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,i=r.shape,a=i[i.length-1],o=fy(s.shape),[l,u,c,h]=FE(s,r),d=nq({inputs:{x:r},backend:n,attrs:{shape:[u,a]}}),p=nq({inputs:{x:s},backend:n,attrs:{shape:[fy(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||"string"===s.dtype){const t=n.readSync(r.dataId),e=n.bufferSync(s),i=WH(t,e,s.dtype,u,a,c,h,s.shape,o);return n.makeTensorInfo(l,s.dtype,i.values)}const f=new tZ(a,h,[u,c]),m=n.runWebGLProgram(f,[p,d],p.dtype),g=nq({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class nZ{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=TH(this.rank),s=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)s.push(2===r?"int(getIndices(resRC.x, resRC.z))":`${n[r]}`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}const sZ={kernelName:sv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:i}=e,{axis:a,batchDims:o}=s,l=dN(r,i,_y(a,r.shape)[0],o),u=fy(i.shape),c=[],h=nq({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=nq({inputs:{x:i},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});c.push(h),c.push(d);const p=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const t=n.bufferSync(d),e=n.bufferSync(h),s=UH(e,t,p);return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(l.outputShape,s.dtype,s.values)}const f=new nZ(h.shape,p),m=n.runWebGLProgram(f,[h,d],h.dtype);c.push(m);const g=nq({inputs:{x:m},backend:n,attrs:{shape:l.outputShape}});return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),g}},rZ=XG({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:jH,dtype:"bool"}),iZ={kernelName:iv,backendName:"webgl",kernelFunc:rZ},aZ=XG({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:HH}),oZ={kernelName:av,backendName:"webgl",kernelFunc:aZ},lZ={kernelName:lv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e;return LX(s,!0,n)}},uZ=KG({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),cZ={kernelName:cv,backendName:"webgl",kernelFunc:uZ},hZ=KG({opSnippet:"return float(isinf(x));",dtype:"bool"}),dZ={kernelName:hv,backendName:"webgl",kernelFunc:hZ},pZ=KG({opSnippet:"return float(isnan(x));",dtype:"bool"}),fZ={kernelName:dv,backendName:"webgl",kernelFunc:pZ},mZ=XG({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:GH,dtype:"bool"}),gZ={kernelName:fv,backendName:"webgl",kernelFunc:mZ},yZ=XG({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:qH,dtype:"bool"}),bZ={kernelName:mv,backendName:"webgl",kernelFunc:yZ},vZ={kernelName:gv,backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,a=KH(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}},wZ=KG({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:XH}),_Z={kernelName:yv,backendName:"webgl",kernelFunc:wZ},xZ=KG({opSnippet:"return log(1.0 + x);"}),kZ={kernelName:bv,backendName:"webgl",kernelFunc:xZ},CZ=XG({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),SZ={kernelName:vv,backendName:"webgl",kernelFunc:CZ},IZ=KG({opSnippet:"return float(!(x >= 1.0));"}),EZ={kernelName:wv,backendName:"webgl",kernelFunc:IZ},NZ=XG({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),TZ={kernelName:_v,backendName:"webgl",kernelFunc:NZ};class AZ{constructor(t,e,n,s,r){this.variableNames=["x"],this.outputShape=[];const i=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class $Z{constructor(t,e,n,s,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const RZ={kernelName:xv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s,u=Hy().getBool("WEBGL_PACK_NORMALIZATION")?new $Z(r.shape,i,a,o,l):new AZ(r.shape,i,a,o,l);return n.runWebGLProgram(u,[r],r.dtype)}};class OZ{constructor(t,e,n,s,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=s,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const FZ={kernelName:kv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=s,h=new OZ(r.shape,o,l,u,c);return n.runWebGLProgram(h,[r,i,a],r.dtype)}};function DZ(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=r.shape.length,l=_y(i,r.shape);let u=l;const c=rS(u,o),h=null!=c,d=n.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const t=n.texData.get(p.dataId).values,e=new Array(o);for(let n=0;n<e.length;n++)e[n]=r.shape[c[n]];const s=yG(t,r.shape,r.dtype,c,e);p=n.makeTensorInfo(e,r.dtype),n.texData.get(p.dataId).values=s}else p=uq(r,c,n);u=aS(u.length,o)}sS("max",u,o);const[f,m]=eS(p.shape,u);let g,y=f;if(a&&(y=nS(f,l)),d){const t=n.texData.get(p.dataId),e=ZH(t.values,fy(m),y,r.dtype);g=n.makeTensorInfo(y,r.dtype),n.texData.get(g.dataId).values=e}else g=function(t,e,n,s){const r=fy(e),i=nq({inputs:{x:t},attrs:{shape:[fy(t.shape)/r,r]},backend:s}),a=aq(i,t.dtype,"max",s),o=nq({inputs:{x:a},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const LZ={kernelName:Cv,backendName:"webgl",kernelFunc:DZ},MZ=XG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:YH}),PZ={kernelName:Sv,backendName:"webgl",kernelFunc:MZ},zZ={kernelName:Iv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;tH(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s;cy(eC(a,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const u=Hk(r.shape,i,a,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&my(u.inShape,u.outShape))return PG({inputs:{x:r},backend:n});const c=new qq(u,"max",!1);return n.runWebGLProgram(c,[r],r.dtype)}},VZ={kernelName:Nv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:u}=s,c=Gk(r.shape,i,a,[1,1,1],o,u,l),h=new Kq(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class BZ{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${e*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class WZ{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${e*n*s-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${s} +\n                  wR * ${s} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const UZ={kernelName:Tv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=s,h=Gk(a.shape,o,l,[1,1,1],u,c),d=new Kq(h,"max",!0),p=n.runWebGLProgram(d,[a],a.dtype),f=new WZ(h),m=n.runWebGLProgram(f,[r,p],a.dtype);return n.disposeIntermediateTensorInfo(p),m}},jZ={kernelName:Ev,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:a}=e,o=i;tH([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=Hk(o.shape,l,u,1,c,h),p=new qq(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new BZ(d),g=n.runWebGLProgram(m,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},HZ={kernelName:Av,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,l=n;cy(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];cy(eC(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Hk(s.shape,r,i,u,a),[h,d]=function(t,e,n,s){let r=new qq(n,"max",!1);const i=s.runWebGLProgram(r,[t],"float32");return r=new qq(n,"max",!0,!0,e),[i,s.runWebGLProgram(r,[t],"float32")]}(s,o,c,l);return[h,d]}},GZ={kernelName:$v,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{keepDims:r,axis:i}=e,a=n,o=s.shape.length,l=_y(i,s.shape);let u=l;const c=rS(u,o),h=null!=c,d=a.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const t=a.texData.get(f.dataId).values,e=new Array(o);for(let r=0;r<e.length;r++)e[r]=s.shape[c[r]];const n=yG(t,s.shape,s.dtype,c,e);f=a.makeTensorInfo(e,s.dtype),a.texData.get(f.dataId).values=n}else f=uq(s,c,a);p.push(f),u=aS(u.length,o)}sS("sum",u,o);const[m,g]=eS(f.shape,u);let y=m;r&&(y=nS(m,l));const b=function(t,e,n,s){const r=fy(e),i=nq({inputs:{x:t},attrs:{shape:[fy(t.shape)/r,r]},backend:s}),a=aq(i,"float32","mean",s),o=nq({inputs:{x:a},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}(f,g,y,a);for(const v of p)a.disposeIntermediateTensorInfo(v);return b}},qZ={kernelName:Rv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=_y(i,r.shape);let u=l;const c=rS(u,o);let h=r;null!=c&&(h=dq({inputs:{x:r},backend:n,attrs:{perm:c}}),u=aS(u.length,r.shape.length)),sS("min",u,o);const[d,p]=eS(h.shape,u),f=nq({inputs:{x:h},backend:n,attrs:{shape:[-1,fy(p)]}}),m=aq(f,f.dtype,"min",n);let g;return g=nq(a?{inputs:{x:m},backend:n,attrs:{shape:nS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},KZ=XG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:QH}),XZ={kernelName:Ov,backendName:"webgl",kernelFunc:KZ};class ZZ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=TH(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l="reflect"===n?0:1;this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class YZ{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=TH(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=wG("rc",s),l=wG("source",s),u=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===s){const t=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const t=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[s-2]} += 1;\n        if(${o[s-2]} < ${this.outputShape[s-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[s-1]} += 1;\n          if(${u}) {\n            ${t}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const QZ={kernelName:Fv,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:i}=n,a=Hy().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new YZ(s.shape,r,i):new ZZ(s.shape,r,i);return e.runWebGLProgram(a,[s],s.dtype)}},JZ=XG({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),tY={kernelName:Dv,backendName:"webgl",kernelFunc:JZ};class eY{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}const nY=XG({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),sY={kernelName:Wb,backendName:"webgl",kernelFunc:nY},rY="return a - b;",iY=XG({opSnippet:rY,packedOpSnippet:rY,supportsComplex:!0,cpuKernelImpl:fG}),aY={kernelName:Fw,backendName:"webgl",kernelFunc:iY};function oY(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:i}=s,a=_y([i],r.shape),o=DZ({inputs:{x:r},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=nS(o.shape,a),u=nq({inputs:{x:o},backend:n,attrs:{shape:l}}),c=iY({inputs:{a:r,b:u},backend:n}),h=NX({inputs:{x:c},backend:n}),d=cq({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:!1}}),p=nq({inputs:{x:d},backend:n,attrs:{shape:l}}),f=nY({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const lY={kernelName:xw,backendName:"webgl",kernelFunc:oY},uY={kernelName:Lv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,l=o?r:oY({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=new eY(l.shape[0],l.shape[1],i),c=u.getCustomSetupFunc(a),h=n.runWebGLProgram(u,[l],"int32",c);return o||n.disposeIntermediateTensorInfo(l),h}},cY="return -x;",hY={kernelName:Pv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const t=n.texData.get(s.dataId),[e,r]=tG(t.values,s.shape,s.dtype);return n.makeTensorInfo(r,s.dtype,e)}let r;return r=Hy().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new AG(s.shape,cY):new EG(s.shape,cY),n.runWebGLProgram(r,[s],s.dtype)}},dY=kI,pY={kernelName:Vv,backendName:"webgl",kernelFunc:function(t){GE("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=dY(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},fY=CI,mY={kernelName:Bv,backendName:"webgl",kernelFunc:function(t){GE("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=fY(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},gY=SI,yY={kernelName:Wv,backendName:"webgl",kernelFunc:function(t){GE("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),d=a,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=gY(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class bY{constructor(t,e,n,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const vY={kernelName:jv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{depth:i,onValue:a,offValue:o}=s,l=fy(r.shape),u=new bY(l,i,a,o),c=nq({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[c],r.dtype);n.disposeIntermediateTensorInfo(c);const d=nq({inputs:{x:h},backend:n,attrs:{shape:[...r.shape,i]}});return n.disposeIntermediateTensorInfo(h),d}};function wY(t){const{inputs:e,backend:n}=t,{x:s}=e;if("complex64"===s.dtype){const t=fK({inputs:{input:s},backend:n}),e=wY({inputs:{x:t},backend:n}),r=TK({inputs:{input:s},backend:n}),i=wY({inputs:{x:r},backend:n}),a=VG({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}return zX({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:n})}const _Y={kernelName:jw,backendName:"webgl",kernelFunc:wY},xY={kernelName:Uv,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=fK({inputs:{input:r},backend:s}),n=t({inputs:{x:e},backend:s}),i=TK({inputs:{input:r},backend:s}),a=wY({inputs:{x:i},backend:s}),o=VG({inputs:{real:n,imag:a},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}return zX({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:s})}},kY={kernelName:Hv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(1===e.length)return AX({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(t=>{hy(i,t.shape,"All tensors passed to stack must have matching shapes"),cy(a===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=RK({inputs:e.map(t=>{const e=AX({inputs:{input:t},backend:n,attrs:{dim:r}});return o.push(e),e}),backend:n,attrs:{axis:r}});return o.forEach(t=>n.disposeIntermediateTensorInfo(t)),l}};class CY{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=TH(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n      uniform float value;\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class SY{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=TH(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=wG("rc",s),l=wG("source",s),u=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${o[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${o[s-2]} += 1;\n       if(${o[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${o[s-1]} += 1;\n         if(${u}) {`],d=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===s?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n      uniform float value;\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}const IY=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:a}=s,o=Hy().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SY(r.shape,i,a):new CY(r.shape,i,a),l=o.getCustomSetupFunc(a);return n.runWebGLProgram(o,[r],r.dtype,l)},EY={kernelName:Gv,backendName:"webgl",kernelFunc:IY},NY=XG({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),TY={kernelName:qv,backendName:"webgl",kernelFunc:NY},AY={kernelName:Xv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=[],u=_y(i,r.shape);let c=u;const h=rS(c,o);let d,p=r;if(null!=h&&(p=dq({inputs:{x:r},backend:n,attrs:{perm:h}}),c=aS(c.length,o),l.push(p)),sS("prod",c,o),n.shouldExecuteOnCPU([p])){const t=n.texData.get(p.dataId).values,{outVals:e,outShape:s,outDtype:r}=nG(p.shape,p.dtype,t,c);d=n.makeTensorInfo(s,r,e)}else{const[t,e]=eS(p.shape,c),s=fy(e),i=nq({inputs:{x:p},backend:n,attrs:{shape:[-1,s]}}),a=aq(i,G_(r.dtype),"prod",n);d=nq({inputs:{x:a},backend:n,attrs:{shape:t}}),l.push(i),l.push(a)}if(a){l.push(d);const t=nS(d.shape,u);d=nq({inputs:{x:d},backend:n,attrs:{shape:t}})}return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),d}},$Y=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:i,dtype:a}=n,o=sG(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},RY={kernelName:Zv,backendName:"webgl",kernelFunc:$Y},OY=KG({opSnippet:"return 1.0 / x;"}),FY={kernelName:Qv,backendName:"webgl",kernelFunc:OY},DY=KG({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),LY={kernelName:Jv,backendName:"webgl",kernelFunc:DY},MY=KG({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),PY={kernelName:iw,backendName:"webgl",kernelFunc:MY};class zY{constructor(t,e,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class VY{constructor(t,e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const BY={kernelName:sw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,u]=o,c=Hy().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new VY(r.shape,l,u,i,a):new zY(r.shape,l,u,i,a);return n.runWebGLProgram(c,[r],"float32")}};class WY{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,r]=e,[,i,a]=t,o=[n&&i>1?s-1:s,n&&a>1?r-1:r],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const UY={kernelName:rw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:a}=s,o=new WY(i.shape,r.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class jY{constructor(t,e,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class HY{constructor(t,e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const GY={kernelName:ew,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,u]=o,c=Hy().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new HY(r.shape,l,u,i,a):new jY(r.shape,l,u,i,a);return n.runWebGLProgram(c,[r],r.dtype)}};class qY{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,r]=e,[,i,a]=t,o=[n&&i>1?s-1:s,n&&a>1?r-1:r],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const KY={kernelName:nw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:a}=s,o=new qY(i.shape,r.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class XY{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const s=t.map((n,s)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(s)).join(","),r=TH(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class ZY{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const s=wG("rc",n),r=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,a=TH(n);function o(n){const s=t.map((s,r)=>function(n,s){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${s[n]} - 1`:`${s[n]}`}(r,n));return`getChannel(getX(${s.join(",")}), vec2(${s.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return o(t)}(s.slice())};\n          if(${r}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",o(t)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",o(t)}(s.slice())};\n            if(${r}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",o(t)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const YY={kernelName:aw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:i}=s,a=r.shape.length,o=_y(i,r.shape);if(0===a)return PG({inputs:{x:r},backend:n});const l=Hy().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZY(r.shape,o):new XY(r.shape,o);return n.runWebGLProgram(l,[r],r.dtype)}};class QY{constructor(t,e){this.variableNames=["Image"],this.outputShape=[];const n=t[1],s=t[2];this.outputShape=t;let r="";r="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(t,e,n,s){return(r,i)=>{null==this.paramsLoc&&(this.paramsLoc=r.getUniformLocationNoThrow(i,"params")),r.gl.uniform4f(this.paramsLoc,t,e,n,s)}}}const JY={kernelName:qw,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:a}=e,o=n,l=new QY(s.shape,i),[u,c]=NE(a,s.shape[1],s.shape[2]),h=l.getCustomSetupFunc(u,c,Math.sin(r),Math.cos(r));return o.runWebGLProgram(l,[s],s.dtype,h)}},tQ=KG({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),eQ={kernelName:ow,backendName:"webgl",kernelFunc:tQ},nQ=KG({opSnippet:"return inversesqrt(x);",cpuKernelImpl:rG}),sQ={kernelName:lw,backendName:"webgl",kernelFunc:nQ};class rQ{constructor(t,e,n,s,r,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const o=TH(r.length),l=TH(i.length);let u="";1===n?u="i":2===n&&(u="i, j");let c="";1===s?c="i":2===s&&(c="i, coords[1]"),this.userCode=`\n        ${o} strides = ${o}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const iQ={kernelName:uw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ME(0,r,a),d=[h/u,u];if(0===h)return n.makeTensorInfo(a,r.dtype);const p=nq({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),f=nq({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new rQ(l,o,p.shape.length,f.shape.length,c,d),y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=nq({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class aQ{constructor(t,e,n){let s,r;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",s="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let s=0;s<e.length;s++)a.push(`${n[s]}`),s<t&&i.push(`${n[s]}`);s=i.join(),r=a.join()}const i=TH(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const oQ={kernelName:cw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e,a=new aQ(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(a,[s,r,i],H_(r.dtype,i.dtype))}},lQ=KG({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${PE};\n  float scale = ${zE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),uQ={kernelName:hw,backendName:"webgl",kernelFunc:lQ},cQ=KG({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),hQ={kernelName:gw,backendName:"webgl",kernelFunc:cQ},dQ=KG({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),pQ={kernelName:mw,backendName:"webgl",kernelFunc:dQ},fQ=KG({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),mQ={kernelName:pw,backendName:"webgl",kernelFunc:fQ},gQ=KG({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),yQ={kernelName:fw,backendName:"webgl",kernelFunc:gQ},bQ=KG({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),vQ={kernelName:yw,backendName:"webgl",kernelFunc:bQ},wQ={kernelName:ww,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,paddings:a}=s;cy(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((t,e)=>t*e),l=[[0,0]];l.push(...a);for(let y=1+i.length;y<r.shape.length;++y)l.push([0,0]);const u=[],c=IY({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=TE(c.shape,i,o,!1),d=AE(h.length,i.length,!1),p=$E(c.shape,i,o,!1),f=nq({inputs:{x:c},backend:n,attrs:{shape:h}}),m=dq({inputs:{x:f},backend:n,attrs:{perm:d}}),g=nq({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(t=>n.disposeIntermediateTensorInfo(t)),g}},_Q={kernelName:kw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.readSync(s.dataId),l=n.readSync(r.dataId),u=n.readSync(i.dataId),c=n.readSync(a.dataId)[0],[h,d,p,f,m]=oG(o,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(t=>Number(t)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}},xQ={kernelName:Cw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:i}=e;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.readSync(r.dataId)),o=n.readSync(s.dataId),l=Array.from(n.readSync(i.dataId)),[u,c,h]=lG(o,s.shape,s.dtype,a,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}},kQ={kernelName:Sw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const a=n.readSync(s.dataId),o=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=uG(a,s.shape,s.dtype,o,l,!0);return n.makeTensorInfo(c,s.dtype,u)}},CQ={kernelName:Iw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const a=n.readSync(s.dataId),o=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=uG(a,s.shape,s.dtype,o,l);return n.makeTensorInfo(c,s.dtype,u)}},SQ={kernelName:Ew,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:u,strides:c,outputSize:h}=ME(0,r,o),d=new rQ(u,l,r.shape.length,i.shape.length,c,[h,1],!1),p=n.runWebGLProgram(d,[i,r,a],i.dtype),f=nq({inputs:{x:p},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),f}},IQ={kernelName:_w,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=_y(a,r.shape)[0],l=uN(r,i,o),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(t=>{const e=[...c];e[o]=t;const s=lK({inputs:{x:r},backend:n,attrs:{begin:u,size:e}});return u[o]+=t,s})}},EQ=KG({opSnippet:"return sqrt(x);"}),NQ={kernelName:bw,backendName:"webgl",kernelFunc:EQ},TQ={kernelName:Tw,backendName:"webgl",kernelFunc:KG({opSnippet:"return x * x;"})},AQ="return (a - b) * (a - b);",$Q=XG({opSnippet:AQ,packedOpSnippet:AQ}),RQ={kernelName:Nw,backendName:"webgl",kernelFunc:$Q},OQ={kernelName:Hw,backendName:"webgl",kernelFunc:function({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=new EG(s.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${e.alpha});\n  `);return n.runWebGLProgram(r,[s],s.dtype)}};class FQ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const s=n.length,r=TH(n.length),i=TH(n.length);let a="";if(1===s)a="coords * strides + begin";else{let t=0;a=n.map((e,s)=>(t++,1===n.length?`coords * strides[${s}] + begin[${s}]`:`coords[${t-1}] * strides[${s}] + begin[${s}]`)).join(",")}this.userCode=`\n      ${r} begin = ${r}(${t});\n      ${r} strides = ${r}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const DQ={kernelName:Aw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=Ik(r.shape,i,a,o,l,u,c,h,d),v=nq({inputs:{x:r},backend:n,attrs:{shape:y}});let w;if(p){const t=lK({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});w=nq({inputs:{x:t},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(t)}else if(b.some(t=>0===t))w=n.makeTensorInfo(b,r.dtype,[]);else if(n.shouldExecuteOnCPU([v])){const t=n.texData.get(v.dataId),e=Xx(v.shape,v.dtype,t.values),s=cG(b,e,m,f);w=n.makeTensorInfo(b,v.dtype,s.values)}else{const t=new FQ(f,m,b);w=n.runWebGLProgram(t,[v],v.dtype)}const _=nq({inputs:{x:w},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),_}},LQ={kernelName:$w,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=hG(d,p,r,i,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},MQ={kernelName:Rw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.readSync(i.dataId),l=n.readSync(a.dataId)[0],[u,c,h]=dG(o,l,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},PQ={kernelName:Ow,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:i}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=n.readSync(i.dataId),o=pG(a,r);return n.makeTensorInfo(i.shape,"int32",o)}},zQ=KG({opSnippet:"return tan(x);"}),VQ={kernelName:Dw,backendName:"webgl",kernelFunc:zQ},BQ=KG({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),WQ={kernelName:Lw,backendName:"webgl",kernelFunc:BQ};class UQ{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;const s=TH(this.rank),r=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function jQ(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;if("string"===r.dtype||r.shape.length>5){const t=n.readSync(r.dataId),e="string"===r.dtype?t.map(t=>k_(t)):t,s=Xx(r.shape,r.dtype,e),a=mG(s,i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new UQ(r.shape,i);return n.runWebGLProgram(a,[r],r.dtype)}const HQ={kernelName:Mw,backendName:"webgl",kernelFunc:jQ},GQ={kernelName:Pw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i,sorted:a}=s,o=n.readSync(r.dataId),[l,u]=gG(o,r.shape,r.dtype,i,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};class qQ{constructor(t,e,n,s,r,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===n?1:2;let o;switch(s){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const KQ={kernelName:zw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=s,[c,h,d,p]=r.shape,[f,m]=null!=u?u:[h,d],g=new qQ(h,d,a,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[r,i],"float32")}},XQ={kernelName:Bw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;tH(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:l,indices:u}=bG(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([u.length],"int32",u)]}},ZQ={kernelName:Ww,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,l=r.shape[i],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==i&&(u[c++]=a.shape[m]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[i]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[i]=m;const t=lK({inputs:{x:a},backend:n,attrs:{begin:d,size:p}}),e=nq({inputs:{x:t},backend:n,attrs:{shape:u}});f[m]=e,h.push(t)}return h.forEach(t=>n.disposeIntermediateTensorInfo(t)),f}};class YQ{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,s=t.batchSize,r=t.inSize,i=t.numSegments,a=i*Math.ceil(r/n);this.outputShape=[s,a];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const QQ=[RZ,FZ,mq,yq,vq,_q,Cq,Eq,Nq,Tq,Dq,Lq,Pq,Vq,jq,Wq,Gq,Zq,Xq,Jq,tK,eK,rK,cK,hK,gK,vK,xK,SK,BG,OK,jK,HK,zK,qK,KK,GK,ZK,QK,tX,rX,iX,oX,pX,fX,cX,gX,bX,vX,_X,xX,CX,IX,TX,$X,FX,MX,VX,WX,HX,qX,ZX,QX,JX,eZ,sZ,iZ,oZ,zG,lZ,AK,cZ,dZ,fZ,jG,gZ,bZ,vZ,kZ,_Z,SZ,EZ,TZ,LZ,VZ,zZ,UZ,jZ,HZ,PZ,GZ,qZ,XZ,QZ,tY,uY,eq,hY,pY,mY,yY,pK,vY,xY,kY,EY,TY,qG,AY,RY,mK,sY,FY,PY,LY,sq,BY,UY,GY,KY,YY,JY,eQ,sQ,iQ,oQ,uQ,hQ,pQ,mQ,yQ,uK,lY,vQ,wQ,_Q,xQ,kQ,CQ,SQ,IQ,NQ,TQ,RQ,OQ,DQ,LQ,MQ,PQ,aY,hq,VQ,WQ,HQ,GQ,KQ,pq,XQ,ZQ,{kernelName:Uw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:i}=e,{numSegments:a}=s,o=r.shape.length,l=[];let u=0;const c=rS([u],o);let h=r;null!=c&&(h=dq({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(h),u=aS(1,o)[0]);const d=hN(h.shape,u,a),p=fy([h.shape[u]]),f=nq({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=G_(r.dtype),g=(t,e,s,r,i)=>{const a=t.shape[0],o=t.shape[1],u=cN(o,i),c=new YQ({windowSize:u,inSize:o,batchSize:a,numSegments:i},e),h=n.compileAndRun(c,[t,s],r);if(l.push(h),h.shape[1]===i)return h;const d=$Y({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),p=jQ({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});return l.push(d),l.push(p),g(h,e,p,r,i)},y=nq({inputs:{x:g(f,"unsortedSegmentSum",i,m,a)},backend:n,attrs:{shape:d}});let b=y;if(null!=c){l.push(y);const t=iS(c);b=dq({inputs:{x:b},backend:n,attrs:{perm:t}})}return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),b}},_Y];for(const M7 of QQ)n_(M7);function JQ(t,e,n,s){return new(n||(n=Promise))(function(r,i){function a(t){try{l(s.next(t))}catch(t){i(t)}}function o(t){try{l(s.throw(t))}catch(t){i(t)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n(function(t){t(e)})).then(a,o)}l((s=s.apply(t,e||[])).next())})}function tJ(t,e){var n,s,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function o(i){return function(o){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,s&&(r=2&i[0]?s.return:i[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,i[1])).done)return r;switch(s=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,s=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!(r=(r=a.trys).length>0&&r[r.length-1])&&(6===i[0]||2===i[0])){a=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){a.label=i[1];break}if(6===i[0]&&a.label<r[1]){a.label=r[1],r=i;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(i);break}r[2]&&a.ops.pop(),a.trys.pop();continue}i=e.call(t,a)}catch(t){i=[6,t],s=0}finally{n=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,o])}}}var eJ=function(t){return{startEndTensor:t,startPoint:ES(t,[0,0],[-1,2]),endPoint:ES(t,[0,2],[-1,2])}},nJ={strides:[8,16],anchors:[2,6]};function sJ(t,e){var n,s,r;if(t.topLeft instanceof L_&&t.bottomRight instanceof L_){var i=Rk(function(){return[hC([ES(jC(e-1,t.topLeft),0,1),ES(t.topLeft,1,1)]),hC([jC(e-1,ES(t.bottomRight,0,1)),ES(t.bottomRight,1,1)])]});n=i[0],s=i[1],null!=t.landmarks&&(r=Rk(function(){var n=jC(zS([e-1,0]),t.landmarks),s=zS([1,-1]);return UC(n,s)}))}else{var a=t.topLeft,o=t.bottomRight;n=[e-1-a[0],a[1]],s=[e-1-o[0],o[1]],null!=t.landmarks&&(r=t.landmarks.map(function(t){return[e-1-t[0],t[1]]}))}var l={topLeft:n,bottomRight:s};return null!=r&&(l.landmarks=r),null!=t.probability&&(l.probability=t.probability instanceof L_?t.probability.clone():t.probability),l}function rJ(t,e){return Rk(function(){var n;return n=t.hasOwnProperty("box")?t.box:t,LS(function(t,e){var n=UC(t.startPoint,e),s=UC(t.endPoint,e),r=pC([n,s],1);return eJ(r)}(n,e).startEndTensor)})}var iJ=function(){function t(t,e,n,s,r,i){this.blazeFaceModel=t,this.width=e,this.height=n,this.maxFaces=s,this.anchorsData=function(t,e,n){for(var s=[],r=0;r<n.strides.length;r++)for(var i=n.strides[r],a=Math.floor((e+i-1)/i),o=Math.floor((t+i-1)/i),l=n.anchors[r],u=0;u<a;u++)for(var c=i*(u+.5),h=0;h<o;h++)for(var d=i*(h+.5),p=0;p<l;p++)s.push([d,c]);return s}(e,n,nJ),this.anchors=VS(this.anchorsData),this.inputSizeData=[e,n],this.inputSize=zS([e,n]),this.iouThreshold=r,this.scoreThreshold=i}return t.prototype.getBoundingBoxes=function(t,e,n){return void 0===n&&(n=!0),JQ(this,void 0,void 0,function(){var s,r,i,a,o,l,u,c,h,d,p,f,m,g,y=this;return tJ(this,function(b){switch(b.label){case 0:return s=Rk(function(){var e=uE.resizeBilinear(t,[y.width,y.height]),n=UC(jC(SC(e,255),.5),2),s=y.blazeFaceModel.predict(n),r=LS(s),i=function(t,e,n){var s=ES(t,[0,1],[-1,2]),r=Vk(s,e),i=ES(t,[0,3],[-1,2]),a=SC(i,n),o=SC(r,n),l=SC(a,2),u=jC(o,l),c=Vk(o,l),h=UC(u,n),d=UC(c,n);return pC([h,d],1)}(r,y.anchors,y.inputSize),a=ES(r,[0,0],[-1,1]);return[r,i,LS(IS(a))]}),r=s[0],i=s[1],a=s[2],o=console.warn,console.warn=function(){},l=uE.nonMaxSuppression(i,a,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=o,[4,l.array()];case 1:return u=b.sent(),l.dispose(),c=u.map(function(t){return ES(i,[t,0],[1,-1])}),e?[3,3]:[4,Promise.all(c.map(function(t){return JQ(y,void 0,void 0,function(){var e;return tJ(this,function(n){switch(n.label){case 0:return[4,t.array()];case 1:return e=n.sent(),t.dispose(),[2,e]}})})}))];case 2:c=b.sent(),b.label=3;case 3:for(h=t.shape[1],d=t.shape[2],p=e?SC([d,h],this.inputSize):[d/this.inputSizeData[0],h/this.inputSizeData[1]],f=[],m=function(t){var s=c[t],i=Rk(function(){var i=eJ(s instanceof L_?s:VS(s));if(!n)return i;var o,l=u[t];return o=e?ES(y.anchors,[l,0],[1,2]):y.anchorsData[l],{box:i,landmarks:sC(LS(ES(r,[l,5],[1,-1])),[6,-1]),probability:ES(a,[l],[1]),anchor:o}});f.push(i)},g=0;g<c.length;g++)m(g);return i.dispose(),a.dispose(),r.dispose(),[2,{boxes:f,scaleFactor:p}]}})})},t.prototype.estimateFaces=function(t,e,n,s){return void 0===e&&(e=!1),void 0===n&&(n=!1),void 0===s&&(s=!0),JQ(this,void 0,void 0,function(){var r,i,a,o,l,u,c=this;return tJ(this,function(h){switch(h.label){case 0:return r=function(t){return t instanceof L_?[t.shape[0],t.shape[1]]:[t.height,t.width]}(t),i=r[1],a=Rk(function(){return t instanceof L_||(t=ck(t)),$C(Zx(t,"float32"),0)}),[4,this.getBoundingBoxes(a,e,s)];case 1:return o=h.sent(),l=o.boxes,u=o.scaleFactor,a.dispose(),e?[2,l.map(function(t){var e=rJ(t,u),r={topLeft:ES(e,[0],[2]),bottomRight:ES(e,[2],[2])};if(s){var a=t.probability,o=UC(Vk(t.landmarks,t.anchor),u);r.landmarks=o,r.probability=a}return n&&(r=sJ(r,i)),r})]:[2,Promise.all(l.map(function(t){return JQ(c,void 0,void 0,function(){var e,r,a,o,l,c,h,d,p,f,m=this;return tJ(this,function(g){switch(g.label){case 0:return e=rJ(t,u),s?[3,2]:[4,e.array()];case 1:return o=g.sent(),r={topLeft:o.slice(0,2),bottomRight:o.slice(2)},[3,4];case 2:return[4,Promise.all([t.landmarks,e,t.probability].map(function(t){return JQ(m,void 0,void 0,function(){return tJ(this,function(e){return[2,t.array()]})})}))];case 3:a=g.sent(),o=a[1],l=a[2],c=t.anchor,d=(h=u)[0],p=h[1],f=a[0].map(function(t){return[(t[0]+c[0])*d,(t[1]+c[1])*p]}),r={topLeft:o.slice(0,2),bottomRight:o.slice(2),landmarks:f,probability:l},function(t){t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose()}(t.box),t.landmarks.dispose(),t.probability.dispose(),g.label=4;case 4:return e.dispose(),n&&(r=sJ(r,i)),[2,r]}})})}))]}})})},t}();class aJ{}class oJ{}class lJ{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(t=>{const e=t.indexOf(":");if(e>0){const n=t.slice(0,e),s=n.toLowerCase(),r=t.slice(e+1).trim();this.maybeSetNormalizedName(n,s),this.headers.has(s)?this.headers.get(s).push(r):this.headers.set(s,[r])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let n=t[e];const s=e.toLowerCase();"string"==typeof n&&(n=[n]),n.length>0&&(this.headers.set(s,n),this.maybeSetNormalizedName(e,s))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof lJ?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new lJ;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof lJ?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let n=t.value;if("string"==typeof n&&(n=[n]),0===n.length)return;this.maybeSetNormalizedName(t.name,e);const s=("a"===t.op?this.headers.get(e):void 0)||[];s.push(...n),this.headers.set(e,s);break;case"d":const r=t.value;if(r){let t=this.headers.get(e);if(!t)return;t=t.filter(t=>-1===r.indexOf(t)),0===t.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,t)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class uJ{encodeKey(t){return cJ(t)}encodeValue(t){return cJ(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}function cJ(t){return encodeURIComponent(t).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/gi,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%2B/gi,"+").replace(/%3D/gi,"=").replace(/%3F/gi,"?").replace(/%2F/gi,"/")}function hJ(t){return`${t}`}class dJ{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new uJ,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function(t,e){const n=new Map;return t.length>0&&t.replace(/^\?/,"").split("&").forEach(t=>{const s=t.indexOf("="),[r,i]=-1==s?[e.decodeKey(t),""]:[e.decodeKey(t.slice(0,s)),e.decodeValue(t.slice(s+1))],a=n.get(r)||[];a.push(i),n.set(r,a)}),n}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const n=t.fromObject[e];this.map.set(e,Array.isArray(n)?n:[n])})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(n=>{const s=t[n];Array.isArray(s)?s.forEach(t=>{e.push({param:n,value:t,op:"a"})}):e.push({param:n,value:s,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(t=>e+"="+this.encoder.encodeValue(t)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new dJ({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(hJ(t.value)),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let e=this.map.get(t.param)||[];const n=e.indexOf(hJ(t.value));-1!==n&&e.splice(n,1),e.length>0?this.map.set(t.param,e):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class pJ{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}keys(){return this.map.keys()}}function fJ(t){return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer}function mJ(t){return"undefined"!=typeof Blob&&t instanceof Blob}function gJ(t){return"undefined"!=typeof FormData&&t instanceof FormData}class yJ{constructor(t,e,n,s){let r;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function(t){switch(t){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==n?n:null,r=s):r=n,r&&(this.reportProgress=!!r.reportProgress,this.withCredentials=!!r.withCredentials,r.responseType&&(this.responseType=r.responseType),r.headers&&(this.headers=r.headers),r.context&&(this.context=r.context),r.params&&(this.params=r.params)),this.headers||(this.headers=new lJ),this.context||(this.context=new pJ),this.params){const t=this.params.toString();if(0===t.length)this.urlWithParams=e;else{const n=e.indexOf("?");this.urlWithParams=e+(-1===n?"?":n<e.length-1?"&":"")+t}}else this.params=new dJ,this.urlWithParams=e}serializeBody(){return null===this.body?null:fJ(this.body)||mJ(this.body)||gJ(this.body)||"string"==typeof this.body?this.body:this.body instanceof dJ?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||gJ(this.body)?null:mJ(this.body)?this.body.type||null:fJ(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof dJ?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){var e;const n=t.method||this.method,s=t.url||this.url,r=t.responseType||this.responseType,i=void 0!==t.body?t.body:this.body,a=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,o=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let l=t.headers||this.headers,u=t.params||this.params;const c=null!==(e=t.context)&&void 0!==e?e:this.context;return void 0!==t.setHeaders&&(l=Object.keys(t.setHeaders).reduce((e,n)=>e.set(n,t.setHeaders[n]),l)),t.setParams&&(u=Object.keys(t.setParams).reduce((e,n)=>e.set(n,t.setParams[n]),u)),new yJ(n,s,i,{params:u,headers:l,context:c,reportProgress:o,responseType:r,withCredentials:a})}}var bJ=function(t){return t[t.Sent=0]="Sent",t[t.UploadProgress=1]="UploadProgress",t[t.ResponseHeader=2]="ResponseHeader",t[t.DownloadProgress=3]="DownloadProgress",t[t.Response=4]="Response",t[t.User=5]="User",t}({});class vJ{constructor(t,e=200,n="OK"){this.headers=t.headers||new lJ,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||n,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class wJ extends vJ{constructor(t={}){super(t),this.type=bJ.ResponseHeader}clone(t={}){return new wJ({headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class _J extends vJ{constructor(t={}){super(t),this.type=bJ.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new _J({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class xJ extends vJ{constructor(t){super(t,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?`Http failure during parsing for ${t.url||"(unknown url)"}`:`Http failure response for ${t.url||"(unknown url)"}: ${t.status} ${t.statusText}`,this.error=t.error||null}}function kJ(t,e){return{body:e,headers:t.headers,context:t.context,observe:t.observe,params:t.params,reportProgress:t.reportProgress,responseType:t.responseType,withCredentials:t.withCredentials}}let CJ=(()=>{class t{constructor(t){this.handler=t}request(t,e,n={}){let s;if(t instanceof yJ)s=t;else{let r,i;r=n.headers instanceof lJ?n.headers:new lJ(n.headers),n.params&&(i=n.params instanceof dJ?n.params:new dJ({fromObject:n.params})),s=new yJ(t,e,void 0!==n.body?n.body:null,{headers:r,context:n.context,params:i,reportProgress:n.reportProgress,responseType:n.responseType||"json",withCredentials:n.withCredentials})}const r=op(s).pipe(Pp(t=>this.handler.handle(t)));if(t instanceof yJ||"events"===n.observe)return r;const i=r.pipe(Rp(t=>t instanceof _J));switch(n.observe||"body"){case"body":switch(s.responseType){case"arraybuffer":return i.pipe(X(t=>{if(null!==t.body&&!(t.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return t.body}));case"blob":return i.pipe(X(t=>{if(null!==t.body&&!(t.body instanceof Blob))throw new Error("Response is not a Blob.");return t.body}));case"text":return i.pipe(X(t=>{if(null!==t.body&&"string"!=typeof t.body)throw new Error("Response is not a string.");return t.body}));case"json":default:return i.pipe(X(t=>t.body))}case"response":return i;default:throw new Error(`Unreachable: unhandled observe type ${n.observe}}`)}}delete(t,e={}){return this.request("DELETE",t,e)}get(t,e={}){return this.request("GET",t,e)}head(t,e={}){return this.request("HEAD",t,e)}jsonp(t,e){return this.request("JSONP",t,{params:(new dJ).append(e,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(t,e={}){return this.request("OPTIONS",t,e)}patch(t,e,n={}){return this.request("PATCH",t,kJ(n,e))}post(t,e,n={}){return this.request("POST",t,kJ(n,e))}put(t,e,n={}){return this.request("PUT",t,kJ(n,e))}}return t.\u0275fac=function(e){return new(e||t)(Os(aJ))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();class SJ{constructor(t,e){this.next=t,this.interceptor=e}handle(t){return this.interceptor.intercept(t,this.next)}}const IJ=new ms("HTTP_INTERCEPTORS");let EJ=(()=>{class t{intercept(t,e){return e.handle(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const NJ=/^\)\]\}',?\n/;let TJ=(()=>{class t{constructor(t){this.xhrFactory=t}handle(t){if("JSONP"===t.method)throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");return new B(e=>{const n=this.xhrFactory.build();if(n.open(t.method,t.urlWithParams),t.withCredentials&&(n.withCredentials=!0),t.headers.forEach((t,e)=>n.setRequestHeader(t,e.join(","))),t.headers.has("Accept")||n.setRequestHeader("Accept","application/json, text/plain, */*"),!t.headers.has("Content-Type")){const e=t.detectContentTypeHeader();null!==e&&n.setRequestHeader("Content-Type",e)}if(t.responseType){const e=t.responseType.toLowerCase();n.responseType="json"!==e?e:"text"}const s=t.serializeBody();let r=null;const i=()=>{if(null!==r)return r;const e=1223===n.status?204:n.status,s=n.statusText||"OK",i=new lJ(n.getAllResponseHeaders()),a=function(t){return"responseURL"in t&&t.responseURL?t.responseURL:/^X-Request-URL:/m.test(t.getAllResponseHeaders())?t.getResponseHeader("X-Request-URL"):null}(n)||t.url;return r=new wJ({headers:i,status:e,statusText:s,url:a}),r},a=()=>{let{headers:s,status:r,statusText:a,url:o}=i(),l=null;204!==r&&(l=void 0===n.response?n.responseText:n.response),0===r&&(r=l?200:0);let u=r>=200&&r<300;if("json"===t.responseType&&"string"==typeof l){const t=l;l=l.replace(NJ,"");try{l=""!==l?JSON.parse(l):null}catch(c){l=t,u&&(u=!1,l={error:c,text:l})}}u?(e.next(new _J({body:l,headers:s,status:r,statusText:a,url:o||void 0})),e.complete()):e.error(new xJ({error:l,headers:s,status:r,statusText:a,url:o||void 0}))},o=t=>{const{url:s}=i(),r=new xJ({error:t,status:n.status||0,statusText:n.statusText||"Unknown Error",url:s||void 0});e.error(r)};let l=!1;const u=s=>{l||(e.next(i()),l=!0);let r={type:bJ.DownloadProgress,loaded:s.loaded};s.lengthComputable&&(r.total=s.total),"text"===t.responseType&&n.responseText&&(r.partialText=n.responseText),e.next(r)},c=t=>{let n={type:bJ.UploadProgress,loaded:t.loaded};t.lengthComputable&&(n.total=t.total),e.next(n)};return n.addEventListener("load",a),n.addEventListener("error",o),n.addEventListener("timeout",o),n.addEventListener("abort",o),t.reportProgress&&(n.addEventListener("progress",u),null!==s&&n.upload&&n.upload.addEventListener("progress",c)),n.send(s),e.next({type:bJ.Sent}),()=>{n.removeEventListener("error",o),n.removeEventListener("abort",o),n.removeEventListener("load",a),n.removeEventListener("timeout",o),t.reportProgress&&(n.removeEventListener("progress",u),null!==s&&n.upload&&n.upload.removeEventListener("progress",c)),n.readyState!==n.DONE&&n.abort()}})}}return t.\u0275fac=function(e){return new(e||t)(Os(wh))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const AJ=new ms("XSRF_COOKIE_NAME"),$J=new ms("XSRF_HEADER_NAME");class RJ{}let OJ=(()=>{class t{constructor(t,e,n){this.doc=t,this.platform=e,this.cookieName=n,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const t=this.doc.cookie||"";return t!==this.lastCookieString&&(this.parseCount++,this.lastToken=Yc(t,this.cookieName),this.lastCookieString=t),this.lastToken}}return t.\u0275fac=function(e){return new(e||t)(Os(kc),Os(Tu),Os(AJ))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),FJ=(()=>{class t{constructor(t,e){this.tokenService=t,this.headerName=e}intercept(t,e){const n=t.url.toLowerCase();if("GET"===t.method||"HEAD"===t.method||n.startsWith("http://")||n.startsWith("https://"))return e.handle(t);const s=this.tokenService.getToken();return null===s||t.headers.has(this.headerName)||(t=t.clone({headers:t.headers.set(this.headerName,s)})),e.handle(t)}}return t.\u0275fac=function(e){return new(e||t)(Os(RJ),Os($J))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),DJ=(()=>{class t{constructor(t,e){this.backend=t,this.injector=e,this.chain=null}handle(t){if(null===this.chain){const t=this.injector.get(IJ,[]);this.chain=t.reduceRight((t,e)=>new SJ(t,e),this.backend)}return this.chain.handle(t)}}return t.\u0275fac=function(e){return new(e||t)(Os(oJ),Os(Oa))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),LJ=(()=>{class t{static disable(){return{ngModule:t,providers:[{provide:FJ,useClass:EJ}]}}static withOptions(e={}){return{ngModule:t,providers:[e.cookieName?{provide:AJ,useValue:e.cookieName}:[],e.headerName?{provide:$J,useValue:e.headerName}:[]]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[FJ,{provide:IJ,useExisting:FJ,multi:!0},{provide:RJ,useClass:OJ},{provide:AJ,useValue:"XSRF-TOKEN"},{provide:$J,useValue:"X-XSRF-TOKEN"}]}),t})(),MJ=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[CJ,{provide:aJ,useClass:DJ},TJ,{provide:oJ,useExisting:TJ}],imports:[[LJ.withOptions({cookieName:"XSRF-TOKEN",headerName:"X-XSRF-TOKEN"})]]}),t})(),PJ=(()=>{class t{constructor(t){this.http=t,this.settings={},this._modelLoaded=new lp(!1),this.modelLoaded=this._modelLoaded.asObservable(),fetch(sy.mainURL+"/settings").then(t=>{t.json().then(t=>{this.settings=t,console.log(t),this.loadModels().then(()=>{this._modelLoaded.next(!0)}).catch(t=>{this._modelLoaded.next(!1)})}).catch(t=>{console.log(t)})}).catch(t=>{})}loadModels(){var t=this;return ny(function*(){t.blaze=yield function(t){var e=void 0===t?{}:t,n=e.maxFaces,s=void 0===n?10:n,r=e.inputWidth,i=void 0===r?128:r,a=e.inputHeight,o=void 0===a?128:a,l=e.iouThreshold,u=void 0===l?.3:l,c=e.scoreThreshold,h=void 0===c?.75:c,d=e.modelUrl;return JQ(this,void 0,void 0,function(){var t;return tJ(this,function(e){switch(e.label){case 0:return null==d?[3,2]:[4,ZM(d)];case 1:return t=e.sent(),[3,4];case 2:return[4,ZM("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:t=e.sent(),e.label=4;case 4:return[2,new iJ(t,i,o,s,u,h)]}})})}({maxFaces:t.settings.LABELS.length,inputHeight:128,inputWidth:128})})()}loadPred(t){var e=this;return ny(function*(){return e.http.post(sy.mainURL+"/models/"+e.settings.MODEL_NAME,{image:t.arraySync()}).toPromise().then(t=>t.pred).catch(t=>console.log(t))})()}bufftoarr(t){return function(t,e){return uk.apply(this,arguments)}(t)}fromPixels(t){return ck(t)}predict(t){var e=this;return ny(function*(){let n=e.loadImage(t),s=yield e.cropImage(n);if(!s){let t=new Array(e.settings.LABELS.length).fill(0,0,e.settings.LABELS.length);return Ok(n),Ok(s),{bbox:[t],pred:[t]}}let r=yield e.loadPred(s.t);return Ok(n),Ok(s),{bbox:s.bbox,pred:r}})()}loadImage(t){let e=ck(t);return e.pad(this.getPadding(e.shape))}cropImage(t){var e=this;return ny(function*(){let n=Rk(()=>t.clone().resizeBilinear([256,256])),s=yield e.blaze.estimateFaces(n,!1);if(!s.length)return;let r=[];return s.forEach(t=>{let e=t.topLeft.map((t,e)=>t/256).reverse(),n=t.bottomRight.map((t,e)=>t/256).reverse();r.push(e.concat(n))}),{t:Rk(()=>uE.cropAndResize(t.expandDims(),VS(r),new Array(r.length).fill(0),e.settings.IMG_SIZE)),bbox:r}})()}getPadding(t){let e=[[0,0],[0,0],[0,0]],n=t[0]-t[1];return 0===n||(n>0?e[1]=[Math.abs(n/2),Math.abs(n/2)]:e[0]=[Math.abs(n/2),Math.abs(n/2)]),e}}return t.\u0275fac=function(e){return new(e||t)(Os(CJ))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function zJ(t,...e){return e.length?e.some(e=>t[e]):t.altKey||t.shiftKey||t.ctrlKey||t.metaKey}class VJ extends F{constructor(t,e){super()}schedule(t,e=0){return this}}class BJ extends VJ{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const n=this.id,s=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(s,n,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(s,this.id,e),this}requestAsyncId(t,e,n=0){return setInterval(t.flush.bind(t,this),n)}recycleAsyncId(t,e,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(t,e);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let n,s=!1;try{this.work(t)}catch(r){s=!0,n=!!r&&r||new Error(r)}if(s)return this.unsubscribe(),n}_unsubscribe(){const t=this.id,e=this.scheduler,n=e.actions,s=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==s&&n.splice(s,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}let WJ=(()=>{class t{constructor(e,n=t.now){this.SchedulerAction=e,this.now=n}schedule(t,e=0,n){return new this.SchedulerAction(this,t).schedule(n,e)}}return t.now=()=>Date.now(),t})();class UJ extends WJ{constructor(t,e=WJ.now){super(t,()=>UJ.delegate&&UJ.delegate!==this?UJ.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,n){return UJ.delegate&&UJ.delegate!==this?UJ.delegate.schedule(t,e,n):super.schedule(t,e,n)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let n;this.active=!0;do{if(n=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}}const jJ=new UJ(BJ);function HJ(t,e=jJ){return n=>n.lift(new GJ(t,e))}class GJ{constructor(t,e){this.dueTime=t,this.scheduler=e}call(t,e){return e.subscribe(new qJ(t,this.dueTime,this.scheduler))}}class qJ extends M{constructor(t,e,n){super(t),this.dueTime=e,this.scheduler=n,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(t){this.clearDebounce(),this.lastValue=t,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(KJ,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:t}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(t)}}clearDebounce(){const t=this.debouncedSubscription;null!==t&&(this.remove(t),t.unsubscribe(),this.debouncedSubscription=null)}}function KJ(t){t.debouncedNext()}function XJ(t){return null!=t&&"false"!=`${t}`}function ZJ(t,e=0){return function(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}(t)?Number(t):e}function YJ(t){return Array.isArray(t)?t:[t]}function QJ(t){return null==t?"":"string"==typeof t?t:`${t}px`}function JJ(t){return t instanceof nl?t.nativeElement:t}let t0;try{t0="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(L7){t0=!1}let e0,n0=(()=>{class t{constructor(t){this._platformId=t,this.isBrowser=this._platformId?"browser"===this._platformId:"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!t0)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return t.\u0275fac=function(e){return new(e||t)(Os(Tu))},t.\u0275prov=Dt({factory:function(){return new t(Os(Tu))},token:t,providedIn:"root"}),t})(),s0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})();const r0=["color","button","checkbox","date","datetime-local","email","file","hidden","image","month","number","password","radio","range","reset","search","submit","tel","text","time","url","week"];function i0(){if(e0)return e0;if("object"!=typeof document||!document)return e0=new Set(r0),e0;let t=document.createElement("input");return e0=new Set(r0.filter(e=>(t.setAttribute("type",e),t.type===e))),e0}let a0,o0,l0;function u0(t){return function(){if(null==a0&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>a0=!0}))}finally{a0=a0||!1}return a0}()?t:!!t.capture}function c0(){if(null==o0){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return o0=!1,o0;if("scrollBehavior"in document.documentElement.style)o0=!0;else{const t=Element.prototype.scrollTo;o0=!!t&&!/\{\s*\[native code\]\s*\}/.test(t.toString())}}return o0}function h0(t){if(function(){if(null==l0){const t="undefined"!=typeof document?document.head:null;l0=!(!t||!t.createShadowRoot&&!t.attachShadow)}return l0}()){const e=t.getRootNode?t.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}function d0(){let t="undefined"!=typeof document&&document?document.activeElement:null;for(;t&&t.shadowRoot;){const e=t.shadowRoot.activeElement;if(e===t)break;t=e}return t}let p0=(()=>{class t{create(t){return"undefined"==typeof MutationObserver?null:new MutationObserver(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),f0=(()=>{class t{constructor(t){this._mutationObserverFactory=t,this._observedElements=new Map}ngOnDestroy(){this._observedElements.forEach((t,e)=>this._cleanupObserver(e))}observe(t){const e=JJ(t);return new B(t=>{const n=this._observeElement(e).subscribe(t);return()=>{n.unsubscribe(),this._unobserveElement(e)}})}_observeElement(t){if(this._observedElements.has(t))this._observedElements.get(t).count++;else{const e=new G,n=this._mutationObserverFactory.create(t=>e.next(t));n&&n.observe(t,{characterData:!0,childList:!0,subtree:!0}),this._observedElements.set(t,{observer:n,stream:e,count:1})}return this._observedElements.get(t).stream}_unobserveElement(t){this._observedElements.has(t)&&(this._observedElements.get(t).count--,this._observedElements.get(t).count||this._cleanupObserver(t))}_cleanupObserver(t){if(this._observedElements.has(t)){const{observer:e,stream:n}=this._observedElements.get(t);e&&e.disconnect(),n.complete(),this._observedElements.delete(t)}}}return t.\u0275fac=function(e){return new(e||t)(Os(p0))},t.\u0275prov=Dt({factory:function(){return new t(Os(p0))},token:t,providedIn:"root"}),t})(),m0=(()=>{class t{constructor(t,e,n){this._contentObserver=t,this._elementRef=e,this._ngZone=n,this.event=new ru,this._disabled=!1,this._currentSubscription=null}get disabled(){return this._disabled}set disabled(t){this._disabled=XJ(t),this._disabled?this._unsubscribe():this._subscribe()}get debounce(){return this._debounce}set debounce(t){this._debounce=ZJ(t),this._subscribe()}ngAfterContentInit(){this._currentSubscription||this.disabled||this._subscribe()}ngOnDestroy(){this._unsubscribe()}_subscribe(){this._unsubscribe();const t=this._contentObserver.observe(this._elementRef);this._ngZone.runOutsideAngular(()=>{this._currentSubscription=(this.debounce?t.pipe(HJ(this.debounce)):t).subscribe(this.event)})}_unsubscribe(){var t;null===(t=this._currentSubscription)||void 0===t||t.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Xa(f0),Xa(nl),Xa(ju))},t.\u0275dir=be({type:t,selectors:[["","cdkObserveContent",""]],inputs:{disabled:["cdkObserveContentDisabled","disabled"],debounce:"debounce"},outputs:{event:"cdkObserveContent"},exportAs:["cdkObserveContent"]}),t})(),g0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[p0]}),t})();function y0(t,e){return(t.getAttribute(e)||"").match(/\S+/g)||[]}const b0="cdk-describedby-message-container",v0="cdk-describedby-host";let w0=0;const _0=new Map;let x0=null,k0=(()=>{class t{constructor(t){this._document=t}describe(t,e,n){if(!this._canBeDescribed(t,e))return;const s=C0(e,n);"string"!=typeof e?(S0(e),_0.set(s,{messageElement:e,referenceCount:0})):_0.has(s)||this._createMessageElement(e,n),this._isElementDescribedByMessage(t,s)||this._addMessageReference(t,s)}removeDescription(t,e,n){if(!e||!this._isElementNode(t))return;const s=C0(e,n);if(this._isElementDescribedByMessage(t,s)&&this._removeMessageReference(t,s),"string"==typeof e){const t=_0.get(s);t&&0===t.referenceCount&&this._deleteMessageElement(s)}x0&&0===x0.childNodes.length&&this._deleteMessagesContainer()}ngOnDestroy(){const t=this._document.querySelectorAll("[cdk-describedby-host]");for(let e=0;e<t.length;e++)this._removeCdkDescribedByReferenceIds(t[e]),t[e].removeAttribute(v0);x0&&this._deleteMessagesContainer(),_0.clear()}_createMessageElement(t,e){const n=this._document.createElement("div");S0(n),n.textContent=t,e&&n.setAttribute("role",e),this._createMessagesContainer(),x0.appendChild(n),_0.set(C0(t,e),{messageElement:n,referenceCount:0})}_deleteMessageElement(t){const e=_0.get(t),n=e&&e.messageElement;x0&&n&&x0.removeChild(n),_0.delete(t)}_createMessagesContainer(){if(!x0){const t=this._document.getElementById(b0);t&&t.parentNode&&t.parentNode.removeChild(t),x0=this._document.createElement("div"),x0.id=b0,x0.style.visibility="hidden",x0.classList.add("cdk-visually-hidden"),this._document.body.appendChild(x0)}}_deleteMessagesContainer(){x0&&x0.parentNode&&(x0.parentNode.removeChild(x0),x0=null)}_removeCdkDescribedByReferenceIds(t){const e=y0(t,"aria-describedby").filter(t=>0!=t.indexOf("cdk-describedby-message"));t.setAttribute("aria-describedby",e.join(" "))}_addMessageReference(t,e){const n=_0.get(e);!function(t,e,n){const s=y0(t,e);s.some(t=>t.trim()==n.trim())||(s.push(n.trim()),t.setAttribute(e,s.join(" ")))}(t,"aria-describedby",n.messageElement.id),t.setAttribute(v0,""),n.referenceCount++}_removeMessageReference(t,e){const n=_0.get(e);n.referenceCount--,function(t,e,n){const s=y0(t,e).filter(t=>t!=n.trim());s.length?t.setAttribute(e,s.join(" ")):t.removeAttribute(e)}(t,"aria-describedby",n.messageElement.id),t.removeAttribute(v0)}_isElementDescribedByMessage(t,e){const n=y0(t,"aria-describedby"),s=_0.get(e),r=s&&s.messageElement.id;return!!r&&-1!=n.indexOf(r)}_canBeDescribed(t,e){if(!this._isElementNode(t))return!1;if(e&&"object"==typeof e)return!0;const n=null==e?"":`${e}`.trim(),s=t.getAttribute("aria-label");return!(!n||s&&s.trim()===n)}_isElementNode(t){return t.nodeType===this._document.ELEMENT_NODE}}return t.\u0275fac=function(e){return new(e||t)(Os(kc))},t.\u0275prov=Dt({factory:function(){return new t(Os(kc))},token:t,providedIn:"root"}),t})();function C0(t,e){return"string"==typeof t?`${e||""}/${t}`:t}function S0(t){t.id||(t.id="cdk-describedby-message-"+w0++)}let I0=(()=>{class t{constructor(t){this._platform=t}isDisabled(t){return t.hasAttribute("disabled")}isVisible(t){return function(t){return!!(t.offsetWidth||t.offsetHeight||"function"==typeof t.getClientRects&&t.getClientRects().length)}(t)&&"visible"===getComputedStyle(t).visibility}isTabbable(t){if(!this._platform.isBrowser)return!1;const e=function(t){try{return t.frameElement}catch(L7){return null}}((n=t).ownerDocument&&n.ownerDocument.defaultView||window);var n;if(e){if(-1===N0(e))return!1;if(!this.isVisible(e))return!1}let s=t.nodeName.toLowerCase(),r=N0(t);return t.hasAttribute("contenteditable")?-1!==r:"iframe"!==s&&"object"!==s&&!(this._platform.WEBKIT&&this._platform.IOS&&!function(t){let e=t.nodeName.toLowerCase(),n="input"===e&&t.type;return"text"===n||"password"===n||"select"===e||"textarea"===e}(t))&&("audio"===s?!!t.hasAttribute("controls")&&-1!==r:"video"===s?-1!==r&&(null!==r||this._platform.FIREFOX||t.hasAttribute("controls")):t.tabIndex>=0)}isFocusable(t,e){return function(t){return!function(t){return function(t){return"input"==t.nodeName.toLowerCase()}(t)&&"hidden"==t.type}(t)&&(function(t){let e=t.nodeName.toLowerCase();return"input"===e||"select"===e||"button"===e||"textarea"===e}(t)||function(t){return function(t){return"a"==t.nodeName.toLowerCase()}(t)&&t.hasAttribute("href")}(t)||t.hasAttribute("contenteditable")||E0(t))}(t)&&!this.isDisabled(t)&&((null==e?void 0:e.ignoreVisibility)||this.isVisible(t))}}return t.\u0275fac=function(e){return new(e||t)(Os(n0))},t.\u0275prov=Dt({factory:function(){return new t(Os(n0))},token:t,providedIn:"root"}),t})();function E0(t){if(!t.hasAttribute("tabindex")||void 0===t.tabIndex)return!1;let e=t.getAttribute("tabindex");return"-32768"!=e&&!(!e||isNaN(parseInt(e,10)))}function N0(t){if(!E0(t))return null;const e=parseInt(t.getAttribute("tabindex")||"",10);return isNaN(e)?-1:e}class T0{constructor(t,e,n,s,r=!1){this._element=t,this._checker=e,this._ngZone=n,this._document=s,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,r||this.attachAnchors()}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.parentNode&&t.parentNode.removeChild(t)),e&&(e.removeEventListener("focus",this.endAnchorListener),e.parentNode&&e.parentNode.removeChild(e)),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusInitialElement(t)))})}focusFirstTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusFirstTabbableElement(t)))})}focusLastTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusLastTabbableElement(t)))})}_getRegionBoundary(t){let e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);for(let n=0;n<e.length;n++)e[n].hasAttribute(`cdk-focus-${t}`)?console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]):e[n].hasAttribute(`cdk-focus-region-${t}`)&&console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(t){const e=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(e){if(e.hasAttribute("cdk-focus-initial")&&console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0",e),!this._checker.isFocusable(e)){const n=this._getFirstTabbableElement(e);return null==n||n.focus(t),!!n}return e.focus(t),!0}return this.focusFirstTabbableElement(t)}focusFirstTabbableElement(t){const e=this._getRegionBoundary("start");return e&&e.focus(t),!!e}focusLastTabbableElement(t){const e=this._getRegionBoundary("end");return e&&e.focus(t),!!e}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=0;n<e.length;n++){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[n]):null;if(t)return t}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=e.length-1;n>=0;n--){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[n]):null;if(t)return t}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(Sp(1)).subscribe(t)}}let A0=(()=>{class t{constructor(t,e,n){this._checker=t,this._ngZone=e,this._document=n}create(t,e=!1){return new T0(t,this._checker,this._ngZone,this._document,e)}}return t.\u0275fac=function(e){return new(e||t)(Os(I0),Os(ju),Os(kc))},t.\u0275prov=Dt({factory:function(){return new t(Os(I0),Os(ju),Os(kc))},token:t,providedIn:"root"}),t})();function $0(t){return 0===t.buttons}function R0(t){const e=t.touches&&t.touches[0]||t.changedTouches&&t.changedTouches[0];return!(!e||-1!==e.identifier||null!=e.radiusX&&1!==e.radiusX||null!=e.radiusY&&1!==e.radiusY)}"undefined"!=typeof Element&&Element;const O0=new ms("cdk-focus-monitor-default-options"),F0=u0({passive:!0,capture:!0});let D0=(()=>{class t{constructor(t,e,n,s){this._ngZone=t,this._platform=e,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue("keyboard")},this._documentMousedownListener=t=>{if(!this._lastTouchTarget){const e=$0(t)?"keyboard":"mouse";this._setOriginForCurrentEventQueue(e)}},this._documentTouchstartListener=t=>{R0(t)?this._lastTouchTarget||this._setOriginForCurrentEventQueue("keyboard"):(null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=L0(t),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650))},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=t=>{const e=L0(t),n="focus"===t.type?this._onFocus:this._onBlur;for(let s=e;s;s=s.parentElement)n.call(this,t,s)},this._document=n,this._detectionMode=(null==s?void 0:s.detectionMode)||0}monitor(t,e=!1){const n=JJ(t);if(!this._platform.isBrowser||1!==n.nodeType)return op(null);const s=h0(n)||this._getDocument(),r=this._elementInfo.get(n);if(r)return e&&(r.checkChildren=!0),r.subject;const i={checkChildren:e,subject:new G,rootNode:s};return this._elementInfo.set(n,i),this._registerGlobalListeners(i),i.subject}stopMonitoring(t){const e=JJ(t),n=this._elementInfo.get(e);n&&(n.subject.complete(),this._setClasses(e),this._elementInfo.delete(e),this._removeGlobalListeners(n))}focusVia(t,e,n){const s=JJ(t);s===this._getDocument().activeElement?this._getClosestElementsInfo(s).forEach(([t,n])=>this._originChanged(t,e,n)):(this._setOriginForCurrentEventQueue(e),"function"==typeof s.focus&&s.focus(n))}ngOnDestroy(){this._elementInfo.forEach((t,e)=>this.stopMonitoring(e))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(t,e,n){n?t.classList.add(e):t.classList.remove(e)}_getFocusOrigin(t){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(t)?"touch":"program"}_setClasses(t,e){this._toggleClass(t,"cdk-focused",!!e),this._toggleClass(t,"cdk-touch-focused","touch"===e),this._toggleClass(t,"cdk-keyboard-focused","keyboard"===e),this._toggleClass(t,"cdk-mouse-focused","mouse"===e),this._toggleClass(t,"cdk-program-focused","program"===e)}_setOriginForCurrentEventQueue(t){this._ngZone.runOutsideAngular(()=>{this._origin=t,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(t){const e=L0(t);return this._lastTouchTarget instanceof Node&&e instanceof Node&&(e===this._lastTouchTarget||e.contains(this._lastTouchTarget))}_onFocus(t,e){const n=this._elementInfo.get(e);n&&(n.checkChildren||e===L0(t))&&this._originChanged(e,this._getFocusOrigin(t),n)}_onBlur(t,e){const n=this._elementInfo.get(e);!n||n.checkChildren&&t.relatedTarget instanceof Node&&e.contains(t.relatedTarget)||(this._setClasses(e),this._emitOrigin(n.subject,null))}_emitOrigin(t,e){this._ngZone.run(()=>t.next(e))}_registerGlobalListeners(t){if(!this._platform.isBrowser)return;const e=t.rootNode,n=this._rootNodeFocusListenerCount.get(e)||0;n||this._ngZone.runOutsideAngular(()=>{e.addEventListener("focus",this._rootNodeFocusAndBlurListener,F0),e.addEventListener("blur",this._rootNodeFocusAndBlurListener,F0)}),this._rootNodeFocusListenerCount.set(e,n+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const t=this._getDocument(),e=this._getWindow();t.addEventListener("keydown",this._documentKeydownListener,F0),t.addEventListener("mousedown",this._documentMousedownListener,F0),t.addEventListener("touchstart",this._documentTouchstartListener,F0),e.addEventListener("focus",this._windowFocusListener)})}_removeGlobalListeners(t){const e=t.rootNode;if(this._rootNodeFocusListenerCount.has(e)){const t=this._rootNodeFocusListenerCount.get(e);t>1?this._rootNodeFocusListenerCount.set(e,t-1):(e.removeEventListener("focus",this._rootNodeFocusAndBlurListener,F0),e.removeEventListener("blur",this._rootNodeFocusAndBlurListener,F0),this._rootNodeFocusListenerCount.delete(e))}if(!--this._monitoredElementCount){const t=this._getDocument(),e=this._getWindow();t.removeEventListener("keydown",this._documentKeydownListener,F0),t.removeEventListener("mousedown",this._documentMousedownListener,F0),t.removeEventListener("touchstart",this._documentTouchstartListener,F0),e.removeEventListener("focus",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}_originChanged(t,e,n){this._setClasses(t,e),this._emitOrigin(n.subject,e),this._lastFocusOrigin=e}_getClosestElementsInfo(t){const e=[];return this._elementInfo.forEach((n,s)=>{(s===t||n.checkChildren&&s.contains(t))&&e.push([s,n])}),e}}return t.\u0275fac=function(e){return new(e||t)(Os(ju),Os(n0),Os(kc,8),Os(O0,8))},t.\u0275prov=Dt({factory:function(){return new t(Os(ju),Os(n0),Os(kc,8),Os(O0,8))},token:t,providedIn:"root"}),t})();function L0(t){return t.composedPath?t.composedPath()[0]:t.target}const M0="cdk-high-contrast-black-on-white",P0="cdk-high-contrast-white-on-black",z0="cdk-high-contrast-active";let V0=(()=>{class t{constructor(t,e){this._platform=t,this._document=e}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const t=this._document.createElement("div");t.style.backgroundColor="rgb(1,2,3)",t.style.position="absolute",this._document.body.appendChild(t);const e=this._document.defaultView||window,n=e&&e.getComputedStyle?e.getComputedStyle(t):null,s=(n&&n.backgroundColor||"").replace(/ /g,"");switch(this._document.body.removeChild(t),s){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const t=this._document.body.classList;t.remove(z0),t.remove(M0),t.remove(P0),this._hasCheckedHighContrastMode=!0;const e=this.getHighContrastMode();1===e?(t.add(z0),t.add(M0)):2===e&&(t.add(z0),t.add(P0))}}}return t.\u0275fac=function(e){return new(e||t)(Os(n0),Os(kc))},t.\u0275prov=Dt({factory:function(){return new t(Os(n0),Os(kc))},token:t,providedIn:"root"}),t})(),B0=(()=>{class t{constructor(t){t._applyBodyHighContrastModeCssClasses()}}return t.\u0275fac=function(e){return new(e||t)(Os(V0))},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[s0,g0]]}),t})();const W0=new ms("cdk-dir-doc",{providedIn:"root",factory:function(){return Fs(kc)}});let U0=(()=>{class t{constructor(t){if(this.value="ltr",this.change=new ru,t){const e=t.documentElement?t.documentElement.dir:null,n=(t.body?t.body.dir:null)||e;this.value="ltr"===n||"rtl"===n?n:"ltr"}}ngOnDestroy(){this.change.complete()}}return t.\u0275fac=function(e){return new(e||t)(Os(W0,8))},t.\u0275prov=Dt({factory:function(){return new t(Os(W0,8))},token:t,providedIn:"root"}),t})(),j0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})();const H0=new ll("12.0.4");class G0{}const q0="*";function K0(t,e){return{type:7,name:t,definitions:e,options:{}}}function X0(t,e=null){return{type:4,styles:e,timings:t}}function Z0(t,e=null){return{type:2,steps:t,options:e}}function Y0(t){return{type:6,styles:t,offset:null}}function Q0(t,e,n){return{type:0,name:t,styles:e,options:n}}function J0(t){return{type:5,steps:t}}function t1(t,e,n=null){return{type:1,expr:t,animation:e,options:n}}function e1(t){Promise.resolve(null).then(t)}class n1{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){e1(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class s1{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,n=0,s=0;const r=this.players.length;0==r?e1(()=>this._onFinish()):this.players.forEach(t=>{t.onDone(()=>{++e==r&&this._onFinish()}),t.onDestroy(()=>{++n==r&&this._onDestroy()}),t.onStart(()=>{++s==r&&this._onStart()})}),this.totalTime=this.players.reduce((t,e)=>Math.max(t,e.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(t=>{const n=t.totalTime?Math.min(1,e/t.totalTime):1;t.setPosition(n)})}getPosition(){const t=this.players.reduce((t,e)=>null===t||e.totalTime>t.totalTime?e:t,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}function r1(){return"undefined"!=typeof window&&void 0!==window.document}function i1(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function a1(t){switch(t.length){case 0:return new n1;case 1:return t[0];default:return new s1(t)}}function o1(t,e,n,s,r={},i={}){const a=[],o=[];let l=-1,u=null;if(s.forEach(t=>{const n=t.offset,s=n==l,c=s&&u||{};Object.keys(t).forEach(n=>{let s=n,o=t[n];if("offset"!==n)switch(s=e.normalizePropertyName(s,a),o){case"!":o=r[n];break;case q0:o=i[n];break;default:o=e.normalizeStyleValue(n,s,o,a)}c[s]=o}),s||o.push(c),u=c,l=n}),a.length){const t="\n - ";throw new Error(`Unable to animate due to the following errors:${t}${a.join(t)}`)}return o}function l1(t,e,n,s){switch(e){case"start":t.onStart(()=>s(n&&u1(n,"start",t)));break;case"done":t.onDone(()=>s(n&&u1(n,"done",t)));break;case"destroy":t.onDestroy(()=>s(n&&u1(n,"destroy",t)))}}function u1(t,e,n){const s=n.totalTime,r=c1(t.element,t.triggerName,t.fromState,t.toState,e||t.phaseName,null==s?t.totalTime:s,!!n.disabled),i=t._data;return null!=i&&(r._data=i),r}function c1(t,e,n,s,r="",i=0,a){return{element:t,triggerName:e,fromState:n,toState:s,phaseName:r,totalTime:i,disabled:!!a}}function h1(t,e,n){let s;return t instanceof Map?(s=t.get(e),s||t.set(e,s=n)):(s=t[e],s||(s=t[e]=n)),s}function d1(t){const e=t.indexOf(":");return[t.substring(1,e),t.substr(e+1)]}let p1=(t,e)=>!1,f1=(t,e)=>!1,m1=(t,e,n)=>[];const g1=i1();(g1||"undefined"!=typeof Element)&&(p1=r1()?(t,e)=>{for(;e&&e!==document.documentElement;){if(e===t)return!0;e=e.parentNode||e.host}return!1}:(t,e)=>t.contains(e),f1=(()=>{if(g1||Element.prototype.matches)return(t,e)=>t.matches(e);{const t=Element.prototype,e=t.matchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;return e?(t,n)=>e.apply(t,[n]):f1}})(),m1=(t,e,n)=>{let s=[];if(n){const n=t.querySelectorAll(e);for(let t=0;t<n.length;t++)s.push(n[t])}else{const n=t.querySelector(e);n&&s.push(n)}return s});let y1=null,b1=!1;function v1(t){y1||(y1=("undefined"!=typeof document?document.body:null)||{},b1=!!y1.style&&"WebkitAppearance"in y1.style);let e=!0;return y1.style&&!function(t){return"ebkit"==t.substring(1,6)}(t)&&(e=t in y1.style,!e&&b1)&&(e="Webkit"+t.charAt(0).toUpperCase()+t.substr(1)in y1.style),e}const w1=f1,_1=p1,x1=m1;function k1(t){const e={};return Object.keys(t).forEach(n=>{const s=n.replace(/([a-z])([A-Z])/g,"$1-$2");e[s]=t[n]}),e}let C1=(()=>{class t{validateStyleProperty(t){return v1(t)}matchesElement(t,e){return w1(t,e)}containsElement(t,e){return _1(t,e)}query(t,e,n){return x1(t,e,n)}computeStyle(t,e,n){return n||""}animate(t,e,n,s,r,i=[],a){return new n1(n,s)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),S1=(()=>{class t{}return t.NOOP=new C1,t})();const I1="ng-enter",E1="ng-leave",N1="ng-trigger",T1=".ng-trigger",A1="ng-animating",$1=".ng-animating";function R1(t){if("number"==typeof t)return t;const e=t.match(/^(-?[\.\d]+)(m?s)/);return!e||e.length<2?0:O1(parseFloat(e[1]),e[2])}function O1(t,e){switch(e){case"s":return 1e3*t;default:return t}}function F1(t,e,n){return t.hasOwnProperty("duration")?t:function(t,e,n){let s,r=0,i="";if("string"==typeof t){const n=t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===n)return e.push(`The provided timing value "${t}" is invalid.`),{duration:0,delay:0,easing:""};s=O1(parseFloat(n[1]),n[2]);const a=n[3];null!=a&&(r=O1(parseFloat(a),n[4]));const o=n[5];o&&(i=o)}else s=t;if(!n){let n=!1,i=e.length;s<0&&(e.push("Duration values below 0 are not allowed for this animation step."),n=!0),r<0&&(e.push("Delay values below 0 are not allowed for this animation step."),n=!0),n&&e.splice(i,0,`The provided timing value "${t}" is invalid.`)}return{duration:s,delay:r,easing:i}}(t,e,n)}function D1(t,e={}){return Object.keys(t).forEach(n=>{e[n]=t[n]}),e}function L1(t,e,n={}){if(e)for(let s in t)n[s]=t[s];else D1(t,n);return n}function M1(t,e,n){return n?e+":"+n+";":""}function P1(t){let e="";for(let n=0;n<t.style.length;n++){const s=t.style.item(n);e+=M1(0,s,t.style.getPropertyValue(s))}for(const n in t.style)t.style.hasOwnProperty(n)&&!n.startsWith("_")&&(e+=M1(0,n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),t.style[n]));t.setAttribute("style",e)}function z1(t,e,n){t.style&&(Object.keys(e).forEach(s=>{const r=q1(s);n&&!n.hasOwnProperty(s)&&(n[s]=t.style[r]),t.style[r]=e[s]}),i1()&&P1(t))}function V1(t,e){t.style&&(Object.keys(e).forEach(e=>{const n=q1(e);t.style[n]=""}),i1()&&P1(t))}function B1(t){return Array.isArray(t)?1==t.length?t[0]:Z0(t):t}const W1=new RegExp("{{\\s*(.+?)\\s*}}","g");function U1(t){let e=[];if("string"==typeof t){let n;for(;n=W1.exec(t);)e.push(n[1]);W1.lastIndex=0}return e}function j1(t,e,n){const s=t.toString(),r=s.replace(W1,(t,s)=>{let r=e[s];return e.hasOwnProperty(s)||(n.push(`Please provide a value for the animation param ${s}`),r=""),r.toString()});return r==s?t:r}function H1(t){const e=[];let n=t.next();for(;!n.done;)e.push(n.value),n=t.next();return e}const G1=/-+([a-z0-9])/g;function q1(t){return t.replace(G1,(...t)=>t[1].toUpperCase())}function K1(t,e){return 0===t||0===e}function X1(t,e,n){const s=Object.keys(n);if(s.length&&e.length){let i=e[0],a=[];if(s.forEach(t=>{i.hasOwnProperty(t)||a.push(t),i[t]=n[t]}),a.length)for(var r=1;r<e.length;r++){let n=e[r];a.forEach(function(e){n[e]=Y1(t,e)})}}return e}function Z1(t,e,n){switch(e.type){case 7:return t.visitTrigger(e,n);case 0:return t.visitState(e,n);case 1:return t.visitTransition(e,n);case 2:return t.visitSequence(e,n);case 3:return t.visitGroup(e,n);case 4:return t.visitAnimate(e,n);case 5:return t.visitKeyframes(e,n);case 6:return t.visitStyle(e,n);case 8:return t.visitReference(e,n);case 9:return t.visitAnimateChild(e,n);case 10:return t.visitAnimateRef(e,n);case 11:return t.visitQuery(e,n);case 12:return t.visitStagger(e,n);default:throw new Error(`Unable to resolve animation metadata node #${e.type}`)}}function Y1(t,e){return window.getComputedStyle(t)[e]}const Q1="*";function J1(t,e){const n=[];return"string"==typeof t?t.split(/\s*,\s*/).forEach(t=>function(t,e,n){if(":"==t[0]){const s=function(t,e){switch(t){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(t,e)=>parseFloat(e)>parseFloat(t);case":decrement":return(t,e)=>parseFloat(e)<parseFloat(t);default:return e.push(`The transition alias value "${t}" is not supported`),"* => *"}}(t,n);if("function"==typeof s)return void e.push(s);t=s}const s=t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==s||s.length<4)return n.push(`The provided transition expression "${t}" is not supported`),e;const r=s[1],i=s[2],a=s[3];e.push(n2(r,a)),"<"!=i[0]||r==Q1&&a==Q1||e.push(n2(a,r))}(t,n,e)):n.push(t),n}const t2=new Set(["true","1"]),e2=new Set(["false","0"]);function n2(t,e){const n=t2.has(t)||e2.has(t),s=t2.has(e)||e2.has(e);return(r,i)=>{let a=t==Q1||t==r,o=e==Q1||e==i;return!a&&n&&"boolean"==typeof r&&(a=r?t2.has(t):e2.has(t)),!o&&s&&"boolean"==typeof i&&(o=i?t2.has(e):e2.has(e)),a&&o}}const s2=new RegExp("s*:selfs*,?","g");function r2(t,e,n){return new i2(t).build(e,n)}class i2{constructor(t){this._driver=t}build(t,e){const n=new a2(e);return this._resetContextStyleTimingState(n),Z1(this,B1(t),n)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let n=e.queryCount=0,s=e.depCount=0;const r=[],i=[];return"@"==t.name.charAt(0)&&e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"),t.definitions.forEach(t=>{if(this._resetContextStyleTimingState(e),0==t.type){const n=t,s=n.name;s.toString().split(/\s*,\s*/).forEach(t=>{n.name=t,r.push(this.visitState(n,e))}),n.name=s}else if(1==t.type){const r=this.visitTransition(t,e);n+=r.queryCount,s+=r.depCount,i.push(r)}else e.errors.push("only state() and transition() definitions can sit inside of a trigger()")}),{type:7,name:t.name,states:r,transitions:i,queryCount:n,depCount:s,options:null}}visitState(t,e){const n=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(n.containsDynamicStyles){const r=new Set,i=s||{};if(n.styles.forEach(t=>{if(o2(t)){const e=t;Object.keys(e).forEach(t=>{U1(e[t]).forEach(t=>{i.hasOwnProperty(t)||r.add(t)})})}}),r.size){const n=H1(r.values());e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`)}}return{type:0,name:t.name,style:n,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const n=Z1(this,B1(t.animation),e);return{type:1,matchers:J1(t.expr,e.errors),animation:n,queryCount:e.queryCount,depCount:e.depCount,options:l2(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(t=>Z1(this,t,e)),options:l2(t.options)}}visitGroup(t,e){const n=e.currentTime;let s=0;const r=t.steps.map(t=>{e.currentTime=n;const r=Z1(this,t,e);return s=Math.max(s,e.currentTime),r});return e.currentTime=s,{type:3,steps:r,options:l2(t.options)}}visitAnimate(t,e){const n=function(t,e){let n=null;if(t.hasOwnProperty("duration"))n=t;else if("number"==typeof t)return u2(F1(t,e).duration,0,"");const s=t;if(s.split(/\s+/).some(t=>"{"==t.charAt(0)&&"{"==t.charAt(1))){const t=u2(0,0,"");return t.dynamic=!0,t.strValue=s,t}return n=n||F1(s,e),u2(n.duration,n.delay,n.easing)}(t.timings,e.errors);let s;e.currentAnimateTimings=n;let r=t.styles?t.styles:Y0({});if(5==r.type)s=this.visitKeyframes(r,e);else{let r=t.styles,i=!1;if(!r){i=!0;const t={};n.easing&&(t.easing=n.easing),r=Y0(t)}e.currentTime+=n.duration+n.delay;const a=this.visitStyle(r,e);a.isEmptyStep=i,s=a}return e.currentAnimateTimings=null,{type:4,timings:n,style:s,options:null}}visitStyle(t,e){const n=this._makeStyleAst(t,e);return this._validateStyleAst(n,e),n}_makeStyleAst(t,e){const n=[];Array.isArray(t.styles)?t.styles.forEach(t=>{"string"==typeof t?t==q0?n.push(t):e.errors.push(`The provided style string value ${t} is not allowed.`):n.push(t)}):n.push(t.styles);let s=!1,r=null;return n.forEach(t=>{if(o2(t)){const e=t,n=e.easing;if(n&&(r=n,delete e.easing),!s)for(let t in e)if(e[t].toString().indexOf("{{")>=0){s=!0;break}}}),{type:6,styles:n,easing:r,offset:t.offset,containsDynamicStyles:s,options:null}}_validateStyleAst(t,e){const n=e.currentAnimateTimings;let s=e.currentTime,r=e.currentTime;n&&r>0&&(r-=n.duration+n.delay),t.styles.forEach(t=>{"string"!=typeof t&&Object.keys(t).forEach(n=>{if(!this._driver.validateStyleProperty(n))return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`);const i=e.collectedStyles[e.currentQuerySelector],a=i[n];let o=!0;a&&(r!=s&&r>=a.startTime&&s<=a.endTime&&(e.errors.push(`The CSS property "${n}" that exists between the times of "${a.startTime}ms" and "${a.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${s}ms"`),o=!1),r=a.startTime),o&&(i[n]={startTime:r,endTime:s}),e.options&&function(t,e,n){const s=e.params||{},r=U1(t);r.length&&r.forEach(t=>{s.hasOwnProperty(t)||n.push(`Unable to resolve the local animation param ${t} in the given list of values`)})}(t[n],e.options,e.errors)})})}visitKeyframes(t,e){const n={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push("keyframes() must be placed inside of a call to animate()"),n;let s=0;const r=[];let i=!1,a=!1,o=0;const l=t.steps.map(t=>{const n=this._makeStyleAst(t,e);let l=null!=n.offset?n.offset:function(t){if("string"==typeof t)return null;let e=null;if(Array.isArray(t))t.forEach(t=>{if(o2(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}});else if(o2(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}return e}(n.styles),u=0;return null!=l&&(s++,u=n.offset=l),a=a||u<0||u>1,i=i||u<o,o=u,r.push(u),n});a&&e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"),i&&e.errors.push("Please ensure that all keyframe offsets are in order");const u=t.steps.length;let c=0;s>0&&s<u?e.errors.push("Not all style() steps within the declared keyframes() contain offsets"):0==s&&(c=1/(u-1));const h=u-1,d=e.currentTime,p=e.currentAnimateTimings,f=p.duration;return l.forEach((t,s)=>{const i=c>0?s==h?1:c*s:r[s],a=i*f;e.currentTime=d+p.delay+a,p.duration=a,this._validateStyleAst(t,e),t.offset=i,n.styles.push(t)}),n}visitReference(t,e){return{type:8,animation:Z1(this,B1(t.animation),e),options:l2(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:l2(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:l2(t.options)}}visitQuery(t,e){const n=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[r,i]=function(t){const e=!!t.split(/\s*,\s*/).find(t=>":self"==t);return e&&(t=t.replace(s2,"")),[t=t.replace(/@\*/g,T1).replace(/@\w+/g,t=>".ng-trigger-"+t.substr(1)).replace(/:animating/g,$1),e]}(t.selector);e.currentQuerySelector=n.length?n+" "+r:r,h1(e.collectedStyles,e.currentQuerySelector,{});const a=Z1(this,B1(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=n,{type:11,selector:r,limit:s.limit||0,optional:!!s.optional,includeSelf:i,animation:a,originalSelector:t.selector,options:l2(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push("stagger() can only be used inside of query()");const n="full"===t.timings?{duration:0,delay:0,easing:"full"}:F1(t.timings,e.errors,!0);return{type:12,animation:Z1(this,B1(t.animation),e),timings:n,options:null}}}class a2{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function o2(t){return!Array.isArray(t)&&"object"==typeof t}function l2(t){var e;return t?(t=D1(t)).params&&(t.params=(e=t.params)?D1(e):null):t={},t}function u2(t,e,n){return{duration:t,delay:e,easing:n}}function c2(t,e,n,s,r,i,a=null,o=!1){return{type:1,element:t,keyframes:e,preStyleProps:n,postStyleProps:s,duration:r,delay:i,totalTime:r+i,easing:a,subTimeline:o}}class h2{constructor(){this._map=new Map}consume(t){let e=this._map.get(t);return e?this._map.delete(t):e=[],e}append(t,e){let n=this._map.get(t);n||this._map.set(t,n=[]),n.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const d2=new RegExp(":enter","g"),p2=new RegExp(":leave","g");function f2(t,e,n,s,r,i={},a={},o,l,u=[]){return(new m2).buildKeyframes(t,e,n,s,r,i,a,o,l,u)}class m2{buildKeyframes(t,e,n,s,r,i,a,o,l,u=[]){l=l||new h2;const c=new y2(t,e,l,s,r,u,[]);c.options=o,c.currentTimeline.setStyles([i],null,c.errors,o),Z1(this,n,c);const h=c.timelines.filter(t=>t.containsAnimation());if(h.length&&Object.keys(a).length){const t=h[h.length-1];t.allowOnlyTimelineStyles()||t.setStyles([a],null,c.errors,o)}return h.length?h.map(t=>t.buildKeyframes()):[c2(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const n=e.subInstructions.consume(e.element);if(n){const s=e.createSubContext(t.options),r=e.currentTimeline.currentTime,i=this._visitSubInstructions(n,s,s.options);r!=i&&e.transformIntoNewTimeline(i)}e.previousNode=t}visitAnimateRef(t,e){const n=e.createSubContext(t.options);n.transformIntoNewTimeline(),this.visitReference(t.animation,n),e.transformIntoNewTimeline(n.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,n){let s=e.currentTimeline.currentTime;const r=null!=n.duration?R1(n.duration):null,i=null!=n.delay?R1(n.delay):null;return 0!==r&&t.forEach(t=>{const n=e.appendInstructionToTimeline(t,r,i);s=Math.max(s,n.duration+n.delay)}),s}visitReference(t,e){e.updateOptions(t.options,!0),Z1(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const n=e.subContextCount;let s=e;const r=t.options;if(r&&(r.params||r.delay)&&(s=e.createSubContext(r),s.transformIntoNewTimeline(),null!=r.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=g2);const t=R1(r.delay);s.delayNextStep(t)}t.steps.length&&(t.steps.forEach(t=>Z1(this,t,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>n&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const n=[];let s=e.currentTimeline.currentTime;const r=t.options&&t.options.delay?R1(t.options.delay):0;t.steps.forEach(i=>{const a=e.createSubContext(t.options);r&&a.delayNextStep(r),Z1(this,i,a),s=Math.max(s,a.currentTimeline.currentTime),n.push(a.currentTimeline)}),n.forEach(t=>e.currentTimeline.mergeTimelineCollectedStyles(t)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const n=t.strValue;return F1(e.params?j1(n,e.params,e.errors):n,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const n=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;n.delay&&(e.incrementTime(n.delay),s.snapshotCurrentStyles());const r=t.style;5==r.type?this.visitKeyframes(r,e):(e.incrementTime(n.duration),this.visitStyle(r,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const n=e.currentTimeline,s=e.currentAnimateTimings;!s&&n.getCurrentStyleProperties().length&&n.forwardFrame();const r=s&&s.easing||t.easing;t.isEmptyStep?n.applyEmptyStep(r):n.setStyles(t.styles,r,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const n=e.currentAnimateTimings,s=e.currentTimeline.duration,r=n.duration,i=e.createSubContext().currentTimeline;i.easing=n.easing,t.styles.forEach(t=>{i.forwardTime((t.offset||0)*r),i.setStyles(t.styles,t.easing,e.errors,e.options),i.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(i),e.transformIntoNewTimeline(s+r),e.previousNode=t}visitQuery(t,e){const n=e.currentTimeline.currentTime,s=t.options||{},r=s.delay?R1(s.delay):0;r&&(6===e.previousNode.type||0==n&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=g2);let i=n;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let o=null;a.forEach((n,s)=>{e.currentQueryIndex=s;const a=e.createSubContext(t.options,n);r&&a.delayNextStep(r),n===e.element&&(o=a.currentTimeline),Z1(this,t.animation,a),a.currentTimeline.applyStylesToKeyframe(),i=Math.max(i,a.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(i),o&&(e.currentTimeline.mergeTimelineCollectedStyles(o),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const n=e.parentContext,s=e.currentTimeline,r=t.timings,i=Math.abs(r.duration),a=i*(e.currentQueryTotal-1);let o=i*e.currentQueryIndex;switch(r.duration<0?"reverse":r.easing){case"reverse":o=a-o;break;case"full":o=n.currentStaggerTime}const l=e.currentTimeline;o&&l.delayNextStep(o);const u=l.currentTime;Z1(this,t.animation,e),e.previousNode=t,n.currentStaggerTime=s.currentTime-u+(s.startTime-n.currentTimeline.startTime)}}const g2={};class y2{constructor(t,e,n,s,r,i,a,o){this._driver=t,this.element=e,this.subInstructions=n,this._enterClassName=s,this._leaveClassName=r,this.errors=i,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=g2,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=o||new b2(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const n=t;let s=this.options;null!=n.duration&&(s.duration=R1(n.duration)),null!=n.delay&&(s.delay=R1(n.delay));const r=n.params;if(r){let t=s.params;t||(t=this.options.params={}),Object.keys(r).forEach(n=>{e&&t.hasOwnProperty(n)||(t[n]=j1(r[n],t,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const n=t.params={};Object.keys(e).forEach(t=>{n[t]=e[t]})}}return t}createSubContext(t=null,e,n){const s=e||this.element,r=new y2(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,n||0));return r.previousNode=this.previousNode,r.currentAnimateTimings=this.currentAnimateTimings,r.options=this._copyOptions(),r.updateOptions(t),r.currentQueryIndex=this.currentQueryIndex,r.currentQueryTotal=this.currentQueryTotal,r.parentContext=this,this.subContextCount++,r}transformIntoNewTimeline(t){return this.previousNode=g2,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,n){const s={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=n?n:0)+t.delay,easing:""},r=new v2(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(r),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,n,s,r,i){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(d2,"."+this._enterClassName)).replace(p2,"."+this._leaveClassName);let e=this._driver.query(this.element,t,1!=n);0!==n&&(e=n<0?e.slice(e.length+n,e.length):e.slice(0,n)),a.push(...e)}return r||0!=a.length||i.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`),a}}class b2{constructor(t,e,n,s){this._driver=t,this.element=e,this.startTime=n,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new b2(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(t=>{this._backFill[t]=this._globalTimelineStyles[t]||q0,this._currentKeyframe[t]=q0}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,n,s){e&&(this._previousKeyframe.easing=e);const r=s&&s.params||{},i=function(t,e){const n={};let s;return t.forEach(t=>{"*"===t?(s=s||Object.keys(e),s.forEach(t=>{n[t]=q0})):L1(t,!1,n)}),n}(t,this._globalTimelineStyles);Object.keys(i).forEach(t=>{const e=j1(i[t],r,n);this._pendingStyles[t]=e,this._localTimelineStyles.hasOwnProperty(t)||(this._backFill[t]=this._globalTimelineStyles.hasOwnProperty(t)?this._globalTimelineStyles[t]:q0),this._updateStyle(t,e)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(e=>{this._currentKeyframe[e]=t[e]}),Object.keys(this._localTimelineStyles).forEach(t=>{this._currentKeyframe.hasOwnProperty(t)||(this._currentKeyframe[t]=this._localTimelineStyles[t])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const n=this._styleSummary[e],s=t._styleSummary[e];(!n||s.time>n.time)&&this._updateStyle(e,s.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,n=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((r,i)=>{const a=L1(r,!0);Object.keys(a).forEach(n=>{const s=a[n];"!"==s?t.add(n):s==q0&&e.add(n)}),n||(a.offset=i/this.duration),s.push(a)});const r=t.size?H1(t.values()):[],i=e.size?H1(e.values()):[];if(n){const t=s[0],e=D1(t);t.offset=0,e.offset=1,s=[t,e]}return c2(this.element,s,r,i,this.duration,this.startTime,this.easing,!1)}}class v2 extends b2{constructor(t,e,n,s,r,i,a=!1){super(t,e,i.delay),this.element=e,this.keyframes=n,this.preStyleProps=s,this.postStyleProps=r,this._stretchStartingKeyframe=a,this.timings={duration:i.duration,delay:i.delay,easing:i.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:n,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const r=[],i=n+e,a=e/i,o=L1(t[0],!1);o.offset=0,r.push(o);const l=L1(t[0],!1);l.offset=w2(a),r.push(l);const u=t.length-1;for(let s=1;s<=u;s++){let a=L1(t[s],!1);a.offset=w2((e+a.offset*n)/i),r.push(a)}n=i,e=0,s="",t=r}return c2(this.element,t,this.preStyleProps,this.postStyleProps,n,e,s,!0)}}function w2(t,e=3){const n=Math.pow(10,e-1);return Math.round(t*n)/n}class _2{}class x2 extends _2{normalizePropertyName(t,e){return q1(t)}normalizeStyleValue(t,e,n,s){let r="";const i=n.toString().trim();if(k2[e]&&0!==n&&"0"!==n)if("number"==typeof n)r="px";else{const e=n.match(/^[+-]?[\d\.]+([a-z]*)$/);e&&0==e[1].length&&s.push(`Please provide a CSS unit value for ${t}:${n}`)}return i+r}}const k2=(()=>function(t){const e={};return t.forEach(t=>e[t]=!0),e}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function C2(t,e,n,s,r,i,a,o,l,u,c,h,d){return{type:0,element:t,triggerName:e,isRemovalTransition:r,fromState:n,fromStyles:i,toState:s,toStyles:a,timelines:o,queriedElements:l,preStyleProps:u,postStyleProps:c,totalTime:h,errors:d}}const S2={};class I2{constructor(t,e,n){this._triggerName=t,this.ast=e,this._stateStyles=n}match(t,e,n,s){return function(t,e,n,s,r){return t.some(t=>t(e,n,s,r))}(this.ast.matchers,t,e,n,s)}buildStyles(t,e,n){const s=this._stateStyles["*"],r=this._stateStyles[t],i=s?s.buildStyles(e,n):{};return r?r.buildStyles(e,n):i}build(t,e,n,s,r,i,a,o,l,u){const c=[],h=this.ast.options&&this.ast.options.params||S2,d=this.buildStyles(n,a&&a.params||S2,c),p=o&&o.params||S2,f=this.buildStyles(s,p,c),m=new Set,g=new Map,y=new Map,b="void"===s,v={params:Object.assign(Object.assign({},h),p)},w=u?[]:f2(t,e,this.ast.animation,r,i,d,f,v,l,c);let _=0;if(w.forEach(t=>{_=Math.max(t.duration+t.delay,_)}),c.length)return C2(e,this._triggerName,n,s,b,d,f,[],[],g,y,_,c);w.forEach(t=>{const n=t.element,s=h1(g,n,{});t.preStyleProps.forEach(t=>s[t]=!0);const r=h1(y,n,{});t.postStyleProps.forEach(t=>r[t]=!0),n!==e&&m.add(n)});const x=H1(m.values());return C2(e,this._triggerName,n,s,b,d,f,w,x,g,y,_)}}class E2{constructor(t,e){this.styles=t,this.defaultParams=e}buildStyles(t,e){const n={},s=D1(this.defaultParams);return Object.keys(t).forEach(e=>{const n=t[e];null!=n&&(s[e]=n)}),this.styles.styles.forEach(t=>{if("string"!=typeof t){const r=t;Object.keys(r).forEach(t=>{let i=r[t];i.length>1&&(i=j1(i,s,e)),n[t]=i})}}),n}}class N2{constructor(t,e){this.name=t,this.ast=e,this.transitionFactories=[],this.states={},e.states.forEach(t=>{this.states[t.name]=new E2(t.style,t.options&&t.options.params||{})}),T2(this.states,"true","1"),T2(this.states,"false","0"),e.transitions.forEach(e=>{this.transitionFactories.push(new I2(t,e,this.states))}),this.fallbackTransition=new I2(t,{type:1,animation:{type:2,steps:[],options:null},matchers:[(t,e)=>!0],options:null,queryCount:0,depCount:0},this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,n,s){return this.transitionFactories.find(r=>r.match(t,e,n,s))||null}matchStyles(t,e,n){return this.fallbackTransition.buildStyles(t,e,n)}}function T2(t,e,n){t.hasOwnProperty(e)?t.hasOwnProperty(n)||(t[n]=t[e]):t.hasOwnProperty(n)&&(t[e]=t[n])}const A2=new h2;class $2{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._normalizer=n,this._animations={},this._playersById={},this.players=[]}register(t,e){const n=[],s=r2(this._driver,e,n);if(n.length)throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`);this._animations[t]=s}_buildPlayer(t,e,n){const s=t.element,r=o1(0,this._normalizer,0,t.keyframes,e,n);return this._driver.animate(s,r,t.duration,t.delay,t.easing,[],!0)}create(t,e,n={}){const s=[],r=this._animations[t];let i;const a=new Map;if(r?(i=f2(this._driver,e,r,I1,E1,{},{},n,A2,s),i.forEach(t=>{const e=h1(a,t.element,{});t.postStyleProps.forEach(t=>e[t]=null)})):(s.push("The requested animation doesn't exist or has already been destroyed"),i=[]),s.length)throw new Error(`Unable to create the animation due to the following errors: ${s.join("\n")}`);a.forEach((t,e)=>{Object.keys(t).forEach(n=>{t[n]=this._driver.computeStyle(e,n,q0)})});const o=a1(i.map(t=>{const e=a.get(t.element);return this._buildPlayer(t,{},e)}));return this._playersById[t]=o,o.onDestroy(()=>this.destroy(t)),this.players.push(o),o}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const n=this.players.indexOf(e);n>=0&&this.players.splice(n,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw new Error(`Unable to find the timeline player referenced by ${t}`);return e}listen(t,e,n,s){const r=c1(e,"","","");return l1(this._getPlayer(t),n,r,s),()=>{}}command(t,e,n,s){if("register"==n)return void this.register(t,s[0]);if("create"==n)return void this.create(t,e,s[0]||{});const r=this._getPlayer(t);switch(n){case"play":r.play();break;case"pause":r.pause();break;case"reset":r.reset();break;case"restart":r.restart();break;case"finish":r.finish();break;case"init":r.init();break;case"setPosition":r.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const R2="ng-animate-queued",O2="ng-animate-disabled",F2=".ng-animate-disabled",D2=[],L2={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},M2={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class P2{constructor(t,e=""){this.namespaceId=e;const n=t&&t.hasOwnProperty("value");if(this.value=null!=(s=n?t.value:t)?s:null,n){const e=D1(t);delete e.value,this.options=e}else this.options={};var s;this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const t=this.options.params;Object.keys(e).forEach(n=>{null==t[n]&&(t[n]=e[n])})}}}const z2="void",V2=new P2(z2);class B2{constructor(t,e,n){this.id=t,this.hostElement=e,this._engine=n,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,K2(e,this._hostClassName)}listen(t,e,n,s){if(!this._triggers.hasOwnProperty(e))throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`);if(null==n||0==n.length)throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`);if("start"!=(r=n)&&"done"!=r)throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`);var r;const i=h1(this._elementListeners,t,[]),a={name:e,phase:n,callback:s};i.push(a);const o=h1(this._engine.statesByElement,t,{});return o.hasOwnProperty(e)||(K2(t,N1),K2(t,"ng-trigger-"+e),o[e]=V2),()=>{this._engine.afterFlush(()=>{const t=i.indexOf(a);t>=0&&i.splice(t,1),this._triggers[e]||delete o[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw new Error(`The provided animation trigger "${t}" has not been registered!`);return e}trigger(t,e,n,s=!0){const r=this._getTrigger(e),i=new U2(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(K2(t,N1),K2(t,"ng-trigger-"+e),this._engine.statesByElement.set(t,a={}));let o=a[e];const l=new P2(n,this.id);if(!(n&&n.hasOwnProperty("value"))&&o&&l.absorbOptions(o.options),a[e]=l,o||(o=V2),l.value!==z2&&o.value===l.value){if(!function(t,e){const n=Object.keys(t),s=Object.keys(e);if(n.length!=s.length)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(!e.hasOwnProperty(s)||t[s]!==e[s])return!1}return!0}(o.params,l.params)){const e=[],n=r.matchStyles(o.value,o.params,e),s=r.matchStyles(l.value,l.params,e);e.length?this._engine.reportError(e):this._engine.afterFlush(()=>{V1(t,n),z1(t,s)})}return}const u=h1(this._engine.playersByElement,t,[]);u.forEach(t=>{t.namespaceId==this.id&&t.triggerName==e&&t.queued&&t.destroy()});let c=r.matchTransition(o.value,l.value,t,l.params),h=!1;if(!c){if(!s)return;c=r.fallbackTransition,h=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:c,fromState:o,toState:l,player:i,isFallbackTransition:h}),h||(K2(t,R2),i.onStart(()=>{X2(t,R2)})),i.onDone(()=>{let e=this.players.indexOf(i);e>=0&&this.players.splice(e,1);const n=this._engine.playersByElement.get(t);if(n){let t=n.indexOf(i);t>=0&&n.splice(t,1)}}),this.players.push(i),u.push(i),i}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,n)=>{delete e[t]}),this._elementListeners.forEach((e,n)=>{this._elementListeners.set(n,e.filter(e=>e.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(t=>t.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const n=this._engine.driver.query(t,T1,!0);n.forEach(t=>{if(t.__ng_removed)return;const n=this._engine.fetchNamespacesByElement(t);n.size?n.forEach(n=>n.triggerLeaveAnimation(t,e,!1,!0)):this.clearElementCache(t)}),this._engine.afterFlushAnimationsDone(()=>n.forEach(t=>this.clearElementCache(t)))}triggerLeaveAnimation(t,e,n,s){const r=this._engine.statesByElement.get(t);if(r){const i=[];if(Object.keys(r).forEach(e=>{if(this._triggers[e]){const n=this.trigger(t,e,z2,s);n&&i.push(n)}}),i.length)return this._engine.markElementAsRemoved(this.id,t,!0,e),n&&a1(i).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),n=this._engine.statesByElement.get(t);if(e&&n){const s=new Set;e.forEach(e=>{const r=e.name;if(s.has(r))return;s.add(r);const i=this._triggers[r].fallbackTransition,a=n[r]||V2,o=new P2(z2),l=new U2(this.id,r,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:r,transition:i,fromState:a,toState:o,player:l,isFallbackTransition:!0})})}}removeNode(t,e){const n=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(n.totalAnimations){const e=n.players.length?n.playersByQueriedElement.get(t):[];if(e&&e.length)s=!0;else{let e=t;for(;e=e.parentNode;)if(n.statesByElement.get(e)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)n.markElementAsRemoved(this.id,t,!1,e);else{const s=t.__ng_removed;s&&s!==L2||(n.afterFlush(()=>this.clearElementCache(t)),n.destroyInnerAnimations(t),n._onRemovalComplete(t,e))}}insertNode(t,e){K2(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(n=>{const s=n.player;if(s.destroyed)return;const r=n.element,i=this._elementListeners.get(r);i&&i.forEach(e=>{if(e.name==n.triggerName){const s=c1(r,n.triggerName,n.fromState.value,n.toState.value);s._data=t,l1(n.player,e.phase,s,e.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(n)}),this._queue=[],e.sort((t,e)=>{const n=t.transition.ast.depCount,s=e.transition.ast.depCount;return 0==n||0==s?n-s:this._engine.driver.containsElement(t.element,e.element)?1:-1})}destroy(t){this.players.forEach(t=>t.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(e=>e.element===t)||e,e}}class W2{constructor(t,e,n){this.bodyNode=t,this.driver=e,this._normalizer=n,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(t,e)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(e=>{e.queued&&t.push(e)})}),t}createNamespace(t,e){const n=new B2(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(n,e):(this.newHostElements.set(e,n),this.collectEnterElement(e)),this._namespaceLookup[t]=n}_balanceNamespaceList(t,e){const n=this._namespaceList.length-1;if(n>=0){let s=!1;for(let r=n;r>=0;r--)if(this.driver.containsElement(this._namespaceList[r].hostElement,e)){this._namespaceList.splice(r+1,0,t),s=!0;break}s||this._namespaceList.splice(0,0,t)}else this._namespaceList.push(t);return this.namespacesByHostElement.set(e,t),t}register(t,e){let n=this._namespaceLookup[t];return n||(n=this.createNamespace(t,e)),n}registerTrigger(t,e,n){let s=this._namespaceLookup[t];s&&s.register(e,n)&&this.totalAnimations++}destroy(t,e){if(!t)return;const n=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(n.hostElement),delete this._namespaceLookup[t];const e=this._namespaceList.indexOf(n);e>=0&&this._namespaceList.splice(e,1)}),this.afterFlushAnimationsDone(()=>n.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,n=this.statesByElement.get(t);if(n){const t=Object.keys(n);for(let s=0;s<t.length;s++){const r=n[t[s]].namespaceId;if(r){const t=this._fetchNamespace(r);t&&e.add(t)}}}return e}trigger(t,e,n,s){if(j2(e)){const r=this._fetchNamespace(t);if(r)return r.trigger(e,n,s),!0}return!1}insertNode(t,e,n,s){if(!j2(e))return;const r=e.__ng_removed;if(r&&r.setForRemoval){r.setForRemoval=!1,r.setForMove=!0;const t=this.collectedLeaveElements.indexOf(e);t>=0&&this.collectedLeaveElements.splice(t,1)}if(t){const s=this._fetchNamespace(t);s&&s.insertNode(e,n)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),K2(t,O2)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),X2(t,O2))}removeNode(t,e,n,s){if(j2(e)){const r=t?this._fetchNamespace(t):null;if(r?r.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),n){const n=this.namespacesByHostElement.get(e);n&&n.id!==t&&n.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,n,s){this.collectedLeaveElements.push(e),e.__ng_removed={namespaceId:t,setForRemoval:s,hasAnimation:n,removedBeforeQueried:!1}}listen(t,e,n,s,r){return j2(e)?this._fetchNamespace(t).listen(e,n,s,r):()=>{}}_buildInstruction(t,e,n,s,r){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,n,s,t.fromState.options,t.toState.options,e,r)}destroyInnerAnimations(t){let e=this.driver.query(t,T1,!0);e.forEach(t=>this.destroyActiveAnimationsForElement(t)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,$1,!0),e.forEach(t=>this.finishActiveQueriedAnimationOnElement(t)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(t=>{t.queued?t.markedForDestroy=!0:t.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(t=>t.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return a1(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t.__ng_removed;if(e&&e.setForRemoval){if(t.__ng_removed=L2,e.namespaceId){this.destroyInnerAnimations(t);const n=this._fetchNamespace(e.namespaceId);n&&n.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}this.driver.matchesElement(t,F2)&&this.markElementAsDisabled(t,!1),this.driver.query(t,F2,!0).forEach(t=>{this.markElementAsDisabled(t,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((t,e)=>this._balanceNamespaceList(t,e)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let n=0;n<this.collectedEnterElements.length;n++)K2(this.collectedEnterElements[n],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const n=[];try{e=this._flushAnimations(n,t)}finally{for(let t=0;t<n.length;t++)n[t]()}}else for(let n=0;n<this.collectedLeaveElements.length;n++)this.processLeaveNode(this.collectedLeaveElements[n]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(t=>t()),this._flushFns=[],this._whenQuietFns.length){const t=this._whenQuietFns;this._whenQuietFns=[],e.length?a1(e).onDone(()=>{t.forEach(t=>t())}):t.forEach(t=>t())}}reportError(t){throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`)}_flushAnimations(t,e){const n=new h2,s=[],r=new Map,i=[],a=new Map,o=new Map,l=new Map,u=new Set;this.disabledNodes.forEach(t=>{u.add(t);const e=this.driver.query(t,".ng-animate-queued",!0);for(let n=0;n<e.length;n++)u.add(e[n])});const c=this.bodyNode,h=Array.from(this.statesByElement.keys()),d=q2(h,this.collectedEnterElements),p=new Map;let f=0;d.forEach((t,e)=>{const n=I1+f++;p.set(e,n),t.forEach(t=>K2(t,n))});const m=[],g=new Set,y=new Set;for(let A=0;A<this.collectedLeaveElements.length;A++){const t=this.collectedLeaveElements[A],e=t.__ng_removed;e&&e.setForRemoval&&(m.push(t),g.add(t),e.hasAnimation?this.driver.query(t,".ng-star-inserted",!0).forEach(t=>g.add(t)):y.add(t))}const b=new Map,v=q2(h,Array.from(g));v.forEach((t,e)=>{const n=E1+f++;b.set(e,n),t.forEach(t=>K2(t,n))}),t.push(()=>{d.forEach((t,e)=>{const n=p.get(e);t.forEach(t=>X2(t,n))}),v.forEach((t,e)=>{const n=b.get(e);t.forEach(t=>X2(t,n))}),m.forEach(t=>{this.processLeaveNode(t)})});const w=[],_=[];for(let A=this._namespaceList.length-1;A>=0;A--)this._namespaceList[A].drainQueuedTransitions(e).forEach(t=>{const e=t.player,r=t.element;if(w.push(e),this.collectedEnterElements.length){const t=r.__ng_removed;if(t&&t.setForMove)return void e.destroy()}const u=!c||!this.driver.containsElement(c,r),h=b.get(r),d=p.get(r),f=this._buildInstruction(t,n,d,h,u);if(f.errors&&f.errors.length)_.push(f);else{if(u)return e.onStart(()=>V1(r,f.fromStyles)),e.onDestroy(()=>z1(r,f.toStyles)),void s.push(e);if(t.isFallbackTransition)return e.onStart(()=>V1(r,f.fromStyles)),e.onDestroy(()=>z1(r,f.toStyles)),void s.push(e);f.timelines.forEach(t=>t.stretchStartingKeyframe=!0),n.append(r,f.timelines),i.push({instruction:f,player:e,element:r}),f.queriedElements.forEach(t=>h1(a,t,[]).push(e)),f.preStyleProps.forEach((t,e)=>{const n=Object.keys(t);if(n.length){let t=o.get(e);t||o.set(e,t=new Set),n.forEach(e=>t.add(e))}}),f.postStyleProps.forEach((t,e)=>{const n=Object.keys(t);let s=l.get(e);s||l.set(e,s=new Set),n.forEach(t=>s.add(t))})}});if(_.length){const t=[];_.forEach(e=>{t.push(`@${e.triggerName} has failed due to:\n`),e.errors.forEach(e=>t.push(`- ${e}\n`))}),w.forEach(t=>t.destroy()),this.reportError(t)}const x=new Map,k=new Map;i.forEach(t=>{const e=t.element;n.has(e)&&(k.set(e,e),this._beforeAnimationBuild(t.player.namespaceId,t.instruction,x))}),s.forEach(t=>{const e=t.element;this._getPreviousPlayers(e,!1,t.namespaceId,t.triggerName,null).forEach(t=>{h1(x,e,[]).push(t),t.destroy()})});const C=m.filter(t=>Q2(t,o,l)),S=new Map;G2(S,this.driver,y,l,q0).forEach(t=>{Q2(t,o,l)&&C.push(t)});const I=new Map;d.forEach((t,e)=>{G2(I,this.driver,new Set(t),o,"!")}),C.forEach(t=>{const e=S.get(t),n=I.get(t);S.set(t,Object.assign(Object.assign({},e),n))});const E=[],N=[],T={};i.forEach(t=>{const{element:e,player:i,instruction:a}=t;if(n.has(e)){if(u.has(e))return i.onDestroy(()=>z1(e,a.toStyles)),i.disabled=!0,i.overrideTotalTime(a.totalTime),void s.push(i);let t=T;if(k.size>1){let n=e;const s=[];for(;n=n.parentNode;){const e=k.get(n);if(e){t=e;break}s.push(n)}s.forEach(e=>k.set(e,t))}const n=this._buildAnimation(i.namespaceId,a,x,r,I,S);if(i.setRealPlayer(n),t===T)E.push(i);else{const e=this.playersByElement.get(t);e&&e.length&&(i.parentPlayer=a1(e)),s.push(i)}}else V1(e,a.fromStyles),i.onDestroy(()=>z1(e,a.toStyles)),N.push(i),u.has(e)&&s.push(i)}),N.forEach(t=>{const e=r.get(t.element);if(e&&e.length){const n=a1(e);t.setRealPlayer(n)}}),s.forEach(t=>{t.parentPlayer?t.syncPlayerEvents(t.parentPlayer):t.destroy()});for(let A=0;A<m.length;A++){const t=m[A],e=t.__ng_removed;if(X2(t,E1),e&&e.hasAnimation)continue;let n=[];if(a.size){let e=a.get(t);e&&e.length&&n.push(...e);let s=this.driver.query(t,$1,!0);for(let t=0;t<s.length;t++){let e=a.get(s[t]);e&&e.length&&n.push(...e)}}const s=n.filter(t=>!t.destroyed);s.length?Z2(this,t,s):this.processLeaveNode(t)}return m.length=0,E.forEach(t=>{this.players.push(t),t.onDone(()=>{t.destroy();const e=this.players.indexOf(t);this.players.splice(e,1)}),t.play()}),E}elementContainsData(t,e){let n=!1;const s=e.__ng_removed;return s&&s.setForRemoval&&(n=!0),this.playersByElement.has(e)&&(n=!0),this.playersByQueriedElement.has(e)&&(n=!0),this.statesByElement.has(e)&&(n=!0),this._fetchNamespace(t).elementContainsData(e)||n}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,n,s,r){let i=[];if(e){const e=this.playersByQueriedElement.get(t);e&&(i=e)}else{const e=this.playersByElement.get(t);if(e){const t=!r||r==z2;e.forEach(e=>{e.queued||(t||e.triggerName==s)&&i.push(e)})}}return(n||s)&&(i=i.filter(t=>!(n&&n!=t.namespaceId||s&&s!=t.triggerName))),i}_beforeAnimationBuild(t,e,n){const s=e.element,r=e.isRemovalTransition?void 0:t,i=e.isRemovalTransition?void 0:e.triggerName;for(const a of e.timelines){const t=a.element,o=t!==s,l=h1(n,t,[]);this._getPreviousPlayers(t,o,r,i,e.toState).forEach(t=>{const e=t.getRealPlayer();e.beforeDestroy&&e.beforeDestroy(),t.destroy(),l.push(t)})}V1(s,e.fromStyles)}_buildAnimation(t,e,n,s,r,i){const a=e.triggerName,o=e.element,l=[],u=new Set,c=new Set,h=e.timelines.map(e=>{const h=e.element;u.add(h);const d=h.__ng_removed;if(d&&d.removedBeforeQueried)return new n1(e.duration,e.delay);const p=h!==o,f=function(t){const e=[];return Y2(t,e),e}((n.get(h)||D2).map(t=>t.getRealPlayer())).filter(t=>!!t.element&&t.element===h),m=r.get(h),g=i.get(h),y=o1(0,this._normalizer,0,e.keyframes,m,g),b=this._buildPlayer(e,y,f);if(e.subTimeline&&s&&c.add(h),p){const e=new U2(t,a,h);e.setRealPlayer(b),l.push(e)}return b});l.forEach(t=>{h1(this.playersByQueriedElement,t.element,[]).push(t),t.onDone(()=>function(t,e,n){let s;if(t instanceof Map){if(s=t.get(e),s){if(s.length){const t=s.indexOf(n);s.splice(t,1)}0==s.length&&t.delete(e)}}else if(s=t[e],s){if(s.length){const t=s.indexOf(n);s.splice(t,1)}0==s.length&&delete t[e]}return s}(this.playersByQueriedElement,t.element,t))}),u.forEach(t=>K2(t,A1));const d=a1(h);return d.onDestroy(()=>{u.forEach(t=>X2(t,A1)),z1(o,e.toStyles)}),c.forEach(t=>{h1(s,t,[]).push(d)}),d}_buildPlayer(t,e,n){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,n):new n1(t.duration,t.delay)}}class U2{constructor(t,e,n){this.namespaceId=t,this.triggerName=e,this.element=n,this._player=new n1,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(n=>l1(t,e,void 0,n))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){h1(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function j2(t){return t&&1===t.nodeType}function H2(t,e){const n=t.style.display;return t.style.display=null!=e?e:"none",n}function G2(t,e,n,s,r){const i=[];n.forEach(t=>i.push(H2(t)));const a=[];s.forEach((n,s)=>{const i={};n.forEach(t=>{const n=i[t]=e.computeStyle(s,t,r);n&&0!=n.length||(s.__ng_removed=M2,a.push(s))}),t.set(s,i)});let o=0;return n.forEach(t=>H2(t,i[o++])),a}function q2(t,e){const n=new Map;if(t.forEach(t=>n.set(t,[])),0==e.length)return n;const s=new Set(e),r=new Map;function i(t){if(!t)return 1;let e=r.get(t);if(e)return e;const a=t.parentNode;return e=n.has(a)?a:s.has(a)?1:i(a),r.set(t,e),e}return e.forEach(t=>{const e=i(t);1!==e&&n.get(e).push(t)}),n}function K2(t,e){if(t.classList)t.classList.add(e);else{let n=t.$$classes;n||(n=t.$$classes={}),n[e]=!0}}function X2(t,e){if(t.classList)t.classList.remove(e);else{let n=t.$$classes;n&&delete n[e]}}function Z2(t,e,n){a1(n).onDone(()=>t.processLeaveNode(e))}function Y2(t,e){for(let n=0;n<t.length;n++){const s=t[n];s instanceof s1?Y2(s.players,e):e.push(s)}}function Q2(t,e,n){const s=n.get(t);if(!s)return!1;let r=e.get(t);return r?s.forEach(t=>r.add(t)):e.set(t,s),n.delete(t),!0}class J2{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._triggerCache={},this.onRemovalComplete=(t,e)=>{},this._transitionEngine=new W2(t,e,n),this._timelineEngine=new $2(t,e,n),this._transitionEngine.onRemovalComplete=(t,e)=>this.onRemovalComplete(t,e)}registerTrigger(t,e,n,s,r){const i=t+"-"+s;let a=this._triggerCache[i];if(!a){const t=[],e=r2(this._driver,r,t);if(t.length)throw new Error(`The animation trigger "${s}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);a=function(t,e){return new N2(t,e)}(s,e),this._triggerCache[i]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,n,s){this._transitionEngine.insertNode(t,e,n,s)}onRemove(t,e,n,s){this._transitionEngine.removeNode(t,e,s||!1,n)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,n,s){if("@"==n.charAt(0)){const[t,r]=d1(n);this._timelineEngine.command(t,e,r,s)}else this._transitionEngine.trigger(t,e,n,s)}listen(t,e,n,s,r){if("@"==n.charAt(0)){const[t,s]=d1(n);return this._timelineEngine.listen(t,e,s,r)}return this._transitionEngine.listen(t,e,n,s,r)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function t3(t,e){let n=null,s=null;return Array.isArray(e)&&e.length?(n=n3(e[0]),e.length>1&&(s=n3(e[e.length-1]))):e&&(n=n3(e)),n||s?new e3(t,n,s):null}let e3=(()=>{class t{constructor(e,n,s){this._element=e,this._startStyles=n,this._endStyles=s,this._state=0;let r=t.initialStylesByElement.get(e);r||t.initialStylesByElement.set(e,r={}),this._initialStyles=r}start(){this._state<1&&(this._startStyles&&z1(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(z1(this._element,this._initialStyles),this._endStyles&&(z1(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(t.initialStylesByElement.delete(this._element),this._startStyles&&(V1(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(V1(this._element,this._endStyles),this._endStyles=null),z1(this._element,this._initialStyles),this._state=3)}}return t.initialStylesByElement=new WeakMap,t})();function n3(t){let e=null;const n=Object.keys(t);for(let s=0;s<n.length;s++){const r=n[s];s3(r)&&(e=e||{},e[r]=t[r])}return e}function s3(t){return"display"===t||"position"===t}const r3="animation",i3="animationend";class a3{constructor(t,e,n,s,r,i,a){this._element=t,this._name=e,this._duration=n,this._delay=s,this._easing=r,this._fillMode=i,this._onDoneFn=a,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=t=>this._handleCallback(t)}apply(){!function(t,e){const n=d3(t,"").trim();n.length&&(function(t,e){let n=0;for(let s=0;s<t.length;s++)","===t.charAt(s)&&n++}(n),e=`${n}, ${e}`),h3(t,"",e)}(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),c3(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){o3(this._element,this._name,"paused")}resume(){o3(this._element,this._name,"running")}setPosition(t){const e=l3(this._element,this._name);this._position=t*this._duration,h3(this._element,"Delay",`-${this._position}ms`,e)}getPosition(){return this._position}_handleCallback(t){const e=t._ngTestManualTimestamp||Date.now(),n=1e3*parseFloat(t.elapsedTime.toFixed(3));t.animationName==this._name&&Math.max(e-this._startTime,0)>=this._delay&&n>=this._duration&&this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),c3(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(t,e){const n=d3(t,"").split(","),s=u3(n,e);s>=0&&(n.splice(s,1),h3(t,"",n.join(",")))}(this._element,this._name))}}function o3(t,e,n){h3(t,"PlayState",n,l3(t,e))}function l3(t,e){const n=d3(t,"");return n.indexOf(",")>0?u3(n.split(","),e):u3([n],e)}function u3(t,e){for(let n=0;n<t.length;n++)if(t[n].indexOf(e)>=0)return n;return-1}function c3(t,e,n){n?t.removeEventListener(i3,e):t.addEventListener(i3,e)}function h3(t,e,n,s){const r=r3+e;if(null!=s){const e=t.style[r];if(e.length){const t=e.split(",");t[s]=n,n=t.join(",")}}t.style[r]=n}function d3(t,e){return t.style[r3+e]||""}class p3{constructor(t,e,n,s,r,i,a,o){this.element=t,this.keyframes=e,this.animationName=n,this._duration=s,this._delay=r,this._finalStyles=a,this._specialStyles=o,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this.currentSnapshot={},this._state=0,this.easing=i||"linear",this.totalTime=s+r,this._buildStyler()}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}destroy(){this.init(),this._state>=4||(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(t=>t()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}finish(){this.init(),this._state>=3||(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&&this._specialStyles.finish(),this._flushDoneFns())}setPosition(t){this._styler.setPosition(t)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state>=2}init(){this._state>=1||(this._state=1,this._styler.apply(),this._delay&&this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&&this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._state=0,this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new a3(this.element,this.animationName,this._duration,this._delay,this.easing,"forwards",()=>this.finish())}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}beforeDestroy(){this.init();const t={};if(this.hasStarted()){const e=this._state>=3;Object.keys(this._finalStyles).forEach(n=>{"offset"!=n&&(t[n]=e?this._finalStyles[n]:Y1(this.element,n))})}this.currentSnapshot=t}}class f3 extends n1{constructor(t,e){super(),this.element=t,this._startingStyles={},this.__initialized=!1,this._styles=k1(e)}init(){!this.__initialized&&this._startingStyles&&(this.__initialized=!0,Object.keys(this._styles).forEach(t=>{this._startingStyles[t]=this.element.style[t]}),super.init())}play(){this._startingStyles&&(this.init(),Object.keys(this._styles).forEach(t=>this.element.style.setProperty(t,this._styles[t])),super.play())}destroy(){this._startingStyles&&(Object.keys(this._startingStyles).forEach(t=>{const e=this._startingStyles[t];e?this.element.style.setProperty(t,e):this.element.style.removeProperty(t)}),this._startingStyles=null,super.destroy())}}class m3{constructor(){this._count=0}validateStyleProperty(t){return v1(t)}matchesElement(t,e){return w1(t,e)}containsElement(t,e){return _1(t,e)}query(t,e,n){return x1(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}buildKeyframeElement(t,e,n){n=n.map(t=>k1(t));let s=`@keyframes ${e} {\n`,r="";n.forEach(t=>{r=" ";const e=parseFloat(t.offset);s+=`${r}${100*e}% {\n`,r+=" ",Object.keys(t).forEach(e=>{const n=t[e];switch(e){case"offset":return;case"easing":return void(n&&(s+=`${r}animation-timing-function: ${n};\n`));default:return void(s+=`${r}${e}: ${n};\n`)}}),s+=`${r}}\n`}),s+="}\n";const i=document.createElement("style");return i.textContent=s,i}animate(t,e,n,s,r,i=[],a){const o=i.filter(t=>t instanceof p3),l={};K1(n,s)&&o.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const u=function(t){let e={};return t&&(Array.isArray(t)?t:[t]).forEach(t=>{Object.keys(t).forEach(n=>{"offset"!=n&&"easing"!=n&&(e[n]=t[n])})}),e}(e=X1(t,e,l));if(0==n)return new f3(t,u);const c="gen_css_kf_"+this._count++,h=this.buildKeyframeElement(t,c,e);(function(t){var e;const n=null===(e=t.getRootNode)||void 0===e?void 0:e.call(t);return"undefined"!=typeof ShadowRoot&&n instanceof ShadowRoot?n:document.head})(t).appendChild(h);const d=t3(t,e),p=new p3(t,e,c,n,s,r,u,d);return p.onDestroy(()=>{var t;(t=h).parentNode.removeChild(t)}),p}}class g3{constructor(t,e,n,s){this.element=t,this.keyframes=e,this.options=n,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=n.duration,this._delay=n.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,n){return t.animate(e,n)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};this.hasStarted()&&Object.keys(this._finalKeyframe).forEach(e=>{"offset"!=e&&(t[e]=this._finished?this._finalKeyframe[e]:Y1(this.element,e))}),this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class y3{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(b3().toString()),this._cssKeyframesDriver=new m3}validateStyleProperty(t){return v1(t)}matchesElement(t,e){return w1(t,e)}containsElement(t,e){return _1(t,e)}query(t,e,n){return x1(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}overrideWebAnimationsSupport(t){this._isNativeImpl=t}animate(t,e,n,s,r,i=[],a){if(!a&&!this._isNativeImpl)return this._cssKeyframesDriver.animate(t,e,n,s,r,i);const o={duration:n,delay:s,fill:0==s?"both":"forwards"};r&&(o.easing=r);const l={},u=i.filter(t=>t instanceof g3);K1(n,s)&&u.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const c=t3(t,e=X1(t,e=e.map(t=>L1(t,!1)),l));return new g3(t,e,o,c)}}function b3(){return r1()&&Element.prototype.animate||{}}let v3=(()=>{class t extends G0{constructor(t,e){super(),this._nextAnimationId=0,this._renderer=t.createRenderer(e.body,{id:"0",encapsulation:Zt.None,styles:[],data:{animation:[]}})}build(t){const e=this._nextAnimationId.toString();this._nextAnimationId++;const n=Array.isArray(t)?Z0(t):t;return x3(this._renderer,null,e,"register",[n]),new w3(e,this._renderer)}}return t.\u0275fac=function(e){return new(e||t)(Os(rl),Os(kc))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();class w3 extends class{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new _3(this._id,t,e||{},this._renderer)}}class _3{constructor(t,e,n,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",n)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return x3(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function x3(t,e,n,s,r){return t.setProperty(e,`@@${n}:${s}`,r)}const k3="@",C3="@.disabled";let S3=(()=>{class t{constructor(t,e,n){this.delegate=t,this.engine=e,this._zone=n,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),e.onRemovalComplete=(t,e)=>{e&&e.parentNode(t)&&e.removeChild(t.parentNode,t)}}createRenderer(t,e){const n=this.delegate.createRenderer(t,e);if(!(t&&e&&e.data&&e.data.animation)){let t=this._rendererCache.get(n);return t||(t=new I3("",n,this.engine),this._rendererCache.set(n,t)),t}const s=e.id,r=e.id+"-"+this._currentId;this._currentId++,this.engine.register(r,t);const i=e=>{Array.isArray(e)?e.forEach(i):this.engine.registerTrigger(s,r,t,e.name,e)};return e.data.animation.forEach(i),new E3(this,r,n,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(t,e,n){t>=0&&t<this._microtaskId?this._zone.run(()=>e(n)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(t=>{const[e,n]=t;e(n)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([e,n]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return t.\u0275fac=function(e){return new(e||t)(Os(rl),Os(J2),Os(ju))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();class I3{constructor(t,e,n){this.namespaceId=t,this.delegate=e,this.engine=n,this.destroyNode=this.delegate.destroyNode?t=>e.destroyNode(t):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,n,s=!0){this.delegate.insertBefore(t,e,n),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,n){this.engine.onRemove(this.namespaceId,e,this.delegate,n)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,n,s){this.delegate.setAttribute(t,e,n,s)}removeAttribute(t,e,n){this.delegate.removeAttribute(t,e,n)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,n,s){this.delegate.setStyle(t,e,n,s)}removeStyle(t,e,n){this.delegate.removeStyle(t,e,n)}setProperty(t,e,n){e.charAt(0)==k3&&e==C3?this.disableAnimations(t,!!n):this.delegate.setProperty(t,e,n)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,n){return this.delegate.listen(t,e,n)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class E3 extends I3{constructor(t,e,n,s){super(e,n,s),this.factory=t,this.namespaceId=e}setProperty(t,e,n){e.charAt(0)==k3?"."==e.charAt(1)&&e==C3?this.disableAnimations(t,n=void 0===n||!!n):this.engine.process(this.namespaceId,t,e.substr(1),n):this.delegate.setProperty(t,e,n)}listen(t,e,n){if(e.charAt(0)==k3){const s=function(t){switch(t){case"body":return document.body;case"document":return document;case"window":return window;default:return t}}(t);let r=e.substr(1),i="";return r.charAt(0)!=k3&&([r,i]=function(t){const e=t.indexOf(".");return[t.substring(0,e),t.substr(e+1)]}(r)),this.engine.listen(this.namespaceId,s,r,i,t=>{this.factory.scheduleListenerCallback(t._data||-1,n,t)})}return this.delegate.listen(t,e,n)}}let N3=(()=>{class t extends J2{constructor(t,e,n){super(t.body,e,n)}ngOnDestroy(){this.flush()}}return t.\u0275fac=function(e){return new(e||t)(Os(kc),Os(S1),Os(_2))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const T3=new ms("AnimationModuleType"),A3=[{provide:G0,useClass:v3},{provide:_2,useFactory:function(){return new x2}},{provide:J2,useClass:N3},{provide:rl,useFactory:function(t,e,n){return new S3(t,e,n)},deps:[Ph,J2,ju]}],$3=[{provide:S1,useFactory:function(){return"function"==typeof b3()?new y3:new m3}},{provide:T3,useValue:"BrowserAnimations"},...A3],R3=[{provide:S1,useClass:C1},{provide:T3,useValue:"NoopAnimations"},...A3];let O3=(()=>{class t{static withConfig(e){return{ngModule:t,providers:e.disableAnimations?R3:$3}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:$3,imports:[Jh]}),t})();const F3=new ll("12.0.4"),D3=new ms("mat-sanity-checks",{providedIn:"root",factory:function(){return!0}});let L3,M3=(()=>{class t{constructor(t,e,n){this._hasDoneGlobalChecks=!1,this._document=n,t._applyBodyHighContrastModeCssClasses(),this._sanityChecks=e,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getWindow(){const t=this._document.defaultView||window;return"object"==typeof t&&t?t:null}_checksAreEnabled(){return rc()&&!this._isTestEnv()}_isTestEnv(){const t=this._getWindow();return t&&(t.__karma__||t.jasmine)}_checkDoctypeIsDefined(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype)&&!this._document.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){if(!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme||!this._document.body||"function"!=typeof getComputedStyle)return;const t=this._document.createElement("div");t.classList.add("mat-theme-loaded-marker"),this._document.body.appendChild(t);const e=getComputedStyle(t);e&&"none"!==e.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),this._document.body.removeChild(t)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&F3.full!==H0.full&&console.warn("The Angular Material version ("+F3.full+") does not match the Angular CDK version ("+H0.full+").\nPlease ensure the versions of these two packages exactly match.")}}return t.\u0275fac=function(e){return new(e||t)(Os(V0),Os(D3,8),Os(kc))},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[j0],j0]}),t})();function P3(t){return class extends t{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=XJ(t)}}}function z3(t,e){return class extends t{constructor(...t){super(...t),this.defaultColor=e,this.color=e}get color(){return this._color}set color(t){const e=t||this.defaultColor;e!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),e&&this._elementRef.nativeElement.classList.add(`mat-${e}`),this._color=e)}}}function V3(t){return class extends t{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=XJ(t)}}}function B3(t){return class extends t{constructor(...t){super(...t),this.errorState=!1,this.stateChanges=new G}updateErrorState(){const t=this.errorState,e=(this.errorStateMatcher||this._defaultErrorStateMatcher).isErrorState(this.ngControl?this.ngControl.control:null,this._parentFormGroup||this._parentForm);e!==t&&(this.errorState=e,this.stateChanges.next())}}}try{L3="undefined"!=typeof Intl}catch(L7){L3=!1}let W3=(()=>{class t{isErrorState(t,e){return!!(t&&t.invalid&&(t.touched||e&&e.submitted))}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),U3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3],M3]}),t})();class j3{constructor(t,e,n){this._renderer=t,this.element=e,this.config=n,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const H3={enterDuration:450,exitDuration:400},G3=u0({passive:!0}),q3=["mousedown","touchstart"],K3=["mouseup","mouseleave","touchend","touchcancel"];class X3{constructor(t,e,n,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=JJ(n))}fadeInRipple(t,e,n={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),r=Object.assign(Object.assign({},H3),n.animation);n.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const i=n.radius||function(t,e,n){const s=Math.max(Math.abs(t-n.left),Math.abs(t-n.right)),r=Math.max(Math.abs(e-n.top),Math.abs(e-n.bottom));return Math.sqrt(s*s+r*r)}(t,e,s),a=t-s.left,o=e-s.top,l=r.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=a-i+"px",u.style.top=o-i+"px",u.style.height=2*i+"px",u.style.width=2*i+"px",null!=n.color&&(u.style.backgroundColor=n.color),u.style.transitionDuration=`${l}ms`,this._containerElement.appendChild(u),window.getComputedStyle(u).getPropertyValue("opacity"),u.style.transform="scale(1)";const c=new j3(this,u,n);return c.state=0,this._activeRipples.add(c),n.persistent||(this._mostRecentTransientRipple=c),this._runTimeoutOutsideZone(()=>{const t=c===this._mostRecentTransientRipple;c.state=1,n.persistent||t&&this._isPointerDown||c.fadeOut()},l),c}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const n=t.element,s=Object.assign(Object.assign({},H3),t.config.animation);n.style.transitionDuration=`${s.exitDuration}ms`,n.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,n.parentNode.removeChild(n)},s.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._activeRipples.forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=JJ(t);e&&e!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(q3))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(K3),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=$0(t),n=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||e||n||(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!R0(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let t=0;t<e.length;t++)this.fadeInRipple(e[t].clientX,e[t].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(t=>{this._triggerElement.addEventListener(t,this,G3)})})}_removeTriggerEvents(){this._triggerElement&&(q3.forEach(t=>{this._triggerElement.removeEventListener(t,this,G3)}),this._pointerUpEventsRegistered&&K3.forEach(t=>{this._triggerElement.removeEventListener(t,this,G3)}))}}const Z3=new ms("mat-ripple-global-options");let Y3=(()=>{class t{constructor(t,e,n,s,r){this._elementRef=t,this._animationMode=r,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=s||{},this._rippleRenderer=new X3(this,e,t,n)}get disabled(){return this._disabled}set disabled(t){t&&this.fadeOutAllNonPersistent(),this._disabled=t,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(t){this._trigger=t,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(t,e=0,n){return"number"==typeof t?this._rippleRenderer.fadeInRipple(t,e,Object.assign(Object.assign({},this.rippleConfig),n)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),t))}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(ju),Xa(n0),Xa(Z3,8),Xa(T3,8))},t.\u0275dir=be({type:t,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(t,e){2&t&&xo("mat-ripple-unbounded",e.unbounded)},inputs:{radius:["matRippleRadius","radius"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"],color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],animation:["matRippleAnimation","animation"]},exportAs:["matRipple"]}),t})(),Q3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3,s0],M3]}),t})(),J3=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3]]}),t})(),t4=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[Q3,gh,M3,J3]]}),t})();const e4=["*"],n4=".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n";class s4{constructor(){this.columnIndex=0,this.rowIndex=0}get rowCount(){return this.rowIndex+1}get rowspan(){const t=Math.max(...this.tracker);return t>1?this.rowCount+t-1:this.rowCount}update(t,e){this.columnIndex=0,this.rowIndex=0,this.tracker=new Array(t),this.tracker.fill(0,0,this.tracker.length),this.positions=e.map(t=>this._trackTile(t))}_trackTile(t){const e=this._findMatchingGap(t.colspan);return this._markTilePosition(e,t),this.columnIndex=e+t.colspan,new r4(this.rowIndex,e)}_findMatchingGap(t){let e=-1,n=-1;do{this.columnIndex+t>this.tracker.length?(this._nextRow(),e=this.tracker.indexOf(0,this.columnIndex),n=this._findGapEndIndex(e)):(e=this.tracker.indexOf(0,this.columnIndex),-1!=e?(n=this._findGapEndIndex(e),this.columnIndex=e+1):(this._nextRow(),e=this.tracker.indexOf(0,this.columnIndex),n=this._findGapEndIndex(e)))}while(n-e<t||0==n);return Math.max(e,0)}_nextRow(){this.columnIndex=0,this.rowIndex++;for(let t=0;t<this.tracker.length;t++)this.tracker[t]=Math.max(0,this.tracker[t]-1)}_findGapEndIndex(t){for(let e=t+1;e<this.tracker.length;e++)if(0!=this.tracker[e])return e;return this.tracker.length}_markTilePosition(t,e){for(let n=0;n<e.colspan;n++)this.tracker[t+n]=e.rowspan}}class r4{constructor(t,e){this.row=t,this.col=e}}const i4=new ms("MAT_GRID_LIST");let a4=(()=>{class t{constructor(t,e){this._element=t,this._gridList=e,this._rowspan=1,this._colspan=1}get rowspan(){return this._rowspan}set rowspan(t){this._rowspan=Math.round(ZJ(t))}get colspan(){return this._colspan}set colspan(t){this._colspan=Math.round(ZJ(t))}_setStyle(t,e){this._element.nativeElement.style[t]=e}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(i4,8))},t.\u0275cmp=de({type:t,selectors:[["mat-grid-tile"]],hostAttrs:[1,"mat-grid-tile"],hostVars:2,hostBindings:function(t,e){2&t&&Ga("rowspan",e.rowspan)("colspan",e.colspan)},inputs:{rowspan:"rowspan",colspan:"colspan"},exportAs:["matGridTile"],ngContentSelectors:e4,decls:2,vars:0,consts:[[1,"mat-grid-tile-content"]],template:function(t,e){1&t&&(mo(),Qa(0,"div",0),go(1),Ja())},styles:[n4],encapsulation:2,changeDetection:0}),t})();const o4=/^-?\d+((\.\d+)?[A-Za-z%$]?)+$/;class l4{constructor(){this._rows=0,this._rowspan=0}init(t,e,n,s){this._gutterSize=p4(t),this._rows=e.rowCount,this._rowspan=e.rowspan,this._cols=n,this._direction=s}getBaseTileSize(t,e){return`(${t}% - (${this._gutterSize} * ${e}))`}getTilePosition(t,e){return 0===e?"0":d4(`(${t} + ${this._gutterSize}) * ${e}`)}getTileSize(t,e){return`(${t} * ${e}) + (${e-1} * ${this._gutterSize})`}setStyle(t,e,n){let s=100/this._cols,r=(this._cols-1)/this._cols;this.setColStyles(t,n,s,r),this.setRowStyles(t,e,s,r)}setColStyles(t,e,n,s){let r=this.getBaseTileSize(n,s);t._setStyle("rtl"===this._direction?"right":"left",this.getTilePosition(r,e)),t._setStyle("width",d4(this.getTileSize(r,t.colspan)))}getGutterSpan(){return`${this._gutterSize} * (${this._rowspan} - 1)`}getTileSpan(t){return`${this._rowspan} * ${this.getTileSize(t,1)}`}getComputedHeight(){return null}}class u4 extends l4{constructor(t){super(),this.fixedRowHeight=t}init(t,e,n,s){super.init(t,e,n,s),this.fixedRowHeight=p4(this.fixedRowHeight),o4.test(this.fixedRowHeight)}setRowStyles(t,e){t._setStyle("top",this.getTilePosition(this.fixedRowHeight,e)),t._setStyle("height",d4(this.getTileSize(this.fixedRowHeight,t.rowspan)))}getComputedHeight(){return["height",d4(`${this.getTileSpan(this.fixedRowHeight)} + ${this.getGutterSpan()}`)]}reset(t){t._setListStyle(["height",null]),t._tiles&&t._tiles.forEach(t=>{t._setStyle("top",null),t._setStyle("height",null)})}}class c4 extends l4{constructor(t){super(),this._parseRatio(t)}setRowStyles(t,e,n,s){this.baseTileHeight=this.getBaseTileSize(n/this.rowHeightRatio,s),t._setStyle("marginTop",this.getTilePosition(this.baseTileHeight,e)),t._setStyle("paddingTop",d4(this.getTileSize(this.baseTileHeight,t.rowspan)))}getComputedHeight(){return["paddingBottom",d4(`${this.getTileSpan(this.baseTileHeight)} + ${this.getGutterSpan()}`)]}reset(t){t._setListStyle(["paddingBottom",null]),t._tiles.forEach(t=>{t._setStyle("marginTop",null),t._setStyle("paddingTop",null)})}_parseRatio(t){const e=t.split(":");this.rowHeightRatio=parseFloat(e[0])/parseFloat(e[1])}}class h4 extends l4{setRowStyles(t,e){let n=this.getBaseTileSize(100/this._rowspan,(this._rows-1)/this._rows);t._setStyle("top",this.getTilePosition(n,e)),t._setStyle("height",d4(this.getTileSize(n,t.rowspan)))}reset(t){t._tiles&&t._tiles.forEach(t=>{t._setStyle("top",null),t._setStyle("height",null)})}}function d4(t){return`calc(${t})`}function p4(t){return t.match(/([A-Za-z%]+)$/)?t:`${t}px`}let f4=(()=>{class t{constructor(t,e){this._element=t,this._dir=e,this._gutter="1px"}get cols(){return this._cols}set cols(t){this._cols=Math.max(1,Math.round(ZJ(t)))}get gutterSize(){return this._gutter}set gutterSize(t){this._gutter=`${null==t?"":t}`}get rowHeight(){return this._rowHeight}set rowHeight(t){const e=`${null==t?"":t}`;e!==this._rowHeight&&(this._rowHeight=e,this._setTileStyler(this._rowHeight))}ngOnInit(){this._checkCols(),this._checkRowHeight()}ngAfterContentChecked(){this._layoutTiles()}_checkCols(){}_checkRowHeight(){this._rowHeight||this._setTileStyler("1:1")}_setTileStyler(t){this._tileStyler&&this._tileStyler.reset(this),this._tileStyler="fit"===t?new h4:t&&t.indexOf(":")>-1?new c4(t):new u4(t)}_layoutTiles(){this._tileCoordinator||(this._tileCoordinator=new s4);const t=this._tileCoordinator,e=this._tiles.filter(t=>!t._gridList||t._gridList===this),n=this._dir?this._dir.value:"ltr";this._tileCoordinator.update(this.cols,e),this._tileStyler.init(this.gutterSize,t,this.cols,n),e.forEach((e,n)=>{const s=t.positions[n];this._tileStyler.setStyle(e,s.row,s.col)}),this._setListStyle(this._tileStyler.getComputedHeight())}_setListStyle(t){t&&(this._element.nativeElement.style[t[0]]=t[1])}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(U0,8))},t.\u0275cmp=de({type:t,selectors:[["mat-grid-list"]],contentQueries:function(t,e,n){if(1&t&&bu(n,a4,5),2&t){let t;gu(t=vu())&&(e._tiles=t)}},hostAttrs:[1,"mat-grid-list"],hostVars:1,hostBindings:function(t,e){2&t&&Ga("cols",e.cols)},inputs:{cols:"cols",gutterSize:"gutterSize",rowHeight:"rowHeight"},exportAs:["matGridList"],features:[Xo([{provide:i4,useExisting:t}])],ngContentSelectors:e4,decls:2,vars:0,template:function(t,e){1&t&&(mo(),Qa(0,"div"),go(1),Ja())},styles:[n4],encapsulation:2,changeDetection:0}),t})(),m4=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[U3,M3],U3,M3]}),t})();const g4=["*",[["mat-toolbar-row"]]],y4=["*","mat-toolbar-row"];class b4{constructor(t){this._elementRef=t}}const v4=z3(b4);let w4=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=be({type:t,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),t})(),_4=(()=>{class t extends v4{constructor(t,e,n){super(t),this._platform=e,this._document=n}ngAfterViewInit(){this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(n0),Xa(kc))},t.\u0275cmp=de({type:t,selectors:[["mat-toolbar"]],contentQueries:function(t,e,n){if(1&t&&bu(n,w4,5),2&t){let t;gu(t=vu())&&(e._toolbarRows=t)}},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(t,e){2&t&&xo("mat-toolbar-multiple-rows",e._toolbarRows.length>0)("mat-toolbar-single-row",0===e._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[Da],ngContentSelectors:y4,decls:2,vars:0,template:function(t,e){1&t&&(mo(g4),go(0),go(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),t})(),x4=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3],M3]}),t})();const k4=["mat-button",""],C4=["*"],S4=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"];class I4{constructor(t){this._elementRef=t}}const E4=z3(P3(V3(I4)));let N4=(()=>{class t extends E4{constructor(t,e,n){super(t),this._focusMonitor=e,this._animationMode=n,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const s of S4)this._hasHostAttributes(s)&&this._getHostElement().classList.add(s);t.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(t,e){t?this._focusMonitor.focusVia(this._getHostElement(),t,e):this._getHostElement().focus(e)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...t){return t.some(t=>this._getHostElement().hasAttribute(t))}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(D0),Xa(T3,8))},t.\u0275cmp=de({type:t,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(t,e){if(1&t&&yu(Y3,5),2&t){let t;gu(t=vu())&&(e.ripple=t.first)}},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(t,e){2&t&&(Ga("disabled",e.disabled||null),xo("_mat-animation-noopable","NoopAnimations"===e._animationMode)("mat-button-disabled",e.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Da],attrs:k4,ngContentSelectors:C4,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(t,e){1&t&&(mo(),Qa(0,"span",0),go(1),Ja(),to(2,"span",1),to(3,"span",2)),2&t&&(xi(2),xo("mat-button-ripple-round",e.isRoundButton||e.isIconButton),Za("matRippleDisabled",e._isRippleDisabled())("matRippleCentered",e.isIconButton)("matRippleTrigger",e._getHostElement()))},directives:[Y3],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"],encapsulation:2,changeDetection:0}),t})(),T4=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[Q3,M3],M3]}),t})();const A4=["*"];function $4(t){return Error(`Unable to find icon with the name "${t}"`)}function R4(t){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`)}function O4(t){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`)}class F4{constructor(t,e,n){this.url=t,this.svgText=e,this.options=n}}let D4=(()=>{class t{constructor(t,e,n,s){this._httpClient=t,this._sanitizer=e,this._errorHandler=s,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass="material-icons",this._document=n}addSvgIcon(t,e,n){return this.addSvgIconInNamespace("",t,e,n)}addSvgIconLiteral(t,e,n){return this.addSvgIconLiteralInNamespace("",t,e,n)}addSvgIconInNamespace(t,e,n,s){return this._addSvgIconConfig(t,e,new F4(n,null,s))}addSvgIconResolver(t){return this._resolvers.push(t),this}addSvgIconLiteralInNamespace(t,e,n,s){const r=this._sanitizer.sanitize(xr.HTML,n);if(!r)throw O4(n);return this._addSvgIconConfig(t,e,new F4("",r,s))}addSvgIconSet(t,e){return this.addSvgIconSetInNamespace("",t,e)}addSvgIconSetLiteral(t,e){return this.addSvgIconSetLiteralInNamespace("",t,e)}addSvgIconSetInNamespace(t,e,n){return this._addSvgIconSetConfig(t,new F4(e,null,n))}addSvgIconSetLiteralInNamespace(t,e,n){const s=this._sanitizer.sanitize(xr.HTML,e);if(!s)throw O4(e);return this._addSvgIconSetConfig(t,new F4("",s,n))}registerFontClassAlias(t,e=t){return this._fontCssClassesByAlias.set(t,e),this}classNameForFontAlias(t){return this._fontCssClassesByAlias.get(t)||t}setDefaultFontSetClass(t){return this._defaultFontSetClass=t,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(t){const e=this._sanitizer.sanitize(xr.RESOURCE_URL,t);if(!e)throw R4(t);const n=this._cachedIconsByUrl.get(e);return n?op(L4(n)):this._loadSvgIconFromConfig(new F4(t,null)).pipe(Yp(t=>this._cachedIconsByUrl.set(e,t)),X(t=>L4(t)))}getNamedSvgIcon(t,e=""){const n=M4(e,t);let s=this._svgIconConfigs.get(n);if(s)return this._getSvgFromConfig(s);if(s=this._getIconConfigFromResolvers(e,t),s)return this._svgIconConfigs.set(n,s),this._getSvgFromConfig(s);const r=this._iconSetConfigs.get(e);return r?this._getSvgFromIconSetConfigs(t,r):(i=$4(n),new B(t=>t.error(i)));var i}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(t){return t.svgText?op(L4(this._svgElementFromConfig(t))):this._loadSvgIconFromConfig(t).pipe(X(t=>L4(t)))}_getSvgFromIconSetConfigs(t,e){const n=this._extractIconWithNameFromAnySet(t,e);return n?op(n):td(e.filter(t=>!t.svgText).map(t=>this._loadSvgIconSetFromConfig(t).pipe(Dp(e=>{const n=this._sanitizer.sanitize(xr.RESOURCE_URL,t.url);return this._errorHandler.handleError(new Error(`Loading icon set URL: ${n} failed: ${e.message}`)),op(null)})))).pipe(X(()=>{const n=this._extractIconWithNameFromAnySet(t,e);if(!n)throw $4(t);return n}))}_extractIconWithNameFromAnySet(t,e){for(let n=e.length-1;n>=0;n--){const s=e[n];if(s.svgText&&s.svgText.indexOf(t)>-1){const e=this._svgElementFromConfig(s),n=this._extractSvgIconFromSet(e,t,s.options);if(n)return n}}return null}_loadSvgIconFromConfig(t){return this._fetchIcon(t).pipe(Yp(e=>t.svgText=e),X(()=>this._svgElementFromConfig(t)))}_loadSvgIconSetFromConfig(t){return t.svgText?op(null):this._fetchIcon(t).pipe(Yp(e=>t.svgText=e))}_extractSvgIconFromSet(t,e,n){const s=t.querySelector(`[id="${e}"]`);if(!s)return null;const r=s.cloneNode(!0);if(r.removeAttribute("id"),"svg"===r.nodeName.toLowerCase())return this._setSvgAttributes(r,n);if("symbol"===r.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(r),n);const i=this._svgElementFromString("<svg></svg>");return i.appendChild(r),this._setSvgAttributes(i,n)}_svgElementFromString(t){const e=this._document.createElement("DIV");e.innerHTML=t;const n=e.querySelector("svg");if(!n)throw Error("<svg> tag not found");return n}_toSvgElement(t){const e=this._svgElementFromString("<svg></svg>"),n=t.attributes;for(let s=0;s<n.length;s++){const{name:t,value:r}=n[s];"id"!==t&&e.setAttribute(t,r)}for(let s=0;s<t.childNodes.length;s++)t.childNodes[s].nodeType===this._document.ELEMENT_NODE&&e.appendChild(t.childNodes[s].cloneNode(!0));return e}_setSvgAttributes(t,e){return t.setAttribute("fit",""),t.setAttribute("height","100%"),t.setAttribute("width","100%"),t.setAttribute("preserveAspectRatio","xMidYMid meet"),t.setAttribute("focusable","false"),e&&e.viewBox&&t.setAttribute("viewBox",e.viewBox),t}_fetchIcon(t){var e;const{url:n,options:s}=t,r=null!==(e=null==s?void 0:s.withCredentials)&&void 0!==e&&e;if(!this._httpClient)throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.");if(null==n)throw Error(`Cannot fetch icon from URL "${n}".`);const i=this._sanitizer.sanitize(xr.RESOURCE_URL,n);if(!i)throw R4(n);const a=this._inProgressUrlFetches.get(i);if(a)return a;const o=this._httpClient.get(i,{responseType:"text",withCredentials:r}).pipe(tf(()=>this._inProgressUrlFetches.delete(i)),xt());return this._inProgressUrlFetches.set(i,o),o}_addSvgIconConfig(t,e,n){return this._svgIconConfigs.set(M4(t,e),n),this}_addSvgIconSetConfig(t,e){const n=this._iconSetConfigs.get(t);return n?n.push(e):this._iconSetConfigs.set(t,[e]),this}_svgElementFromConfig(t){if(!t.svgElement){const e=this._svgElementFromString(t.svgText);this._setSvgAttributes(e,t.options),t.svgElement=e}return t.svgElement}_getIconConfigFromResolvers(t,e){for(let s=0;s<this._resolvers.length;s++){const r=this._resolvers[s](e,t);if(r)return(n=r).url&&n.options?new F4(r.url,null,r.options):new F4(r,null)}var n}}return t.\u0275fac=function(e){return new(e||t)(Os(CJ,8),Os(Kh),Os(kc,8),Os($r))},t.\u0275prov=Dt({factory:function(){return new t(Os(CJ,8),Os(Kh),Os(kc,8),Os($r))},token:t,providedIn:"root"}),t})();function L4(t){return t.cloneNode(!0)}function M4(t,e){return t+":"+e}class P4{constructor(t){this._elementRef=t}}const z4=z3(P4),V4=new ms("mat-icon-location",{providedIn:"root",factory:function(){const t=Fs(kc),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}}),B4=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],W4=B4.map(t=>`[${t}]`).join(", "),U4=/^url\(['"]?#(.*?)['"]?\)$/;let j4=(()=>{class t extends z4{constructor(t,e,n,s,r){super(t),this._iconRegistry=e,this._location=s,this._errorHandler=r,this._inline=!1,this._currentIconFetch=F.EMPTY,n||t.nativeElement.setAttribute("aria-hidden","true")}get inline(){return this._inline}set inline(t){this._inline=XJ(t)}get svgIcon(){return this._svgIcon}set svgIcon(t){t!==this._svgIcon&&(t?this._updateSvgIcon(t):this._svgIcon&&this._clearSvgElement(),this._svgIcon=t)}get fontSet(){return this._fontSet}set fontSet(t){const e=this._cleanupFontValue(t);e!==this._fontSet&&(this._fontSet=e,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(t){const e=this._cleanupFontValue(t);e!==this._fontIcon&&(this._fontIcon=e,this._updateFontIconClasses())}_splitIconName(t){if(!t)return["",""];const e=t.split(":");switch(e.length){case 1:return["",e[0]];case 2:return e;default:throw Error(`Invalid icon name: "${t}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const t=this._elementsWithExternalReferences;if(t&&t.size){const t=this._location.getPathname();t!==this._previousPath&&(this._previousPath=t,this._prependPathToReferences(t))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(t){this._clearSvgElement();const e=t.querySelectorAll("style");for(let s=0;s<e.length;s++)e[s].textContent+=" ";const n=this._location.getPathname();this._previousPath=n,this._cacheChildrenWithExternalReferences(t),this._prependPathToReferences(n),this._elementRef.nativeElement.appendChild(t)}_clearSvgElement(){const t=this._elementRef.nativeElement;let e=t.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();e--;){const n=t.childNodes[e];1===n.nodeType&&"svg"!==n.nodeName.toLowerCase()||t.removeChild(n)}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const t=this._elementRef.nativeElement,e=this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet):this._iconRegistry.getDefaultFontSetClass();e!=this._previousFontSetClass&&(this._previousFontSetClass&&t.classList.remove(this._previousFontSetClass),e&&t.classList.add(e),this._previousFontSetClass=e),this.fontIcon!=this._previousFontIconClass&&(this._previousFontIconClass&&t.classList.remove(this._previousFontIconClass),this.fontIcon&&t.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(t){return"string"==typeof t?t.trim().split(" ")[0]:t}_prependPathToReferences(t){const e=this._elementsWithExternalReferences;e&&e.forEach((e,n)=>{e.forEach(e=>{n.setAttribute(e.name,`url('${t}#${e.value}')`)})})}_cacheChildrenWithExternalReferences(t){const e=t.querySelectorAll(W4),n=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let s=0;s<e.length;s++)B4.forEach(t=>{const r=e[s],i=r.getAttribute(t),a=i?i.match(U4):null;if(a){let e=n.get(r);e||(e=[],n.set(r,e)),e.push({name:t,value:a[1]})}})}_updateSvgIcon(t){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),t){const[e,n]=this._splitIconName(t);e&&(this._svgNamespace=e),n&&(this._svgName=n),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(n,e).pipe(Sp(1)).subscribe(t=>this._setSvgElement(t),t=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${e}:${n}! ${t.message}`))})}}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(D4),ds("aria-hidden"),Xa(V4),Xa($r))},t.\u0275cmp=de({type:t,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:7,hostBindings:function(t,e){2&t&&(Ga("data-mat-icon-type",e._usingFontIcon()?"font":"svg")("data-mat-icon-name",e._svgName||e.fontIcon)("data-mat-icon-namespace",e._svgNamespace||e.fontSet),xo("mat-icon-inline",e.inline)("mat-icon-no-color","primary"!==e.color&&"accent"!==e.color&&"warn"!==e.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[Da],ngContentSelectors:A4,decls:1,vars:0,template:function(t,e){1&t&&(mo(),go(0))},styles:[".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"],encapsulation:2,changeDetection:0}),t})(),H4=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3],M3]}),t})();function G4(t,e){if(1&t&&(Nn(),to(0,"circle",3)),2&t){const t=po();_o("animation-name","mat-progress-spinner-stroke-rotate-"+t._spinnerAnimationLabel)("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),Ga("r",t._getCircleRadius())}}function q4(t,e){if(1&t&&(Nn(),to(0,"circle",3)),2&t){const t=po();_o("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),Ga("r",t._getCircleRadius())}}function K4(t,e){if(1&t&&(Nn(),to(0,"circle",3)),2&t){const t=po();_o("animation-name","mat-progress-spinner-stroke-rotate-"+t._spinnerAnimationLabel)("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),Ga("r",t._getCircleRadius())}}function X4(t,e){if(1&t&&(Nn(),to(0,"circle",3)),2&t){const t=po();_o("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),Ga("r",t._getCircleRadius())}}const Z4=".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:currentColor;stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n";class Y4{constructor(t){this._elementRef=t}}const Q4=z3(Y4,"primary"),J4=new ms("mat-progress-spinner-default-options",{providedIn:"root",factory:function(){return{diameter:100}}});let t5=(()=>{class t extends Q4{constructor(e,n,s,r,i){super(e),this._elementRef=e,this._document=s,this._diameter=100,this._value=0,this._fallbackAnimation=!1,this.mode="determinate";const a=t._diameters;this._spinnerAnimationLabel=this._getSpinnerAnimationLabel(),a.has(s.head)||a.set(s.head,new Set([100])),this._fallbackAnimation=n.EDGE||n.TRIDENT,this._noopAnimations="NoopAnimations"===r&&!!i&&!i._forceAnimations,i&&(i.diameter&&(this.diameter=i.diameter),i.strokeWidth&&(this.strokeWidth=i.strokeWidth))}get diameter(){return this._diameter}set diameter(t){this._diameter=ZJ(t),this._spinnerAnimationLabel=this._getSpinnerAnimationLabel(),!this._fallbackAnimation&&this._styleRoot&&this._attachStyleNode()}get strokeWidth(){return this._strokeWidth||this.diameter/10}set strokeWidth(t){this._strokeWidth=ZJ(t)}get value(){return"determinate"===this.mode?this._value:0}set value(t){this._value=Math.max(0,Math.min(100,ZJ(t)))}ngOnInit(){const t=this._elementRef.nativeElement;this._styleRoot=h0(t)||this._document.head,this._attachStyleNode(),t.classList.add(`mat-progress-spinner-indeterminate${this._fallbackAnimation?"-fallback":""}-animation`)}_getCircleRadius(){return(this.diameter-10)/2}_getViewBox(){const t=2*this._getCircleRadius()+this.strokeWidth;return`0 0 ${t} ${t}`}_getStrokeCircumference(){return 2*Math.PI*this._getCircleRadius()}_getStrokeDashOffset(){return"determinate"===this.mode?this._getStrokeCircumference()*(100-this._value)/100:this._fallbackAnimation&&"indeterminate"===this.mode?.2*this._getStrokeCircumference():null}_getCircleStrokeWidth(){return this.strokeWidth/this.diameter*100}_attachStyleNode(){const e=this._styleRoot,n=this._diameter,s=t._diameters;let r=s.get(e);if(!r||!r.has(n)){const t=this._document.createElement("style");t.setAttribute("mat-spinner-animation",this._spinnerAnimationLabel),t.textContent=this._getAnimationText(),e.appendChild(t),r||(r=new Set,s.set(e,r)),r.add(n)}}_getAnimationText(){const t=this._getStrokeCircumference();return"\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g,""+.95*t).replace(/END_VALUE/g,""+.2*t).replace(/DIAMETER/g,`${this._spinnerAnimationLabel}`)}_getSpinnerAnimationLabel(){return this.diameter.toString().replace(".","_")}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(n0),Xa(kc,8),Xa(T3,8),Xa(J4))},t.\u0275cmp=de({type:t,selectors:[["mat-progress-spinner"]],hostAttrs:["role","progressbar","tabindex","-1",1,"mat-progress-spinner"],hostVars:10,hostBindings:function(t,e){2&t&&(Ga("aria-valuemin","determinate"===e.mode?0:null)("aria-valuemax","determinate"===e.mode?100:null)("aria-valuenow","determinate"===e.mode?e.value:null)("mode",e.mode),_o("width",e.diameter,"px")("height",e.diameter,"px"),xo("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color",mode:"mode",diameter:"diameter",strokeWidth:"strokeWidth",value:"value"},exportAs:["matProgressSpinner"],features:[Da],decls:3,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false","aria-hidden","true",3,"ngSwitch"],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(Nn(),Qa(0,"svg",0),Ka(1,G4,1,9,"circle",1),Ka(2,q4,1,7,"circle",2),Ja()),2&t&&(_o("width",e.diameter,"px")("height",e.diameter,"px"),Za("ngSwitch","indeterminate"===e.mode),Ga("viewBox",e._getViewBox()),xi(1),Za("ngSwitchCase",!0),xi(1),Za("ngSwitchCase",!1))},directives:[ah,oh],styles:[Z4],encapsulation:2,changeDetection:0}),t._diameters=new WeakMap,t})(),e5=(()=>{class t extends t5{constructor(t,e,n,s,r){super(t,e,n,s,r),this.mode="indeterminate"}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(n0),Xa(kc,8),Xa(T3,8),Xa(J4))},t.\u0275cmp=de({type:t,selectors:[["mat-spinner"]],hostAttrs:["role","progressbar","mode","indeterminate",1,"mat-spinner","mat-progress-spinner"],hostVars:6,hostBindings:function(t,e){2&t&&(_o("width",e.diameter,"px")("height",e.diameter,"px"),xo("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color"},features:[Da],decls:3,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false","aria-hidden","true",3,"ngSwitch"],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(Nn(),Qa(0,"svg",0),Ka(1,K4,1,9,"circle",1),Ka(2,X4,1,7,"circle",2),Ja()),2&t&&(_o("width",e.diameter,"px")("height",e.diameter,"px"),Za("ngSwitch","indeterminate"===e.mode),Ga("viewBox",e._getViewBox()),xi(1),Za("ngSwitchCase",!0),xi(1),Za("ngSwitchCase",!1))},directives:[ah,oh],styles:[Z4],encapsulation:2,changeDetection:0}),t})(),n5=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3,gh],M3]}),t})();function s5(t,e,n,s){return I(n)&&(s=n,n=void 0),s?s5(t,e,n).pipe(X(t=>$(t)?s(...t):s(t))):new B(s=>{r5(t,e,function(t){s.next(arguments.length>1?Array.prototype.slice.call(arguments):t)},s,n)})}function r5(t,e,n,s,r){let i;if(function(t){return t&&"function"==typeof t.addEventListener&&"function"==typeof t.removeEventListener}(t)){const s=t;t.addEventListener(e,n,r),i=()=>s.removeEventListener(e,n,r)}else if(function(t){return t&&"function"==typeof t.on&&"function"==typeof t.off}(t)){const s=t;t.on(e,n),i=()=>s.off(e,n)}else if(function(t){return t&&"function"==typeof t.addListener&&"function"==typeof t.removeListener}(t)){const s=t;t.addListener(e,n),i=()=>s.removeListener(e,n)}else{if(!t||!t.length)throw new TypeError("Invalid event target");for(let i=0,a=t.length;i<a;i++)r5(t[i],e,n,s,r)}s.add(i)}function i5(t){return e=>e.lift(new a5(t))}class a5{constructor(t){this.notifier=t}call(t,e){const n=new o5(t),s=lt(this.notifier,new at(n));return s&&!n.seenValue?(n.add(s),e.subscribe(n)):n}}class o5 extends ot{constructor(t){super(t),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}const l5=["underline"],u5=["connectionContainer"],c5=["inputContainer"],h5=["label"];function d5(t,e){1&t&&(eo(0),Qa(1,"div",14),to(2,"div",15),to(3,"div",16),to(4,"div",17),Ja(),Qa(5,"div",18),to(6,"div",15),to(7,"div",16),to(8,"div",17),Ja(),no())}function p5(t,e){1&t&&(Qa(0,"div",19),go(1,1),Ja())}function f5(t,e){if(1&t&&(eo(0),go(1,2),Qa(2,"span"),No(3),Ja(),no()),2&t){const t=po(2);xi(3),To(t._control.placeholder)}}function m5(t,e){1&t&&go(0,3,["*ngSwitchCase","true"])}function g5(t,e){1&t&&(Qa(0,"span",23),No(1," *"),Ja())}function y5(t,e){if(1&t){const t=so();Qa(0,"label",20,21),oo("cdkObserveContent",function(){return nn(t),po().updateOutlineGap()}),Ka(2,f5,4,1,"ng-container",12),Ka(3,m5,1,0,"ng-content",12),Ka(4,g5,2,0,"span",22),Ja()}if(2&t){const t=po();xo("mat-empty",t._control.empty&&!t._shouldAlwaysFloat())("mat-form-field-empty",t._control.empty&&!t._shouldAlwaysFloat())("mat-accent","accent"==t.color)("mat-warn","warn"==t.color),Za("cdkObserveContentDisabled","outline"!=t.appearance)("id",t._labelId)("ngSwitch",t._hasLabel()),Ga("for",t._control.id)("aria-owns",t._control.id),xi(2),Za("ngSwitchCase",!1),xi(1),Za("ngSwitchCase",!0),xi(1),Za("ngIf",!t.hideRequiredMarker&&t._control.required&&!t._control.disabled)}}function b5(t,e){1&t&&(Qa(0,"div",24),go(1,4),Ja())}function v5(t,e){if(1&t&&(Qa(0,"div",25,26),to(2,"span",27),Ja()),2&t){const t=po();xi(2),xo("mat-accent","accent"==t.color)("mat-warn","warn"==t.color)}}function w5(t,e){1&t&&(Qa(0,"div"),go(1,5),Ja()),2&t&&Za("@transitionMessages",po()._subscriptAnimationState)}function _5(t,e){if(1&t&&(Qa(0,"div",31),No(1),Ja()),2&t){const t=po(2);Za("id",t._hintLabelId),xi(1),To(t.hintLabel)}}function x5(t,e){if(1&t&&(Qa(0,"div",28),Ka(1,_5,2,2,"div",29),go(2,6),to(3,"div",30),go(4,7),Ja()),2&t){const t=po();Za("@transitionMessages",t._subscriptAnimationState),xi(1),Za("ngIf",t.hintLabel)}}const k5=["*",[["","matPrefix",""]],[["mat-placeholder"]],[["mat-label"]],[["","matSuffix",""]],[["mat-error"]],[["mat-hint",3,"align","end"]],[["mat-hint","align","end"]]],C5=["*","[matPrefix]","mat-placeholder","mat-label","[matSuffix]","mat-error","mat-hint:not([align='end'])","mat-hint[align='end']"],S5=new ms("MatError"),I5={transitionMessages:K0("transitionMessages",[Q0("enter",Y0({opacity:1,transform:"translateY(0%)"})),t1("void => enter",[Y0({opacity:0,transform:"translateY(-5px)"}),X0("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])])};let E5=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=be({type:t}),t})();const N5=new ms("MatHint");let T5=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=be({type:t,selectors:[["mat-label"]]}),t})(),A5=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=be({type:t,selectors:[["mat-placeholder"]]}),t})();const $5=new ms("MatPrefix"),R5=new ms("MatSuffix");let O5=0;class F5{constructor(t){this._elementRef=t}}const D5=z3(F5,"primary"),L5=new ms("MAT_FORM_FIELD_DEFAULT_OPTIONS"),M5=new ms("MatFormField");let P5=(()=>{class t extends D5{constructor(t,e,n,s,r,i,a,o){super(t),this._elementRef=t,this._changeDetectorRef=e,this._dir=s,this._defaults=r,this._platform=i,this._ngZone=a,this._outlineGapCalculationNeededImmediately=!1,this._outlineGapCalculationNeededOnStable=!1,this._destroyed=new G,this._showAlwaysAnimate=!1,this._subscriptAnimationState="",this._hintLabel="",this._hintLabelId="mat-hint-"+O5++,this._labelId="mat-form-field-label-"+O5++,this.floatLabel=this._getDefaultFloatLabelState(),this._animationsEnabled="NoopAnimations"!==o,this.appearance=r&&r.appearance?r.appearance:"legacy",this._hideRequiredMarker=!(!r||null==r.hideRequiredMarker)&&r.hideRequiredMarker}get appearance(){return this._appearance}set appearance(t){const e=this._appearance;this._appearance=t||this._defaults&&this._defaults.appearance||"legacy","outline"===this._appearance&&e!==t&&(this._outlineGapCalculationNeededOnStable=!0)}get hideRequiredMarker(){return this._hideRequiredMarker}set hideRequiredMarker(t){this._hideRequiredMarker=XJ(t)}_shouldAlwaysFloat(){return"always"===this.floatLabel&&!this._showAlwaysAnimate}_canLabelFloat(){return"never"!==this.floatLabel}get hintLabel(){return this._hintLabel}set hintLabel(t){this._hintLabel=t,this._processHints()}get floatLabel(){return"legacy"!==this.appearance&&"never"===this._floatLabel?"auto":this._floatLabel}set floatLabel(t){t!==this._floatLabel&&(this._floatLabel=t||this._getDefaultFloatLabelState(),this._changeDetectorRef.markForCheck())}get _control(){return this._explicitFormFieldControl||this._controlNonStatic||this._controlStatic}set _control(t){this._explicitFormFieldControl=t}getLabelId(){return this._hasFloatingLabel()?this._labelId:null}getConnectedOverlayOrigin(){return this._connectionContainerRef||this._elementRef}ngAfterContentInit(){this._validateControlChild();const t=this._control;t.controlType&&this._elementRef.nativeElement.classList.add(`mat-form-field-type-${t.controlType}`),t.stateChanges.pipe(Np(null)).subscribe(()=>{this._validatePlaceholders(),this._syncDescribedByIds(),this._changeDetectorRef.markForCheck()}),t.ngControl&&t.ngControl.valueChanges&&t.ngControl.valueChanges.pipe(i5(this._destroyed)).subscribe(()=>this._changeDetectorRef.markForCheck()),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.pipe(i5(this._destroyed)).subscribe(()=>{this._outlineGapCalculationNeededOnStable&&this.updateOutlineGap()})}),ft(this._prefixChildren.changes,this._suffixChildren.changes).subscribe(()=>{this._outlineGapCalculationNeededOnStable=!0,this._changeDetectorRef.markForCheck()}),this._hintChildren.changes.pipe(Np(null)).subscribe(()=>{this._processHints(),this._changeDetectorRef.markForCheck()}),this._errorChildren.changes.pipe(Np(null)).subscribe(()=>{this._syncDescribedByIds(),this._changeDetectorRef.markForCheck()}),this._dir&&this._dir.change.pipe(i5(this._destroyed)).subscribe(()=>{"function"==typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>this.updateOutlineGap())}):this.updateOutlineGap()})}ngAfterContentChecked(){this._validateControlChild(),this._outlineGapCalculationNeededImmediately&&this.updateOutlineGap()}ngAfterViewInit(){this._subscriptAnimationState="enter",this._changeDetectorRef.detectChanges()}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete()}_shouldForward(t){const e=this._control?this._control.ngControl:null;return e&&e[t]}_hasPlaceholder(){return!!(this._control&&this._control.placeholder||this._placeholderChild)}_hasLabel(){return!(!this._labelChildNonStatic&&!this._labelChildStatic)}_shouldLabelFloat(){return this._canLabelFloat()&&(this._control&&this._control.shouldLabelFloat||this._shouldAlwaysFloat())}_hideControlPlaceholder(){return"legacy"===this.appearance&&!this._hasLabel()||this._hasLabel()&&!this._shouldLabelFloat()}_hasFloatingLabel(){return this._hasLabel()||"legacy"===this.appearance&&this._hasPlaceholder()}_getDisplayedMessages(){return this._errorChildren&&this._errorChildren.length>0&&this._control.errorState?"error":"hint"}_animateAndLockLabel(){this._hasFloatingLabel()&&this._canLabelFloat()&&(this._animationsEnabled&&this._label&&(this._showAlwaysAnimate=!0,s5(this._label.nativeElement,"transitionend").pipe(Sp(1)).subscribe(()=>{this._showAlwaysAnimate=!1})),this.floatLabel="always",this._changeDetectorRef.markForCheck())}_validatePlaceholders(){}_processHints(){this._validateHints(),this._syncDescribedByIds()}_validateHints(){}_getDefaultFloatLabelState(){return this._defaults&&this._defaults.floatLabel||"auto"}_syncDescribedByIds(){if(this._control){let t=[];if(this._control.userAriaDescribedBy&&"string"==typeof this._control.userAriaDescribedBy&&t.push(...this._control.userAriaDescribedBy.split(" ")),"hint"===this._getDisplayedMessages()){const e=this._hintChildren?this._hintChildren.find(t=>"start"===t.align):null,n=this._hintChildren?this._hintChildren.find(t=>"end"===t.align):null;e?t.push(e.id):this._hintLabel&&t.push(this._hintLabelId),n&&t.push(n.id)}else this._errorChildren&&t.push(...this._errorChildren.map(t=>t.id));this._control.setDescribedByIds(t)}}_validateControlChild(){}updateOutlineGap(){const t=this._label?this._label.nativeElement:null;if("outline"!==this.appearance||!t||!t.children.length||!t.textContent.trim())return;if(!this._platform.isBrowser)return;if(!this._isAttachedToDOM())return void(this._outlineGapCalculationNeededImmediately=!0);let e=0,n=0;const s=this._connectionContainerRef.nativeElement,r=s.querySelectorAll(".mat-form-field-outline-start"),i=s.querySelectorAll(".mat-form-field-outline-gap");if(this._label&&this._label.nativeElement.children.length){const r=s.getBoundingClientRect();if(0===r.width&&0===r.height)return this._outlineGapCalculationNeededOnStable=!0,void(this._outlineGapCalculationNeededImmediately=!1);const i=this._getStartEnd(r),a=t.children,o=this._getStartEnd(a[0].getBoundingClientRect());let l=0;for(let t=0;t<a.length;t++)l+=a[t].offsetWidth;e=Math.abs(o-i)-5,n=l>0?.75*l+10:0}for(let a=0;a<r.length;a++)r[a].style.width=`${e}px`;for(let a=0;a<i.length;a++)i[a].style.width=`${n}px`;this._outlineGapCalculationNeededOnStable=this._outlineGapCalculationNeededImmediately=!1}_getStartEnd(t){return this._dir&&"rtl"===this._dir.value?t.right:t.left}_isAttachedToDOM(){const t=this._elementRef.nativeElement;if(t.getRootNode){const e=t.getRootNode();return e&&e!==t}return document.documentElement.contains(t)}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(Nl),Xa(nl),Xa(U0,8),Xa(L5,8),Xa(n0),Xa(ju),Xa(T3,8))},t.\u0275cmp=de({type:t,selectors:[["mat-form-field"]],contentQueries:function(t,e,n){if(1&t&&(bu(n,E5,5),bu(n,E5,7),bu(n,T5,5),bu(n,T5,7),bu(n,A5,5),bu(n,S5,5),bu(n,N5,5),bu(n,$5,5),bu(n,R5,5)),2&t){let t;gu(t=vu())&&(e._controlNonStatic=t.first),gu(t=vu())&&(e._controlStatic=t.first),gu(t=vu())&&(e._labelChildNonStatic=t.first),gu(t=vu())&&(e._labelChildStatic=t.first),gu(t=vu())&&(e._placeholderChild=t.first),gu(t=vu())&&(e._errorChildren=t),gu(t=vu())&&(e._hintChildren=t),gu(t=vu())&&(e._prefixChildren=t),gu(t=vu())&&(e._suffixChildren=t)}},viewQuery:function(t,e){if(1&t&&(yu(l5,5),yu(u5,7),yu(c5,5),yu(h5,5)),2&t){let t;gu(t=vu())&&(e.underlineRef=t.first),gu(t=vu())&&(e._connectionContainerRef=t.first),gu(t=vu())&&(e._inputContainerRef=t.first),gu(t=vu())&&(e._label=t.first)}},hostAttrs:[1,"mat-form-field"],hostVars:40,hostBindings:function(t,e){2&t&&xo("mat-form-field-appearance-standard","standard"==e.appearance)("mat-form-field-appearance-fill","fill"==e.appearance)("mat-form-field-appearance-outline","outline"==e.appearance)("mat-form-field-appearance-legacy","legacy"==e.appearance)("mat-form-field-invalid",e._control.errorState)("mat-form-field-can-float",e._canLabelFloat())("mat-form-field-should-float",e._shouldLabelFloat())("mat-form-field-has-label",e._hasFloatingLabel())("mat-form-field-hide-placeholder",e._hideControlPlaceholder())("mat-form-field-disabled",e._control.disabled)("mat-form-field-autofilled",e._control.autofilled)("mat-focused",e._control.focused)("ng-untouched",e._shouldForward("untouched"))("ng-touched",e._shouldForward("touched"))("ng-pristine",e._shouldForward("pristine"))("ng-dirty",e._shouldForward("dirty"))("ng-valid",e._shouldForward("valid"))("ng-invalid",e._shouldForward("invalid"))("ng-pending",e._shouldForward("pending"))("_mat-animation-noopable",!e._animationsEnabled)},inputs:{color:"color",floatLabel:"floatLabel",appearance:"appearance",hideRequiredMarker:"hideRequiredMarker",hintLabel:"hintLabel"},exportAs:["matFormField"],features:[Xo([{provide:M5,useExisting:t}]),Da],ngContentSelectors:C5,decls:15,vars:8,consts:[[1,"mat-form-field-wrapper"],[1,"mat-form-field-flex",3,"click"],["connectionContainer",""],[4,"ngIf"],["class","mat-form-field-prefix",4,"ngIf"],[1,"mat-form-field-infix"],["inputContainer",""],[1,"mat-form-field-label-wrapper"],["class","mat-form-field-label",3,"cdkObserveContentDisabled","id","mat-empty","mat-form-field-empty","mat-accent","mat-warn","ngSwitch","cdkObserveContent",4,"ngIf"],["class","mat-form-field-suffix",4,"ngIf"],["class","mat-form-field-underline",4,"ngIf"],[1,"mat-form-field-subscript-wrapper",3,"ngSwitch"],[4,"ngSwitchCase"],["class","mat-form-field-hint-wrapper",4,"ngSwitchCase"],[1,"mat-form-field-outline"],[1,"mat-form-field-outline-start"],[1,"mat-form-field-outline-gap"],[1,"mat-form-field-outline-end"],[1,"mat-form-field-outline","mat-form-field-outline-thick"],[1,"mat-form-field-prefix"],[1,"mat-form-field-label",3,"cdkObserveContentDisabled","id","ngSwitch","cdkObserveContent"],["label",""],["class","mat-placeholder-required mat-form-field-required-marker","aria-hidden","true",4,"ngIf"],["aria-hidden","true",1,"mat-placeholder-required","mat-form-field-required-marker"],[1,"mat-form-field-suffix"],[1,"mat-form-field-underline"],["underline",""],[1,"mat-form-field-ripple"],[1,"mat-form-field-hint-wrapper"],["class","mat-hint",3,"id",4,"ngIf"],[1,"mat-form-field-hint-spacer"],[1,"mat-hint",3,"id"]],template:function(t,e){1&t&&(mo(k5),Qa(0,"div",0),Qa(1,"div",1,2),oo("click",function(t){return e._control.onContainerClick&&e._control.onContainerClick(t)}),Ka(3,d5,9,0,"ng-container",3),Ka(4,p5,2,0,"div",4),Qa(5,"div",5,6),go(7),Qa(8,"span",7),Ka(9,y5,5,16,"label",8),Ja(),Ja(),Ka(10,b5,2,0,"div",9),Ja(),Ka(11,v5,3,4,"div",10),Qa(12,"div",11),Ka(13,w5,2,1,"div",12),Ka(14,x5,5,2,"div",13),Ja(),Ja()),2&t&&(xi(3),Za("ngIf","outline"==e.appearance),xi(1),Za("ngIf",e._prefixChildren.length),xi(5),Za("ngIf",e._hasFloatingLabel()),xi(1),Za("ngIf",e._suffixChildren.length),xi(1),Za("ngIf","outline"!=e.appearance),xi(1),Za("ngSwitch",e._getDisplayedMessages()),xi(1),Za("ngSwitchCase","error"),xi(1),Za("ngSwitchCase","hint"))},directives:[nh,ah,oh,m0],styles:[".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n",'.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n','.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n',".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n",".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n",".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"],encapsulation:2,data:{animation:[I5.transitionMessages]},changeDetection:0}),t})(),z5=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[gh,M3,g0],M3]}),t})();class V5{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new B5(t,this.durationSelector))}}class B5 extends ot{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let e;try{const{durationSelector:n}=this;e=n(t)}catch(D7){return this.destination.error(D7)}const n=lt(e,new at(this));!n||n.closed?this.clearThrottle():this.add(this.throttled=n)}}clearThrottle(){const{value:t,hasValue:e,throttled:n}=this;n&&(this.remove(n),this.throttled=void 0,n.unsubscribe()),e&&(this.value=void 0,this.hasValue=!1,this.destination.next(t))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function W5(t){return!$(t)&&t-parseFloat(t)+1>=0}function U5(t){const{index:e,period:n,subscriber:s}=t;if(s.next(e),!s.closed){if(-1===n)return s.complete();t.index=e+1,this.schedule(t,n)}}function j5(t,e=jJ){return n=()=>function(t=0,e,n){let s=-1;return W5(e)?s=Number(e)<1?1:Number(e):K(e)&&(n=e),K(n)||(n=jJ),new B(e=>{const r=W5(t)?t:+t-n.now();return n.schedule(U5,r,{index:0,period:s,subscriber:e})})}(t,e),function(t){return t.lift(new V5(n))};var n}const H5=u0({passive:!0});let G5=(()=>{class t{constructor(t,e){this._platform=t,this._ngZone=e,this._monitoredElements=new Map}monitor(t){if(!this._platform.isBrowser)return bp;const e=JJ(t),n=this._monitoredElements.get(e);if(n)return n.subject;const s=new G,r="cdk-text-field-autofilled",i=t=>{"cdk-text-field-autofill-start"!==t.animationName||e.classList.contains(r)?"cdk-text-field-autofill-end"===t.animationName&&e.classList.contains(r)&&(e.classList.remove(r),this._ngZone.run(()=>s.next({target:t.target,isAutofilled:!1}))):(e.classList.add(r),this._ngZone.run(()=>s.next({target:t.target,isAutofilled:!0})))};return this._ngZone.runOutsideAngular(()=>{e.addEventListener("animationstart",i,H5),e.classList.add("cdk-text-field-autofill-monitored")}),this._monitoredElements.set(e,{subject:s,unlisten:()=>{e.removeEventListener("animationstart",i,H5)}}),s}stopMonitoring(t){const e=JJ(t),n=this._monitoredElements.get(e);n&&(n.unlisten(),n.subject.complete(),e.classList.remove("cdk-text-field-autofill-monitored"),e.classList.remove("cdk-text-field-autofilled"),this._monitoredElements.delete(e))}ngOnDestroy(){this._monitoredElements.forEach((t,e)=>this.stopMonitoring(e))}}return t.\u0275fac=function(e){return new(e||t)(Os(n0),Os(ju))},t.\u0275prov=Dt({factory:function(){return new t(Os(n0),Os(ju))},token:t,providedIn:"root"}),t})(),q5=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[s0]]}),t})();const K5=new ms("MAT_INPUT_VALUE_ACCESSOR"),X5=["button","checkbox","file","hidden","image","radio","range","reset","submit"];let Z5=0;class Y5{constructor(t,e,n,s){this._defaultErrorStateMatcher=t,this._parentForm=e,this._parentFormGroup=n,this.ngControl=s}}const Q5=B3(Y5);let J5=(()=>{class t extends Q5{constructor(t,e,n,s,r,i,a,o,l,u){super(i,s,r,n),this._elementRef=t,this._platform=e,this.ngControl=n,this._autofillMonitor=o,this._formField=u,this._uid="mat-input-"+Z5++,this.focused=!1,this.stateChanges=new G,this.controlType="mat-input",this.autofilled=!1,this._disabled=!1,this._required=!1,this._type="text",this._readonly=!1,this._neverEmptyInputTypes=["date","datetime","datetime-local","month","time","week"].filter(t=>i0().has(t));const c=this._elementRef.nativeElement,h=c.nodeName.toLowerCase();this._inputValueAccessor=a||c,this._previousNativeValue=this.value,this.id=this.id,e.IOS&&l.runOutsideAngular(()=>{t.nativeElement.addEventListener("keyup",t=>{const e=t.target;e.value||0!==e.selectionStart||0!==e.selectionEnd||(e.setSelectionRange(1,1),e.setSelectionRange(0,0))})}),this._isServer=!this._platform.isBrowser,this._isNativeSelect="select"===h,this._isTextarea="textarea"===h,this._isNativeSelect&&(this.controlType=c.multiple?"mat-native-select-multiple":"mat-native-select")}get disabled(){return this.ngControl&&null!==this.ngControl.disabled?this.ngControl.disabled:this._disabled}set disabled(t){this._disabled=XJ(t),this.focused&&(this.focused=!1,this.stateChanges.next())}get id(){return this._id}set id(t){this._id=t||this._uid}get required(){return this._required}set required(t){this._required=XJ(t)}get type(){return this._type}set type(t){this._type=t||"text",this._validateType(),!this._isTextarea&&i0().has(this._type)&&(this._elementRef.nativeElement.type=this._type)}get value(){return this._inputValueAccessor.value}set value(t){t!==this.value&&(this._inputValueAccessor.value=t,this.stateChanges.next())}get readonly(){return this._readonly}set readonly(t){this._readonly=XJ(t)}ngAfterViewInit(){this._platform.isBrowser&&this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(t=>{this.autofilled=t.isAutofilled,this.stateChanges.next()})}ngOnChanges(){this.stateChanges.next()}ngOnDestroy(){this.stateChanges.complete(),this._platform.isBrowser&&this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement)}ngDoCheck(){this.ngControl&&this.updateErrorState(),this._dirtyCheckNativeValue(),this._dirtyCheckPlaceholder()}focus(t){this._elementRef.nativeElement.focus(t)}_focusChanged(t){t===this.focused||this.readonly&&t||(this.focused=t,this.stateChanges.next())}_onInput(){}_dirtyCheckPlaceholder(){var t,e;const n=(null===(e=null===(t=this._formField)||void 0===t?void 0:t._hideControlPlaceholder)||void 0===e?void 0:e.call(t))?null:this.placeholder;if(n!==this._previousPlaceholder){const t=this._elementRef.nativeElement;this._previousPlaceholder=n,n?t.setAttribute("placeholder",n):t.removeAttribute("placeholder")}}_dirtyCheckNativeValue(){const t=this._elementRef.nativeElement.value;this._previousNativeValue!==t&&(this._previousNativeValue=t,this.stateChanges.next())}_validateType(){X5.indexOf(this._type)}_isNeverEmpty(){return this._neverEmptyInputTypes.indexOf(this._type)>-1}_isBadInput(){let t=this._elementRef.nativeElement.validity;return t&&t.badInput}get empty(){return!(this._isNeverEmpty()||this._elementRef.nativeElement.value||this._isBadInput()||this.autofilled)}get shouldLabelFloat(){if(this._isNativeSelect){const t=this._elementRef.nativeElement,e=t.options[0];return this.focused||t.multiple||!this.empty||!!(t.selectedIndex>-1&&e&&e.label)}return this.focused||!this.empty}setDescribedByIds(t){t.length?this._elementRef.nativeElement.setAttribute("aria-describedby",t.join(" ")):this._elementRef.nativeElement.removeAttribute("aria-describedby")}onContainerClick(){this.focused||this.focus()}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(n0),Xa(xd,10),Xa(Zd,8),Xa(ep,8),Xa(W3),Xa(K5,10),Xa(G5),Xa(ju),Xa(M5,8))},t.\u0275dir=be({type:t,selectors:[["input","matInput",""],["textarea","matInput",""],["select","matNativeControl",""],["input","matNativeControl",""],["textarea","matNativeControl",""]],hostAttrs:[1,"mat-input-element","mat-form-field-autofill-control"],hostVars:9,hostBindings:function(t,e){1&t&&oo("focus",function(){return e._focusChanged(!0)})("blur",function(){return e._focusChanged(!1)})("input",function(){return e._onInput()}),2&t&&($o("disabled",e.disabled)("required",e.required),Ga("id",e.id)("data-placeholder",e.placeholder)("readonly",e.readonly&&!e._isNativeSelect||null)("aria-invalid",e.empty&&e.required?null:e.errorState)("aria-required",e.required),xo("mat-input-server",e._isServer))},inputs:{id:"id",disabled:"disabled",required:"required",type:"type",value:"value",readonly:"readonly",placeholder:"placeholder",errorStateMatcher:"errorStateMatcher",userAriaDescribedBy:["aria-describedby","userAriaDescribedBy"]},exportAs:["matInput"],features:[Xo([{provide:E5,useExisting:t}]),Da,Re]}),t})(),t6=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[W3],imports:[[q5,z5,M3],q5,z5]}),t})(),e6=(()=>{class t{constructor(t,e,n){this._ngZone=t,this._platform=e,this._scrolled=new G,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=n}register(t){this.scrollContainers.has(t)||this.scrollContainers.set(t,t.elementScrolled().subscribe(()=>this._scrolled.next(t)))}deregister(t){const e=this.scrollContainers.get(t);e&&(e.unsubscribe(),this.scrollContainers.delete(t))}scrolled(t=20){return this._platform.isBrowser?new B(e=>{this._globalSubscription||this._addGlobalListener();const n=t>0?this._scrolled.pipe(j5(t)).subscribe(e):this._scrolled.subscribe(e);return this._scrolledCount++,()=>{n.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):op()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((t,e)=>this.deregister(e)),this._scrolled.complete()}ancestorScrolled(t,e){const n=this.getAncestorScrollContainers(t);return this.scrolled(e).pipe(Rp(t=>!t||n.indexOf(t)>-1))}getAncestorScrollContainers(t){const e=[];return this.scrollContainers.forEach((n,s)=>{this._scrollableContainsElement(s,t)&&e.push(s)}),e}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(t,e){let n=JJ(e),s=t.getElementRef().nativeElement;do{if(n==s)return!0}while(n=n.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>s5(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return t.\u0275fac=function(e){return new(e||t)(Os(ju),Os(n0),Os(kc,8))},t.\u0275prov=Dt({factory:function(){return new t(Os(ju),Os(n0),Os(kc,8))},token:t,providedIn:"root"}),t})(),n6=(()=>{class t{constructor(t,e,n){this._platform=t,this._change=new G,this._changeListener=t=>{this._change.next(t)},this._document=n,e.runOutsideAngular(()=>{if(t.isBrowser){const t=this._getWindow();t.addEventListener("resize",this._changeListener),t.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const t=this._getWindow();t.removeEventListener("resize",this._changeListener),t.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const t={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),t}getViewportRect(){const t=this.getViewportScrollPosition(),{width:e,height:n}=this.getViewportSize();return{top:t.top,left:t.left,bottom:t.top+n,right:t.left+e,height:n,width:e}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const t=this._document,e=this._getWindow(),n=t.documentElement,s=n.getBoundingClientRect();return{top:-s.top||t.body.scrollTop||e.scrollY||n.scrollTop||0,left:-s.left||t.body.scrollLeft||e.scrollX||n.scrollLeft||0}}change(t=20){return t>0?this._change.pipe(j5(t)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const t=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:t.innerWidth,height:t.innerHeight}:{width:0,height:0}}}return t.\u0275fac=function(e){return new(e||t)(Os(n0),Os(ju),Os(kc,8))},t.\u0275prov=Dt({factory:function(){return new t(Os(n0),Os(ju),Os(kc,8))},token:t,providedIn:"root"}),t})(),s6=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})(),r6=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[j0,s0,s6],j0,s6]}),t})();class i6{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class a6 extends i6{constructor(t,e,n,s){super(),this.component=t,this.viewContainerRef=e,this.injector=n,this.componentFactoryResolver=s}}class o6 extends i6{constructor(t,e,n){super(),this.templateRef=t,this.viewContainerRef=e,this.context=n}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class l6 extends i6{constructor(t){super(),this.element=t instanceof nl?t.nativeElement:t}}class u6{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof a6?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof o6?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof l6?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class c6 extends u6{constructor(t,e,n,s,r){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=n,this._defaultInjector=s,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");e.parentNode.insertBefore(n,e),this.outletElement.appendChild(e),this._attachedPortal=t,super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=r}attachComponentPortal(t){const e=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let n;return t.viewContainerRef?(n=t.viewContainerRef.createComponent(e,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>n.destroy())):(n=e.create(t.injector||this._defaultInjector),this._appRef.attachView(n.hostView),this.setDisposeFn(()=>{this._appRef.detachView(n.hostView),n.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(n)),this._attachedPortal=t,n}attachTemplatePortal(t){let e=t.viewContainerRef,n=e.createEmbeddedView(t.templateRef,t.context);return n.rootNodes.forEach(t=>this.outletElement.appendChild(t)),n.detectChanges(),this.setDisposeFn(()=>{let t=e.indexOf(n);-1!==t&&e.remove(t)}),this._attachedPortal=t,n}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let h6=(()=>{class t extends u6{constructor(t,e,n){super(),this._componentFactoryResolver=t,this._viewContainerRef=e,this._isInitialized=!1,this.attached=new ru,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");t.setAttachedHost(this),e.parentNode.insertBefore(n,e),this._getRootNode().appendChild(e),this._attachedPortal=t,super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=n}get portal(){return this._attachedPortal}set portal(t){(!this.hasAttached()||t||this._isInitialized)&&(this.hasAttached()&&super.detach(),t&&super.attach(t),this._attachedPortal=t)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(t){t.setAttachedHost(this);const e=null!=t.viewContainerRef?t.viewContainerRef:this._viewContainerRef,n=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component),s=e.createComponent(n,e.length,t.injector||e.injector);return e!==this._viewContainerRef&&this._getRootNode().appendChild(s.hostView.rootNodes[0]),super.setDisposeFn(()=>s.destroy()),this._attachedPortal=t,this._attachedRef=s,this.attached.emit(s),s}attachTemplatePortal(t){t.setAttachedHost(this);const e=this._viewContainerRef.createEmbeddedView(t.templateRef,t.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=t,this._attachedRef=e,this.attached.emit(e),e}_getRootNode(){const t=this._viewContainerRef.element.nativeElement;return t.nodeType===t.ELEMENT_NODE?t:t.parentNode}}return t.\u0275fac=function(e){return new(e||t)(Xa(Qo),Xa(Vl),Xa(kc))},t.\u0275dir=be({type:t,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[Da]}),t})(),d6=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})();const p6=c0();class f6{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=QJ(-this._previousScrollPosition.left),t.style.top=QJ(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,e=t.style,n=this._document.body.style,s=e.scrollBehavior||"",r=n.scrollBehavior||"";this._isEnabled=!1,e.left=this._previousHTMLStyles.left,e.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),p6&&(e.scrollBehavior=n.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),p6&&(e.scrollBehavior=s,n.scrollBehavior=r)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const t=this._document.body,e=this._viewportRuler.getViewportSize();return t.scrollHeight>e.height||t.scrollWidth>e.width}}class m6{constructor(t,e,n,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=n,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const t=this._viewportRuler.getViewportScrollPosition().top;Math.abs(t-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class g6{enable(){}disable(){}attach(){}}function y6(t,e){return e.some(e=>t.bottom<e.top||t.top>e.bottom||t.right<e.left||t.left>e.right)}function b6(t,e){return e.some(e=>t.top<e.top||t.bottom>e.bottom||t.left<e.left||t.right>e.right)}class v6{constructor(t,e,n,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const t=this._overlayRef.overlayElement.getBoundingClientRect(),{width:e,height:n}=this._viewportRuler.getViewportSize();y6(t,[{width:e,height:n,bottom:n,right:e,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let w6=(()=>{class t{constructor(t,e,n,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this.noop=()=>new g6,this.close=t=>new m6(this._scrollDispatcher,this._ngZone,this._viewportRuler,t),this.block=()=>new f6(this._viewportRuler,this._document),this.reposition=t=>new v6(this._scrollDispatcher,this._viewportRuler,this._ngZone,t),this._document=s}}return t.\u0275fac=function(e){return new(e||t)(Os(e6),Os(n6),Os(ju),Os(kc))},t.\u0275prov=Dt({factory:function(){return new t(Os(e6),Os(n6),Os(ju),Os(kc))},token:t,providedIn:"root"}),t})();class _6{constructor(t){if(this.scrollStrategy=new g6,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const n of e)void 0!==t[n]&&(this[n]=t[n])}}}class x6{constructor(t,e,n,s,r){this.offsetX=n,this.offsetY=s,this.panelClass=r,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class k6{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let C6=(()=>{class t{constructor(t){this._attachedOverlays=[],this._document=t}ngOnDestroy(){this.detach()}add(t){this.remove(t),this._attachedOverlays.push(t)}remove(t){const e=this._attachedOverlays.indexOf(t);e>-1&&this._attachedOverlays.splice(e,1),0===this._attachedOverlays.length&&this.detach()}}return t.\u0275fac=function(e){return new(e||t)(Os(kc))},t.\u0275prov=Dt({factory:function(){return new t(Os(kc))},token:t,providedIn:"root"}),t})(),S6=(()=>{class t extends C6{constructor(t){super(t),this._keydownListener=t=>{const e=this._attachedOverlays;for(let n=e.length-1;n>-1;n--)if(e[n]._keydownEvents.observers.length>0){e[n]._keydownEvents.next(t);break}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(Os(kc))},t.\u0275prov=Dt({factory:function(){return new t(Os(kc))},token:t,providedIn:"root"}),t})(),I6=(()=>{class t extends C6{constructor(t,e){super(t),this._platform=e,this._cursorStyleIsSet=!1,this._clickListener=t=>{const e=t.composedPath?t.composedPath()[0]:t.target,n=this._attachedOverlays.slice();for(let s=n.length-1;s>-1;s--){const r=n[s];if(!(r._outsidePointerEvents.observers.length<1)&&r.hasAttached()){if(r.overlayElement.contains(e))break;r._outsidePointerEvents.next(t)}}}}add(t){if(super.add(t),!this._isAttached){const t=this._document.body;t.addEventListener("click",this._clickListener,!0),t.addEventListener("auxclick",this._clickListener,!0),t.addEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=t.style.cursor,t.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const t=this._document.body;t.removeEventListener("click",this._clickListener,!0),t.removeEventListener("auxclick",this._clickListener,!0),t.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(t.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}}return t.\u0275fac=function(e){return new(e||t)(Os(kc),Os(n0))},t.\u0275prov=Dt({factory:function(){return new t(Os(kc),Os(n0))},token:t,providedIn:"root"}),t})();const E6=!("undefined"==typeof window||!window||!window.__karma__&&!window.jasmine);let N6=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}ngOnDestroy(){const t=this._containerElement;t&&t.parentNode&&t.parentNode.removeChild(t)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const t="cdk-overlay-container";if(this._platform.isBrowser||E6){const e=this._document.querySelectorAll(`.${t}[platform="server"], .${t}[platform="test"]`);for(let t=0;t<e.length;t++)e[t].parentNode.removeChild(e[t])}const e=this._document.createElement("div");e.classList.add(t),E6?e.setAttribute("platform","test"):this._platform.isBrowser||e.setAttribute("platform","server"),this._document.body.appendChild(e),this._containerElement=e}}return t.\u0275fac=function(e){return new(e||t)(Os(kc),Os(n0))},t.\u0275prov=Dt({factory:function(){return new t(Os(kc),Os(n0))},token:t,providedIn:"root"}),t})();class T6{constructor(t,e,n,s,r,i,a,o,l){this._portalOutlet=t,this._host=e,this._pane=n,this._config=s,this._ngZone=r,this._keyboardDispatcher=i,this._document=a,this._location=o,this._outsideClickDispatcher=l,this._backdropElement=null,this._backdropClick=new G,this._attachments=new G,this._detachments=new G,this._locationChanges=F.EMPTY,this._backdropClickHandler=t=>this._backdropClick.next(t),this._keydownEvents=new G,this._outsidePointerEvents=new G,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Sp(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=QJ(this._config.width),t.height=QJ(this._config.height),t.minWidth=QJ(this._config.minWidth),t.minHeight=QJ(this._config.minHeight),t.maxWidth=QJ(this._config.maxWidth),t.maxHeight=QJ(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let t,e=this._backdropElement;if(!e)return;let n=()=>{e&&(e.removeEventListener("click",this._backdropClickHandler),e.removeEventListener("transitionend",n),e.parentNode&&e.parentNode.removeChild(e)),this._backdropElement==e&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(e,this._config.backdropClass,!1),clearTimeout(t)};e.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{e.addEventListener("transitionend",n)}),e.style.pointerEvents="none",t=this._ngZone.runOutsideAngular(()=>setTimeout(n,500))}_toggleClasses(t,e,n){const s=t.classList;YJ(e).forEach(t=>{t&&(n?s.add(t):s.remove(t))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(i5(ft(this._attachments,this._detachments))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}}const A6="cdk-overlay-connected-position-bounding-box",$6=/([A-Za-z%]+)$/;class R6{constructor(t,e,n,s,r){this._viewportRuler=e,this._document=n,this._platform=s,this._overlayContainer=r,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new G,this._resizeSubscription=F.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(A6),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,n=this._viewportRect,s=[];let r;for(let i of this._preferredPositions){let a=this._getOriginPoint(t,i),o=this._getOverlayPoint(a,e,i),l=this._getOverlayFit(o,e,n,i);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(i,a);this._canFitWithFlexibleDimensions(l,o,n)?s.push({position:i,origin:a,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(a,i)}):(!r||r.overlayFit.visibleArea<l.visibleArea)&&(r={overlayFit:l,overlayPoint:o,originPoint:a,position:i,overlayRect:e})}if(s.length){let t=null,e=-1;for(const n of s){const s=n.boundingBoxRect.width*n.boundingBoxRect.height*(n.position.weight||1);s>e&&(e=s,t=n)}return this._isPushed=!1,void this._applyPosition(t.position,t.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(r.position,r.originPoint);this._applyPosition(r.position,r.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&O6(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(A6),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let n,s;if("center"==e.originX)n=t.left+t.width/2;else{const s=this._isRtl()?t.right:t.left,r=this._isRtl()?t.left:t.right;n="start"==e.originX?s:r}return s="center"==e.originY?t.top+t.height/2:"top"==e.originY?t.top:t.bottom,{x:n,y:s}}_getOverlayPoint(t,e,n){let s,r;return s="center"==n.overlayX?-e.width/2:"start"===n.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,r="center"==n.overlayY?-e.height/2:"top"==n.overlayY?0:-e.height,{x:t.x+s,y:t.y+r}}_getOverlayFit(t,e,n,s){const r=D6(e);let{x:i,y:a}=t,o=this._getOffset(s,"x"),l=this._getOffset(s,"y");o&&(i+=o),l&&(a+=l);let u=0-a,c=a+r.height-n.height,h=this._subtractOverflows(r.width,0-i,i+r.width-n.width),d=this._subtractOverflows(r.height,u,c),p=h*d;return{visibleArea:p,isCompletelyWithinViewport:r.width*r.height===p,fitsInViewportVertically:d===r.height,fitsInViewportHorizontally:h==r.width}}_canFitWithFlexibleDimensions(t,e,n){if(this._hasFlexibleDimensions){const s=n.bottom-e.y,r=n.right-e.x,i=F6(this._overlayRef.getConfig().minHeight),a=F6(this._overlayRef.getConfig().minWidth),o=t.fitsInViewportHorizontally||null!=a&&a<=r;return(t.fitsInViewportVertically||null!=i&&i<=s)&&o}return!1}_pushOverlayOnScreen(t,e,n){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=D6(e),r=this._viewportRect,i=Math.max(t.x+s.width-r.width,0),a=Math.max(t.y+s.height-r.height,0),o=Math.max(r.top-n.top-t.y,0),l=Math.max(r.left-n.left-t.x,0);let u=0,c=0;return u=s.width<=r.width?l||-i:t.x<this._viewportMargin?r.left-n.left-t.x:0,c=s.height<=r.height?o||-a:t.y<this._viewportMargin?r.top-n.top-t.y:0,this._previousPushAmount={x:u,y:c},{x:t.x+u,y:t.y+c}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const e=this._getScrollVisibility(),n=new k6(t,e);this._positionChanges.next(n)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let n,s=t.overlayY;n="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let r=0;r<e.length;r++)e[r].style.transformOrigin=`${n} ${s}`}_calculateBoundingBoxRect(t,e){const n=this._viewportRect,s=this._isRtl();let r,i,a,o,l,u;if("top"===e.overlayY)i=t.y,r=n.height-i+this._viewportMargin;else if("bottom"===e.overlayY)a=n.height-t.y+2*this._viewportMargin,r=n.height-a+this._viewportMargin;else{const e=Math.min(n.bottom-t.y+n.top,t.y),s=this._lastBoundingBoxSize.height;r=2*e,i=t.y-e,r>s&&!this._isInitialRender&&!this._growAfterOpen&&(i=t.y-s/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)u=n.width-t.x+this._viewportMargin,o=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)l=t.x,o=n.right-t.x;else{const e=Math.min(n.right-t.x+n.left,t.x),s=this._lastBoundingBoxSize.width;o=2*e,l=t.x-e,o>s&&!this._isInitialRender&&!this._growAfterOpen&&(l=t.x-s/2)}return{top:i,left:l,bottom:a,right:u,width:o,height:r}}_setBoundingBoxStyles(t,e){const n=this._calculateBoundingBoxRect(t,e);this._isInitialRender||this._growAfterOpen||(n.height=Math.min(n.height,this._lastBoundingBoxSize.height),n.width=Math.min(n.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const t=this._overlayRef.getConfig().maxHeight,r=this._overlayRef.getConfig().maxWidth;s.height=QJ(n.height),s.top=QJ(n.top),s.bottom=QJ(n.bottom),s.width=QJ(n.width),s.left=QJ(n.left),s.right=QJ(n.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",t&&(s.maxHeight=QJ(t)),r&&(s.maxWidth=QJ(r))}this._lastBoundingBoxSize=n,O6(this._boundingBox.style,s)}_resetBoundingBoxStyles(){O6(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){O6(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const n={},s=this._hasExactPosition(),r=this._hasFlexibleDimensions,i=this._overlayRef.getConfig();if(s){const s=this._viewportRuler.getViewportScrollPosition();O6(n,this._getExactOverlayY(e,t,s)),O6(n,this._getExactOverlayX(e,t,s))}else n.position="static";let a="",o=this._getOffset(e,"x"),l=this._getOffset(e,"y");o&&(a+=`translateX(${o}px) `),l&&(a+=`translateY(${l}px)`),n.transform=a.trim(),i.maxHeight&&(s?n.maxHeight=QJ(i.maxHeight):r&&(n.maxHeight="")),i.maxWidth&&(s?n.maxWidth=QJ(i.maxWidth):r&&(n.maxWidth="")),O6(this._pane.style,n)}_getExactOverlayY(t,e,n){let s={top:"",bottom:""},r=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&&(r=this._pushOverlayOnScreen(r,this._overlayRect,n));let i=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return r.y-=i,"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(r.y+this._overlayRect.height)+"px":s.top=QJ(r.y),s}_getExactOverlayX(t,e,n){let s,r={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,n)),s=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===s?r.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":r.left=QJ(i.x),r}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),n=this._scrollables.map(t=>t.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:b6(t,n),isOriginOutsideView:y6(t,n),isOverlayClipped:b6(e,n),isOverlayOutsideView:y6(e,n)}}_subtractOverflows(t,...e){return e.reduce((t,e)=>t-Math.max(e,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,n=this._viewportRuler.getViewportScrollPosition();return{top:n.top+this._viewportMargin,left:n.left+this._viewportMargin,right:n.left+t-this._viewportMargin,bottom:n.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&YJ(t).forEach(t=>{""!==t&&-1===this._appliedPanelClasses.indexOf(t)&&(this._appliedPanelClasses.push(t),this._pane.classList.add(t))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof nl)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,n=t.height||0;return{top:t.y,bottom:t.y+n,left:t.x,right:t.x+e,height:n,width:e}}}function O6(t,e){for(let n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function F6(t){if("number"!=typeof t&&null!=t){const[e,n]=t.split($6);return n&&"px"!==n?null:parseFloat(e)}return t||null}function D6(t){return{top:Math.floor(t.top),right:Math.floor(t.right),bottom:Math.floor(t.bottom),left:Math.floor(t.left),width:Math.floor(t.width),height:Math.floor(t.height)}}class L6{constructor(t,e,n,s,r,i,a){this._preferredPositions=[],this._positionStrategy=new R6(n,s,r,i,a).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e),this.onPositionChange=this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&&(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,n,s){const r=new x6(t,e,n,s);return this._preferredPositions.push(r),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}const M6="cdk-global-overlay-wrapper";class P6{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(M6),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._rightOffset="",this._leftOffset=t,this._justifyContent="flex-start",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._leftOffset="",this._rightOffset=t,this._justifyContent="flex-end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._justifyContent="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,n=this._overlayRef.getConfig(),{width:s,height:r,maxWidth:i,maxHeight:a}=n,o=!("100%"!==s&&"100vw"!==s||i&&"100%"!==i&&"100vw"!==i),l=!("100%"!==r&&"100vh"!==r||a&&"100%"!==a&&"100vh"!==a);t.position=this._cssPosition,t.marginLeft=o?"0":this._leftOffset,t.marginTop=l?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,o?e.justifyContent="flex-start":"center"===this._justifyContent?e.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?e.justifyContent="flex-end":"flex-end"===this._justifyContent&&(e.justifyContent="flex-start"):e.justifyContent=this._justifyContent,e.alignItems=l?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,n=e.style;e.classList.remove(M6),n.justifyContent=n.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let z6=(()=>{class t{constructor(t,e,n,s){this._viewportRuler=t,this._document=e,this._platform=n,this._overlayContainer=s}global(){return new P6}connectedTo(t,e,n){return new L6(e,n,t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(t){return new R6(t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return t.\u0275fac=function(e){return new(e||t)(Os(n6),Os(kc),Os(n0),Os(N6))},t.\u0275prov=Dt({factory:function(){return new t(Os(n6),Os(kc),Os(n0),Os(N6))},token:t,providedIn:"root"}),t})(),V6=0,B6=(()=>{class t{constructor(t,e,n,s,r,i,a,o,l,u,c){this.scrollStrategies=t,this._overlayContainer=e,this._componentFactoryResolver=n,this._positionBuilder=s,this._keyboardDispatcher=r,this._injector=i,this._ngZone=a,this._document=o,this._directionality=l,this._location=u,this._outsideClickDispatcher=c}create(t){const e=this._createHostElement(),n=this._createPaneElement(e),s=this._createPortalOutlet(n),r=new _6(t);return r.direction=r.direction||this._directionality.value,new T6(s,e,n,r,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(t){const e=this._document.createElement("div");return e.id="cdk-overlay-"+V6++,e.classList.add("cdk-overlay-pane"),t.appendChild(e),e}_createHostElement(){const t=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(t),t}_createPortalOutlet(t){return this._appRef||(this._appRef=this._injector.get(hc)),new c6(t,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return t.\u0275fac=function(e){return new(e||t)(Os(w6),Os(N6),Os(Qo),Os(z6),Os(S6),Os(Oa),Os(ju),Os(kc),Os(U0),Os(Pc),Os(I6))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})();const W6={provide:new ms("cdk-connected-overlay-scroll-strategy"),deps:[B6],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let U6=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[B6,W6],imports:[[j0,d6,r6],r6]}),t})();class j6{constructor(t){this.total=t}call(t,e){return e.subscribe(new H6(t,this.total))}}class H6 extends M{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){++this.count>this.total&&this.destination.next(t)}}const G6=new Set;let q6,K6=(()=>{class t{constructor(t){this._platform=t,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):X6}matchMedia(t){return this._platform.WEBKIT&&function(t){if(!G6.has(t))try{q6||(q6=document.createElement("style"),q6.setAttribute("type","text/css"),document.head.appendChild(q6)),q6.sheet&&(q6.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`,0),G6.add(t))}catch(e){console.error(e)}}(t),this._matchMedia(t)}}return t.\u0275fac=function(e){return new(e||t)(Os(n0))},t.\u0275prov=Dt({factory:function(){return new t(Os(n0))},token:t,providedIn:"root"}),t})();function X6(t){return{matches:"all"===t||""===t,media:t,addListener:()=>{},removeListener:()=>{}}}let Z6=(()=>{class t{constructor(t,e){this._mediaMatcher=t,this._zone=e,this._queries=new Map,this._destroySubject=new G}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(t){return Y6(YJ(t)).some(t=>this._registerQuery(t).mql.matches)}observe(t){let e=pp(Y6(YJ(t)).map(t=>this._registerQuery(t).observable));return e=yp(e.pipe(Sp(1)),e.pipe(t=>t.lift(new j6(1)),HJ(0))),e.pipe(X(t=>{const e={matches:!1,breakpoints:{}};return t.forEach(({matches:t,query:n})=>{e.matches=e.matches||t,e.breakpoints[n]=t}),e}))}_registerQuery(t){if(this._queries.has(t))return this._queries.get(t);const e=this._mediaMatcher.matchMedia(t),n={observable:new B(t=>{const n=e=>this._zone.run(()=>t.next(e));return e.addListener(n),()=>{e.removeListener(n)}}).pipe(Np(e),X(({matches:e})=>({query:t,matches:e})),i5(this._destroySubject)),mql:e};return this._queries.set(t,n),n}}return t.\u0275fac=function(e){return new(e||t)(Os(K6),Os(ju))},t.\u0275prov=Dt({factory:function(){return new t(Os(K6),Os(ju))},token:t,providedIn:"root"}),t})();function Y6(t){return t.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}const Q6={tooltipState:K0("state",[Q0("initial, void, hidden",Y0({opacity:0,transform:"scale(0)"})),Q0("visible",Y0({transform:"scale(1)"})),t1("* => visible",X0("200ms cubic-bezier(0, 0, 0.2, 1)",J0([Y0({opacity:0,transform:"scale(0)",offset:0}),Y0({opacity:.5,transform:"scale(0.99)",offset:.5}),Y0({opacity:1,transform:"scale(1)",offset:1})]))),t1("* => hidden",X0("100ms cubic-bezier(0, 0, 0.2, 1)",Y0({opacity:0})))])},J6=u0({passive:!0}),t8=new ms("mat-tooltip-scroll-strategy"),e8={provide:t8,deps:[B6],useFactory:function(t){return()=>t.scrollStrategies.reposition({scrollThrottle:20})}},n8=new ms("mat-tooltip-default-options",{providedIn:"root",factory:function(){return{showDelay:0,hideDelay:0,touchendHideDelay:1500}}});let s8=(()=>{class t{constructor(t,e,n,s,r,i,a,o,l,u,c,h){this._overlay=t,this._elementRef=e,this._scrollDispatcher=n,this._viewContainerRef=s,this._ngZone=r,this._platform=i,this._ariaDescriber=a,this._focusMonitor=o,this._dir=u,this._defaultOptions=c,this._position="below",this._disabled=!1,this._viewInitialized=!1,this._pointerExitEventsInitialized=!1,this._viewportMargin=8,this._cssClassPrefix="mat",this.showDelay=this._defaultOptions.showDelay,this.hideDelay=this._defaultOptions.hideDelay,this.touchGestures="auto",this._message="",this._passiveListeners=[],this._destroyed=new G,this._handleKeydown=t=>{this._isTooltipVisible()&&27===t.keyCode&&!zJ(t)&&(t.preventDefault(),t.stopPropagation(),this._ngZone.run(()=>this.hide(0)))},this._scrollStrategy=l,this._document=h,c&&(c.position&&(this.position=c.position),c.touchGestures&&(this.touchGestures=c.touchGestures)),u.change.pipe(i5(this._destroyed)).subscribe(()=>{this._overlayRef&&this._updatePosition(this._overlayRef)}),r.runOutsideAngular(()=>{e.nativeElement.addEventListener("keydown",this._handleKeydown)})}get position(){return this._position}set position(t){var e;t!==this._position&&(this._position=t,this._overlayRef&&(this._updatePosition(this._overlayRef),null===(e=this._tooltipInstance)||void 0===e||e.show(0),this._overlayRef.updatePosition()))}get disabled(){return this._disabled}set disabled(t){this._disabled=XJ(t),this._disabled?this.hide(0):this._setupPointerEnterEventsIfNeeded()}get message(){return this._message}set message(t){this._ariaDescriber.removeDescription(this._elementRef.nativeElement,this._message,"tooltip"),this._message=null!=t?String(t).trim():"",!this._message&&this._isTooltipVisible()?this.hide(0):(this._setupPointerEnterEventsIfNeeded(),this._updateTooltipMessage(),this._ngZone.runOutsideAngular(()=>{Promise.resolve().then(()=>{this._ariaDescriber.describe(this._elementRef.nativeElement,this.message,"tooltip")})}))}get tooltipClass(){return this._tooltipClass}set tooltipClass(t){this._tooltipClass=t,this._tooltipInstance&&this._setTooltipClass(this._tooltipClass)}ngAfterViewInit(){this._viewInitialized=!0,this._setupPointerEnterEventsIfNeeded(),this._focusMonitor.monitor(this._elementRef).pipe(i5(this._destroyed)).subscribe(t=>{t?"keyboard"===t&&this._ngZone.run(()=>this.show()):this._ngZone.run(()=>this.hide(0))})}ngOnDestroy(){const t=this._elementRef.nativeElement;clearTimeout(this._touchstartTimeout),this._overlayRef&&(this._overlayRef.dispose(),this._tooltipInstance=null),t.removeEventListener("keydown",this._handleKeydown),this._passiveListeners.forEach(([e,n])=>{t.removeEventListener(e,n,J6)}),this._passiveListeners.length=0,this._destroyed.next(),this._destroyed.complete(),this._ariaDescriber.removeDescription(t,this.message,"tooltip"),this._focusMonitor.stopMonitoring(t)}show(t=this.showDelay){if(this.disabled||!this.message||this._isTooltipVisible()&&!this._tooltipInstance._showTimeoutId&&!this._tooltipInstance._hideTimeoutId)return;const e=this._createOverlay();this._detach(),this._portal=this._portal||new a6(this._tooltipComponent,this._viewContainerRef),this._tooltipInstance=e.attach(this._portal).instance,this._tooltipInstance.afterHidden().pipe(i5(this._destroyed)).subscribe(()=>this._detach()),this._setTooltipClass(this._tooltipClass),this._updateTooltipMessage(),this._tooltipInstance.show(t)}hide(t=this.hideDelay){this._tooltipInstance&&this._tooltipInstance.hide(t)}toggle(){this._isTooltipVisible()?this.hide():this.show()}_isTooltipVisible(){return!!this._tooltipInstance&&this._tooltipInstance.isVisible()}_createOverlay(){if(this._overlayRef)return this._overlayRef;const t=this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),e=this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`).withFlexibleDimensions(!1).withViewportMargin(this._viewportMargin).withScrollableContainers(t);return e.positionChanges.pipe(i5(this._destroyed)).subscribe(t=>{this._updateCurrentPositionClass(t.connectionPair),this._tooltipInstance&&t.scrollableViewProperties.isOverlayClipped&&this._tooltipInstance.isVisible()&&this._ngZone.run(()=>this.hide(0))}),this._overlayRef=this._overlay.create({direction:this._dir,positionStrategy:e,panelClass:`${this._cssClassPrefix}-tooltip-panel`,scrollStrategy:this._scrollStrategy()}),this._updatePosition(this._overlayRef),this._overlayRef.detachments().pipe(i5(this._destroyed)).subscribe(()=>this._detach()),this._overlayRef}_detach(){this._overlayRef&&this._overlayRef.hasAttached()&&this._overlayRef.detach(),this._tooltipInstance=null}_updatePosition(t){const e=t.getConfig().positionStrategy,n=this._getOrigin(),s=this._getOverlayPosition();e.withPositions([this._addOffset(Object.assign(Object.assign({},n.main),s.main)),this._addOffset(Object.assign(Object.assign({},n.fallback),s.fallback))])}_addOffset(t){return t}_getOrigin(){const t=!this._dir||"ltr"==this._dir.value,e=this.position;let n;"above"==e||"below"==e?n={originX:"center",originY:"above"==e?"top":"bottom"}:"before"==e||"left"==e&&t||"right"==e&&!t?n={originX:"start",originY:"center"}:("after"==e||"right"==e&&t||"left"==e&&!t)&&(n={originX:"end",originY:"center"});const{x:s,y:r}=this._invertPosition(n.originX,n.originY);return{main:n,fallback:{originX:s,originY:r}}}_getOverlayPosition(){const t=!this._dir||"ltr"==this._dir.value,e=this.position;let n;"above"==e?n={overlayX:"center",overlayY:"bottom"}:"below"==e?n={overlayX:"center",overlayY:"top"}:"before"==e||"left"==e&&t||"right"==e&&!t?n={overlayX:"end",overlayY:"center"}:("after"==e||"right"==e&&t||"left"==e&&!t)&&(n={overlayX:"start",overlayY:"center"});const{x:s,y:r}=this._invertPosition(n.overlayX,n.overlayY);return{main:n,fallback:{overlayX:s,overlayY:r}}}_updateTooltipMessage(){this._tooltipInstance&&(this._tooltipInstance.message=this.message,this._tooltipInstance._markForCheck(),this._ngZone.onMicrotaskEmpty.pipe(Sp(1),i5(this._destroyed)).subscribe(()=>{this._tooltipInstance&&this._overlayRef.updatePosition()}))}_setTooltipClass(t){this._tooltipInstance&&(this._tooltipInstance.tooltipClass=t,this._tooltipInstance._markForCheck())}_invertPosition(t,e){return"above"===this.position||"below"===this.position?"top"===e?e="bottom":"bottom"===e&&(e="top"):"end"===t?t="start":"start"===t&&(t="end"),{x:t,y:e}}_updateCurrentPositionClass(t){const{overlayY:e,originX:n,originY:s}=t;let r;if(r="center"===e?this._dir&&"rtl"===this._dir.value?"end"===n?"left":"right":"start"===n?"left":"right":"bottom"===e&&"top"===s?"above":"below",r!==this._currentPosition){const t=this._overlayRef;if(t){const e=`${this._cssClassPrefix}-tooltip-panel-`;t.removePanelClass(e+this._currentPosition),t.addPanelClass(e+r)}this._currentPosition=r}}_setupPointerEnterEventsIfNeeded(){!this._disabled&&this.message&&this._viewInitialized&&!this._passiveListeners.length&&(this._platformSupportsMouseEvents()?this._passiveListeners.push(["mouseenter",()=>{this._setupPointerExitEventsIfNeeded(),this.show()}]):"off"!==this.touchGestures&&(this._disableNativeGesturesIfNecessary(),this._passiveListeners.push(["touchstart",()=>{this._setupPointerExitEventsIfNeeded(),clearTimeout(this._touchstartTimeout),this._touchstartTimeout=setTimeout(()=>this.show(),500)}])),this._addListeners(this._passiveListeners))}_setupPointerExitEventsIfNeeded(){if(this._pointerExitEventsInitialized)return;this._pointerExitEventsInitialized=!0;const t=[];if(this._platformSupportsMouseEvents())t.push(["mouseleave",()=>this.hide()],["wheel",t=>this._wheelListener(t)]);else if("off"!==this.touchGestures){this._disableNativeGesturesIfNecessary();const e=()=>{clearTimeout(this._touchstartTimeout),this.hide(this._defaultOptions.touchendHideDelay)};t.push(["touchend",e],["touchcancel",e])}this._addListeners(t),this._passiveListeners.push(...t)}_addListeners(t){t.forEach(([t,e])=>{this._elementRef.nativeElement.addEventListener(t,e,J6)})}_platformSupportsMouseEvents(){return!this._platform.IOS&&!this._platform.ANDROID}_wheelListener(t){if(this._isTooltipVisible()){const e=this._document.elementFromPoint(t.clientX,t.clientY),n=this._elementRef.nativeElement;e===n||n.contains(e)||this.hide()}}_disableNativeGesturesIfNecessary(){const t=this.touchGestures;if("off"!==t){const e=this._elementRef.nativeElement,n=e.style;("on"===t||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName)&&(n.userSelect=n.msUserSelect=n.webkitUserSelect=n.MozUserSelect="none"),"on"!==t&&e.draggable||(n.webkitUserDrag="none"),n.touchAction="none",n.webkitTapHighlightColor="transparent"}}}return t.\u0275fac=function(e){return new(e||t)(Xa(B6),Xa(nl),Xa(e6),Xa(Vl),Xa(ju),Xa(n0),Xa(k0),Xa(D0),Xa(void 0),Xa(U0),Xa(void 0),Xa(kc))},t.\u0275dir=be({type:t,inputs:{showDelay:["matTooltipShowDelay","showDelay"],hideDelay:["matTooltipHideDelay","hideDelay"],touchGestures:["matTooltipTouchGestures","touchGestures"],position:["matTooltipPosition","position"],disabled:["matTooltipDisabled","disabled"],message:["matTooltip","message"],tooltipClass:["matTooltipClass","tooltipClass"]}}),t})(),r8=(()=>{class t extends s8{constructor(t,e,n,s,r,i,a,o,l,u,c,h){super(t,e,n,s,r,i,a,o,l,u,c,h),this._tooltipComponent=a8}}return t.\u0275fac=function(e){return new(e||t)(Xa(B6),Xa(nl),Xa(e6),Xa(Vl),Xa(ju),Xa(n0),Xa(k0),Xa(D0),Xa(t8),Xa(U0,8),Xa(n8,8),Xa(kc))},t.\u0275dir=be({type:t,selectors:[["","matTooltip",""]],hostAttrs:[1,"mat-tooltip-trigger"],exportAs:["matTooltip"],features:[Da]}),t})(),i8=(()=>{class t{constructor(t){this._changeDetectorRef=t,this._visibility="initial",this._closeOnInteraction=!1,this._onHide=new G}show(t){clearTimeout(this._hideTimeoutId),this._closeOnInteraction=!0,this._showTimeoutId=setTimeout(()=>{this._visibility="visible",this._showTimeoutId=void 0,this._markForCheck()},t)}hide(t){clearTimeout(this._showTimeoutId),this._hideTimeoutId=setTimeout(()=>{this._visibility="hidden",this._hideTimeoutId=void 0,this._markForCheck()},t)}afterHidden(){return this._onHide}isVisible(){return"visible"===this._visibility}ngOnDestroy(){clearTimeout(this._showTimeoutId),clearTimeout(this._hideTimeoutId),this._onHide.complete()}_animationStart(){this._closeOnInteraction=!1}_animationDone(t){const e=t.toState;"hidden"!==e||this.isVisible()||this._onHide.next(),"visible"!==e&&"hidden"!==e||(this._closeOnInteraction=!0)}_handleBodyInteraction(){this._closeOnInteraction&&this.hide(0)}_markForCheck(){this._changeDetectorRef.markForCheck()}}return t.\u0275fac=function(e){return new(e||t)(Xa(Nl))},t.\u0275dir=be({type:t}),t})(),a8=(()=>{class t extends i8{constructor(t,e){super(t),this._breakpointObserver=e,this._isHandset=this._breakpointObserver.observe("(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)")}}return t.\u0275fac=function(e){return new(e||t)(Xa(Nl),Xa(Z6))},t.\u0275cmp=de({type:t,selectors:[["mat-tooltip-component"]],hostAttrs:["aria-hidden","true"],hostVars:2,hostBindings:function(t,e){1&t&&oo("click",function(){return e._handleBodyInteraction()},!1,Or)("auxclick",function(){return e._handleBodyInteraction()},!1,Or),2&t&&_o("zoom","visible"===e._visibility?1:null)},features:[Da],decls:3,vars:7,consts:[[1,"mat-tooltip",3,"ngClass"]],template:function(t,e){if(1&t&&(Qa(0,"div",0),oo("@state.start",function(){return e._animationStart()})("@state.done",function(t){return e._animationDone(t)}),eu(1,"async"),No(2),Ja()),2&t){let t;xo("mat-tooltip-handset",null==(t=nu(1,5,e._isHandset))?null:t.matches),Za("ngClass",e.tooltipClass)("@state",e._visibility),xi(2),To(e.message)}},directives:[Qc],pipes:[fh],styles:[".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"],encapsulation:2,data:{animation:[Q6.tooltipState]},changeDetection:0}),t})(),o8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[e8],imports:[[B0,gh,U6,M3],M3,s6]}),t})();const l8=["primaryValueBar"];class u8{constructor(t){this._elementRef=t}}const c8=z3(u8,"primary"),h8=new ms("mat-progress-bar-location",{providedIn:"root",factory:function(){const t=Fs(kc),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}});let d8=0,p8=(()=>{class t extends c8{constructor(t,e,n,s){super(t),this._elementRef=t,this._ngZone=e,this._animationMode=n,this._isNoopAnimation=!1,this._value=0,this._bufferValue=0,this.animationEnd=new ru,this._animationEndSubscription=F.EMPTY,this.mode="determinate",this.progressbarId="mat-progress-bar-"+d8++;const r=s?s.getPathname().split("#")[0]:"";this._rectangleFillValue=`url('${r}#${this.progressbarId}')`,this._isNoopAnimation="NoopAnimations"===n}get value(){return this._value}set value(t){this._value=f8(ZJ(t)||0)}get bufferValue(){return this._bufferValue}set bufferValue(t){this._bufferValue=f8(t||0)}_primaryTransform(){return{transform:`scale3d(${this.value/100}, 1, 1)`}}_bufferTransform(){return"buffer"===this.mode?{transform:`scale3d(${this.bufferValue/100}, 1, 1)`}:null}ngAfterViewInit(){this._ngZone.runOutsideAngular(()=>{const t=this._primaryValueBar.nativeElement;this._animationEndSubscription=s5(t,"transitionend").pipe(Rp(e=>e.target===t)).subscribe(()=>{"determinate"!==this.mode&&"buffer"!==this.mode||this._ngZone.run(()=>this.animationEnd.next({value:this.value}))})})}ngOnDestroy(){this._animationEndSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(ju),Xa(T3,8),Xa(h8,8))},t.\u0275cmp=de({type:t,selectors:[["mat-progress-bar"]],viewQuery:function(t,e){if(1&t&&yu(l8,5),2&t){let t;gu(t=vu())&&(e._primaryValueBar=t.first)}},hostAttrs:["role","progressbar","aria-valuemin","0","aria-valuemax","100","tabindex","-1",1,"mat-progress-bar"],hostVars:4,hostBindings:function(t,e){2&t&&(Ga("aria-valuenow","indeterminate"===e.mode||"query"===e.mode?null:e.value)("mode",e.mode),xo("_mat-animation-noopable",e._isNoopAnimation))},inputs:{color:"color",mode:"mode",value:"value",bufferValue:"bufferValue"},outputs:{animationEnd:"animationEnd"},exportAs:["matProgressBar"],features:[Da],decls:10,vars:4,consts:[["aria-hidden","true"],["width","100%","height","4","focusable","false",1,"mat-progress-bar-background","mat-progress-bar-element"],["x","4","y","0","width","8","height","4","patternUnits","userSpaceOnUse",3,"id"],["cx","2","cy","2","r","2"],["width","100%","height","100%"],[1,"mat-progress-bar-buffer","mat-progress-bar-element",3,"ngStyle"],[1,"mat-progress-bar-primary","mat-progress-bar-fill","mat-progress-bar-element",3,"ngStyle"],["primaryValueBar",""],[1,"mat-progress-bar-secondary","mat-progress-bar-fill","mat-progress-bar-element"]],template:function(t,e){1&t&&(Qa(0,"div",0),Nn(),Qa(1,"svg",1),Qa(2,"defs"),Qa(3,"pattern",2),to(4,"circle",3),Ja(),Ja(),to(5,"rect",4),Ja(),Qe.lFrame.currentNamespace=null,to(6,"div",5),to(7,"div",6,7),to(9,"div",8),Ja()),2&t&&(xi(3),Za("id",e.progressbarId),xi(2),Ga("fill",e._rectangleFillValue),xi(1),Za("ngStyle",e._bufferTransform()),xi(1),Za("ngStyle",e._primaryTransform()))},directives:[lh],styles:['.mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:"";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n'],encapsulation:2,changeDetection:0}),t})();function f8(t,e=0,n=100){return Math.max(e,Math.min(n,t))}let m8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[gh,M3],M3]}),t})();function g8(t,e){1&t&&to(0,"mat-spinner")}function y8(t,e){if(1&t){const t=so();Qa(0,"input",20),oo("change",function(e){return nn(t),po(2).onFileChange(e)}),Ja()}}function b8(t,e){if(1&t){const t=so();Qa(0,"input",21),oo("change",function(e){return nn(t),po(2).onUrlChange(e)}),Ja()}}function v8(t,e){if(1&t&&(Qa(0,"div",16),Ka(1,y8,1,0,"input",17),Qa(2,"span"),No(3,"OR"),Ja(),Qa(4,"mat-form-field",18),Ka(5,b8,1,0,"input",19),Ja(),Ja()),2&t){const t=po();xi(1),Za("ngIf",!t.imageURL),xi(4),Za("ngIf",!t.imageURL)}}function w8(t,e){1&t&&(Qa(0,"span"),Qa(1,"h1"),No(2," Detects OT9! "),Ja(),Qa(3,"h3"),No(4," upload an image "),to(5,"br"),Qa(6,"mat-icon"),No(7,"keyboard_backspace"),Ja(),Ja(),Ja())}function _8(t,e){if(1&t&&(Qa(0,"span"),Qa(1,"h2"),No(2),to(3,"p",24),Ja(),Ja()),2&t){const t=po(2);xi(2),Ao(" This is a ",t.prediction,"! "),xi(1),Za("innerHTML",t.sb,kr)}}function x8(t,e){if(1&t&&(Qa(0,"h2"),No(1),Ja()),2&t){const t=po(2);xi(1),Ao(" This is a ",t.prediction," ")}}function k8(t,e){if(1&t&&(Qa(0,"div"),Qa(1,"p",25),eu(2,"percent"),No(3),Ja(),to(4,"mat-progress-bar",26),to(5,"br"),Ja()),2&t){const t=e.$implicit,n=e.index,s=po(2);xi(1),yo("matTooltip",nu(2,3,t)),xi(2),To(s.labels[n]),xi(1),Za("value",100*t)}}function C8(t,e){if(1&t&&(Qa(0,"div",22),Ka(1,_8,4,2,"span",6),Ka(2,x8,2,1,"h2",6),Qa(3,"h3"),No(4),eu(5,"percent"),Ja(),to(6,"br"),Qa(7,"div"),Ka(8,k8,6,5,"div",23),Ja(),Ja()),2&t){const t=po();xi(1),Za("ngIf",t.prediction===t.labels[0]),xi(1),Za("ngIf",t.prediction!=t.labels[0]),xi(2),Ao(" (",nu(5,4,t.certainty),") "),xi(4),Za("ngForOf",t.stats)}}function S8(t,e){1&t&&(Qa(0,"h2"),No(1," No face detected "),Ja())}function I8(t,e){if(1&t&&(Qa(0,"div"),Ka(1,S8,2,0,"h2",6),Ja()),2&t){const t=po();xi(1),Za("ngIf",0===t.certainty)}}function E8(t,e){1&t&&to(0,"mat-spinner")}let N8=(()=>{class t{constructor(t){this.TfService=t,this.sb="&#127827",this.title="leappdepwinss",this.results={bbox:[],pred:[]},this.certainty=-1,this.prediction="",this.labels=[],this.stats=[],this.imageURL="",this.form=new Gd({pic:new Hd(""),url:new Hd("")}),this.modelLoaded=!1,this.predicting=!1}ngOnInit(){this.form.reset(),this.imageURL="",this.prediction="",this.certainty=-1,this.labels=[],this.modelSub=this.TfService.modelLoaded.subscribe(t=>{this.modelLoaded=t,this.labels=this.TfService.settings.LABELS})}onFileChange(t){const e=t.target.files;if(0===e.length)return;if(null==e[0].type.match(/image\/*/))return;const n=new FileReader;n.readAsDataURL(e[0]),n.onload=t=>{let e=new Image;e.src=n.result,e.onload=()=>{this.imageURL=e.src;let t=document.getElementById("canv"),n=t.getContext("2d");t.width=e.width,t.height=e.height,null==n||n.drawImage(e,0,0)}}}onUrlChange(t){var e;this.imageURL=null===(e=this.form.get("url"))||void 0===e?void 0:e.value,this.getBase64ImageFromURL(this.imageURL).subscribe(t=>{})}getBase64ImageFromURL(t){return B.create(e=>{let n=new Image;n.crossOrigin="Anonymous",n.src=t,n.complete?(e.next(this.getBase64Image(n)),e.complete()):(n.onload=()=>{e.next(this.getBase64Image(n)),e.complete()},n.onerror=t=>{e.error(t)})})}getBase64Image(t){var e=document.getElementById("canv");return e.width=t.width,e.height=t.height,e.getContext("2d").drawImage(t,0,0),e.toDataURL("image/png").replace(/^data:image\/(png|jpg);base64,/,"")}getLabels(t){let e=document.getElementById("canv"),n=e.getContext("2d"),s=Math.abs(e.width-e.height);t.forEach((t,r)=>{let i=e.width>e.height?t[1]*e.width:t[1]*(e.width+s)-s/2,a=e.width>e.height?t[0]*(e.height+s)-s/2:t[0]*e.height,o=e.width>e.height?Math.abs(t[1]-t[3])*e.width:Math.abs(t[0]-t[2])*e.height,l=sy.colorsRGB[this.results.pred[r].indexOf(Math.max(...this.results.pred[r]))];n.beginPath(),n.rect(i,a,o,o),n.strokeStyle=l,n.lineWidth=15,n.stroke()})}deletePic(){this.ngOnDestroy(),this.ngOnInit()}onSubmit(){var t=this;return ny(function*(){t.predicting=!0,t.results=yield t.TfService.predict(document.getElementById("canv")),t.stats=t.results.pred[0],t.certainty=Math.max(...t.stats),t.prediction=0===t.certainty?"":t.TfService.settings.LABELS[t.stats.indexOf(t.certainty)],t.getLabels(t.results.bbox),t.predicting=!1})()}ngOnDestroy(){this.modelSub.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Xa(PJ))},t.\u0275cmp=de({type:t,selectors:[["app-root"]],decls:22,vars:12,consts:[["cols","4","rowHeight","1vh"],["colspan","4","rowspan","5"],["color","accent",2,"top","0","position","sticky","z-index","1000"],["src","../favicon.ico","alt",""],[3,"formGroup","ngSubmit"],["colspan","3","rowspan","75",2,"background","rgb(203, 250, 203)"],[4,"ngIf"],["class","dropzone",4,"ngIf"],["id","img-container",3,"hidden"],["id","canv",1,"upload"],["id","urlsubject","crossorigin","anonymous",3,"src"],["mat-fab","","mat-ripple","","type","button",2,"z-index","3","position","absolute","top","2%","right","1%",3,"click"],["colspan","1","rowspan","75",2,"background","lightblue"],["style","width: 95%;",4,"ngIf"],["colspan","4","rowspan","15",2,"background","lightgreen"],["mat-raised-button","","mat-ripple","","color","accent",3,"disabled","onClick"],[1,"dropzone"],["type","file","formControlName","pic",3,"change",4,"ngIf"],["appearance","fill",2,"width","90%"],["matInput","","type","url","formControlName","url","placeholder","paste image url",3,"change",4,"ngIf"],["type","file","formControlName","pic",3,"change"],["matInput","","type","url","formControlName","url","placeholder","paste image url",3,"change"],[2,"width","95%"],[4,"ngFor","ngForOf"],[3,"innerHTML"],[3,"matTooltip"],["mode","determinate",3,"value"]],template:function(t,e){1&t&&(Qa(0,"mat-grid-list",0),Qa(1,"mat-grid-tile",1),Qa(2,"mat-toolbar",2),to(3,"img",3),Ja(),Ja(),Qa(4,"form",4),oo("ngSubmit",function(){return e.onSubmit()}),Qa(5,"mat-grid-tile",5),Ka(6,g8,1,0,"mat-spinner",6),Ka(7,v8,6,2,"div",7),Qa(8,"div",8),Qa(9,"canvas",9),to(10,"img",10),Ja(),Qa(11,"button",11),oo("click",function(){return e.deletePic()}),Qa(12,"mat-icon"),No(13,"close"),Ja(),Ja(),Ja(),Ja(),Qa(14,"mat-grid-tile",12),Ka(15,w8,8,0,"span",6),Ka(16,C8,9,6,"div",13),Ka(17,I8,2,1,"div",6),Ja(),Qa(18,"mat-grid-tile",14),Qa(19,"button",15),oo("onClick",function(){return e.onSubmit()}),No(20," Submit "),Ja(),Ka(21,E8,1,0,"mat-spinner",6),Ja(),Ja(),Ja()),2&t&&(xi(2),xo("mat-elevation-z5",!0),xi(2),Za("formGroup",e.form),xi(2),Za("ngIf",!e.modelLoaded),xi(1),Za("ngIf",""===e.imageURL&&e.modelLoaded),xi(1),Za("hidden",""===e.imageURL||!e.modelLoaded),xi(2),Za("src",e.imageURL,Cr),xi(5),Za("ngIf",-1===e.certainty),xi(1),Za("ngIf",""!=e.prediction),xi(1),Za("ngIf",""===e.prediction),xi(2),Za("disabled",e.predicting),xi(2),Za("ngIf",e.predicting))},directives:[f4,a4,_4,Yd,Sd,ep,nh,N4,Y3,j4,e5,P5,od,Cd,sp,J5,th,r8,p8],pipes:[mh],styles:[".img-container[_ngcontent-%COMP%]{position:relative}.overlay[_ngcontent-%COMP%]{color:#fff;background-color:#000c;padding:10px;border-radius:10%;position:absolute;bottom:20px;left:20px;z-index:5}.dropzone[_ngcontent-%COMP%]{align-items:center;display:flex;flex-direction:column;justify-content:space-around;text-align:center;height:50%;width:80%;z-index:5;border:1px dashed #979797}.upload[_ngcontent-%COMP%]{display:block;margin:5 auto;padding:auto;object-fit:scale-down;height:70vh;max-height:75vh}"]}),t})();const T8={provide:new ms("mat-autocomplete-scroll-strategy"),deps:[B6],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let A8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[T8],imports:[[U6,t4,M3,gh],s6,t4,M3]}),t})(),$8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})(),R8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[Q3,M3,g0,$8],M3,$8]}),t})(),O8=(()=>{class t{constructor(){this.changes=new G,this.calendarLabel="Calendar",this.openCalendarLabel="Open calendar",this.closeCalendarLabel="Close calendar",this.prevMonthLabel="Previous month",this.nextMonthLabel="Next month",this.prevYearLabel="Previous year",this.nextYearLabel="Next year",this.prevMultiYearLabel="Previous 24 years",this.nextMultiYearLabel="Next 24 years",this.switchToMonthViewLabel="Choose date",this.switchToMultiYearViewLabel="Choose month and year"}formatYearRange(t,e){return`${t} \u2013 ${e}`}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const F8={provide:new ms("mat-datepicker-scroll-strategy"),deps:[B6],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let D8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[O8,F8],imports:[[gh,T4,U6,B0,d6,M3],s6]}),t})(),L8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[Q3,M3],M3]}),t})();const M8={provide:new ms("mat-select-scroll-strategy"),deps:[B6],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let P8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[M8],imports:[[gh,U6,t4,M3],s6,z5,t4,M3]}),t})(),z8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[gh,M3],M3]}),t})(),V8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})(),B8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[V8,Q3,M3,g0],V8,M3]}),t})();const W8={provide:new ms("mat-menu-scroll-strategy"),deps:[B6],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let U8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[W8],imports:[M3]}),t})(),j8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[W8],imports:[[gh,M3,Q3,U6,U8],s6,M3,U8]}),t})(),H8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[gh,M3,s0,s6],s6,M3]}),t})(),G8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3],M3]}),t})(),q8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3],M3]}),t})(),K8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})(),X8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[gh,M3,K8,d6]]}),t})(),Z8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[U3,Q3,M3,J3,gh],U3,M3,J3,q8]}),t})(),Y8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[j0]]}),t})(),Q8=(()=>{class t{constructor(){this.changes=new G,this.optionalLabel="Optional"}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const J8={provide:Q8,deps:[[new Ps,new zs,Q8]],useFactory:function(t){return t||new Q8}};let t7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[J8,W3],imports:[[M3,gh,d6,T4,Y8,H4,Q3],M3]}),t})(),e7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[gh,M3,d6,Q3,g0,B0],M3]}),t})(),n7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({}),t})(),s7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[n7,M3],M3]}),t})(),r7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[M3,Q3],M3]}),t})(),i7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[B0,M3],M3]}),t})();const a7=new ms("mat-chips-default-options"),o7={separatorKeyCodes:[13]};let l7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[W3,{provide:a7,useValue:o7}],imports:[[M3]]}),t})(),u7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[U6,M3,d6],M3]}),t})();function c7(t,e){}class h7{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.autoFocus=!0,this.restoreFocus=!0,this.closeOnNavigation=!0}}const d7={dialogContainer:K0("dialogContainer",[Q0("void, exit",Y0({opacity:0,transform:"scale(0.7)"})),Q0("enter",Y0({transform:"none"})),t1("* => enter",X0("150ms cubic-bezier(0, 0, 0.2, 1)",Y0({transform:"none",opacity:1}))),t1("* => void, * => exit",X0("75ms cubic-bezier(0.4, 0.0, 0.2, 1)",Y0({opacity:0})))])};let p7=(()=>{class t extends u6{constructor(t,e,n,s,r,i){super(),this._elementRef=t,this._focusTrapFactory=e,this._changeDetectorRef=n,this._config=r,this._focusMonitor=i,this._animationStateChanged=new ru,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=t=>(this._portalOutlet.hasAttached(),this._portalOutlet.attachDomPortal(t)),this._ariaLabelledBy=r.ariaLabelledBy||null,this._document=s}_initializeWithAttachedContent(){this._setupFocusTrap(),this._capturePreviouslyFocusedElement(),this._focusDialogContainer()}attachComponentPortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachComponentPortal(t)}attachTemplatePortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachTemplatePortal(t)}_recaptureFocus(){this._containsFocus()||(!this._config.autoFocus||!this._focusTrap.focusInitialElement())&&this._elementRef.nativeElement.focus()}_trapFocus(){this._config.autoFocus?this._focusTrap.focusInitialElementWhenReady():this._containsFocus()||this._elementRef.nativeElement.focus()}_restoreFocus(){const t=this._elementFocusedBeforeDialogWasOpened;if(this._config.restoreFocus&&t&&"function"==typeof t.focus){const e=d0(),n=this._elementRef.nativeElement;e&&e!==this._document.body&&e!==n&&!n.contains(e)||(this._focusMonitor?(this._focusMonitor.focusVia(t,this._closeInteractionType),this._closeInteractionType=null):t.focus())}this._focusTrap&&this._focusTrap.destroy()}_setupFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement)}_capturePreviouslyFocusedElement(){this._document&&(this._elementFocusedBeforeDialogWasOpened=d0())}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const t=this._elementRef.nativeElement,e=d0();return t===e||t.contains(e)}}return t.\u0275fac=function(e){return new(e||t)(Xa(nl),Xa(A0),Xa(Nl),Xa(kc,8),Xa(h7),Xa(D0))},t.\u0275dir=be({type:t,viewQuery:function(t,e){if(1&t&&yu(h6,7),2&t){let t;gu(t=vu())&&(e._portalOutlet=t.first)}},features:[Da]}),t})(),f7=(()=>{class t extends p7{constructor(){super(...arguments),this._state="enter"}_onAnimationDone({toState:t,totalTime:e}){"enter"===t?(this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:e})):"exit"===t&&(this._restoreFocus(),this._animationStateChanged.next({state:"closed",totalTime:e}))}_onAnimationStart({toState:t,totalTime:e}){"enter"===t?this._animationStateChanged.next({state:"opening",totalTime:e}):"exit"!==t&&"void"!==t||this._animationStateChanged.next({state:"closing",totalTime:e})}_startExitAnimation(){this._state="exit",this._changeDetectorRef.markForCheck()}}return t.\u0275fac=function(){let e;return function(n){return(e||(e=cs(t)))(n||t)}}(),t.\u0275cmp=de({type:t,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1","aria-modal","true",1,"mat-dialog-container"],hostVars:6,hostBindings:function(t,e){1&t&&lo("@dialogContainer.start",function(t){return e._onAnimationStart(t)})("@dialogContainer.done",function(t){return e._onAnimationDone(t)}),2&t&&($o("id",e._id),Ga("role",e._config.role)("aria-labelledby",e._config.ariaLabel?null:e._ariaLabelledBy)("aria-label",e._config.ariaLabel)("aria-describedby",e._config.ariaDescribedBy||null),Ro("@dialogContainer",e._state))},features:[Da],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(t,e){1&t&&Ka(0,c7,0,0,"ng-template",0)},directives:[h6],styles:[".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"],encapsulation:2,data:{animation:[d7.dialogContainer]}}),t})(),m7=0;class g7{constructor(t,e,n="mat-dialog-"+m7++){this._overlayRef=t,this._containerInstance=e,this.id=n,this.disableClose=this._containerInstance._config.disableClose,this._afterOpened=new G,this._afterClosed=new G,this._beforeClosed=new G,this._state=0,e._id=n,e._animationStateChanged.pipe(Rp(t=>"opened"===t.state),Sp(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),e._animationStateChanged.pipe(Rp(t=>"closed"===t.state),Sp(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._afterClosed.next(this._result),this._afterClosed.complete(),this.componentInstance=null,this._overlayRef.dispose()}),t.keydownEvents().pipe(Rp(t=>27===t.keyCode&&!this.disableClose&&!zJ(t))).subscribe(t=>{t.preventDefault(),y7(this,"keyboard")}),t.backdropClick().subscribe(()=>{this.disableClose?this._containerInstance._recaptureFocus():y7(this,"mouse")})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(Rp(t=>"closing"===t.state),Sp(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._afterClosed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._overlayRef.backdropClick()}keydownEvents(){return this._overlayRef.keydownEvents()}updatePosition(t){let e=this._getPositionStrategy();return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._overlayRef.updatePosition(),this}updateSize(t="",e=""){return this._overlayRef.updateSize({width:t,height:e}),this._overlayRef.updatePosition(),this}addPanelClass(t){return this._overlayRef.addPanelClass(t),this}removePanelClass(t){return this._overlayRef.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._overlayRef.dispose()}_getPositionStrategy(){return this._overlayRef.getConfig().positionStrategy}}function y7(t,e,n){return void 0!==t._containerInstance&&(t._containerInstance._closeInteractionType=e),t.close(n)}const b7=new ms("MatDialogData"),v7=new ms("mat-dialog-default-options"),w7=new ms("mat-dialog-scroll-strategy"),_7={provide:w7,deps:[B6],useFactory:function(t){return()=>t.scrollStrategies.block()}};let x7=(()=>{class t{constructor(t,e,n,s,r,i,a,o,l){this._overlay=t,this._injector=e,this._defaultOptions=n,this._parentDialog=s,this._overlayContainer=r,this._dialogRefConstructor=a,this._dialogContainerType=o,this._dialogDataToken=l,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new G,this._afterOpenedAtThisLevel=new G,this._ariaHiddenElements=new Map,this.afterAllClosed=wp(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Np(void 0))),this._scrollStrategy=i}get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const t=this._parentDialog;return t?t._getAfterAllClosed():this._afterAllClosedAtThisLevel}open(t,e){(e=function(t,e){return Object.assign(Object.assign({},e),t)}(e,this._defaultOptions||new h7)).id&&this.getDialogById(e.id);const n=this._createOverlay(e),s=this._attachDialogContainer(n,e),r=this._attachDialogContent(t,s,n,e);return this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(r),r.afterClosed().subscribe(()=>this._removeOpenDialog(r)),this.afterOpened.next(r),s._initializeWithAttachedContent(),r}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(t){return this.openDialogs.find(e=>e.id===t)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_createOverlay(t){const e=this._getOverlayConfig(t);return this._overlay.create(e)}_getOverlayConfig(t){const e=new _6({positionStrategy:this._overlay.position().global(),scrollStrategy:t.scrollStrategy||this._scrollStrategy(),panelClass:t.panelClass,hasBackdrop:t.hasBackdrop,direction:t.direction,minWidth:t.minWidth,minHeight:t.minHeight,maxWidth:t.maxWidth,maxHeight:t.maxHeight,disposeOnNavigation:t.closeOnNavigation});return t.backdropClass&&(e.backdropClass=t.backdropClass),e}_attachDialogContainer(t,e){const n=Oa.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:h7,useValue:e}]}),s=new a6(this._dialogContainerType,e.viewContainerRef,n,e.componentFactoryResolver);return t.attach(s).instance}_attachDialogContent(t,e,n,s){const r=new this._dialogRefConstructor(n,e,s.id);if(t instanceof Ol)e.attachTemplatePortal(new o6(t,null,{$implicit:s.data,dialogRef:r}));else{const n=this._createInjector(s,r,e),i=e.attachComponentPortal(new a6(t,s.viewContainerRef,n));r.componentInstance=i.instance}return r.updateSize(s.width,s.height).updatePosition(s.position),r}_createInjector(t,e,n){const s=t&&t.viewContainerRef&&t.viewContainerRef.injector,r=[{provide:this._dialogContainerType,useValue:n},{provide:this._dialogDataToken,useValue:t.data},{provide:this._dialogRefConstructor,useValue:e}];return!t.direction||s&&s.get(U0,null)||r.push({provide:U0,useValue:{value:t.direction,change:op()}}),Oa.create({parent:s||this._injector,providers:r})}_removeOpenDialog(t){const e=this.openDialogs.indexOf(t);e>-1&&(this.openDialogs.splice(e,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((t,e)=>{t?e.setAttribute("aria-hidden",t):e.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const t=this._overlayContainer.getContainerElement();if(t.parentElement){const e=t.parentElement.children;for(let n=e.length-1;n>-1;n--){let s=e[n];s===t||"SCRIPT"===s.nodeName||"STYLE"===s.nodeName||s.hasAttribute("aria-live")||(this._ariaHiddenElements.set(s,s.getAttribute("aria-hidden")),s.setAttribute("aria-hidden","true"))}}}_closeDialogs(t){let e=t.length;for(;e--;)t[e].close()}}return t.\u0275fac=function(e){return new(e||t)(Xa(B6),Xa(Oa),Xa(void 0),Xa(void 0),Xa(N6),Xa(void 0),Xa(ys),Xa(ys),Xa(ms))},t.\u0275dir=be({type:t}),t})(),k7=(()=>{class t extends x7{constructor(t,e,n,s,r,i,a){super(t,e,s,i,a,r,g7,f7,b7)}}return t.\u0275fac=function(e){return new(e||t)(Os(B6),Os(Oa),Os(Pc,8),Os(v7,8),Os(w7),Os(t,12),Os(N6))},t.\u0275prov=Dt({token:t,factory:t.\u0275fac}),t})(),C7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[k7,_7],imports:[[U6,d6,M3],M3]}),t})(),S7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[U6,d6,gh,T4,M3],M3]}),t})(),I7=(()=>{class t{constructor(){this.changes=new G,this.itemsPerPageLabel="Items per page:",this.nextPageLabel="Next page",this.previousPageLabel="Previous page",this.firstPageLabel="First page",this.lastPageLabel="Last page",this.getRangeLabel=(t,e,n)=>{if(0==n||0==e)return`0 of ${n}`;const s=t*e;return`${s+1} \u2013 ${s<(n=Math.max(n,0))?Math.min(s+e,n):s+e} of ${n}`}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const E7={provide:I7,deps:[[new Ps,new zs,I7]],useFactory:function(t){return t||new I7}};let N7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[E7],imports:[[gh,T4,P8,o8,M3]]}),t})(),T7=(()=>{class t{constructor(){this.changes=new G}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Dt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const A7={provide:T7,deps:[[new Ps,new zs,T7]],useFactory:function(t){return t||new T7}};let $7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({providers:[A7],imports:[[gh,M3]]}),t})(),R7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[r6]]}),t})(),O7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t}),t.\u0275inj=Lt({imports:[[R7,M3],M3]}),t})(),F7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ge({type:t,bootstrap:[N8]}),t.\u0275inj=Lt({providers:[],imports:[[Jh,ty,O3,ip,ap,MJ,A8,R8,D8,z5,t6,L8,P8,z8,B8,j8,H8,x4,G8,q8,X8,m4,Z8,t7,e7,s7,T4,r7,i7,l7,H4,n5,m8,Q3,u7,C7,S7,o8,N7,$7,O7],A8,R8,D8,z5,t6,L8,P8,z8,B8,j8,H8,x4,G8,q8,X8,m4,Z8,t7,e7,s7,T4,r7,i7,l7,H4,n5,m8,Q3,u7,C7,S7,o8,N7,$7,O7]}),t})();sy.production&&function(){if(sc)throw new Error("Cannot enable prod mode after platform setup.");nc=!1}(),Yh().bootstrapModule(F7).catch(t=>console.error(t))},410:()=>{},628:()=>{},601:()=>{},792:()=>{},42:()=>{}},t=>{"use strict";t(t.s=998)}]);